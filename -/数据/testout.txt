#No. 1
#File: E:\bishe\1\$Gson$Types.java
#Comment:
  /**
   * Returns a type that is functionally equal but not necessarily equal
   * according to {@link Object#equals(Object) Object.equals()}. The returned
   * type is {@link java.io.Serializable}.
   */

#Code:
  public static Type canonicalize(Type type) {
    if (type instanceof Class) {
      Class<?> c = (Class<?>) type;
      return c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c;

    } else if (type instanceof ParameterizedType) {
      ParameterizedType p = (ParameterizedType) type;
      return new ParameterizedTypeImpl(p.getOwnerType(),
          p.getRawType(), p.getActualTypeArguments());

    } else if (type instanceof GenericArrayType) {
      GenericArrayType g = (GenericArrayType) type;
      return new GenericArrayTypeImpl(g.getGenericComponentType());

    } else if (type instanceof WildcardType) {
      WildcardType w = (WildcardType) type;
      return new WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds());

    } else {
      // type is either serializable as-is or unsupported
      return type;
    }
  }

#No. 2
#File: E:\bishe\1\$Gson$Types.java
#Comment:
  /**
   * Returns the generic supertype for {@code supertype}. For example, given a class {@code
   * IntegerSet}, the result for when supertype is {@code Set.class} is {@code Set<Integer>} and the
   * result when the supertype is {@code Collection.class} is {@code Collection<Integer>}.
   */

#Code:
  static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResolve) {
    if (toResolve == rawType) {
      return context;
    }

    // we skip searching through interfaces if unknown is an interface
    if (toResolve.isInterface()) {
      Class<?>[] interfaces = rawType.getInterfaces();
      for (int i = 0, length = interfaces.length; i < length; i++) {
        if (interfaces[i] == toResolve) {
          return rawType.getGenericInterfaces()[i];
        } else if (toResolve.isAssignableFrom(interfaces[i])) {
          return getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], toResolve);
        }
      }
    }

    // check our supertypes
    if (!rawType.isInterface()) {
      while (rawType != Object.class) {
        Class<?> rawSupertype = rawType.getSuperclass();
        if (rawSupertype == toResolve) {
          return rawType.getGenericSuperclass();
        } else if (toResolve.isAssignableFrom(rawSupertype)) {
          return getGenericSupertype(rawType.getGenericSuperclass(), rawSupertype, toResolve);
        }
        rawType = rawSupertype;
      }
    }

    // we can't resolve this further
    return toResolve;
  }

#No. 3
#File: E:\bishe\1\$Gson$Types.java
#Comment:
  /**
   * Returns the generic form of {@code supertype}. For example, if this is {@code
   * ArrayList<String>}, this returns {@code Iterable<String>} given the input {@code
   * Iterable.class}.
   *
   * @param supertype a superclass of, or interface implemented by, this.
   */

#Code:
  static Type getSupertype(Type context, Class<?> contextRawType, Class<?> supertype) {
    checkArgument(supertype.isAssignableFrom(contextRawType));
    return resolve(context, contextRawType,
        $Gson$Types.getGenericSupertype(context, contextRawType, supertype));
  }

#No. 4
#File: E:\bishe\1\$Gson$Types.java
#Comment:
  /**
   * Returns the component type of this array type.
   * @throws ClassCastException if this type is not an array.
   */

#Code:
  public static Type getArrayComponentType(Type array) {
    return array instanceof GenericArrayType
        ? ((GenericArrayType) array).getGenericComponentType()
        : ((Class<?>) array).getComponentType();
  }

#No. 5
#File: E:\bishe\1\$Gson$Types.java
#Comment:
  /**
   * Returns the element type of this collection type.
   * @throws IllegalArgumentException if this type is not a collection.
   */

#Code:
  public static Type getCollectionElementType(Type context, Class<?> contextRawType) {
    Type collectionType = getSupertype(context, contextRawType, Collection.class);

    if (collectionType instanceof WildcardType) {
      collectionType = ((WildcardType)collectionType).getUpperBounds()[0];
    }
    if (collectionType instanceof ParameterizedType) {
      return ((ParameterizedType) collectionType).getActualTypeArguments()[0];
    }
    return Object.class;
  }

#No. 6
#File: E:\bishe\1\$Gson$Types.java
#Comment:
  /**
   * Returns a two element array containing this map's key and value types in
   * positions 0 and 1 respectively.
   */

#Code:
  public static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType) {
    /*
     * Work around a problem with the declaration of java.util.Properties. That
     * class should extend Hashtable<String, String>, but it's declared to
     * extend Hashtable<Object, Object>.
     */
    if (context == Properties.class) {
      return new Type[] { String.class, String.class }; // TODO: test subclasses of Properties!
    }

    Type mapType = getSupertype(context, contextRawType, Map.class);
    // TODO: strip wildcards?
    if (mapType instanceof ParameterizedType) {
      ParameterizedType mapParameterizedType = (ParameterizedType) mapType;
      return mapParameterizedType.getActualTypeArguments();
    }
    return new Type[] { Object.class, Object.class };
  }

#No. 7
#File: E:\bishe\1\$Gson$Types.java
#Comment:
  /**
   * Returns the declaring class of {@code typeVariable}, or {@code null} if it was not declared by
   * a class.
   */

#Code:
  private static Class<?> declaringClassOf(TypeVariable<?> typeVariable) {
    GenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration();
    return genericDeclaration instanceof Class
        ? (Class<?>) genericDeclaration
        : null;
  }

#No. 8
#File: E:\bishe\1\${className}Dao.java
#Comment:
	/**
	 *
	 * @Title: selectAll
	 * @Description: 查找所有记录
	 */

#Code:
	List<${className}> selectAll();

	/**
	 *
	 * @Title: save
	 * @Description: 保存
	 */
	void insert(${className} ${classNameLower});

	/**
	 *
	 * @Title: update

	 * @Description: 更新
	 */
	int update(${className} ${classNameLower});

	/**
	 *
	 * @Title: selectByPK

	 * @Description: 查询
	 */
	${className} selectByPK(${clazz.fields?first.javaType} ${clazz.fields?first.fieldName});

	/**
	 *
	 * @Title: delete
	 *
	 * @Description: 删除
	 */
	int deleteByPK(${clazz.fields?first.javaType} ${clazz.fields?first.fieldName});

}

#No. 9
#File: E:\bishe\1\2-sum.java
#Comment:
    /*
     * @param numbers : An array of Integer
     * @param target : target = numbers[index1] + numbers[index2]
     * @return : [index1 + 1, index2 + 1] (index1 < index2)
     */

#Code:
    public int[] twoSum(int[] numbers, int target) {
        // write your code here
        int first = -1;
        int second = -1;
        boolean found = false;
        
        for (int i = 0; i < numbers.length; i++) {
            for (int j = numbers.length - 1; j > i; j--) {
                if (numbers[i] + numbers[j] == target) {
                    first = i + 1;
                    second = j + 1;
                    found = true;
                    break;
                }
            }
            if (found) {
                break;
            }
        }
        
        int[] res = {first, second};
        return res;
    }

#No. 10
#File: E:\bishe\1\3-sum-closest.java
#Comment:
    /**
     * @param numbers: Give an array numbers of n integer
     * @param target : An integer
     * @return : return the sum of the three integers, the sum closest target.
     */

#Code:
    public int threeSumClosest(int[] numbers ,int target) {
        // write your code here
        Arrays.sort(numbers);
        int sum = 0;
        int err = Integer.MAX_VALUE;

        for (int i = 0; i < numbers.length; i++) {
        	int left = i + 1;
        	int right = numbers.length - 1;

        	while (left < right) {
        		int tempSum = numbers[i] + numbers[left] + numbers[right];
        		int tempErr = Math.abs(target - tempSum);
        		if (tempErr == 0) {
        			return tempSum;
        		} else if (tempErr < err) {
        			err = tempErr;
        			sum = tempSum;
        		}

        		if (tempSum > target) {
        			right--;
        		} else {
        			left++;
        		}
        	}
        }

        return sum;
    }

#No. 11
#File: E:\bishe\1\a-b-problem.java
#Comment:
    /*
     * param a: The first integer
     * param b: The second integer
     * return: The sum of a and b
     */

#Code:
    public int aplusb(int a, int b) {
        if (b == 0) {
            return a;
        }
        
        int sum = a ^ b; // add without carry
        int carry = (a & b) << 1; // carry without sum;
        return aplusb(sum, carry);
    }

#No. 12
#File: E:\bishe\1\A2Service.java
#Comment:
                /*
                 * Some delay to avoid setting A2 before Activity ends, which would
                 * have no effect
                 */

#Code:
                Thread.sleep(600L);
            } catch (InterruptedException ex) {
            }

#No. 13
#File: E:\bishe\1\A2Service.java
#Comment:
        /* Get screenshot "luminance" and calculate, when possible, an shade alpha 
         * such that final "luminance" is equal to LUMINANCE_TARGET
         */

#Code:
        int lumi = getTotalLuminance(pixels);
        int maxLumi = 3*255*ss.getWidth()*ss.getHeight();
        double alpha = ((double) (LUMINANCE_TARGET - lumi)) / (maxLumi - lumi);
        int ialpha = Math.min(CONTRAST_MAX, Math.max(CONTRAST_MIN, (int)(alpha*255)));
        
        Log.i("A2", "Screen lumiance = "+lumi);
        Log.i("A2", "Target lumiance = "+LUMINANCE_TARGET);
        Log.i("A2", "Max lumiance = "+maxLumi);
        Log.i("A2", "Target alpha (0 to 255) = "+ialpha);
        
        shadeOverlay.setBackgroundColor((ialpha << 24) + 0xffffff);
    }
    
    private int getTotalLuminance(int[] pixels) {
        int avg = 0;
        for (int px : pixels)
            avg += (px & 0xff) + ((px>>8) & 0xff) + ((px>>16) & 0xff);
        
        return avg;
    }

#No. 14
#File: E:\bishe\1\AaaActivity.java
#Comment:
    /**
     * 设置下拉刷新控件，下拉后加载新的数据
     */

#Code:
    private void setSwipeRefreshLayout() {
        swipeRefreshLayout.setSize(SwipeRefreshLayout.DEFAULT);
        // 设置下拉圆圈上的颜色，蓝色、绿色、橙色、红色
        swipeRefreshLayout.setColorSchemeResources(android.R.color.holo_blue_bright, android.R.color.holo_green_light,
                android.R.color.holo_orange_light, android.R.color.holo_red_light);
        swipeRefreshLayout.setOnRefreshListener(new SwipeRefreshLayout.OnRefreshListener() {
            @Override
            public void onRefresh() {
                if (!isLoadingData) {
                    //Log.d(TAG, "加载新的数据");
                    mDataManager.loadNewData(AaaActivity.this);
                    isLoadingData = true;
                }
            }
        });
    }

#No. 15
#File: E:\bishe\1\AaaActivity.java
#Comment:
    /**
     * 设置头部的view
     */

#Code:
    private void setHeaderView() {
        headerIv.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                // 跳转到某个位置
                waterFallRcv.scrollToPosition(10);
            }
        });
        headerIv.post(new Runnable() {
            @Override
            public void run() {
                headerHeight = headerIv.getHeight();
                //Log.d(TAG, "headerHeight" + headerHeight);
            }
        });

    }

#No. 16
#File: E:\bishe\1\AaaActivity.java
#Comment:
    /**
     * 设置底部的view
     */

#Code:
    private void setFooterView() {
        footerBtn.setText("正在加载...");
        footerBtn.getBackground().setAlpha(80);
    }

#No. 17
#File: E:\bishe\1\AaaActivity.java
#Comment:
    /**
     * 滑动时影藏float button
     */

#Code:
    private void hideViews() {
        FrameLayout.LayoutParams lp = (FrameLayout.LayoutParams) floatIV.getLayoutParams();
        int fabBottomMargin = lp.bottomMargin;
        floatIV.animate().translationY(floatIV.getHeight() + fabBottomMargin).setInterpolator(new AccelerateInterpolator(2)).start();
    }

#No. 18
#File: E:\bishe\1\AaaActivity.java
#Comment:
    /**
     * 滑动时出现float button
     */

#Code:
    private void showViews() {
        floatIV.animate().translationY(0).setInterpolator(new DecelerateInterpolator(2)).start();
    }

#No. 19
#File: E:\bishe\1\AaaActivity.java
#Comment:
    /**
     * 通过滚动的状态来设置toolbar的透明度
     */

#Code:
    private void setToolbarBgByScrollDistance(int distance) {
        //Log.d(TAG, "distance" + distance);
        final float ratio = Math.min(distance / headerHeight, 1);
        final float newAlpha = ratio * 1;
        toolbar.setAlpha(newAlpha);
    }

#No. 20
#File: E:\bishe\1\AABBRotator.java
#Comment:
	/**
	 * @param aabb
	 *            The axis aligned boundingbox to rotate
	 * @param ang
	 *            The angle to rotate the aabb in radians
	 */

#Code:
	public static void rotateAABBAroundY(AxisAlignedBB aabb, double xoff, double zoff, float ang)
	{
		double y0 = aabb.minY;
		double y1 = aabb.maxY;
		
		vec00.xCoord = aabb.minX - xoff;
		vec00.zCoord = aabb.minZ - zoff;
		
		vec01.xCoord = aabb.minX - xoff;
		vec01.zCoord = aabb.maxZ - zoff;
		
		vec10.xCoord = aabb.maxX - xoff;
		vec10.zCoord = aabb.minZ - zoff;
		
		vec11.xCoord = aabb.maxX - xoff;
		vec11.zCoord = aabb.maxZ - zoff;
		
		vec00.rotateAroundY(ang);
		vec01.rotateAroundY(ang);
		vec10.rotateAroundY(ang);
		vec11.rotateAroundY(ang);
		
		vec0h.xCoord = (vec00.xCoord + vec01.xCoord) / 2D;
		vec0h.zCoord = (vec00.zCoord + vec01.zCoord) / 2D;
		
		vec1h.xCoord = (vec10.xCoord + vec11.xCoord) / 2D;
		vec1h.zCoord = (vec10.zCoord + vec11.zCoord) / 2D;
		
		vech0.xCoord = (vec00.xCoord + vec10.xCoord) / 2D;
		vech0.zCoord = (vec00.zCoord + vec10.zCoord) / 2D;
		
		vech1.xCoord = (vec01.xCoord + vec11.xCoord) / 2D;
		vech1.zCoord = (vec01.zCoord + vec11.zCoord) / 2D;
		
		aabb.setBounds(minX(), y0, minZ(), maxX(), y1, maxZ()).offset(xoff, 0F, zoff);
	}

#No. 21
#File: E:\bishe\1\AABBUtils.java
#Comment:
	/**
	 * Gets an empty {@link AxisAlignedBB} (size 0x0x0) at position 0,0,0.
	 *
	 * @return the axis aligned bb
	 */

#Code:
	public static AxisAlignedBB empty()
	{
		return empty(BlockPos.ORIGIN);
	}

#No. 22
#File: E:\bishe\1\AABBUtils.java
#Comment:
	/**
	 * Gets an empty {@link AxisAlignedBB} (size 0x0x0) at the {@link BlockPos} position.
	 *
	 * @param pos the pos
	 * @return the axis aligned bb
	 */

#Code:
	public static AxisAlignedBB empty(BlockPos pos)
	{
		return new AxisAlignedBB(pos.getX(), pos.getY(), pos.getZ(), pos.getX(), pos.getY(), pos.getZ());
	}

#No. 23
#File: E:\bishe\1\AABBUtils.java
#Comment:
	/**
	 * Gets an identity {@link AxisAlignedBB} (size 1x1x1) at position 0,0,0.
	 *
	 * @return the axis aligned bb
	 */

#Code:
	public static AxisAlignedBB identity()
	{
		return Block.FULL_BLOCK_AABB;
	}

#No. 24
#File: E:\bishe\1\AABBUtils.java
#Comment:
	/**
	 * Gets an identity {@link AxisAlignedBB} (size 1x1x1) at {@link BlockPos} position;
	 *
	 * @param pos the pos
	 * @return the axis aligned bb
	 */

#Code:
	public static AxisAlignedBB identity(BlockPos pos)
	{
		return new AxisAlignedBB(pos.getX(), pos.getY(), pos.getZ(), pos.getX() + 1, pos.getY() + 1, pos.getZ() + 1);
	}

#No. 25
#File: E:\bishe\1\AABBUtils.java
#Comment:
	/**
	 * Gets an identity {@link AxisAlignedBB} (size 1x1x1) at position 0,0,0 returned as an array.
	 *
	 * @return the axis aligned b b[]
	 */

#Code:
	public static AxisAlignedBB[] identities()
	{
		return identities(BlockPos.ORIGIN);
	}

#No. 26
#File: E:\bishe\1\AABBUtils.java
#Comment:
	/**
	 * Rotates the {@link AxisAlignedBB} based on the specified direction.<br>
	 * Assumes {@link EnumFacing#SOUTH} to be the default non rotated direction.<br>
	 *
	 *
	 * @param aabb the aabb
	 * @param dir the dir
	 * @return the axis aligned bb
	 */

#Code:
	public static AxisAlignedBB rotate(AxisAlignedBB aabb, EnumFacing dir)
	{
		if (dir == EnumFacing.SOUTH)
			return aabb;

		int angle = dir.getAxis() == Axis.Y ? dir.getAxisDirection().getOffset() : EnumFacingUtils.getRotationCount(dir);
		Axis axis = dir.getAxis() == Axis.Y ? Axis.X : Axis.Y;

		return rotate(aabb, angle, axis);
	}

#No. 27
#File: E:\bishe\1\AABBUtils.java
#Comment:
	/**
	 * Rotates an array of {@link AxisAlignedBB} around the Y axis based on the specified direction.<br>
	 * Assumes {@link EnumFacing#SOUTH} to be the default non rotated direction.<br>
	 *
	 * @param aabbs the aabbs
	 * @param dir the dir
	 * @return the axis aligned b b[]
	 */

#Code:
	public static AxisAlignedBB[] rotate(AxisAlignedBB[] aabbs, EnumFacing dir)
	{
		if (ArrayUtils.isEmpty(aabbs) || dir == EnumFacing.SOUTH)
			return aabbs;

		int angle = dir.getAxis() == Axis.Y ? dir.getAxisDirection().getOffset() : EnumFacingUtils.getRotationCount(dir);
		Axis axis = dir.getAxis() == Axis.Y ? Axis.X : Axis.Y;

		for (int i = 0; i < aabbs.length; i++)
			aabbs[i] = rotate(aabbs[i], angle, axis);
		return aabbs;
	}

#No. 28
#File: E:\bishe\1\AABBUtils.java
#Comment:
	/**
	 * Rotates the {@link AxisAlignedBB} around the Y axis based on the specified angle.<br>
	 *
	 * @param aabb the aabb
	 * @param angle the angle
	 * @return the axis aligned bb
	 */

#Code:
	public static AxisAlignedBB rotate(AxisAlignedBB aabb, int angle)
	{
		return rotate(aabb, angle, Axis.Y);
	}

#No. 29
#File: E:\bishe\1\AABBUtils.java
#Comment:
	/**
	 * Reads a {@link AxisAlignedBB} from {@link NBTTagCompound}.<br>
	 *
	 * @param tag the tag
	 * @return the axis aligned BB
	 */

#Code:
	public static AxisAlignedBB readFromNBT(NBTTagCompound tag)
	{
		return readFromNBT(tag, null);
	}

#No. 30
#File: E:\bishe\1\AABBUtils.java
#Comment:
	/**
	 * Reads a {@link AxisAlignedBB} from {@link NBTTagCompound} with the specified prefix.<br>
	 *
	 * @param tag the tag
	 * @param prefix the prefix
	 * @return the axis aligned bb
	 */

#Code:
	public static AxisAlignedBB readFromNBT(NBTTagCompound tag, String prefix)
	{
		prefix = prefix == null ? "" : prefix + ".";
		return tag != null	? new AxisAlignedBB(tag.getDouble(prefix + "minX"),
												tag.getDouble(prefix + "minY"),
												tag.getDouble(prefix + "minZ"),
												tag.getDouble(prefix + "maxX"),
												tag.getDouble(prefix + "maxY"),
												tag.getDouble(prefix + "maxZ"))
							: null;
	}

#No. 31
#File: E:\bishe\1\AABBUtils.java
#Comment:
	/**
	 * Writes a {@link AxisAlignedBB} to a {@link NBTTagCompound}.<br>
	 *
	 * @param tag the tag
	 * @param aabb the aabb
	 */

#Code:
	public static void writeToNBT(NBTTagCompound tag, AxisAlignedBB aabb)
	{
		writeToNBT(tag, aabb, null);
	}

#No. 32
#File: E:\bishe\1\AABBUtils.java
#Comment:
	/**
	 * Writes a {@link AxisAlignedBB} to a {@link NBTTagCompound} with the specified prefix.<br>
	 *
	 * @param tag the tag
	 * @param aabb the aabb
	 * @param prefix the prefix
	 */

#Code:
	public static void writeToNBT(NBTTagCompound tag, AxisAlignedBB aabb, String prefix)
	{
		if (tag == null || aabb == null)
			return;

		prefix = prefix == null ? "" : prefix + ".";
		tag.setDouble(prefix + "minX", aabb.minX);
		tag.setDouble(prefix + "minY", aabb.minY);
		tag.setDouble(prefix + "minZ", aabb.minZ);
		tag.setDouble(prefix + "maxX", aabb.maxX);
		tag.setDouble(prefix + "maxY", aabb.maxY);
		tag.setDouble(prefix + "maxZ", aabb.maxZ);
	}

#No. 33
#File: E:\bishe\1\AABBUtils.java
#Comment:
	/**
	 * Gets a {@link AxisAlignedBB} that encompasses the passed {@code AxisAlignedBB}.
	 *
	 * @param aabbs the aabbs
	 * @return the axis aligned bb
	 */

#Code:
	public static AxisAlignedBB combine(AxisAlignedBB[] aabbs)
	{
		if (ArrayUtils.isEmpty(aabbs))
			return null;

		AxisAlignedBB ret = null;
		for (AxisAlignedBB aabb : aabbs)
		{
			if (ret == null)
				ret = aabb;
			else if (aabb != null)
				ret = ret.union(aabb);
		}

		return ret;
	}

#No. 34
#File: E:\bishe\1\AABBUtils.java
#Comment:
	/**
	 * Offsets the passed {@link AxisAlignedBB} array by the specified coordinates.
	 *
	 * @param x the x
	 * @param y the y
	 * @param z the z
	 * @param aabbs the aabbs
	 */

#Code:
	public static AxisAlignedBB[] offset(double x, double y, double z, AxisAlignedBB... aabbs)
	{
		return offset(new BlockPos(x, y, z), aabbs);
	}

#No. 35
#File: E:\bishe\1\AABBUtils.java
#Comment:
	/**
	 * Offsets the passed {@link AxisAlignedBB} by the {@link BlockPos} coordinates.
	 *
	 * @param pos the pos
	 * @param aabb the aabb
	 * @return the axis aligned bb
	 */

#Code:
	public static AxisAlignedBB offset(BlockPos pos, AxisAlignedBB aabb)
	{
		if (aabb == null || pos == null)
			return aabb;
		return aabb.offset(pos.getX(), pos.getY(), pos.getZ());
	}

#No. 36
#File: E:\bishe\1\AABBUtils.java
#Comment:
	/**
	 * Offsets the passed {@link AxisAlignedBB} array by the {@link BlockPos} coordinates.
	 *
	 * @param pos the pos
	 * @param aabbs the aabbs
	 * @return the axis aligned b b[]
	 */

#Code:
	public static AxisAlignedBB[] offset(BlockPos pos, AxisAlignedBB... aabbs)
	{
		if (ArrayUtils.isEmpty(aabbs))
			return aabbs;

		for (int i = 0; i < aabbs.length; i++)
			if (aabbs[i] != null)
				aabbs[i] = aabbs[i].offset(pos.getX(), pos.getY(), pos.getZ());
		return aabbs;
	}

#No. 37
#File: E:\bishe\1\AABBUtils.java
#Comment:
	/**
	 * Checks if an {@link AxisAlignedBB} array is colliding with another one.
	 *
	 * @param aabbs1 the aabbs1
	 * @param aabbs2 the aabbs2
	 * @return true, if is colliding
	 */

#Code:
	public static boolean isColliding(AxisAlignedBB[] aabbs1, AxisAlignedBB[] aabbs2)
	{
		if (ArrayUtils.isEmpty(aabbs1) || ArrayUtils.isEmpty(aabbs2))
			return false;

		for (AxisAlignedBB aabb1 : aabbs1)
		{
			if (aabb1 != null)
			{
				for (AxisAlignedBB aabb2 : aabbs2)
					if (aabb2 != null && aabb1.intersects(aabb2))
						return true;
			}
		}

		return false;
	}

#No. 38
#File: E:\bishe\1\AABBUtils.java
#Comment:
	/**
	 * Gets the collision {@link AxisAlignedBB} for the {@link Block} as the {@link BlockPos} coordinates.
	 *
	 * @param world the world
	 * @param block the block
	 * @param pos the pos
	 * @return the collision bounding boxes
	 */

#Code:
	public static AxisAlignedBB[] getCollisionBoundingBoxes(World world, Block block, BlockPos pos)
	{
		return getCollisionBoundingBoxes(world, new MBlockState(pos, block), false);
	}

#No. 39
#File: E:\bishe\1\AABBUtils.java
#Comment:
	/**
	 * Gets the collision {@link AxisAlignedBB} for the {@link Block} as the {@link BlockPos} coordinates.
	 *
	 * @param world the world
	 * @param block the block
	 * @param pos the pos
	 * @param offset if true, the boxes are offset by the coordinate
	 * @return the collision bounding boxes
	 */

#Code:
	public static AxisAlignedBB[] getCollisionBoundingBoxes(World world, Block block, BlockPos pos, boolean offset)
	{
		return getCollisionBoundingBoxes(world, new MBlockState(pos, block), offset);
	}

#No. 40
#File: E:\bishe\1\AABBUtils.java
#Comment:
	/**
	 * Gets the collision {@link AxisAlignedBB} for the {@link MBlockState}.
	 *
	 * @param world the world
	 * @param state the state
	 * @return the collision bounding boxes
	 */

#Code:
	public static AxisAlignedBB[] getCollisionBoundingBoxes(World world, MBlockState state)
	{
		return getCollisionBoundingBoxes(world, state, false);
	}

#No. 41
#File: E:\bishe\1\AABBUtils.java
#Comment:
	/**
	 * Gets the collision {@link AxisAlignedBB} for the {@link MBlockState}.
	 *
	 * @param world the world
	 * @param state the state
	 * @param offset the offset
	 * @return the collision bounding boxes
	 */

#Code:
	public static AxisAlignedBB[] getCollisionBoundingBoxes(World world, MBlockState state, boolean offset)
	{
		AxisAlignedBB[] aabbs = new AxisAlignedBB[0];
		if (world == null || state == null)
			return aabbs;

		if (state.getBlock() instanceof IBoundingBox)
			aabbs = ((IBoundingBox) state.getBlock()).getCollisionBoundingBoxes(world, state.getPos(), state.getBlockState());
		else
		{
			AxisAlignedBB aabb = state.getBlockState().getCollisionBoundingBox(world, state.getPos());
			if (aabb != null)
				aabbs = new AxisAlignedBB[] { aabb };
		}

		if (offset)
			AABBUtils.offset(state.getX(), state.getY(), state.getZ(), aabbs);

		return aabbs;
	}

#No. 42
#File: E:\bishe\1\AAbout.java
#Comment:
    /**
     * Final Strings variables.
     */

#Code:
    private String ABOUT_APP = null;

    @Override
    public void onCreate(Bundle bundle) {
        super.onCreate(bundle);
        ABOUT_APP = " AIO video downloader [ " + "Version - " + versionName + " ]\n" +
                " Powered by SoftC Software LLC.";

        context = AAbout.this;

        setContentView(R.layout.about_activity);

        initViews();
        initOnClick();
    }

#No. 43
#File: E:\bishe\1\aaFile_Transfer.java
#Comment:
					/* N.B.:
					 * * To view if the file transfer was successful:
					 *       * use `./adb shell` 
					 *       * use the app: File Manager
					 * 
					 * * If you downloaded to '/mnt/sdcard/download', 
					 *   your download might not show up in 'Downloads'
					 *   
					 * * You might not have '/mnt/sdcard/download' directory
					 *   if you have never downloaded anything on your iPhone
					 */

#Code:
					FileOutputStream fos = new FileOutputStream("/mnt/sdcard/download/source-copy2.pdf");
					BufferedOutputStream bos = new BufferedOutputStream(fos);
					bytesRead = is.read(mybytearray,0,mybytearray.length);
					current = bytesRead;
					do {
						bytesRead =
								is.read(mybytearray, current, (mybytearray.length-current));
						if(bytesRead >= 0) current += bytesRead;
					} while(bytesRead > -1);

#No. 44
#File: E:\bishe\1\aAncStatesIntro.java
#Comment:
	/** Returns citation for a package of modules*
 	public String getPackageCitation()
 	
 	NOT overridden because part of the standard Mesquite packages; hence uses standard Mesquite citation
	/*.................................................................................................................*/

#Code:
	/** Returns whether there is a splash banner*/
	public boolean hasSplash(){
 		return true; 
	}

#No. 45
#File: E:\bishe\1\aAssocIntro.java
#Comment:
	/** Returns citation for a package of modules*
 	public String getPackageCitation()

 	NOT overridden because part of the standard Mesquite packages; hence uses standard Mesquite citation
	/*.................................................................................................................*/

#Code:
	/** Returns whether there is a splash banner*/
	public boolean hasSplash(){
		return false; 
	}

#No. 46
#File: E:\bishe\1\AAttackEnemyUnit.java
#Comment:
    /**
     * Selects the best enemy unit and issues attack order.
     * @return <b>true</b> if unit has found valid target and is currently busy with either starting 
     * an attack or just attacking the enemy<br />
     * <b>false</b> if no valid enemy to attack could be found
     */

#Code:
    public static boolean handleAttackEnemyUnits(AUnit unit) {
        AUnit enemyToAttack = AEnemyTargeting.defineBestEnemyToAttackFor(unit);
        
        // =========================================================
        
        // We were unable to define enemy unit to attack, just quit
        if (enemyToAttack == null) {
            return false;
        }
        
        // Don't interrupt when shooting or starting to shoot
        if (unit.isJustShooting()) {
            unit.setTooltip("Shooting");
            return true;
        }
        
        // Check if weapon cooldown allows to attack this enemy
        if (!unit.canAttackThisKindOfUnit(enemyToAttack, true)) {
            unit.setTooltip("Invalid target");
            return false;
        } 
        
        // =========================================================
        
        // If we already are attacking this unit, do not issue double command.
        if (enemyToAttack != null && !unit.isJustShooting()) {
            unit.setTooltip("Attacking " + enemyToAttack.getShortName());
            return unit.attackUnit(enemyToAttack);
        } 
        
        return false;
    }

#No. 47
#File: E:\bishe\1\ABaseTransformer.java
#Comment:
	/**
	 * Apply a property transformation to the given page. For most use cases, this method should not be overridden.
	 * Instead use {@link #transformPage(View, float)} to perform typical transformations.
	 *
	 * @param page
	 *            Apply the transformation to this page
	 * @param position
	 *            Position of page relative to the current front-and-center position of the pager. 0 is front and
	 *            center. 1 is one full page position to the right, and -1 is one page position to the left.
	 */

#Code:
	@Override
	public void transformPage(View page, float position) {
		onPreTransform(page, position);
		onTransform(page, position);
		onPostTransform(page, position);
	}

#No. 48
#File: E:\bishe\1\ABaseTransformer.java
#Comment:
	/**
	 * If the position offset of a fragment is less than negative one or greater than one, returning true will set the
	 * fragment alpha to 0f. Otherwise fragment alpha is always defaulted to 1f.
	 *
	 * @return
	 */

#Code:
	protected boolean hideOffscreenPages() {
		return true;
	}

#No. 49
#File: E:\bishe\1\ABaseTransformer.java
#Comment:
	/**
	 * Indicates if the default animations of the view pager should be used.
	 *
	 * @return
	 */

#Code:
	protected boolean isPagingEnabled() {
		return false;
	}

#No. 50
#File: E:\bishe\1\ABaseTransformer.java
#Comment:
	/**
	 * Called each {@link #transformPage(View, float)} before {{@link #onTransform(View, float)}.
	 * <p>
	 * The default implementation attempts to reset all view properties. This is useful when toggling transforms that do
	 * not modify the same page properties. For instance changing from a transformation that applies rotation to a
	 * transformation that fades can inadvertently leave a fragment stuck with a rotation or with some degree of applied
	 * alpha.
	 *
	 * @param page
	 *            Apply the transformation to this page
	 * @param position
	 *            Position of page relative to the current front-and-center position of the pager. 0 is front and
	 *            center. 1 is one full page position to the right, and -1 is one page position to the left.
	 */

#Code:
	protected void onPreTransform(View page, float position) {
		final float width = page.getWidth();

		page.setRotationX(0);
		page.setRotationY(0);
		page.setRotation(0);
		page.setScaleX(1);
		page.setScaleY(1);
		page.setPivotX(0);
		page.setPivotY(0);
		page.setTranslationY(0);
		page.setTranslationX(isPagingEnabled() ? 0f : -width * position);

		if (hideOffscreenPages()) {
			page.setAlpha(position <= -1f || position >= 1f ? 0f : 1f);
//			page.setEnabled(false);
		} else {
//			page.setEnabled(true);
			page.setAlpha(1f);
		}
	}

#No. 51
#File: E:\bishe\1\ABaseTransformer.java
#Comment:
	/**
	 * Same as {@link Math#min(double, double)} without double casting, zero closest to infinity handling, or NaN support.
	 *
	 * @param val
	 * @param min
	 * @return
	 */

#Code:
	protected static final float min(float val, float min) {
		return val < min ? min : val;
	}

#No. 52
#File: E:\bishe\1\aBasicIntro.java
#Comment:
	/** Returns citation for a package of modules*
 	public String getPackageCitation()
 	
 	NOT overridden because part of the standard Mesquite packages; hence uses standard Mesquite citation
	/*.................................................................................................................*/

#Code:
	/** Returns whether there is a splash banner*/
	public boolean hasSplash(){
 		return false; 
	}

#No. 53
#File: E:\bishe\1\AbastractDataGenerator.java
#Comment:
	/**
	 * 生成第n个数据<br>
	 * index计数从0开始
	 * 
	 * @param index
	 * @return
	 */

#Code:
	public abstract Object generate(int index);

	/**
	 * 获取已经设置好字段的对应值
	 * 
	 * @param field
	 * @return
	 */
	public Object value(String field) {
		if (this.dataMap == null) {
			throw new RuntimeException("the data map can't be null.");
		}
		if (this.dataMap.containsKey(field) == false) {
			throw new RuntimeException("unexist the key[" + field + "] of data map.");
		}
		return this.dataMap.get(field);
	}

#No. 54
#File: E:\bishe\1\AbastractDataGenerator.java
#Comment:
	/**
	 * 循环遍历objects对象列表
	 * 
	 * @param objects
	 * @return
	 */

#Code:
	public static AbastractDataGenerator repeat(Object... objects) {
		return new RepeatDataGenerator(objects);
	}

#No. 55
#File: E:\bishe\1\AbastractDataGenerator.java
#Comment:
	/**
	 * 生成随机对象
	 * 
	 * @param type
	 * @return
	 */

#Code:
	@SuppressWarnings("rawtypes")
	public static AbastractDataGenerator random(Class type) {
		return new RandomDataGenerator(type);
	}

#No. 56
#File: E:\bishe\1\AbastractDataGenerator.java
#Comment:
	/**
	 * 步进生成数据
	 * 
	 * @param from
	 * @param step
	 * @return
	 */

#Code:
	public static AbastractDataGenerator increase(Number from, Number step) {
		return new IncreaseDataGenerator(from, step);
	}

#No. 57
#File: E:\bishe\1\Abbrev.java
#Comment:
/**
 * Annotation to add to a Tool class to provide an abbreviation for the command line.
 */

#Code:
public @interface Abbrev {
	String value();
}
}

#No. 58
#File: E:\bishe\1\Abbreviation.java
#Comment:
/**
 * Abbreviations to identify the URIs of the resources within the
 * {@link OntModel}.
 * 
 * @author anil
 * 
 */

#Code:
public enum Abbreviation {
	ItemIdentifier("II"), AdministrationRecord("AR"), AdministeredItem("AI"), ClassificationScheme(
			"CS"), ClassificationSchemeItem("CSI"), ClassificationSchemeItemRelationship(
			"CSIR"), Concept("CON"), ConceptualDomain("CD"), ConceptualDomainRelationship(
			"CDR"), ConceptRelationship("CONR"), Contact("CNT"), Context("CX"), DataElement(
			"DE"), DataElementConcept("DEC"), DataElementDerivation("DER"), DataElementExample(
			"DAE"), DataElementConceptRelationship("DECR"), Datatype("DT"), Designation(
			"DES"), Definition("DEF"), DerivationRule("DR"), LanguageSection(
			"LS"), ObjectClass("OC"), Property("PR"), RepresentationClass("RC"), ValueDomain(
			"VD"), Organization("ORG"), RegistrationAuthority("RA"), ReferenceDocument(
			"RD"), Submission("SUB"), Stewardship("STEW"), AdministeredItemContext(
			"AIC"), TerminologicalEntry("TE"), UnitOfMeasure("UOM"), NonEnumeratedConceptualDomain(
			"NECD"), NonEnumeratedValueDomain("NEVD"), EnumeratedConceptualDomain(
			"ECD"), EnumeratedValueDomain("EVD"), Value("VAL"), ValueDomainRelationship(
			"VDR"), ValueMeaning("VM"), PermissibleValue("PVAL");

	private final String abbreviation;

	private Abbreviation(String abbreviation) {
		this.abbreviation = abbreviation;
	}

	@Override
	public final String toString() {
		return this.abbreviation;
	}
}

#No. 59
#File: E:\bishe\1\AbbvGapsHMM.java
#Comment:
	/**
	 * @param modelParamFile After training, the model parameters will be saved to this file.
	 */

#Code:
	public AbbvGapsHMM(String modelParamFile) {
		_modelParamsFile = modelParamFile;
	}

#No. 60
#File: E:\bishe\1\AbbvGapsHMM.java
#Comment:
	/**
	 * @param modelParamFile After training, the model parameters will be saved to this file.
	 */

#Code:
	public AbbvGapsHMM(String modelParamFile, boolean allowVowelsMatch) {
		_modelParamsFile = modelParamFile;
	}

#No. 61
#File: E:\bishe\1\AbbvGapsHMM.java
#Comment:
	/**
	 * Initialize the starting probabilities for each state (hard coded).
	 */

#Code:
	protected void initStartProbs(){
		if(_stateStartProb != null)
			return;

		States[] states = States.values();

		_stateStartProb = new ArrayList<Double>();
		for(int i = 0; i < states.length; ++i){
			if(states[i].name().equals("S"))
				_stateStartProb.add(1d);
			else
				_stateStartProb.add(0d);
		}
	}

#No. 62
#File: E:\bishe\1\AbbvGapsHMM.java
#Comment:
	/**
	 * Returns the total change in model parameter values.
	 */

#Code:
	protected Double maximizationStep(){
		
		Double valChange = 0d;
		
		valChange += maximizationStepForEmissions();
		valChange += maximizationStepForTransitions();
		
		return valChange;
	}

#No. 63
#File: E:\bishe\1\AbbvGapsHMM.java
#Comment:
	/**
	 * Dirichlet smoothing
	 * -------------------
	 * 
	 * Without a prior: 
	 * 		P(data | theta) = theta(i)^beta(i) = counters(i)
	 * 
	 * 
	 * With a dirichlet prior:
	 * 		P(data | theta)*p(theta) = theta(i)^(beta(i) + alpha(i)) =
	 * 			theta(i)^beta(i) + theta(i)^alpha(i) 
	 * 			counters(i) + params(i)^alpha(i)
	 */

#Code:
	protected double smoothCounter(int i, List<Double> counters, List<Double> params){
		double alpha = 1;
		return counters.get(i) + Math.pow(params.get(i), alpha);
	}

#No. 64
#File: E:\bishe\1\AbbvGapsHmmBackwardsEvaluator.java
#Comment:
		/**
		 * 
		 */

#Code:
		public BackwardEvalParam(String str) {
			super(str);
			_eval_start = _length;
			_eval_end = 0;
			
			_current = _length;
			_currentStringPos = _length;
		}

#No. 65
#File: E:\bishe\1\AbbvGapsHmmBackwardsEvaluator.java
#Comment:
	/**
	 * If pos is starting a new word in str, returns this word.
	 * Else, returns null.
	 */

#Code:
	protected static String getPartialStartedWord(String str, int pos){
		assert(pos < str.length() && pos >= 0);

		if(	posIsAtWord(str, pos) ){
			int nextSpace = findNextNonLetterOrDigit(str, pos);
			if(nextSpace == -1){
				nextSpace = str.length();
			}
			
			return str.substring(pos, nextSpace);
		}
		return null;
	}

#No. 66
#File: E:\bishe\1\AbbvGapsHmmBackwardsEvaluator.java
#Comment:
	/**
	 * If pos is starting a new word in str, returns this word.
	 * Else, returns null.
	 */

#Code:
	protected static String getStartedWord(String str, int pos){
		assert(pos < str.length() && pos >= 0);

		if(	posIsAtWordStart(str, pos) ){
			int nextSpace = findNextNonLetterOrDigit(str, pos);
			if(nextSpace == -1){
				nextSpace = str.length();
			}
			
			return str.substring(pos, nextSpace);
		}
		return null;
	}

#No. 67
#File: E:\bishe\1\AbbvGapsHMMEvaluator.java
#Comment:
		/**
		 * 
		 */

#Code:
		public EvalParam(String str) {
			_length = str.length();
			_eval_mat_size = _length+2;
		}

#No. 68
#File: E:\bishe\1\AbbvGapsHMMEvaluator.java
#Comment:
		/**
		 * Init evaluation range
		 */

#Code:
		public abstract void initEvalRange();
		
		/**
		 * Advance within evaluation range
		 */
		public abstract void advanceEvalRange();
		
		/**
		 * Is in evaluation range
		 */
		public abstract boolean isInEvalRange();
		
		public boolean isAtRangeStart() { return _current == _eval_start; }
		
		public boolean isAtRangeEnd() { return _current == _eval_start; }
		
		public abstract boolean isInStringMatchingRange();
		
		public int getEvalStringPos() { return _currentStringPos; }
		
		public abstract int offset(int offset);
		
		public int getEvalMatrixSize() { return _eval_mat_size;	}
		
		public int getRangeStart() { return _eval_start; }
		
		public int getRangeEnd() { return _eval_end; }
		
		public abstract void setPartialWord(String str, boolean isAtWordStart);
		
		public abstract int getCurrentPartialWordLen();
		
		public abstract int getCurrentPartialWordMatchPosition();
		
		public abstract boolean isCurrentPartialWordMatchPositionAtWordStart();
		
	};

#No. 69
#File: E:\bishe\1\AbbvGapsHMMEvaluator.java
#Comment:
	/**
	 * Enumerates the possible transitions into state M.
	 * @param currS
	 * @param currL
	 * @param prevS
	 * @param prevL
	 */

#Code:
	protected void updateOutgoingEdgesStateM(
			int currS, int currL,
			int prevS, int prevL,
			Emissions emission
	){
		updateOutgoingEdges(currS, currL, States.M, prevS, prevL, States.DL, Transitions.t_DL_to_M, emission);
		updateOutgoingEdges(currS, currL, States.M, prevS, prevL, States.M, Transitions.t_M_in, emission);
		updateOutgoingEdges(currS, currL, States.M, prevS, prevL, States.D, Transitions.t_D_to_M, emission);
		updateOutgoingEdges(currS, currL, States.M, prevS, prevL, States.S, Transitions.t_S_to_M, emission);
	}

#No. 70
#File: E:\bishe\1\AbbvGapsHMMEvaluator.java
#Comment:
	/**
	 * Enumerates the possible transitions into state D.
	 */

#Code:
	protected void updateOutgoingEdgesStateD(
			int currS, int currL,
			int prevS, int prevL,
			Emissions emission
	){
		updateOutgoingEdges(currS, currL, States.D, prevS, prevL, States.D, Transitions.t_D_in, emission);
		updateOutgoingEdges(currS, currL, States.D, prevS, prevL, States.M, Transitions.t_M_to_D, emission);
	}

#No. 71
#File: E:\bishe\1\AbbvGapsHMMEvaluator.java
#Comment:
	/**
	 * Enumerates the possible transitions into state DL.
	 */

#Code:
	protected void updateOutgoingEdgesStateDL(
			int currS, int currL,
			int prevS, int prevL,
			Emissions emission
	){
		updateOutgoingEdges(currS, currL, States.DL, prevS, prevL, States.DL, Transitions.t_DL_in, emission);
		updateOutgoingEdges(currS, currL, States.DL, prevS, prevL, States.S, Transitions.t_S_to_DL, emission);
	}

#No. 72
#File: E:\bishe\1\AbbvGapsHMMEvaluator.java
#Comment:
	/**
	 * Enumerates the possible transitions into state END.
	 */

#Code:
	protected void updateOutgoingEdgesStateEND(
			int currS, int currL,
			int prevS, int prevL,
			Emissions emission
	){
		updateOutgoingEdges(currS, currL, States.END, prevS, prevL, States.D, Transitions.t_D_to_END, emission);
		updateOutgoingEdges(currS, currL, States.END, prevS, prevL, States.M, Transitions.t_M_to_END, emission);
	}

#No. 73
#File: E:\bishe\1\AbbvGapsHmmForwardEvaluator.java
#Comment:
		/**
		 * 
		 */

#Code:
		public ForwardEvalParam(String str) {
			super(str);
			_eval_start = 0;
			_eval_end = _length;
		}

#No. 74
#File: E:\bishe\1\AbbvGapsHmmForwardEvaluator.java
#Comment:
	/**
	 * If pos is ending a word in str: returns this word.
	 * Else: returns null;
	 */

#Code:
	protected static String getPartialEndedWord(String str, int pos){
		assert(pos < str.length() && pos >= 0);

		if(	posIsAtWord(str, pos) ){
			int prevSpace = findLastNonLetterOrDigit(str, pos);

			return str.substring(prevSpace+1, pos+1);
		}
		return null;
	}

#No. 75
#File: E:\bishe\1\AbbvGapsHmmForwardEvaluator.java
#Comment:
	/**
	 * If pos is ending a word in str: returns this word.
	 * Else: returns null;
	 */

#Code:
	protected static String getEndedWord(String str, int pos){
		assert(pos < str.length() && pos >= 0);

		if(	posIsAtWordEnd(str, pos) ){
			int prevSpace = findLastNonLetterOrDigit(str, pos);

			return str.substring(prevSpace+1, pos+1);
		}
		return null;
	}

#No. 76
#File: E:\bishe\1\AbcGrammar.java
#Comment:
/**
 * Grammar for the classic non-context-free language { a^n b^n c^n : n >= 1 }.
 */

#Code:
public enum AbcGrammar implements GrammarRuleKey {

  S, A, B;

  public static Grammar createGrammar() {
    LexerlessGrammarBuilder b = LexerlessGrammarBuilder.create();

    b.rule(S).is(b.next(A, "c"), b.oneOrMore("a"), B, b.nextNot("a", "b", "c"));
    b.rule(A).is("a", b.optional(A), "b");
    b.rule(B).is("b", b.optional(B), "c");

    return b.build();
  }

}

#No. 77
#File: E:\bishe\1\ABCOrder.java
#Comment:
        /**
         * Gets the value of the status property.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */

#Code:
        public String getStatus() {
            return status;
        }

#No. 78
#File: E:\bishe\1\ABCOrder.java
#Comment:
        /**
         * Sets the value of the status property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         */

#Code:
        public void setStatus(String value) {
            this.status = value;
        }

#No. 79
#File: E:\bishe\1\ABCOrder.java
#Comment:
        /**
         * Gets the value of the customerNum property.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */

#Code:
        public String getCustomerNum() {
            return customerNum;
        }

#No. 80
#File: E:\bishe\1\ABCOrder.java
#Comment:
        /**
         * Sets the value of the customerNum property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         */

#Code:
        public void setCustomerNum(String value) {
            this.customerNum = value;
        }

#No. 81
#File: E:\bishe\1\ABCOrder.java
#Comment:
        /**
         * Gets the value of the orderNum property.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */

#Code:
        public String getOrderNum() {
            return orderNum;
        }

#No. 82
#File: E:\bishe\1\ABCOrder.java
#Comment:
        /**
         * Sets the value of the orderNum property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         */

#Code:
        public void setOrderNum(String value) {
            this.orderNum = value;
        }

#No. 83
#File: E:\bishe\1\ABCOrder.java
#Comment:
            /**
             * Gets the value of the price property.
             * 
             */

#Code:
            public float getPrice() {
                return price;
            }

#No. 84
#File: E:\bishe\1\ABCOrder.java
#Comment:
            /**
             * Sets the value of the price property.
             * 
             */

#Code:
            public void setPrice(float value) {
                this.price = value;
            }

#No. 85
#File: E:\bishe\1\ABCOrder.java
#Comment:
            /**
             * Gets the value of the quantity property.
             * 
             */

#Code:
            public short getQuantity() {
                return quantity;
            }

#No. 86
#File: E:\bishe\1\ABCOrder.java
#Comment:
            /**
             * Sets the value of the quantity property.
             * 
             */

#Code:
            public void setQuantity(short value) {
                this.quantity = value;
            }

#No. 87
#File: E:\bishe\1\ABCOrder.java
#Comment:
            /**
             * Gets the value of the id property.
             * 
             * @return
             *     possible object is
             *     {@link String }
             *     
             */

#Code:
            public String getId() {
                return id;
            }

#No. 88
#File: E:\bishe\1\ABCOrder.java
#Comment:
            /**
             * Sets the value of the id property.
             * 
             * @param value
             *     allowed object is
             *     {@link String }
             *     
             */

#Code:
            public void setId(String value) {
                this.id = value;
            }

#No. 89
#File: E:\bishe\1\AbcPullToRefreshAttacher.java
#Comment:
        /**
         * @return Context which should be used for inflating the header layout
         */

#Code:
        public Context getContextForInflater(Activity activity) {
            Context context = null;
            ActionBar ab = ((ActionBarActivity) activity).getSupportActionBar();
            if (ab != null) {
                context = ab.getThemedContext();
            }
            if (context == null) {
                context = activity;
            }
            return context;
        }

#No. 90
#File: E:\bishe\1\AbiType.java
#Comment:
/**
 * Represent the various types of ABIs that exist (extracted from "elf.h" file from libc6-dev package).
 */

#Code:
public enum AbiType {
    SYSV(0, "UNIX System V ABI"),
    HPUX(1, "HP-UX"),
    NETBSD(2, "NetBSD."),
    GNU(3, "Object uses GNU ELF extensions."),
    SOLARIS(6, "Sun Solaris."),
    AIX(7, "IBM AIX."),
    IRIX(8, "SGI Irix."),
    FREEBSD(9, "FreeBSD."),
    TRU64(10, "Compaq TRU64 UNIX."),
    MODESTO(11, "Novell Modesto."),
    OPENBSD(12, "OpenBSD."),
    ARM_AEABI(64, "ARM EABI"),
    ARM(97, "ARM"),
    STANDALONE(255, "Standalone (embedded) application");

    private final int no;
    private final String desc;

    private AbiType(int no, String desc) {
        this.no = no;
        this.desc = desc;
    }

    static AbiType valueOf(int value) {
        for (AbiType at : values()) {
            if (at.no == value) {
                return at;
            }
        }
        throw new IllegalArgumentException("Invalid ABI type: " + value);
    }

    @Override
    public String toString() {
        return desc;
    }
}
#No. 91
#File: E:\bishe\1\Ablepsia.java
#Comment:
    /**
     * 携带 flag ,如果你多次调用{@link #flags(int) },那么只会认为最后一次是有效操作,如果你需要携带多个 flag ,你应该使用 '|'
     * <p>
     *     Portable flag, If you call a number of times{@link #flags(int) },
     *     it will only think that the last time is an effective operation,
     *     if you need to carry more than one flag, you should use'|'
     *
     * @param flags FLAG
     * @return Doctor.Proxy
     *
     * <code>
     *
     *     Ablepsia.flags(Intent.FLAG_1).open(context,TargetActivity.class);
     *
     *     Ablepsia.flags(Intent.FLAG_1 | Intent.FLAG_2).open(context,TargetActivity.class);
     *
     * </code>
     */

#Code:
    static public Doctor.Proxy flags(int flags) {
        return getDoctor().getProxy().flag(flags);
    }

#No. 92
#File: E:\bishe\1\Ablepsia.java
#Comment:
    /**
     * 从 Intent 中获取所有的参数
     * <p>
     *     Get all the parameters from Intent
     *
     * @param kvIntent 包含参数的 Intent
     * @return Doctor.Proxy
     *
     * <code>
     *
     *     Intent intent = new Intent();
     *
     *     intent.putExtra("name","tom");
     *     intent.putExtra("age",13);
     *
     *     Ablepsia.kvFromIntent(intent)
     *             .kv("loveGirl",true)
     *             .open(this, UseInfoActivity.class);
     *
     * </code>
     */

#Code:
    static public Doctor.Proxy kvFromIntent(@NonNull Intent kvIntent){
        return getDoctor().getProxy().kvFromIntent(kvIntent);
    }

    /**
     * 携带参数
     * <p>
     *     Portable parameters
     *
     * @see Intent#putExtra
     *
     * @param name key
     * @param value value
     * @return Doctor.Proxy
     *
     * <code>
     *
     *     Ablepsia.kv("name","tom")
     *             .kv("age",100)
     *             .kv("loveGirl",true)
     *             .open(context,TargetActivity.class);
     *
     *      |--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|
     *
     *      protected void onCreate(Bundle savedInstanceState) {
     *          super.onCreate(savedInstanceState);
     *
     *          String   name     = getIntent().getStringExtra("name");
     *          int      age      = getIntent().getIntExtra("age");
     *          boolean  loveGirl = getIntent().getBooleanExtra("loveGirl");
     *
     *      }

#No. 93
#File: E:\bishe\1\AbLogUtil.java
#Comment:
	/**
	 * debug日志
	 * @param tag
	 * @param message
	 */

#Code:
	public static void d(String tag,String message) {
		if(D) Log.d(tag, message);
	}

#No. 94
#File: E:\bishe\1\AbLogUtil.java
#Comment:
	/**
	 * debug日志
	 * @param context
	 * @param message
	 */

#Code:
	public static void d(Context context,String message) {
		String tag = context.getClass().getSimpleName();
		d(tag, message);
	}

#No. 95
#File: E:\bishe\1\AbLogUtil.java
#Comment:
	/**
	 * debug日志
	 * @param clazz
	 * @param message
	 */

#Code:
	public static void d(Class<?> clazz,String message) {
		String tag = clazz.getSimpleName();
		d(tag, message);
	}

#No. 96
#File: E:\bishe\1\AbLogUtil.java
#Comment:
	/**
	 * info日志
	 * @param tag
	 * @param message
	 */

#Code:
	public static void i(String tag,String message) {
		if(!TextUtils.isEmpty(message)){
			Log.i(tag, message);
		}
	}

#No. 97
#File: E:\bishe\1\AbLogUtil.java
#Comment:
	/**
	 * info日志
	 * @param context
	 * @param message
	 */

#Code:
	public static void i(Context context,String message) {
		String tag = context.getClass().getSimpleName();
		i(tag, message);
	}

#No. 98
#File: E:\bishe\1\AbLogUtil.java
#Comment:
	/**
	 * info日志
	 * @param clazz
	 * @param message
	 */

#Code:
	public static void i(Class<?> clazz,String message) {
		String tag = clazz.getSimpleName();
		i(tag, message);
	}

#No. 99
#File: E:\bishe\1\AbLogUtil.java
#Comment:
	/**
	 * error日志
	 * @param tag
	 * @param message
	 */

#Code:
	public static void e(String tag,String message) {
		Log.e(tag, message);
	}

#No. 100
#File: E:\bishe\1\AbLogUtil.java
#Comment:
	/**
	 * error日志
	 * @param context
	 * @param message
	 */

#Code:
	public static void e(Context context,String message) {
		String tag = context.getClass().getSimpleName();
		e(tag, message);
	}

#No. 101
#File: E:\bishe\1\AbLogUtil.java
#Comment:
	/**
	 * error日志
	 * @param clazz
	 * @param message
	 */

#Code:
	public static void e(Class<?> clazz,String message) {
		String tag = clazz.getSimpleName();
		e(tag, message);
	}

#No. 102
#File: E:\bishe\1\AbLogUtil.java
#Comment:
	/**
	 * 描述：记录当前时间毫秒.
	 *
	 */

#Code:
	public static void prepareLog(String tag) {
		Calendar current = Calendar.getInstance();
		startLogTimeInMillis = current.getTimeInMillis();
		Log.d(tag,"日志计时开始："+startLogTimeInMillis);
	}

#No. 103
#File: E:\bishe\1\AbLogUtil.java
#Comment:
	/**
	 * 描述：记录当前时间毫秒.
	 *
	 */

#Code:
	public static void prepareLog(Context context) {
		String tag = context.getClass().getSimpleName();
		prepareLog(tag);
	}

#No. 104
#File: E:\bishe\1\AbLogUtil.java
#Comment:
	/**
	 * 描述：记录当前时间毫秒.
	 *
	 */

#Code:
	public static void prepareLog(Class<?> clazz) {
		String tag = clazz.getSimpleName();
		prepareLog(tag);
	}

#No. 105
#File: E:\bishe\1\AbLogUtil.java
#Comment:
	/**
	 * 描述：打印这次的执行时间毫秒，需要首先调用prepareLog().
	 *
	 * @param tag 标记
	 * @param message 描述
	 * @param printTime 是否打印时间
	 */

#Code:
	public static void d(String tag, String message,boolean printTime) {
		Calendar current = Calendar.getInstance();
		long endLogTimeInMillis = current.getTimeInMillis();
		Log.d(tag,message+":"+(endLogTimeInMillis-startLogTimeInMillis)+"ms");
	}

#No. 106
#File: E:\bishe\1\AbLogUtil.java
#Comment:
	/**
	 * 描述：打印这次的执行时间毫秒，需要首先调用prepareLog().
	 *
	 * @param context
	 * @param message 描述
	 * @param printTime 是否打印时间
	 */

#Code:
	public static void d(Context context,String message,boolean printTime) {
		String tag = context.getClass().getSimpleName();
		d(tag,message,printTime);
	}

#No. 107
#File: E:\bishe\1\AbLogUtil.java
#Comment:
	/**
	 * 描述：打印这次的执行时间毫秒，需要首先调用prepareLog().
	 *
	 * @param clazz 标记
	 * @param message 描述
	 * @param printTime 是否打印时间
	 */

#Code:
	public static void d(Class<?> clazz,String message,boolean printTime) {
		String tag = clazz.getSimpleName();
		d(tag,message,printTime);
	}

#No. 108
#File: E:\bishe\1\AbLogUtil.java
#Comment:
	/**
	 * debug日志的开关
	 * @param d
	 */

#Code:
	public static void debug(boolean d) {
		D  = d;
	}

#No. 109
#File: E:\bishe\1\AbLogUtil.java
#Comment:
	/**
	 * info日志的开关
	 * @param i
	 */

#Code:
	public static void info(boolean i) {
		I  = i;
	}

#No. 110
#File: E:\bishe\1\AbLogUtil.java
#Comment:
	/**
	 * error日志的开关
	 * @param e
	 */

#Code:
	public static void error(boolean e) {
		E  = e;
	}

#No. 111
#File: E:\bishe\1\AbLogUtil.java
#Comment:
	/**
	 * 设置日志的开关
	 * @param e
	 */

#Code:
	public static void setVerbose(boolean d,boolean i,boolean e) {
		D  = d;
		I  = i;
		E  = e;
	}

#No. 112
#File: E:\bishe\1\AbLogUtil.java
#Comment:
	/**
	 * 打开所有日志，默认全打开
	 * @param
	 */

#Code:
	public static void openAll() {
		D  = true;
		I  = true;
		E  = true;
	}

#No. 113
#File: E:\bishe\1\AbLogUtil.java
#Comment:
	/**
	 * 关闭所有日志
	 * @param
	 */

#Code:
	public static void closeAll() {
		D  = false;
		I  = false;
		E  = false;
	}

#No. 114
#File: E:\bishe\1\AbnormalTerminationException.java
#Comment:
/**
 * Implements an exception thrown when the CLI terminates abruptly.
 */

#Code:
public class AbnormalTerminationException
        extends Exception {

    private static final long serialVersionUID = 1;

    /**
     * Creates an exception thrown when the CLI terminates abruptly.
     */
    public AbnormalTerminationException() {
    }

    /**
     * Creates an exception thrown when the CLI terminates abruptly.
     *
     * @param s A string describing the problem.
     */
    public AbnormalTerminationException(String s) {
        super(s);
    }
}

#No. 115
#File: E:\bishe\1\Abortables.java
#Comment:
    /**
     * Abort async <i>abortable</i>
     *
     * @param abortable the {@code AsyncAbortable} object to be aborted, or null, in which case this method
     *                  does nothing.
     * @param swallowIOException if true, don't propagate IO exceptions thrown by the {@code abort} methods
     * @throws IOException if {@code swallowIOException} is false and {@code abort} throws an {@code IOException}
     * @see #abort(Abortable, boolean)
     */

#Code:
    public static void abort(@Nullable AsyncAbortable abortable,
                             boolean swallowIOException)
            throws IOException {
        if (null == abortable) {
            return;
        }
        try {
            FutureUtils.result(abortable.asyncAbort());
        } catch (IOException ioe) {
            if (swallowIOException) {
                logger.warn("IOException thrown while aborting Abortable {} : ", abortable, ioe);
            } else {
                throw ioe;
            }
        }
    }

#No. 116
#File: E:\bishe\1\Abortables.java
#Comment:
    /**
     * Abort the abortables in sequence.
     *
     * @param executorService
     *          executor service to execute
     * @param abortables
     *          abortables to abort
     * @return future represents the abort future
     */

#Code:
    public static Future<Void> abortSequence(ExecutorService executorService,
                                             AsyncAbortable... abortables) {
        List<AsyncAbortable> abortableList = Lists.newArrayListWithExpectedSize(abortables.length);
        for (AsyncAbortable abortable : abortables) {
            if (null == abortable) {
                abortableList.add(AsyncAbortable.NULL);
            } else {
                abortableList.add(abortable);
            }
        }
        return FutureUtils.processList(
                abortableList,
                AsyncAbortable.ABORT_FUNC,
                executorService).map(VoidFunctions.LIST_TO_VOID_FUNC);
    }

#No. 117
#File: E:\bishe\1\AbortAllCommand.java
#Comment:
/**
   Command to issue abort against transaction held in TxnDispatcherState
 */

#Code:
class AbortAllCommand implements Command {
    AbortAllCommand() {
    }

    public Serializable execute(PrevalentSystem aSystem) throws Exception {
        TxnDispatcherState mySystem = (TxnDispatcherState) aSystem;

        mySystem.abortAll();

        return null;
    }

    public String toString() {
        return " AA";
    }
}

#No. 118
#File: E:\bishe\1\AbortCommand.java
#Comment:
/**
   Command to issue abort against transaction held in TxnDispatcherState
 */

#Code:
class AbortCommand implements Command {
    static final long serialVersionUID = 182858469530698187L;

    private TxnId theId;

    AbortCommand(TxnId anId) {
        theId = anId;
    }

    public Serializable execute(PrevalentSystem aSystem) throws Exception {
        TxnDispatcherState mySystem = (TxnDispatcherState) aSystem;

        try {
            mySystem.abort(theId);
        } catch (UnknownTransactionException aUTE) {
            /*
              We may have logged the abort command whilst the transaction was
              in active state which means there's no prior prepare command in
              the log.  If we then run recovery, the first time we'll do
              anything with the transaction is when we load and execute abort.
              Because there's no prior prepare, we will have no state loaded
              for the transaction. Thus, if we can't find the transaction it's
              okay but we shouldn't take further action.

              Of course, we could be asked to abort something we're
              unaware of which can happen under various circumstances 
              (including a buggy TxnMgr) but it's okay to swallow that silently.
            */
            TxnDispatcher.theLogger.log(Level.FINE,
                                     "Abort failed - transaction is missing",
                                     aUTE);
        }

        return null;
    }

    public String toString() {
        return " AB : " + theId;
    }
}

#No. 119
#File: E:\bishe\1\AbortGroupException.java
#Comment:
    /**
	 * 
	 */

#Code:
    private static final long serialVersionUID = 1L;

}
}

#No. 120
#File: E:\bishe\1\AbortOnConsolidationFailureInterceptor.java
#Comment:
/**
 * @author eitany
 * @since 9.0.1
 */

#Code:
@com.gigaspaces.api.InternalApi
public class AbortOnConsolidationFailureInterceptor
        extends SynchronizationEndpointInterceptor {
    public static AbortOnConsolidationFailureInterceptor INSTANCE = new AbortOnConsolidationFailureInterceptor();

    @Override
    public void onTransactionConsolidationFailure(ConsolidationParticipantData participantData) {
        participantData.abort();
    }
}

#No. 121
#File: E:\bishe\1\AbortProcessingException.java
#Comment:
/**
 * Exception thrown when annotation processing should be aborted for the current class. Processing
 * can continue on other classes. Throwing this exception does not cause a compiler error, so either
 * one should explicitly be emitted or it should be clear that the compiler will be producing its
 * own error for other reasons.
 *
 * @author emcmanus@google.com (Éamonn McManus)
 */

#Code:
@SuppressWarnings("serial")
class AbortProcessingException extends RuntimeException {
}

#No. 122
#File: E:\bishe\1\AbortScriptException.java
#Comment:
    /**
	 * 
	 */

#Code:
    private static final long serialVersionUID = 1L;

}
}

#No. 123
#File: E:\bishe\1\AboutActivityFacade.java
#Comment:
	/**
	 * Construct the <code>Facade</code> multiton instance for this
	 * <code>Activity</code>.
	 * 
	 * @param multitonKey
	 * 		Multiton key for this <code>Facade</code> multiton instance.
	 */

#Code:
	public AboutActivityFacade( String multitonKey )
	{
		super(multitonKey);
	}

#No. 124
#File: E:\bishe\1\AboutActivityFacade.java
#Comment:
	/**
	 * <code>ApplicationFacade</code> singleton fabrication method
	 * implementation.
	 * 
	 * @param multitonKey
	 * 		Multiton key of the facade instance to get.
	 */

#Code:
	public static AboutActivityFacade getInst( String multitonKey )
	{
		if( instanceMap.get(multitonKey) == null )
			instanceMap.put( multitonKey, new AboutActivityFacade( multitonKey ) );

		return (AboutActivityFacade) instanceMap.get(multitonKey);
	}

#No. 125
#File: E:\bishe\1\AboutActivityFacade.java
#Comment:
	/**
	 * Start the <code>Activity</code> initialization sequence.
	 * 
	 * @param activity
	 * 		A reference to the <code>Activity</code> to initialize.
	 */

#Code:
	public void startup( AboutActivity activity )
	{
		sendNotification(  NotificationNames.STARTUP, activity  );
	}

#No. 126
#File: E:\bishe\1\AboutAppFragment.java
#Comment:
    /**
     * Returns a new instance of this fragment for the given section
     * number.
     */

#Code:
    public static AboutAppFragment newInstance(int sectionNumber) {
        AboutAppFragment fragment = new AboutAppFragment();
        Bundle args = new Bundle();
        args.putInt(Constants.ARG_SECTION_NUMBER, sectionNumber);
        fragment.setArguments(args);
        return fragment;
    }

#No. 127
#File: E:\bishe\1\AboutAppOverlay.java
#Comment:
    /**
     * Add a new inflated layout into a GestureOverlayView and return the new view
     *
     * @param context context
     * @param layout  the layout to inflate
     * @param rawId   the resource identifier of the gesture file in your raw folder
     * @return the new contentView wrapped in a GestureOverlayView
     */

#Code:
    @Deprecated
    public static View getOverlayContentView(Context context, int layout, int rawId) {
        View contentView = LayoutInflater.from(context).inflate(layout, null);
        return getOverlayContentView(contentView, null, rawId);
    }

#No. 128
#File: E:\bishe\1\AboutAppOverlay.java
#Comment:
    /**
     * Add a new inflated layout into a GestureOverlayView and return the new view
     *
     * @param context     context
     * @param layout      the layout to inflate
     * @param packageName the package name of the app who uses this library
     * @param rawId       the resource identifier of the gesture file in your raw folder
     * @return the new contentView wrapped in a GestureOverlayView
     */

#Code:
    public static View getOverlayContentView(Context context, int layout, String packageName,
                                             int rawId) {
        View contentView = LayoutInflater.from(context).inflate(layout, null);
        return getOverlayContentView(contentView, packageName, rawId);
    }

#No. 129
#File: E:\bishe\1\AboutAppOverlay.java
#Comment:
    /**
     * Add the content view of the activity into a GestureOverlayView and return the new view
     *
     * @param contentView the original content view of the activity
     * @param packageName the package name of the app who uses this library
     * @param rawId       the resource identifier of the gesture file in your raw folder
     * @return the new contentView wrapped in a GestureOverlayView
     */

#Code:
    public static View getOverlayContentView(final View contentView, final String packageName,
                                             int rawId) {
        //load the gestures
        final GestureLibrary gestureLib = GestureLibraries
                .fromRawResource(contentView.getContext(), rawId);
        if (!gestureLib.load()) {
            Log.w(TAG, "could not load gestures");
            return contentView;
        }

        GestureOverlayView gestureOverlayView = new GestureOverlayView(contentView.getContext());
        gestureOverlayView.setGestureColor(Color.TRANSPARENT);
        gestureOverlayView.setUncertainGestureColor(Color.TRANSPARENT);
        gestureOverlayView.addView(contentView);
        gestureOverlayView
                .addOnGesturePerformedListener(new GestureOverlayView.OnGesturePerformedListener() {
                    @Override
                    public void onGesturePerformed(GestureOverlayView overlay, Gesture gesture) {
                        //load all gestures
                        ArrayList<Prediction> predictions = gestureLib.recognize(gesture);
                        //the only received prediction should be "netural"
                        for (Prediction prediction : predictions) {
                            if (prediction.score > 1.0) {
                                showDialog(contentView.getContext(), packageName);
                            }
                        }
                    }
                });
        return gestureOverlayView;
    }

#No. 130
#File: E:\bishe\1\AboutAppOverlay.java
#Comment:
    /**
     * Gets a field from the project's BuildConfig. This is useful when, for example, flavors are
     * used at the project level to set custom fields.
     *
     * @param context     Used to find the correct file
     * @param packageName the package name of the app who uses this library
     * @param fieldName   The name of the field-to-access
     * @return The value of the field, or {@code null} if the field is not found.
     */

#Code:
    public static Object getBuildConfigValue(Context context, String packageName,
                                             String fieldName) {
        if (packageName == null) {
            packageName = context.getPackageName();
        }
        try {
            Class<?> clazz = Class.forName(packageName + ".BuildConfig");
            Field field = clazz.getField(fieldName);
            return field.get(null);
        } catch (ClassNotFoundException e) {
            Log.w(TAG, "error reading BuildConfig value", e);
        } catch (NoSuchFieldException e) {
            Log.w(TAG, "error reading BuildConfig value", e);
        } catch (IllegalAccessException e) {
            Log.w(TAG, "error reading BuildConfig value", e);
        }
        return null;
    }

#No. 131
#File: E:\bishe\1\AboutCanvas.java
#Comment:
    /**
     * Draw about canvas.
     * @param g
     */

#Code:
    protected void paint(Graphics g) {
        /** Clear canvas */
        g.setColor(Theme.BACKGROUND_COLOR);
        g.fillRect(0, 0, this.getWidth(), this.getHeight());
        
        /** Draw about text */
        int height = 0;
        height += balloon.draw(g, texts[0], "Mobidentica", 5 + height);
        height += balloon.draw(g, texts[1], "Mobidentica", 5 + height);
        height += balloon.draw(g, texts[2], "Mobidentica", 5 + height);
    }

#No. 132
#File: E:\bishe\1\AboutDialogShow.java
#Comment:
/**
 * Shows the {@link AboutDialog}.
 *
 * @author Andreas Wenger
 */

#Code:
@AllArgsConstructor
public class AboutDialogShow
	extends TransparentCommand {
	
	private Window owner;

	@Override public void execute() {
		Dialog.dialog(AboutDialog.class).showDialog(owner);
	}

#No. 133
#File: E:\bishe\1\AboutLibrariesFragment.java
#Comment:
/**
 * Author:      Kartik Sharma
 * Email Id:    cr42yh17m4n@gmail.com
 * Created:     2/13/2017 1:09 PM
 * Description: Unavailable
 */

#Code:

public class AboutLibrariesFragment extends BaseSupportFragment implements AboutLibrariesContract.View,
        AboutLibrariesRecyclerAdapter.OnLibraryItemClickListener {
    private static final String TAG = "AboutLibrariesFragment";
    private final CustomTabsIntent mCustomTabsIntent = new CustomTabsIntent.Builder()
            .enableUrlBarHiding()
            .setShowTitle(true)
            .build();
    private final CustomTabsActivityHelper.CustomTabsFallback mCustomTabsFallback =
            new CustomTabsActivityHelper.CustomTabsFallback() {
                @Override
                public void openUri(Activity activity, Uri uri) {
                    try {
                        activity.startActivity(new Intent(Intent.ACTION_VIEW, uri));
                    } catch (ActivityNotFoundException e) {
                        e.printStackTrace();
                        Toast.makeText(activity, R.string.no_application_available_to_open_this_url, Toast.LENGTH_LONG)
                                .show();
                    }
                }
            };
    @BindView(R.id.recycler_view_libraries)
    RecyclerView recyclerViewLibraries;
    private AboutLibrariesRecyclerAdapter mAboutLibrariesRecyclerAdapter;
    private AboutLibrariesContract.Presenter mAboutLibrariesPresenter;

    public static AboutLibrariesFragment newInstance() {
        return new AboutLibrariesFragment();
    }

    @Override
    public void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setPresenter(new AboutLibrariesPresenter(this));
        mAboutLibrariesPresenter.subscribe();
    }

#No. 134
#File: E:\bishe\1\AboutPage.java
#Comment:
    /**
     * Add a new group that will display a header in this AboutPage
     * <p>
     * A header will be displayed in the order it was added. For e.g:
     * <p>
     * <code>
     * new AboutPage(this)
     * .addItem(firstItem)
     * .addGroup("Header")
     * .addItem(secondItem)
     * .create();
     * </code>
     * <p>
     * Will display the following
     * [First item]
     * [Header]
     * [Second item]
     *
     * @param name the title for this group
     * @return this AboutPage instance for builder pattern support
     */

#Code:
    public AboutPage addGroup(String name) {

        TextView textView = new TextView(mContext);
        textView.setText(name);
        TextViewCompat.setTextAppearance(textView, R.style.about_groupTextAppearance);
        LinearLayout.LayoutParams textParams = new LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);

        if (mCustomFont != null) {
            textView.setTypeface(mCustomFont);
        }

        int padding = mContext.getResources().getDimensionPixelSize(R.dimen.about_group_text_padding);
        textView.setPadding(padding, padding, padding, padding);


        if (mIsRTL) {
            textView.setGravity(Gravity.END | Gravity.CENTER_VERTICAL);
            textParams.gravity = Gravity.END | Gravity.CENTER_VERTICAL;
        } else {
            textView.setGravity(Gravity.START | Gravity.CENTER_VERTICAL);
            textParams.gravity = Gravity.START | Gravity.CENTER_VERTICAL;
        }
        textView.setLayoutParams(textParams);

        ((LinearLayout) mView.findViewById(R.id.about_providers)).addView(textView);
        return this;
    }

#No. 135
#File: E:\bishe\1\AboutPage.java
#Comment:
    /**
     * Turn on the RTL mode.
     *
     * @param value
     * @return this AboutPage instance for builder pattern support
     */

#Code:
    public AboutPage isRTL(boolean value) {
        this.mIsRTL = value;
        return this;
    }

#No. 136
#File: E:\bishe\1\AboutPage.java
#Comment:
    /**
     * Create and inflate this AboutPage. After this method is called the AboutPage
     * cannot be customized any more.
     *
     * @return the inflated {@link View} of this AboutPage
     */

#Code:
    public View create() {
        TextView description = (TextView) mView.findViewById(R.id.description);
        ImageView image = (ImageView) mView.findViewById(R.id.image);
        if (mImage > 0) {
            image.setImageResource(mImage);
        }

        if (!TextUtils.isEmpty(mDescription)) {
            description.setText(mDescription);
        }

        description.setGravity(Gravity.CENTER);

        if (mCustomFont != null) {
            description.setTypeface(mCustomFont);
        }

        return mView;
    }

#No. 137
#File: E:\bishe\1\AboveRegionParser.java
#Comment:
  /**
   * Parses an element for an above region.
   *
   * @param element The element.
   */

#Code:
  public AboveRegionParser(Element element) throws RegionException {
    String xAxisValue = element.getAttributeValue("x");
    if (xAxisValue != null && !Numbers.isDecimal(xAxisValue)) {
      throw new InvalidRegionAttributeException("x", element);
    }

    String yAxisValue = element.getAttributeValue("y");
    if (yAxisValue != null && !Numbers.isDecimal(yAxisValue)) {
      throw new InvalidRegionAttributeException("y", element);
    }

    String zAxisValue = element.getAttributeValue("z");
    if (zAxisValue != null && !Numbers.isDecimal(zAxisValue)) {
      throw new InvalidRegionAttributeException("z", element);
    }

    min = new Vector(
        Numbers.parseDouble(xAxisValue, Double.NEGATIVE_INFINITY),
        Numbers.parseDouble(yAxisValue, Double.NEGATIVE_INFINITY),
        Numbers.parseDouble(zAxisValue, Double.NEGATIVE_INFINITY));
  }

#No. 138
#File: E:\bishe\1\AbsActionBarView.java
#Comment:
    /*
     * Must be public so we can dispatch pre-2.2 via ActionBarImpl.
     */

#Code:
    @Override
    public void onConfigurationChanged(Configuration newConfig) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.FROYO) {
            super.onConfigurationChanged(newConfig);
        } else if (mMenuView != null) {
            mMenuView.onConfigurationChanged(newConfig);
        }

        // Action bar can change size on configuration changes.
        // Reread the desired height from the theme-specified style.
        TypedArray a = getContext().obtainStyledAttributes(null, R.styleable.SherlockActionBar,
                R.attr.actionBarStyle, 0);
        setContentHeight(a.getLayoutDimension(R.styleable.SherlockActionBar_height, 0));
        a.recycle();
        if (mSplitWhenNarrow) {
            setSplitActionBar(getResources_getBoolean(getContext(),
                    R.bool.abs__split_action_bar_is_narrow));
        }
        if (mActionMenuPresenter != null) {
            mActionMenuPresenter.onConfigurationChanged(newConfig);
        }
    }

#No. 139
#File: E:\bishe\1\AbsActionBarView.java
#Comment:
    /**
     * Sets whether the bar should be split right now, no questions asked.
     * @param split true if the bar should split
     */

#Code:
    public void setSplitActionBar(boolean split) {
        mSplitActionBar = split;
    }

#No. 140
#File: E:\bishe\1\AbsActionBarView.java
#Comment:
    /**
     * Sets whether the bar should split if we enter a narrow screen configuration.
     * @param splitWhenNarrow true if the bar should check to split after a config change
     */

#Code:
    public void setSplitWhenNarrow(boolean splitWhenNarrow) {
        mSplitWhenNarrow = splitWhenNarrow;
    }

#No. 141
#File: E:\bishe\1\AbsActionBarView.java
#Comment:
    /**
     * @return Current visibility or if animating, the visibility being animated to.
     */

#Code:
    public int getAnimatedVisibility() {
        if (mVisibilityAnim != null) {
            return mVisAnimListener.mFinalVisibility;
        }
        return getVisibility();
    }

#No. 142
#File: E:\bishe\1\AbsActionTitleBarNav.java
#Comment:
	/* 
	 * @see android.app.v4.ActionBar#setNavigationMode(int)
	 */

#Code:
	@Override
	public void setNavigationMode(int mode) {
		mNavViewContext = initActionBarNavView();
		if(mode != getNavigationMode()){
			navigationMode = mode;
			switch (mode) {
			case NAVIGATION_MODE_TABS:
				//TODO impl tab fragment change
				tabsLayout = (LinearLayout) findView(getActionView(), R.id.actiontitle_bar_nav);
				if(tabsLayout == null){
					tabsLayout = (LinearLayout) mNavViewContext;
				}
				
				break;
			case NAVIGATION_MODE_LIST:
				if(mNavViewContext.getChildCount() > 0){
					getActionBarNavView().setVisibility(View.VISIBLE);
				}else{
					Spinner spinner = new Spinner(mContext);
					mNavViewContext.addView(spinner);
				}
				
				break;
			case NAVIGATION_MODE_STANDARD:
				// NAVIGATION up
				setDisplayHomeAsUpEnabled(true);
				//default home up 
				findView(mBasicActionView, R.id.action_home_up).setOnClickListener(onBackListener);
				break;
			default:
				//if not mode set clean home up
				setDisplayHomeAsUpEnabled(false);
				break;
			}
		}
	}

#No. 143
#File: E:\bishe\1\AbsActionTitleBarNav.java
#Comment:
	/**
	 * @return
	 */

#Code:
	private ViewGroup initActionBarNavView(){
		View navView = getActionView().findViewById(R.id.action_bar_nav_list);
		if(navView instanceof ViewStub){
			ViewGroup actionViewContext = (ViewGroup) ((ViewStub) navView).inflate();
			actionViewContext.removeAllViews();
			return actionViewContext;
		}else{
			ViewGroup actionViewContext = (ViewGroup) navView;
			actionViewContext.removeAllViews();
			return actionViewContext;
		}
	}

#No. 144
#File: E:\bishe\1\AbsActionTitleBarNav.java
#Comment:
	 /**
	 *  actionbar list nav listener
	 */

#Code:
	private final AdapterView.OnItemSelectedListener mNavItemSelectedListener =
	            new AdapterView.OnItemSelectedListener() {
	        public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {
	            if (mCallback != null) {
	                mCallback.onNavigationItemSelected(position, id);
	            }
	        }
	        public void onNothingSelected(AdapterView<?> parent) {
	            // Do nothing
	        }
	    };

#No. 145
#File: E:\bishe\1\AbsAmount.java
#Comment:
/**
 * 絶対値の金額(必須)を表現する制約注釈。
 */

#Code:
@Documented
@Constraint(validatedBy = {})
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
@ReportAsSingleViolation
@NotNull
@Digits(integer = 16, fraction = 4)
@DecimalMin("0.00")
public @interface AbsAmount {
    String message() default "{error.domain.absAmount}";

    Class<?>[] groups() default {};

    Class<? extends Payload>[] payload() default {};

    @OverridesAttribute(constraint = Digits.class, name = "integer")
    int integer() default 16;

    @OverridesAttribute(constraint = Digits.class, name = "fraction")
    int fraction() default 4;

    @OverridesAttribute(constraint = DecimalMin.class, name = "value")
    String min() default "0.00";

    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    public @interface List {
        AbsAmount[] value();
    }

#No. 146
#File: E:\bishe\1\AbsAmountEmpty.java
#Comment:
/**
 * 絶対値の金額を表現する制約注釈。
 */

#Code:
@Documented
@Constraint(validatedBy = {})
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
@ReportAsSingleViolation
@Digits(integer = 16, fraction = 4)
@DecimalMin("0.00")
public @interface AbsAmountEmpty {
    String message() default "{error.domain.absAmount}";

    Class<?>[] groups() default {};

    Class<? extends Payload>[] payload() default {};

    @OverridesAttribute(constraint = Digits.class, name = "integer")
    int integer() default 16;

    @OverridesAttribute(constraint = Digits.class, name = "fraction")
    int fraction() default 4;

    @OverridesAttribute(constraint = DecimalMin.class, name = "value")
    String min() default "0.00";

    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    public @interface List {
        AbsAmountEmpty[] value();
    }

#No. 147
#File: E:\bishe\1\AbsApplicationsLoader.java
#Comment:
	/**
	 * Handles a request to completely reset the Loader.
	 */

#Code:
	@Override
	protected void onReset() {
		super.onReset();

		// Ensure the loader is stopped
		onStopLoading();

		// Stop monitoring for changes.
		if (mPackageObserver != null) {
			getContext().unregisterReceiver(mPackageObserver);
			mPackageObserver = null;
		}
	}

#No. 148
#File: E:\bishe\1\AbsApplicationsLoader.java
#Comment:
	/**
	 * Handles a request to start the Loader.
	 */

#Code:
	@Override
	protected void onStartLoading() {

		// Start watching for changes in the app data.
		if (mPackageObserver == null) {
			mPackageObserver = new PackageIntentReceiver(this);
		}

		// Has something interesting in the configuration changed since we
		// last built the app list?
		final boolean configChange = mLastConfig.applyNewConfig(getContext().getResources());

		if (takeContentChanged() || configChange) {
			// If the data has changed since the last time it was loaded
			// or is not currently available, start a load.
			forceLoad();
		}
	}

#No. 149
#File: E:\bishe\1\AbsApplicationsLoader.java
#Comment:
	/**
	 * Handles a request to stop the Loader.
	 */

#Code:
	@Override
	protected void onStopLoading() {
		// Attempt to cancel the current load task if possible.
		cancelLoad();
	}

#No. 150
#File: E:\bishe\1\AbsArrayAdapter.java
#Comment:
	/**
	 * Adds the specified Collection at the end of the adapter. Will repeat the last filtering
	 * request if invoked while filtered results are being displayed.
	 *
	 * @param items The Collection to add at the end of the adapter.
	 */

#Code:
	public void addAll(@NonNull Collection<? extends T> items) {
		boolean isModified;

		synchronized (mLock) {
			if (mOriginalValues != null) {
				isModified = mOriginalValues.addAll(items);
				if (isModified) {
					getFilter().filter(mLastConstraint);
				}
			} else {
				isModified = mObjects.addAll(items);
			}
		}

#No. 151
#File: E:\bishe\1\AbsArrayAdapter.java
#Comment:
	/**
	 * Adds the specified items at the end of the adapter. Will repeat the last filtering request if
	 * invoked while filtered results are being displayed.
	 *
	 * @param items The items to add at the end of the adapter.
	 */

#Code:
	@SafeVarargs
	public final void addAll(@NonNull T... items) {
		boolean isModified;

		synchronized (mLock) {
			if (mOriginalValues != null) {
				isModified = Collections.addAll(mOriginalValues, items);
				if (isModified) {
					getFilter().filter(mLastConstraint);
				}
			} else {
				isModified = Collections.addAll(mObjects, items);
			}
		}

#No. 152
#File: E:\bishe\1\AbsArrayAdapter.java
#Comment:
	/**
	 * Remove all elements from the adapter.
	 */

#Code:
	public void clear() {
		synchronized (mLock) {
			if (mOriginalValues != null) {
				mOriginalValues.clear();
			}
			mObjects.clear();
		}
		if (mNotifyOnChange) {
			notifyDataSetChanged();
		}
	}

#No. 153
#File: E:\bishe\1\AbsArrayAdapter.java
#Comment:
	/**
	 * Tests whether this adapter contains the specified item. Be aware that this is a linear
	 * search.
	 *
	 * @param item The item to search for
	 *
	 * @return {@code true} if the item is an element of this adapter. {@code false} otherwise
	 */

#Code:
	public boolean contains(@Nullable T item) {
		return mObjects.contains(item);
	}

	/**
	 * Tests whether this adapter contains all items contained in the specified collection.  Be
	 * aware that this performs a nested for loop search...eg O(n*m) complexity.
	 *
	 * @param items The collection of items
	 *
	 * @return {@code true} if all items in the specified collection are elements of this adapter,
	 * {@code false} otherwise
	 */
	public boolean containsAll(@NonNull Collection<?> items) {
		return mObjects.containsAll(items);
	}

	/**
	 * @return The Context associated with this adapter.
	 */
	@NonNull
	public Context getContext() {
		return mContext;
	}

#No. 154
#File: E:\bishe\1\AbsArrayAdapter.java
#Comment:
	/**
	 * <p>Get a {@link android.view.View} that displays in the drop down popup the data at the
	 * specified position in the data set.</p>
	 *
	 * @param inflater    the LayoutInflater object that can be used to inflate each view.
	 * @param position    index of the item whose view we want.
	 * @param convertView the old view to reuse, if possible. Note: You should check that this view
	 *                    is non-null and of an appropriate type before using. If it is not possible
	 *                    to convert this view to display the correct data, this method can create a
	 *                    new view.
	 * @param parent      the parent that this view will eventually be attached to
	 *
	 * @return a {@link android.view.View} corresponding to the data at the specified position.
	 */

#Code:
	@NonNull
	public View getDropDownView(@NonNull LayoutInflater inflater, int position,
								@Nullable View convertView, @NonNull ViewGroup parent) {
		return getView(inflater, position, convertView, parent);
	}

	@Override
	public final View getDropDownView(int position, View convertView, ViewGroup parent) {
		return getDropDownView(mInflater, position, convertView, parent);
	}

#No. 155
#File: E:\bishe\1\AbsArrayAdapter.java
#Comment:
	/**
	 * @return The shown filtered list. If no filter is applied, then the original list is returned.
	 */

#Code:
	@NonNull
	public ArrayList<T> getFilteredList() {
		ArrayList<T> objects;
		synchronized (mLock) {
			objects = new ArrayList<>(mObjects);
		}
		return objects;
	}

#No. 156
#File: E:\bishe\1\AbsArrayAdapter.java
#Comment:
	/**
	 * @return The original (unfiltered) list of items stored within the Adapter
	 */

#Code:
	@NonNull
	public ArrayList<T> getList() {
		ArrayList<T> objects;
		synchronized (mLock) {
			if (mOriginalValues != null) {
				objects = new ArrayList<>(mOriginalValues);
			} else {
				objects = new ArrayList<>(mObjects);
			}
		}
		return objects;
	}

#No. 157
#File: E:\bishe\1\AbsArrayAdapter.java
#Comment:
	/**
	 * Resets the adapter to store a new list of items. Convenient way of calling {@link #clear()},
	 * then {@link #addAll(java.util.Collection)} without having to worry about an extra {@link
	 * #notifyDataSetChanged()} invoked in between. Will repeat the last filtering request if
	 * invoked while filtered results are being displayed.
	 *
	 * @param items New list of items to store within the adapter.
	 */

#Code:
	public void setList(@NonNull Collection<? extends T> items) {
		synchronized (mLock) {
			if (mOriginalValues != null) {
				mOriginalValues.clear();
				mOriginalValues.addAll(items);
				getFilter().filter(mLastConstraint);
			} else {
				mObjects.clear();
				mObjects.addAll(items);
			}
		}

#No. 158
#File: E:\bishe\1\AbsArrayAdapter.java
#Comment:
	/**
	 * Returns the position of the specified item in the array.  Be aware that this performs a
	 * linear search.
	 *
	 * @param item The item to retrieve the position of.
	 *
	 * @return The position of the specified item.
	 */

#Code:
	public int getPosition(@Nullable T item) {
		return mObjects.indexOf(item);
	}

	/**
	 * Get a View that displays the data at the specified position in the data set. You can either
	 * create a View manually or inflate it from an XML layout file. When the View is inflated, the
	 * parent View (GridView, ListView...) will apply default layout parameters unless you use
	 * {@link android.view.LayoutInflater#inflate(int, android.view.ViewGroup, boolean)} to specify
	 * a root view and to prevent attachment to the root.
	 *
	 * @param inflater    The LayoutInflater object that can be used to inflate each view.
	 * @param position    The position of the item within the adapter's data set of the item whose
	 *                    view we want.
	 * @param convertView The old view to reuse, if possible. Note: You should check that this view
	 *                    is non-null and of an appropriate type before using. If it is not possible
	 *                    to convert this view to display the correct data, this method can create a
	 *                    new view. Heterogeneous lists can specify their number of view types, so
	 *                    that this View is always of the right type (see {@link
	 *                    #getViewTypeCount()} and {@link #getItemViewType(int)}).
	 * @param parent      The parent that this view will eventually be attached to
	 *
	 * @return A View corresponding to the data at the specified position.
	 */
	public abstract View getView(@NonNull LayoutInflater inflater, int position,
								 @Nullable View convertView, @NonNull ViewGroup parent);

	@Override
	public final View getView(int position, View convertView, ViewGroup parent) {
		return this.getView(mInflater, position, convertView, parent);
	}

#No. 159
#File: E:\bishe\1\AbsArrayAdapter.java
#Comment:
	/**
	 * Determines whether the provided constraint filters out the given item. Allows easy,
	 * customized filtering for subclasses. It's incorrect to modify the adapter or the contents of
	 * the item itself. Any alterations will lead to undefined behavior or crashes. Internally, this
	 * method is only ever invoked from a background thread.
	 *
	 * @param item       The item to compare against the constraint
	 * @param constraint The constraint used to filter the item
	 *
	 * @return True if the item is filtered out by the given constraint. False if the item will
	 * continue to display in the adapter.
	 */

#Code:
	protected abstract boolean isFilteredOut(T item, @NonNull CharSequence constraint);

	@Override
	public void notifyDataSetChanged() {
		super.notifyDataSetChanged();
		mNotifyOnChange = true;
	}

#No. 160
#File: E:\bishe\1\AbsArrayAdapter.java
#Comment:
	/**
	 * Removes the first occurrence of the specified item from the adapter.
	 *
	 * @param item The item to remove.
	 */

#Code:
	public void remove(@Nullable T item) {
		boolean isModified = false;

		synchronized (mLock) {
			if (mOriginalValues != null) {
				isModified = mOriginalValues.remove(item);
			}
			isModified |= mObjects.remove(item);
		}

#No. 161
#File: E:\bishe\1\AbsArrayAdapter.java
#Comment:
	/**
	 * Removes all occurrences in the adapter of each item in the specified collection.
	 *
	 * @param items The collection of items to remove
	 */

#Code:
	public void removeAll(@NonNull Collection<?> items) {
		boolean isModified = false;
		synchronized (mLock) {
			if (mOriginalValues != null) {
				isModified = mOriginalValues.removeAll(items);
			}
			isModified |= mObjects.removeAll(items);
		}

#No. 162
#File: E:\bishe\1\AbsArrayAdapter.java
#Comment:
	/**
	 * Removes all items from this adapter that are not contained in the specified collection.
	 *
	 * @param items The collection of items to retain
	 */

#Code:
	public void retainAll(@NonNull Collection<?> items) {
		boolean isModified = false;

		synchronized (mLock) {
			if (mOriginalValues != null) {
				isModified = mOriginalValues.retainAll(items);
			}
			isModified |= mObjects.retainAll(items);
		}

#No. 163
#File: E:\bishe\1\AbsArrayAdapter.java
#Comment:
	/**
	 * <p>Control whether methods that change the list ({@link #add}, {@link #retainAll}, {@link
	 * #remove}, {@link #clear}) automatically call {@link #notifyDataSetChanged}.  If set to false,
	 * caller must manually call notifyDataSetChanged() to have the changes reflected in the
	 * attached view.</p>
	 *
	 * <p>The default is true, and calling notifyDataSetChanged() resets the flag to true.</p>
	 *
	 * @param notifyOnChange if true, modifications to the list will automatically call {@link
	 *                       #notifyDataSetChanged}
	 */

#Code:
	public void setNotifyOnChange(boolean notifyOnChange) {
		mNotifyOnChange = notifyOnChange;
	}

#No. 164
#File: E:\bishe\1\AbsArrayAdapter.java
#Comment:
	/**
	 * Sorts the content of this adapter using the natural order of the stored items themselves.
	 * This requires items to have implemented {@link java.lang.Comparable} and is equivalent of
	 * passing null to {@link #sort(java.util.Comparator)}.
	 *
	 * @throws java.lang.ClassCastException If the comparator is null and the stored items do not
	 *                                      implement {@code Comparable} or if {@code compareTo}
	 *                                      throws for any pair of items.
	 */

#Code:
	public void sort() {
		sort(null);
	}

#No. 165
#File: E:\bishe\1\AbsArrayAdapter.java
#Comment:
	/**
	 * Sorts the content of this adapter using the specified comparator.
	 *
	 * @param comparator Used to sort the items contained in this adapter. Null to use an item's
	 *                   {@code Comparable} interface.
	 *
	 * @throws java.lang.ClassCastException If the comparator is null and the stored items do not
	 *                                      implement {@code Comparable} or if {@code compareTo}
	 *                                      throws for any pair of items.
	 */

#Code:
	public void sort(@Nullable Comparator<? super T> comparator) {
		synchronized (mLock) {
			if (mOriginalValues != null) {
				Collections.sort(mOriginalValues, comparator);
			}
			Collections.sort(mObjects, comparator);
		}

#No. 166
#File: E:\bishe\1\AbsArrayAdapter.java
#Comment:
	/**
	 * Updates the item at the specified position in the adapter with the specified item. This
	 * operation does not change the size of the adapter. Will repeat the last filtering request if
	 * invoked while filtered results are being displayed. Be-aware this method is only a constant
	 * time operation when the list is not filtered. Otherwise, the position must be converted to a
	 * unfiltered position; which requires traversing the original unfiltered list.
	 *
	 * @param position The location at which to put the specified item
	 * @param item     The new item to replace with the old
	 */

#Code:
	public void update(int position, @Nullable T item) {
		synchronized (mLock) {
			if (mOriginalValues != null) {
				int newPosition = mOriginalValues.indexOf(mObjects.get(position));
				mOriginalValues.set(newPosition, item);
				getFilter().filter(mLastConstraint);
			} else {
				mObjects.set(position, item);
			}
		}

#No. 167
#File: E:\bishe\1\AbsBarObject.java
#Comment:
    /**
     * TODO: Add error checking
     */

#Code:
    AbsBarObject() {
        this.height = 10f;
        this.width = 150f;
    }

#No. 168
#File: E:\bishe\1\AbsBaseActivity.java
#Comment:
        /*
        If you have set an enter transition for the second activity,
        the transition is also activated when the activity starts.
        */

#Code:
            getWindow().setEnterTransition(ts_enter);
            getWindow().setExitTransition(ts_exit);
        }
    }

    @Override
    public void onCreate(Bundle saveInstanceState) {
        //initAnimation();
        super.onCreate(saveInstanceState);
        if (!(this instanceof SplashScreenActivity)) // to avoid that on the splash screen
            registerGCM();

        popUpMessageHelper = new PopUpMessageHelper(this);
        eventBus = EventBus.getDefault();
        tintManager = new SystemBarTintManager(this);
    }

#No. 169
#File: E:\bishe\1\AbsBoxingViewActivity.java
#Comment:
    /**
     * to clear all medias the first time(the page number is 0). do some clean work.
     */

#Code:
    @Override
    public void clearMedia() {
    }

#No. 170
#File: E:\bishe\1\AbsBoxingViewActivity.java
#Comment:
    /**
     * get the {@link ContentResolver}
     */

#Code:
    @NonNull
    @Override
    public final ContentResolver getAppCr() {
        return getApplicationContext().getContentResolver();
    }

#No. 171
#File: E:\bishe\1\AbsBoxingViewActivity.java
#Comment:
    /**
     * called the job is done.Click the ok button, take a photo from camera, crop a photo.
     * most of the time, you do not have to override.
     *
     * @param medias the list of selection
     */

#Code:
    @Override
    public void onFinish(@NonNull List<BaseMedia> medias) {
        Intent intent = new Intent();
        intent.putParcelableArrayListExtra(Boxing.EXTRA_RESULT, (ArrayList<BaseMedia>) medias);
    }

    /**
     * need crop or not
     *
     * @return true, need it.
     */
    public final boolean hasCropBehavior() {
        BoxingConfig config = BoxingManager.getInstance().getBoxingConfig();
        return config != null && config.isSingleImageMode() && config.getCropOption() != null;
    }

#No. 172
#File: E:\bishe\1\AbsBoxingViewActivity.java
#Comment:
    /**
     * to start the crop behavior, call it when {@link #hasCropBehavior()} return true.
     *
     * @param media       the media to be cropped.
     * @param requestCode The integer request code originally supplied to
     *                    startActivityForResult(), allowing you to identify who this
     *                    result came from.
     */

#Code:
    @Override
    public final void startCrop(@NonNull BaseMedia media, int requestCode) {
    }

    /**
     * set or update the config.most of the time, you do not have to call it.
     *
     * @param config {@link BoxingConfig}
     */
    @Override
    public final void setPickerConfig(BoxingConfig config) {
        if (config == null) {
            return;
        }
        BoxingManager.getInstance().setBoxingConfig(config);
    }

#No. 173
#File: E:\bishe\1\AbsBoxingViewActivity.java
#Comment:
    /**
     * call this to clear resource.
     */

#Code:
    @Override
    public void onDestroy() {
        super.onDestroy();
        if (mPresenter != null) {
            mPresenter.destroy();
        }
    }

#No. 174
#File: E:\bishe\1\AbsBoxingViewActivity.java
#Comment:
    /**
     * in {@link BoxingConfig.Mode#MULTI_IMG}, call this to pick the selected medias in all medias.
     */

#Code:
    public final void checkSelectedMedia(List<BaseMedia> allMedias, List<BaseMedia> selectedMedias) {
        mPresenter.checkSelectedMedia(allMedias, selectedMedias);
    }

#No. 175
#File: E:\bishe\1\AbsBoxingViewActivity.java
#Comment:
    /**
     * load first page of medias.
     * use {@link #showMedia(List, int)} to get the result.
     */

#Code:
    public final void loadMedias() {
        mPresenter.loadMedias(0, AlbumEntity.DEFAULT_NAME);
    }

#No. 176
#File: E:\bishe\1\AbsBoxingViewActivity.java
#Comment:
    /**
     * load the medias for the specify page and album id.
     * use {@link #showMedia(List, int)} to get the result.
     *
     * @param page    page numbers.
     * @param albumId the album id is {@link AlbumEntity#mBucketId}.
     */

#Code:
    public final void loadMedias(int page, String albumId) {
        mPresenter.loadMedias(page, albumId);
    }

#No. 177
#File: E:\bishe\1\AbsBoxingViewActivity.java
#Comment:
    /**
     * get the max count set before
     */

#Code:
    public final int getMaxCount() {
        BoxingConfig config = BoxingManager.getInstance().getBoxingConfig();
        if (config == null) {
            return BoxingConfig.DEFAULT_SELECTED_COUNT;
        }
        return config.getMaxCount();
    }

#No. 178
#File: E:\bishe\1\AbsBoxingViewFragment.java
#Comment:
    /**
     * must override when care about the input medias, which means you call {@link #setSelectedBundle(ArrayList)} first.
     * this method is called in {@link Fragment#onCreate(Bundle)}, so override this rather than {@link Fragment#onCreate(Bundle)}.
     *
     * @param bundle         If the fragment is being re-created from
     *                       a previous saved state, this is the state.
     * @param selectedMedias the input medias, the parameter of {@link #setSelectedBundle(ArrayList)}.
     */

#Code:
    public void onCreateWithSelectedMedias(Bundle bundle, @Nullable List<BaseMedia> selectedMedias) {
    }

    /**
     * override this method to handle the medias.
     * make sure {@link #loadMedias()} ()} being called first.
     *
     * @param medias the results of medias
     */
    @Override
    public void showMedia(@Nullable List<BaseMedia> medias, int allCount) {
    }

    /**
     * override this method to handle the album.
     * make sure {@link #loadAlbum()} being called first.
     *
     * @param albums the results of albums
     */
    @Override
    public void showAlbum(@Nullable List<AlbumEntity> albums) {
    }

    /**
     * to clear all medias the first time(the page number is 0). do some clean work.
     */
    @Override
    public void clearMedia() {
    }

#No. 179
#File: E:\bishe\1\AbsBoxingViewFragment.java
#Comment:
    /**
     * called when you have input medias, then call {@link #onCreateWithSelectedMedias(Bundle, List)} to get the input medias.
     *
     * @param selectedMedias input medias
     * @return {@link AbsBoxingViewFragment}
     */

#Code:
    public final AbsBoxingViewFragment setSelectedBundle(ArrayList<BaseMedia> selectedMedias) {
        Bundle bundle = new Bundle();
        if (selectedMedias != null && !selectedMedias.isEmpty()) {
            bundle.putParcelableArrayList(Boxing.EXTRA_SELECTED_MEDIA, selectedMedias);
        }
        setArguments(bundle);
        return this;
    }

#No. 180
#File: E:\bishe\1\AbsBoxingViewFragment.java
#Comment:
    /**
     * get the {@link ContentResolver}
     */

#Code:
    @NonNull
    @Override
    public final ContentResolver getAppCr() {
        return getActivity().getApplicationContext().getContentResolver();
    }

#No. 181
#File: E:\bishe\1\AbsBoxingViewFragment.java
#Comment:
    /**
     * if {@link AbsBoxingViewFragment} is not working with {@link AbsBoxingActivity}, it needs a listener to call
     * when the jobs done.
     *
     * @param onFinishListener {@link Boxing.OnBoxingFinishListener}
     */

#Code:
    final void setOnFinishListener(Boxing.OnBoxingFinishListener onFinishListener) {
        mOnFinishListener = onFinishListener;
    }

#No. 182
#File: E:\bishe\1\AbsBoxingViewFragment.java
#Comment:
    /**
     * called the job is done.Click the ok button, take a photo from camera, crop a photo.
     * most of the time, you do not have to override.
     *
     * @param medias the list of selection
     */

#Code:
    @Override
    public void onFinish(@NonNull List<BaseMedia> medias) {
        Intent intent = new Intent();
        intent.putParcelableArrayListExtra(Boxing.EXTRA_RESULT, (ArrayList<BaseMedia>) medias);
        if (mOnFinishListener != null) {
            mOnFinishListener.onBoxingFinish(intent, medias);
        }

#No. 183
#File: E:\bishe\1\AbsBoxingViewFragment.java
#Comment:
    /**
     * need crop or not
     *
     * @return true, need it.
     */

#Code:
    public final boolean hasCropBehavior() {
        BoxingConfig config = BoxingManager.getInstance().getBoxingConfig();
        return config != null && config.isSingleImageMode() && config.getCropOption() != null;
    }

#No. 184
#File: E:\bishe\1\AbsBoxingViewFragment.java
#Comment:
    /**
     * to start the crop behavior, call it when {@link #hasCropBehavior()} return true.
     *
     * @param media       the media to be cropped.
     * @param requestCode The integer request code originally supplied to
     *                    startActivityForResult(), allowing you to identify who this
     *                    result came from.
     */

#Code:
    @Override
    public final void startCrop(@NonNull BaseMedia media, int requestCode) {
        BoxingCropOption cropConfig = BoxingManager.getInstance().getBoxingConfig().getCropOption();
        BoxingCrop.getInstance().onStartCrop(getActivity(), this, cropConfig, media.getPath(), requestCode);
    }

    /**
     * set or update the config.most of the time, you do not have to call it.
     *
     * @param config {@link BoxingConfig}
     */
    @Override
    public final void setPickerConfig(BoxingConfig config) {
        if (config == null) {
            return;
        }
        BoxingManager.getInstance().setBoxingConfig(config);
    }

#No. 185
#File: E:\bishe\1\AbsBoxingViewFragment.java
#Comment:
    /**
     * in {@link BoxingConfig.Mode#MULTI_IMG}, call this in {@link Fragment#onSaveInstanceState(Bundle)}.
     *
     * @param outState Bundle in which to place your saved state.
     * @param selected the selected medias.
     */

#Code:
    public final void onSaveMedias(Bundle outState, ArrayList<BaseMedia> selected) {
        if (selected != null && !selected.isEmpty()) {
            outState.putParcelableArrayList(Boxing.EXTRA_SELECTED_MEDIA, selected);
        }
    }

#No. 186
#File: E:\bishe\1\AbsBoxingViewFragment.java
#Comment:
    /**
     * call this to clear resource.
     */

#Code:
    @Override
    public void onDestroy() {
        super.onDestroy();
        if (mPresenter != null) {
            mPresenter.destroy();
        }
        if (mCameraPicker != null) {
            mCameraPicker.release();
        }
    }

#No. 187
#File: E:\bishe\1\AbsBoxingViewFragment.java
#Comment:
    /**
     * in {@link BoxingConfig.Mode#MULTI_IMG}, call this to pick the selected medias in all medias.
     */

#Code:
    public final void checkSelectedMedia(List<BaseMedia> allMedias, List<BaseMedia> selectedMedias) {
        mPresenter.checkSelectedMedia(allMedias, selectedMedias);
    }

#No. 188
#File: E:\bishe\1\AbsBoxingViewFragment.java
#Comment:
    /**
     * load first page of medias.
     * use {@link #showMedia(List, int)} to get the result.
     */

#Code:
    public final void loadMedias() {
        mPresenter.loadMedias(0, AlbumEntity.DEFAULT_NAME);
    }

#No. 189
#File: E:\bishe\1\AbsBoxingViewFragment.java
#Comment:
    /**
     * load the medias for the specify page and album id.
     * use {@link #showMedia(List, int)} to get the result.
     *
     * @param page    page numbers.
     * @param albumId the album id is {@link AlbumEntity#mBucketId}.
     */

#Code:
    public final void loadMedias(int page, String albumId) {
        mPresenter.loadMedias(page, albumId);
    }

#No. 190
#File: E:\bishe\1\AbsBoxingViewFragment.java
#Comment:
    /**
     * extra call to load albums in database, use {@link #showAlbum(List)} to get result.
     * In {@link BoxingConfig.Mode#VIDEO} it is not necessary.
     */

#Code:
    public void loadAlbum() {
        if (!BoxingManager.getInstance().getBoxingConfig().isVideoMode()) {
            mPresenter.loadAlbums();
        }
    }

#No. 191
#File: E:\bishe\1\AbsBoxingViewFragment.java
#Comment:
    /**
     * get the max count set before
     */

#Code:
    public final int getMaxCount() {
        BoxingConfig config = BoxingManager.getInstance().getBoxingConfig();
        if (config == null) {
           return BoxingConfig.DEFAULT_SELECTED_COUNT;
        }
        return config.getMaxCount();
    }

#No. 192
#File: E:\bishe\1\AbsBoxingViewFragment.java
#Comment:
    /**
     * successfully get result from camera in {@link #onActivityResult(int, int, Intent)}.
     * call this after other operations.
     */

#Code:
    public void onCameraActivityResult(int requestCode, int resultCode) {
        mCameraPicker.onActivityResult(requestCode, resultCode);
    }

#No. 193
#File: E:\bishe\1\AbsBoxingViewFragment.java
#Comment:
    /**
     * successfully get result from crop in {@link #onActivityResult(int, int, Intent)}
     */

#Code:
    public void onCropActivityResult(int requestCode, int resultCode, @NonNull Intent data) {
        Uri output = BoxingCrop.getInstance().onCropFinish(resultCode, data);
        if (output != null) {
            List<BaseMedia> medias = new ArrayList<>(1);
            ImageMedia media = new ImageMedia(String.valueOf(System.currentTimeMillis()), output.getPath());
            medias.add(media);
            onFinish(medias);
        }

#No. 194
#File: E:\bishe\1\AbsBoxingViewFragment.java
#Comment:
    /**
     * start camera to take a photo.
     *
     * @param activity      the caller activity.
     * @param fragment      the caller fragment, may be null.
     * @param subFolderPath the folder name in "DCIM/bili/boxing/"
     */

#Code:
    public final void startCamera(Activity activity, Fragment fragment, String subFolderPath) {
        try {
            if (!BoxingBuilderConfig.TESTING && ContextCompat.checkSelfPermission(getActivity(), CAMERA_PERMISSIONS[0]) != PERMISSION_GRANTED) {
                requestPermissions(CAMERA_PERMISSIONS, REQUEST_CODE_PERMISSION);
            } else {
                if (!BoxingManager.getInstance().getBoxingConfig().isVideoMode()) {
                    mCameraPicker.startCamera(activity, fragment, subFolderPath);
                }
            }
        } catch (IllegalArgumentException | IllegalStateException e) {
            onRequestPermissionError(CAMERA_PERMISSIONS, e);
        }
    }

#No. 195
#File: E:\bishe\1\AbsCallbackHandler.java
#Comment:
    /**
     * Sets the charset for the response string. If not set, the default is UTF-8.
     */

#Code:
    final public void setCharset(@NonNull final String charset) {
        this.responseCharset = charset;
    }

    /**
     * subclass can override this method to change charset.
     */
    protected String charset() {
        return TextUtils.isEmpty(responseCharset) ? DEFAULT_CHARSET : responseCharset;
    }

#No. 196
#File: E:\bishe\1\AbsCallbackHandler.java
#Comment:
    /**
     * @return request accept
     */

#Code:
    @Override public String accept(){
        return Accept.EMPTY;
    }

    final protected void print(String message){
        Log.d(AbsCallbackHandler.class.getSimpleName(), message);
    }

#No. 197
#File: E:\bishe\1\AbsDanmakuSync.java
#Comment:
    /**
     * Get the uptime of timer synchronization
     *
     * @return
     */

#Code:
    public abstract long getUptimeMillis();

    /**
     * Get the state of timer synchronization
     *
     * @return SYNC_STATE_HALT or SYNC_STATE_PLAYING
     */
    public abstract int getSyncState();

    /**
     * Get the threshold-time of timer synchronization
     * This value should be greater than or equal to 1000L
     *
     * @return
     */
    public long getThresholdTimeMills() {
        return 1500L;
    }

#No. 198
#File: E:\bishe\1\AbsDanmakuSync.java
#Comment:
    /**
     * synchronize pause/resume state with outside playback
     * @return
     */

#Code:
    public boolean isSyncPlayingState() {
        return false;
    }

#No. 199
#File: E:\bishe\1\AbsDatabaseType.java
#Comment:
    /*
        public void setPreparedStatementValue(int iindex,Object value,int type,PreparedStatement pstmt)
                throws SQLException
        {
            if((value instanceof String)&&type!=DBColumnType.VARCHAR&&type!=DBColumnType.CLOB)
            {
                value=DBColumnType.convertStringValueToRealDBTypeValue((String)value,type);
            }
            switch (type)
            {
                case DBColumnType.VARCHAR:
                    String str=(String)value;
                    if(str==null) str="";
                    log.debug("setString("+iindex+","+str+")");
                    pstmt.setString(iindex,str);
                    break;
                case DBColumnType.BYTE:
                    byte b=0;
                    if(value!=null)
                    {
                        b=(Byte)value;
                    }
                    log.debug("setByte("+iindex+","+b+")");
                    pstmt.setByte(iindex,b);
                    break;
                case DBColumnType.BOOLEAN:
                    boolean bl=false;
                    if(value!=null)
                    {
                        bl=(Boolean)value;
                    }
                    log.debug("setBoolean("+iindex+","+bl+")");
                    pstmt.setBoolean(iindex,bl);
                    break;
                case DBColumnType.SHORT:
                    short s=0;
                    if(value!=null)
                    {
                        s=(Short)value;
                    }
                    log.debug("setShort("+iindex+","+s+")");
                    pstmt.setShort(iindex,s);
                    break;
                case DBColumnType.INT:
                    int i=0;
                    if(value!=null)
                    {
                        i=(Integer)value;
                    }
                    log.debug("setInt("+iindex+","+i+")");
                    pstmt.setInt(iindex,i);
                    break;
                case DBColumnType.LONG:
                    long l=0L;
                    if(value!=null)
                    {
                        l=(Long)value;
                    }
                    log.debug("setLong("+iindex+","+l+")");
                    pstmt.setLong(iindex,l);
                    break;
                case DBColumnType.FLOAT:
                    float f=0.0F;
                    if(value!=null)
                    {
                        f=(Float)value;
                    }
                    log.debug("setFloat("+iindex+","+f+")");
                    pstmt.setFloat(iindex,f);
                    break;
                case DBColumnType.DOUBLE:
                    double d=0.0D;
                    if(value!=null)
                    {
                        d=(Double)value;
                    }
                    log.debug("setDouble("+iindex+","+d+")");
                    pstmt.setDouble(iindex,d);
                    break;
                case DBColumnType.BIGDECIMAL:
                    BigDecimal bd=null;
                    if(value!=null)
                    {
                        bd=(BigDecimal)value;
                    }else
                    {
                        bd=new BigDecimal(0);
                    }
                    log.debug("setBigDecimal("+iindex+","+bd+")");
                    pstmt.setBigDecimal(iindex,bd);
                    break;
                case DBColumnType.BLOB:
                    log.debug("setBlob("+iindex+","+value+")");
                    if(value==null||(value instanceof byte[]))
                    {
                        setBlobValue(iindex,(byte[])value,pstmt);
                    }else if(value instanceof InputStream)
                    {
                        setBlobValue(iindex,(InputStream)value,pstmt);
                    }else
                    {
                        throw new WabacusUpdateReportDataException("将"+value
                                +"写入BLOB字段失败，不是byte[]类型或InputStream类型");
                    }
                    break;
                case DBColumnType.CLOB:
                    log.debug("setClob("+iindex+","+value+")");
                    setClobValue(iindex,(String)value,pstmt);
                    break;
                case DBColumnType.DATE:
                case DBColumnType.CDATE:
                    log.debug("setDate("+iindex+","+value+")");
                    pstmt.setDate(iindex,(java.sql.Date)value);
                    break;
                case DBColumnType.TIME:
                case DBColumnType.CTIME:
                    log.debug("setTime("+iindex+","+value+")");
                    pstmt.setTime(iindex,(java.sql.Time)value);
                    break;
                case DBColumnType.TIMESTAMP:
                case DBColumnType.CTIMESTAMP:
                    log.debug("setTimestamp("+iindex+","+value+")");
                    pstmt.setTimestamp(iindex,(java.sql.Timestamp)value);
                    break;
                default:
                    String str2=null;
                    if(value!=null)
                    {
                        str2=String.valueOf(value);
                    }else
                    {
                        str2="";
                    }
                    log.debug("setString("+iindex+","+str2+")");
                    pstmt.setString(iindex,str2);
            }
        }*/

#Code:
}
}

#No. 200
#File: E:\bishe\1\AbsDialogFragment.java
#Comment:
	/*
	@Override
	public void onDismiss(DialogInterface dialog) {
		if (getActivity().getClass().getName().equals("Main")) {  这行NullPointer
			try {
				if (ShakeDetector.sCanDetact)
					ShakeDetector.getInstance(getActivity()).start();
			} catch (Exception e) {
			}
		}
	}
	*/

#Code:
}
}

#No. 201
#File: E:\bishe\1\AbsEditableReportEditDataBean.java
#Comment:
        /*if(!this.isAutoReportdata()) return;
        if(this.lstEditActions!=null)
        {
            AbsExpressionBean expressBeanTmp;
            List<AbsUpdateAction> lstActionsTmp;
            for(Map<AbsExpressionBean,List<AbsUpdateAction>> mEditActionsTmp:this.lstEditActions)
            {
                if(mEditActionsTmp==null||mEditActionsTmp.size()==0) continue;
                expressBeanTmp=mEditActionsTmp.keySet().iterator().next();
                if(expressBeanTmp!=null) expressBeanTmp.doPostLoadFinally();
                lstActionsTmp=mEditActionsTmp.get(expressBeanTmp);
                if(lstActionsTmp==null||lstActionsTmp.size()==0) continue;
                for(AbsUpdateAction actionTmp:lstActionsTmp)
                {
                    actionTmp.doPostLoadFinally();
                }
            }
        }
        if(lstExternalValues!=null)
        {
            for(EditableReportExternalValueBean valueBeanTmp:this.lstExternalValues)
            {
                valueBeanTmp.doPostLoadFinally();
            }
        }*/

#Code:
    }
    
    public Object clone(IEditableReportEditGroupOwnerBean newowner)
    {
        try
        {
            AbsEditableReportEditDataBean newbean=(AbsEditableReportEditDataBean)super.clone();
            newbean.setOwner(newowner);
            if(this.lstEditActionProviders!=null)
            {
                List<AbsUpdateActionProvider> lstBeansNew=new ArrayList<AbsUpdateActionProvider>();
                for(AbsUpdateActionProvider actionBeanTmp:this.lstEditActionProviders)
                {
                    lstBeansNew.add((AbsUpdateActionProvider)actionBeanTmp.clone(newbean));
                }
                newbean.lstEditActionProviders=lstBeansNew;
            }

            if(lstExternalValues!=null)
            {
                List<EditableReportExternalValueBean> lstExternalValuesNew=new ArrayList<EditableReportExternalValueBean>();
                for(EditableReportExternalValueBean valueBeanTmp:lstExternalValues)
                {
                    lstExternalValuesNew.add((EditableReportExternalValueBean)valueBeanTmp.clone());
                }
                newbean.setLstExternalValues(lstExternalValuesNew);
            }
            return newbean;
        }catch(CloneNotSupportedException e)
        {
            e.printStackTrace();
            return null;
        }
    }

#No. 202
#File: E:\bishe\1\AbsEntityCursor.java
#Comment:
    /*
     * observers
     */

#Code:

    @Override
    public void registerContentObserver(ContentObserver observer) {
        cursor.registerContentObserver(observer);
    }

#No. 203
#File: E:\bishe\1\AbsFocusEffectView.java
#Comment:
    /**
     * 获取view的焦点类型
     *
     * @param view
     * @return
     */

#Code:
    protected String getViewFocusType(View view) {
        Object o = view.getTag(R.id.focus_type);
        String focusType = null;
        if (o == null) {
            Log.e(TAG, "没有设置焦点类型：" + view.toString());
            return null;
        } else {
            focusType = (String) o;
        }
        Log.d(TAG, "getViewFocusType:" + focusType);
        return focusType;
    }

#No. 204
#File: E:\bishe\1\AbsFocusEffectView.java
#Comment:
    /**
     * 获取view是否有获取焦点和失去焦点的放大缩小动画
     *
     * @param view
     * @return
     */

#Code:
    protected boolean getViewFocusScaleAnim(View view) {
        Object o = view.getTag(R.id.focus_type_is_scale_anim);
        if (o != null) {
            return (boolean) o;
        }
        return false;
    }

#No. 205
#File: E:\bishe\1\AbsFocusEffectView.java
#Comment:
    /**
     * 获取view是否有焦点效果的移动动画
     *
     * @param view
     * @return
     */

#Code:
    protected boolean getViewFocusTranslateAnim(View view) {
        Object o = view.getTag(R.id.focus_type_is_translate);
        if (o != null) {
            return (boolean) o;
        }
        return false;
    }

#No. 206
#File: E:\bishe\1\AbsFocusEffectView.java
#Comment:
    /**
     * 当在执行动画或者滑动的时候持续更新焦点框位置
     *
     * @param focusView
     * @param padding
     */

#Code:
    private void continueChangeFocusEffect(View focusView, Rect padding) {
        Log.d(TAG, "continueChangeFocusEffect:" + focusView.toString());
        getGlobalVisibleRectOfDecorView(focusView, globalVisibleRect);
        globalVisibleRect.left -= padding.left;
        globalVisibleRect.right += padding.right;
        globalVisibleRect.top -= padding.top;
        globalVisibleRect.bottom += padding.bottom;
        Log.d(TAG, "continueChangeFocusEffect:" + globalVisibleRect.toString());
        changeFocusEffectLocation(globalVisibleRect);
    }

#No. 207
#File: E:\bishe\1\AbsFocusEffectView.java
#Comment:
    /**
     * 获取焦点的动画
     *
     * @param isHasAnim
     * @param startScale
     * @param endScale
     * @param scaleDuration
     */

#Code:
    protected void focusInAnim(boolean isHasAnim, float startScale, float endScale, long scaleDuration) {
        if (isHasAnim) {
            animIn = ValueAnimator.ofFloat(startScale, endScale);
            animIn.setDuration(scaleDuration);
            animIn.setInterpolator(new DecelerateInterpolator());
            animIn.addUpdateListener(focusInUpdateListener);
            animIn.addListener(focusInListener);
            animIn.start();
        } else {
            View view = currentFocusViewRef.get();
            view.setScaleX(endScale);
            view.setScaleY(endScale);
        }
    }

#No. 208
#File: E:\bishe\1\AbsFocusEffectView.java
#Comment:
    /**
     * 失去焦点的动画
     *
     * @param isHasAnim
     * @param startScale
     * @param endScale
     * @param scaleDuration
     */

#Code:
    protected void focusOutAnim(boolean isHasAnim, float startScale, float endScale, long scaleDuration) {
        View currentFocusView = null;
        if (currentFocusViewRef != null) {
            currentFocusView = currentFocusViewRef.get();
        }
        if (currentFocusView == null) {
            return;
        }
        if (isHasAnim) {
            animOut = ValueAnimator.ofFloat(startScale, endScale);
            animOut.setDuration(scaleDuration);
            animOut.setInterpolator(new DecelerateInterpolator());
            animOut.addUpdateListener(focusOutUpdateListener);
            animOut.addListener(focusOutListener);
            animOut.start();
        } else {
            currentFocusView.setScaleX(endScale);
            currentFocusView.setScaleY(endScale);
        }
    }

#No. 209
#File: E:\bishe\1\AbsFocusEffectView.java
#Comment:
    /**
     * 移动焦点框的动画
     *
     * @param startRect
     * @param endRect
     */

#Code:
    protected void tranlateFocusEffect(Rect startRect, Rect endRect, long duration) {
        Log.d(TAG, "tranlateFocusEffect:" + "  " + startRect.toString() + "  " + endRect.toString());
        releaseTranslateAnim();

        if (startRect.equals(endRect)) {
            changeFocusEffectLocation(endRect);
            return;
        }

        ValueAnimator animLeft = ObjectAnimator.ofInt(translateRect, "left", startRect.left, endRect.left);
        ValueAnimator animTop = ObjectAnimator.ofInt(translateRect, "top", startRect.top, endRect.top);
        ValueAnimator animRight = ObjectAnimator.ofInt(translateRect, "right", startRect.right, endRect.right);
        ValueAnimator animBottom = ObjectAnimator.ofInt(translateRect, "bottom", startRect.bottom, endRect.bottom);

        translateAnimatorSet = new AnimatorSet();
        translateAnimatorSet.setDuration(duration);
        translateAnimatorSet.setInterpolator(new DecelerateInterpolator());
        translateAnimatorSet.addListener(translateListener);
        translateAnimatorSet.playTogether(animLeft, animTop, animRight, animBottom);
        translateAnimatorSet.start();
    }

#No. 210
#File: E:\bishe\1\AbsFocusEffectView.java
#Comment:
    /**
     * 奇怪，当recyclerView notify之后，会将本view都设为0
     *
     * @param l
     * @param t
     * @param r
     * @param b
     */

#Code:
    @Override
    public void layout(int l, int t, int r, int b) {
        if (l == 0 && t == 0 && r == 0 && b == 0) {
            Log.e(TAG, "layout 0 0 0 0");
        } else {
            super.layout(l, t, r, b);
        }
    }

#No. 211
#File: E:\bishe\1\AbsFocusEffectView.java
#Comment:
    /**
     * 改变焦点的位置
     */

#Code:
    protected void changeFocusEffectLocation(Rect newFocusEffectRect) {
        this.layout(newFocusEffectRect.left, newFocusEffectRect.top, newFocusEffectRect.right, newFocusEffectRect.bottom);
    }

#No. 212
#File: E:\bishe\1\AbsFocusEffectView.java
#Comment:
    /**
     * 退出时销毁资源
     */

#Code:
    public void destory() {
        unRegisterListener();
        releaseFocusOutAnim();
        releaseFocusInAnim();
        releaseTranslateAnim();
        focusOutUpdateListener = null;
        focusInUpdateListener = null;
        focusOutListener = null;
        focusInListener = null;
        translateListener = null;
        currentPaddingRect = null;
        globalVisibleRect = null;
        translateRect = null;
        if (oldFocusViewRef != null) {
            oldFocusViewRef.clear();
            oldFocusViewRef = null;
        }
        if (currentFocusViewRef != null) {
            currentFocusViewRef.clear();
            currentFocusViewRef = null;
        }
    }

#No. 213
#File: E:\bishe\1\AbsHttpStack.java
#Comment:
    /**
     * 请求成功
     *
     * @param parser
     * @param callback
     * @param response
     */

#Code:
    @Override
    public void onNetResponse(final Net.Parser<T> parser,
                              final Net.Callback<T> callback,
                              final String response) {
        if(isDebugMode()) System.out.println(response);
        if (callback == null) return;
        if (parser == null) {
            Result<T> result = new Result<T>();
            result.setStatus(Result.ERROR);
            result.setMsg(Net.ERR_PARSE_MSG);
            callback.callback(result);
            return;
        }

        Result<T> result = parser.parse(response);
        callback.callback(result);
    }

#No. 214
#File: E:\bishe\1\AbsHttpStack.java
#Comment:
    /**
     * 请求失败
     *
     * @param callback
     * @param msg
     */

#Code:
    @Override
    public void onError(final Net.Callback<T> callback, final String msg) {
        if(isDebugMode()) System.out.println(msg);
        if (callback == null) return;

        Result<T> result = new Result<T>();
        result.setStatus(Result.ERROR);
        result.setMsg(msg);
        callback.callback(result);
    }

#No. 215
#File: E:\bishe\1\AbsLayoutContainer.java
#Comment:
		/**
		 * Callback method to be invoked when an item in this AdapterView has
		 * been clicked.
		 * <p>
		 * Implementers can call getItemAtPosition(position) if they need to
		 * access the data associated with the selected item.
		 * 
		 * @param parent
		 *            The AdapterView where the click happened.
		 * @param view
		 *            The view within the AdapterView that was clicked (this
		 *            will be a view provided by the adapter)
		 * @param position
		 *            The position of the view in the adapter.
		 * @param id
		 *            The row id of the item that was clicked.
		 */

#Code:
		void onItemClick(AbsLayoutContainer parent, FreeFlowItem proxy);
	}

	protected OnItemClickListener mOnItemClickListener;

	/**
	 * Register a callback to be invoked when an item in this AdapterView has
	 * been clicked.
	 * 
	 * @param listener
	 *            The callback that will be invoked.
	 */
	public void setOnItemClickListener(OnItemClickListener listener) {
		mOnItemClickListener = listener;
	}

#No. 216
#File: E:\bishe\1\AbsLayoutContainer.java
#Comment:
	/**
	 * @return The callback to be invoked with an item in this AdapterView has
	 *         been clicked, or null id no callback has been set.
	 */

#Code:
	public final OnItemClickListener getOnItemClickListener() {
		return mOnItemClickListener;
	}

#No. 217
#File: E:\bishe\1\AbsLayoutContainer.java
#Comment:
	/**
	 * Call the OnItemClickListener, if it is defined. Performs all normal
	 * actions associated with clicking: reporting accessibility event, playing
	 * a sound, etc.
	 * 
	 * @param view
	 *            The view within the AdapterView that was clicked.
	 * @param position
	 *            The position of the view in the adapter.
	 * @param id
	 *            The row id of the item that was clicked.
	 * @return True if there was an assigned OnItemClickListener that was
	 *         called, false otherwise is returned.
	 */

#Code:
	public boolean performItemClick(View view, int sectionIndex, int positionInSection, long id) {
		if (mOnItemClickListener != null) {
			// playSoundEffect(SoundEffectConstants.CLICK);
			if (view != null) {
				view.sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);
			}
			mOnItemClickListener.onItemClick(this, getFreeFlowItemForVisibleItemAt(sectionIndex, positionInSection));
			return true;
		}

		return false;
	}

#No. 218
#File: E:\bishe\1\AbsLayoutContainer.java
#Comment:
	/**
	 * Register a callback to be invoked when an item in this AdapterView has
	 * been selected.
	 * 
	 * @param listener
	 *            The callback that will run
	 */

#Code:
	public void setOnItemSelectedListener(OnItemSelectedListener listener) {
		mOnItemSelectedListener = listener;
	}

#No. 219
#File: E:\bishe\1\AbsLayoutContainer.java
#Comment:
    /**
     * Register a callback to be invoked when an item in this AdapterView has
     * been clicked and held
     *
     * @param listener The callback that will run
     */

#Code:
    public void setOnItemLongClickListener(OnItemLongClickListener listener) {
        if (!isLongClickable()) {
            setLongClickable(true);
        }
        mOnItemLongClickListener = listener;
    }

#No. 220
#File: E:\bishe\1\AbsLayoutContainer.java
#Comment:
    /**
     * @return The callback to be invoked with an item in this AdapterView has
     *         been clicked and held, or null id no callback as been set.
     */

#Code:
    public final OnItemLongClickListener getOnItemLongClickListener() {
        return mOnItemLongClickListener;
    }

#No. 221
#File: E:\bishe\1\AbsLayoutContainer.java
#Comment:
    /**
     * Returns the FreeFlowItem instance of a view at position if that
     * view is visible or null if thats not currently visible
     * @param 	section 	The section index of the item 
     * @param	position	The position of the item in the particular section
     * @return	The <code>FreeFlowItem</code> instance representing that section and index. The proxy is guaranteed to have a view associated with it 
     */

#Code:
	public FreeFlowItem getFreeFlowItemForVisibleItemAt(int section, int position) {
		Iterator<?> it = frames.entrySet().iterator();
		FreeFlowItem proxy = null;
		while (it.hasNext()) {
			Map.Entry<?, FreeFlowItem> pairs = (Map.Entry<?, FreeFlowItem>) it.next();
			proxy = pairs.getValue();
			if (proxy.itemSection == section
					&& proxy.itemIndex == position) {
				return proxy;
			}
		}
		return null;
	}

#No. 222
#File: E:\bishe\1\AbsLeafChart.java
#Comment:
    /**
     * 不重写改方法，在布局中使用 wrap_content 显示效果是 match_parent
     * @param widthMeasureSpec
     * @param heightMeasureSpec
     */

#Code:
    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
        int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec);
        int widthSpecSize = MeasureSpec.getSize(widthMeasureSpec);
        int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);
        int heightSpecSize = MeasureSpec.getSize(heightMeasureSpec);

        if(widthSpecMode == MeasureSpec.AT_MOST && heightSpecMode == MeasureSpec.AT_MOST){
            setMeasuredDimension((int) LeafUtil.dp2px(mContext, 300), (int) LeafUtil.dp2px(mContext, 300));
        } else if(widthSpecMode == MeasureSpec.AT_MOST){
            setMeasuredDimension((int)mWidth, heightSpecSize);
        } else if(heightSpecMode == MeasureSpec.AT_MOST){
            setMeasuredDimension(widthSpecSize, (int)mHeight);
        }

    }

#No. 223
#File: E:\bishe\1\AbsLeafChart.java
#Comment:
    /**
     * 设置坐标轴位置
     */

#Code:
    public void resetAsixSize() {
        resetAsixX();

        resetAsixY();
    }

#No. 224
#File: E:\bishe\1\AbsLibraryPagerRecyclerViewCustomGridSizeFragment.java
#Comment:
    /**
     * @return whether the palette should be used at all or not
     */

#Code:
    public final boolean usePalette() {
        if (!usePaletteInitialized) {
            usePalette = loadUsePalette();
            usePaletteInitialized = true;
        }
        return usePalette;
    }

#No. 225
#File: E:\bishe\1\AbsLibraryPagerRecyclerViewCustomGridSizeFragment.java
#Comment:
    /**
     * @return whether the palette option should be available for the current item layout or not
     */

#Code:
    public boolean canUsePalette() {
        return getItemLayoutRes() == R.layout.item_grid;
    }

#No. 226
#File: E:\bishe\1\AbsLibraryPagerRecyclerViewCustomGridSizeFragment.java
#Comment:
    /**
     * Override to customize which item layout currentLayoutRes should be used. You might also want to override {@link #canUsePalette()} then.
     *
     * @see #getGridSize()
     */

#Code:
    @LayoutRes
    protected int getItemLayoutRes() {
        if (getGridSize() > getMaxGridSizeForList()) {
            return R.layout.item_grid;
        }
        return R.layout.item_list;
    }

#No. 227
#File: E:\bishe\1\AbsListReportType.java
#Comment:
    //    /**
    //     * 从拦截器中获取某一行的样式字符串信息
    //     */

#Code:
    //        if(rbean.getInterceptor()!=null)
    //            {//拦截器中返回了<tr/>的样式字符串
    //            }

#No. 228
#File: E:\bishe\1\AbsListReportType.java
#Comment:
            /****if(sRowBeanTmp.getDisplaytype()==AbsListReportStatiBean.STATIROW_DISPLAYTYPE_PAGE)
            {
                if(rrequest.getShowtype()!=Consts.DISPLAY_ON_PAGE&&!this.cacheDataBean.isExportPrintPartData()) continue;
                if(rrequest.getShowtype()==Consts.DISPLAY_ON_PAGE&&cacheDataBean.getPagesize()<0) continue;//当前是显示在页面上，且显示全部数据
            }else if(sRowBeanTmp.getDisplaytype()==AbsListReportStatiBean.STATIROW_DISPLAYTYPE_REPORT)
            {
                if(rrequest.getShowtype()!=Consts.DISPLAY_ON_PAGE&&this.cacheDataBean.isExportPrintPartData()
                        ||rrequest.getShowtype()==Consts.DISPLAY_ON_PAGE&&cacheDataBean.getPagesize()>0)
                {
                    if(cacheDataBean.getFinalPageno()!=cacheDataBean.getPagecount()) continue;
                }
            }*/

#Code:
            if(sRowBeanTmp.getDisplayposition()!=AbsListReportSubDisplayBean.SUBROW_POSITION_BOTH&&sRowBeanTmp.getDisplayposition()!=position)
                continue;
            lstStatiColBeans=sRowBeanTmp.getLstSubColBeans();
            if(lstStatiColBeans==null||lstStatiColBeans.size()==0) continue;
            String stativalue;
            int startcolidx=0;
            int endcolidx=-1;
            CellRangeAddress region;
            for(AbsListReportSubDisplayColBean scbean:lstStatiColBeans)
            {
                stativalue=getSubColDisplayValue(this.subDisplayDataObj,scbean);
                stativalue=Tools.replaceAll(stativalue,"&nbsp;"," ");
                stativalue=stativalue.replaceAll("<.*?\\>","");//替换掉html标签
                if(rbean.getDbean().isDataexportColselect()
                        ||lstStatiColBeans.size()==1
                        ||(cacheDataBean.getAttributes().get("authroize_col_display")!=null&&String.valueOf(
                                cacheDataBean.getAttributes().get("authroize_col_display")).trim().equals("false"))||alrbean.hasControllCol())
                {
                    startcolidx=0;
                    endcolidx=cacheDataBean.getTotalColCount()-1;
                    int deltaCount=0;
                    if(alrdbean.getRowGroupColsNum()>0&&alrdbean.getRowgrouptype()==2)
                    {
                        deltaCount=alrdbean.getRowGroupColsNum()-1;
                    }
                    endcolidx=endcolidx+deltaCount;
                }else
                {
                    startcolidx=endcolidx+1;
                    endcolidx=startcolidx+scbean.getPlainexcel_colspan()-1;
                }
                region=new CellRangeAddress(excelRowIdx,excelRowIdx,startcolidx,endcolidx);
                StandardExcelAssistant.getInstance().setRegionCellStringValue(workbook,excelSheet,region,dataCellStyle,stativalue);
            }

#No. 229
#File: E:\bishe\1\AbsListReportType.java
#Comment:
            /****if(sRowBeanTmp.getDisplaytype()==AbsListReportStatiBean.STATIROW_DISPLAYTYPE_PAGE)
            {
                if(rrequest.getShowtype()!=Consts.DISPLAY_ON_PAGE&&!this.cacheDataBean.isExportPrintPartData()) continue;
                if(rrequest.getShowtype()==Consts.DISPLAY_ON_PAGE&&cacheDataBean.getPagesize()<0) continue;
            }else if(sRowBeanTmp.getDisplaytype()==AbsListReportStatiBean.STATIROW_DISPLAYTYPE_REPORT)
            {
                if(rrequest.getShowtype()!=Consts.DISPLAY_ON_PAGE&&this.cacheDataBean.isExportPrintPartData()
                        ||rrequest.getShowtype()==Consts.DISPLAY_ON_PAGE&&cacheDataBean.getPagesize()>0)
                {
                    if(cacheDataBean.getFinalPageno()!=cacheDataBean.getPagecount()) continue;//如果不是显示最后一页
                }
            }*/

#Code:
            if(sRowBeanTmp.getDisplayposition()!=AbsListReportSubDisplayBean.SUBROW_POSITION_BOTH&&sRowBeanTmp.getDisplayposition()!=position)
                continue;
            lstStatiColBeans=sRowBeanTmp.getLstSubColBeans();
            if(lstStatiColBeans==null||lstStatiColBeans.size()==0) continue;
            String stativalue;
            int startcolidx=0;
            int endcolidx=-1;
            for(AbsListReportSubDisplayColBean scbean:lstStatiColBeans)
            {
                stativalue=getSubColDisplayValue(this.subDisplayDataObj,scbean);
                stativalue=Tools.replaceAll(stativalue,"&nbsp;"," ");
                stativalue=stativalue.replaceAll("<.*?\\>","");
                if(rbean.getDbean().isDataexportColselect()
                        ||lstStatiColBeans.size()==1
                        ||(cacheDataBean.getAttributes().get("authroize_col_display")!=null&&String.valueOf(
                                cacheDataBean.getAttributes().get("authroize_col_display")).trim().equals("false"))||alrbean.hasControllCol())
                {
                    startcolidx=0;
                    endcolidx=cacheDataBean.getTotalColCount();//取到当前参与显示的总列数
                    int deltaCount=0;
                    if(alrdbean.getRowGroupColsNum()>0&&alrdbean.getRowgrouptype()==2)
                    {
                        deltaCount=alrdbean.getRowGroupColsNum()-1;
                    }
                    endcolidx=endcolidx+deltaCount;
                }else
                {
                    startcolidx=endcolidx+1;
                    endcolidx=startcolidx+scbean.getPlainexcel_colspan();
                }
                addDataCell(scbean,stativalue,1,endcolidx-startcolidx,Element.ALIGN_LEFT);
            }

#No. 230
#File: E:\bishe\1\AbsListViewAssert.java
#Comment:
/**
 * Assertions for {@link AbsListView} instances.
 * <p>
 * This class is final. To extend use {@link AbstractAbsListViewAssert}.
 */

#Code:
public final class AbsListViewAssert
    extends AbstractAbsListViewAssert<AbsListViewAssert, AbsListView> {
  public AbsListViewAssert(AbsListView actual) {
    super(actual, AbsListViewAssert.class);
  }
}

#No. 231
#File: E:\bishe\1\AbsListViewPaginate.java
#Comment:
        /**
         * Set the offset from the end of the list at which the load more event needs to be triggered. Default offset
         * if 5.
         *
         * @param threshold number of items from the end of the list.
         * @return {@link com.paginate.abslistview.AbsListViewPaginate.Builder}
         */

#Code:
        public Builder setLoadingTriggerThreshold(int threshold) {
            this.loadingTriggerThreshold = threshold;
            return this;
        }

#No. 232
#File: E:\bishe\1\AbsListViewPaginate.java
#Comment:
        /**
         * Paginate is using OnScrollListener in order to detect when list is scrolled near the end. That means that
         * internal listener is attached on AbsListView. Since AbsListView can have only one OnScrollListener it is
         * needed to use this method to add additional OnScrollListener (as delegate).
         *
         * @param onScrollListener that will be called when list is scrolled.
         * @return {@link com.paginate.abslistview.AbsListViewPaginate.Builder}
         */

#Code:
        public Builder setOnScrollListener(AbsListView.OnScrollListener onScrollListener) {
            this.onScrollListener = onScrollListener;
            return this;
        }

#No. 233
#File: E:\bishe\1\AbsListViewPaginate.java
#Comment:
        /**
         * Setup loading row. If loading row is used original adapter set on AbsListView will be wrapped with
         * internal adapter that will add loading row as the last item in the list. Paginate will observer the
         * changes upon original adapter and remove loading row if there is no more data to load. By default loading
         * row will be added.
         *
         * @param addLoadingListItem true if loading row needs to be added, false otherwise.
         * @return {@link com.paginate.abslistview.AbsListViewPaginate.Builder}
         * @see {@link com.paginate.Paginate.Callbacks#hasLoadedAllItems()}
         * @see {@link com.paginate.abslistview.AbsListViewPaginate.Builder#setLoadingListItemCreator(LoadingListItemCreator)}
         */

#Code:
        public Builder addLoadingListItem(boolean addLoadingListItem) {
            this.addLoadingListItem = addLoadingListItem;
            return this;
        }

#No. 234
#File: E:\bishe\1\AbsListViewPaginate.java
#Comment:
        /**
         * Set custom loading list item creator. If no creator is set default one will be used.
         *
         * @param loadingListItemCreator Creator that will ne called for inflating and binding loading list item.
         * @return {@link com.paginate.abslistview.AbsListViewPaginate.Builder}
         */

#Code:
        public Builder setLoadingListItemCreator(LoadingListItemCreator loadingListItemCreator) {
            this.loadingListItemCreator = loadingListItemCreator;
            return this;
        }

#No. 235
#File: E:\bishe\1\AbsListViewPaginate.java
#Comment:
        /**
         * Create pagination functionality upon AbsListView.
         *
         * @return {@link Paginate} instance.
         */

#Code:
        public Paginate build() {
            if (absListView.getAdapter() == null) {
                throw new IllegalStateException("Adapter needs to be set!");
            }

            if (loadingListItemCreator == null) {
                loadingListItemCreator = LoadingListItemCreator.DEFAULT;
            }

            return new AbsListViewPaginate(absListView, callbacks, loadingTriggerThreshold, onScrollListener,
                    addLoadingListItem, loadingListItemCreator);
        }

#No. 236
#File: E:\bishe\1\AbsMessage_Deprecated.java
#Comment:
	/**
	 * @return the contentObject
	 */

#Code:
	public Object getContentObject() {
		return contentObject;
	}

#No. 237
#File: E:\bishe\1\AbsMessage_Deprecated.java
#Comment:
	/**
	 * @param contentObject the contentObject to set
	 */

#Code:
	public void setContentObject(Object contentObject) {
		this.contentObject = contentObject;
	}

#No. 238
#File: E:\bishe\1\AbsModel.java
#Comment:
    /**
     * 根据状态码返回信息
     * @param status
     * @return
     */

#Code:
    protected String getResponseInfo(int status) {
        String msg = null;
        switch (status) {
            case Api.Code.OK:
                msg = "请求成功";
                break;

            case Api.Code.PERMISSION_DENIED:
                msg = "认证失败";
                break;

            default:
                msg = "未知错误";
        }
        return msg;
    }

#No. 239
#File: E:\bishe\1\AbsModule.java
#Comment:
  /**
   * Asserts that the given {@code object} with name {@code param} is not null, throws
   * {@link IllegalArgumentException} otherwise.
   */

#Code:
  void assertNotNull(Object object, String param) {
    if (object == null) {
      throw new IllegalArgumentException(String.format(
          "%s may not be null.", param));
    }
  }

#No. 240
#File: E:\bishe\1\AbsModule.java
#Comment:
  /**
   * Extracts the resource ID from the given {@code resource} of name {@code param}.
   * Throws {@link IllegalArgumentException} if the value is not present.
   */

#Code:
  String getResourceIdOrThrow(CMAResource resource, String param) {
    final String resourceId = resource.getId();
    if (resourceId == null) {
      throw new IllegalArgumentException(String.format(
          "%s.setId() was not called.", param));
    }
    return resourceId;
  }

#No. 241
#File: E:\bishe\1\AbsModule.java
#Comment:
  /**
   * Extracts the Space ID from the given {@code resource} of name {@code param}.
   * Throws {@link IllegalArgumentException} if the value is not present.
   */

#Code:
  String getSpaceIdOrThrow(CMAResource resource, String param) {
    final String spaceId = resource.getSpaceId();
    if (spaceId == null) {
      throw new IllegalArgumentException(String.format(
          "%s must have a space associated.", param));
    }
    return spaceId;
  }

#No. 242
#File: E:\bishe\1\AbsModule.java
#Comment:
  /**
   * Extracts the version number for the given {@code resource}.
   * Throws {@link IllegalArgumentException} if the value is not present.
   */

#Code:
  Integer getVersionOrThrow(CMAResource resource, String action) {
    final Integer version = resource.getVersion();
    if (version == null) {
      throw new IllegalArgumentException(String.format(
          "Cannot perform %s action on a resource that has no version associated.",
          action));
    }
    return version;
  }

#No. 243
#File: E:\bishe\1\AbsModule.java
#Comment:
  /**
   * Creates an Observable with the given {@code func} function and subscribes to it
   * with a set of pre-defined actions. The provided {@code callback} will be passed to these
   * actions in order to populate the events.
   */

#Code:
  <R> CMACallback<R> defer(DefFunc<R> func, CMACallback<R> callback) {
    assertNotNull(callback, "callback");
    Observable.defer(func)
        .subscribeOn(Schedulers.io())
        .subscribe(
            new ActionSuccess<R>(callbackExecutor, callback),
            new ActionError(callbackExecutor, callback));
    return callback;
  }

#No. 244
#File: E:\bishe\1\AbsMQTTReceive.java
#Comment:
	/**
	 * 消息到达事件
	 * 
	 * @param context
	 * @param topicName
	 * @param msg
	 * @param notifyShowing
	 *            false --当前主窗体 true --service触发
	 */

#Code:
	public abstract void MsgReceive(Context context, String topicName,
			String msg, boolean notifyShowing,MqttClient client);
}
}

#No. 245
#File: E:\bishe\1\AbsoluteCountMetric.java
#Comment:
    /**
     * Adds a long (can be negative) to the current count.
     *
     * @param value The count to add.
     */

#Code:
    public void add(long value) {
        count += value;
    }

#No. 246
#File: E:\bishe\1\AbsoluteLayoutAssert.java
#Comment:
/**
 * Assertions for {@link AbsoluteLayout} instances.
 * <p>
 * This class is final. To extend use {@link AbstractAbsoluteLayoutAssert}.
 */

#Code:
public final class AbsoluteLayoutAssert
    extends AbstractAbsoluteLayoutAssert<AbsoluteLayoutAssert, AbsoluteLayout> {
  public AbsoluteLayoutAssert(AbsoluteLayout actual) {
    super(actual, AbsoluteLayoutAssert.class);
  }
}

#No. 247
#File: E:\bishe\1\AbsoluteTemplateNameDef.java
#Comment:
/**
 * User: ed
 * Date: Aug 24, 2010
 * Time: 5:36:22 PM
 *
 * SoyPsiElement that represents the template name within a soy template tag.
 */

#Code:
public class AbsoluteTemplateNameDef
        extends SoyPsiElement
        implements SoyNamedElement, ItemPresentation, TemplateMemberElement, NamespaceMemberElement {

    private static final PsiElementPath PARAMETER_DECLARATION_PATH =
            new PsiElementPath(new ElementTypePredicate(SoyElement.tag_and_doc_comment).onFirstAncestor(),
                               new ElementTypePredicate(SoyElement.doc_comment).onChildren(),
                               new ElementTypePredicate(SoyElement.doc_comment_param_def).onChildren());
    private static final PsiElementPath PRIVATE_ATTRIBUTE_PATH =
            new PsiElementPath(new ElementTypePredicate(SoyElement.template_tag).onFirstAncestor(),
                               new ElementTypePredicate(SoyElement.tag_between_braces).onChildren(),
                               AttributePredicate.hasAttributeWithValue("private","true").onChildren());
    private static final PsiElementPath DELTEMPLATE_PATH =
            new PsiElementPath(PsiElementPath.PARENT_ELEMENT,
                               new ElementTypePredicate(SoyElement.command_keyword).onFirstChild(),
                               new ElementTextPredicate("deltemplate"));

    public AbsoluteTemplateNameDef(@NotNull ASTNode node) {
        super(node);
    }

#No. 248
#File: E:\bishe\1\AbsOpenAPI.java
#Comment:
    /**
     * HTTP 异步请求。
     *
     * @param url        请求的地址
     * @param params     请求的参数
     * @param httpMethod 请求方法
     * @param listener   请求后的回调接口
     */

#Code:
    protected void requestAsync(String url, WeiboParameters params, String httpMethod, RequestListener listener) {
        if (null == mAccessToken
                || TextUtils.isEmpty(url)
                || null == params
                || TextUtils.isEmpty(httpMethod)
                || null == listener) {
            LogUtil.e(TAG, "Argument error!");
            return;
        }

        params.put(KEY_ACCESS_TOKEN, mAccessToken.getToken());
        new AsyncWeiboRunner(mContext).requestAsync(url, params, httpMethod, listener);
    }

#No. 249
#File: E:\bishe\1\AbsOpenAPI.java
#Comment:
    /**
     * HTTP 同步请求。
     *
     * @param url        请求的地址
     * @param params     请求的参数
     * @param httpMethod 请求方法
     *
     * @return 同步请求后，服务器返回的字符串。
     */

#Code:
    protected String requestSync(String url, WeiboParameters params, String httpMethod) {
        if (null == mAccessToken
                || TextUtils.isEmpty(url)
                || null == params
                || TextUtils.isEmpty(httpMethod)) {
            LogUtil.e(TAG, "Argument error!");
            return "";
        }

        params.put(KEY_ACCESS_TOKEN, mAccessToken.getToken());
        return new AsyncWeiboRunner(mContext).request(url, params, httpMethod);
    }

#No. 250
#File: E:\bishe\1\AbsPdfInterceptor.java
#Comment:
    /***************************************************************************
     *  下面是针对没有配置模板的报表显示到PDF时的拦截方法                                                  
     **************************************************************************/

#Code:

    public boolean beforeDisplayReportWithoutTemplate(Document document,AbsReportType reportTypeObj)
    {
        return true;
    }

#No. 251
#File: E:\bishe\1\AbsPdfInterceptor.java
#Comment:
    /***************************************************************************
     *  下面是针对有模板的拦截方法                                                  
     **************************************************************************/

#Code:

    public boolean beforeDisplayPdfPageWithTemplate(IComponentConfigBean ccbean,Map<String,AbsReportType> mReportTypeObjs,int rowindex,
            PdfStamper pdfstamp)
    {
        return true;
    }

#No. 252
#File: E:\bishe\1\AbsPresenter.java
#Comment:
    /**
     * Clean up the references
     */

#Code:
    void destroy();
}
}

#No. 253
#File: E:\bishe\1\AbsPullToRefreshAttacher.java
#Comment:
        /**
         * @return Context which should be used for inflating the header layout
         */

#Code:
        public Context getContextForInflater(Activity activity) {
            ActionBar ab = null;
            if (activity instanceof SherlockActivity) {
                ab = ((SherlockActivity) activity).getSupportActionBar();
            } else if (activity instanceof SherlockListActivity) {
                ab = ((SherlockListActivity) activity).getSupportActionBar();
            } else if (activity instanceof SherlockFragmentActivity) {
                ab = ((SherlockFragmentActivity) activity).getSupportActionBar();
            } else if (activity instanceof SherlockExpandableListActivity) {
                ab = ((SherlockExpandableListActivity) activity).getSupportActionBar();
            } else if (activity instanceof SherlockPreferenceActivity) {
                ab = ((SherlockPreferenceActivity) activity).getSupportActionBar();
            }

            Context context = null;
            if (ab != null) {
                context = ab.getThemedContext();
            }
            if (context == null) {
                context = activity;
            }
            return context;
        }

#No. 254
#File: E:\bishe\1\AbsRationalDBUpdateAction.java
#Comment:
    /*private String getExternalValueOfReferedCol(ReportBean rbean,ReportRequest rrequest,EditableReportParamBean paramBean,String paramvalue)
    {
        ColBean referredColBean=(ColBean)((EditableReportExternalValueBean)paramBean.getOwner()).getRefObj();//取到被引用的其它报表的列对象
        String colParamname=referredColBean.getReportBean().getId()+referredColBean.getProperty();
        if(paramvalue.indexOf(".insert.")>0)
        {
            List<Map<String,String>> lstInsertedCValues=rrequest.getLstInsertedData(referredColBean.getReportBean());
            if(lstInsertedCValues!=null&&lstInsertedCValues.size()>0)
            {
                paramvalue=paramBean.getParamValue(lstInsertedCValues.get(0).get(colParamname),rrequest,rbean);
            }else
            {
                paramvalue="";
            }
        }else if(paramvalue.indexOf(".update.")>0)
        {
            List<Map<String,String>> lstUpdatedCValues=rrequest.getLstUpdatedData(referredColBean.getReportBean());//取到被引用的报表本次保存时所有变量的数据
            if(lstUpdatedCValues!=null&&lstUpdatedCValues.size()>0)
            {
                paramvalue=Tools.getRealKeyByDefine("@",paramvalue).trim();
                if(paramvalue.endsWith(".old"))
                {
                    paramvalue=lstUpdatedCValues.get(0).get(colParamname+"_old");
                    if(paramvalue==null)
                    {
                        paramvalue=lstUpdatedCValues.get(0).get(colParamname);
                    }
                    paramvalue=paramBean.getParamValue(paramvalue,rrequest,rbean);
                }else
                {
                    paramvalue=paramBean.getParamValue(lstUpdatedCValues.get(0).get(colParamname),rrequest,rbean);
                }
            }else
            {
                paramvalue="";
            }
        }else if(paramvalue.indexOf(".delete.")>0)
        {
            List<Map<String,String>> lstDeletedCValues=rrequest.getLstDeletedData(referredColBean.getReportBean());//取到被引用的报表本次保存时所有变量的数据
            if(lstDeletedCValues!=null&&lstDeletedCValues.size()>0)
            {
                paramvalue=lstDeletedCValues.get(0).get(colParamname+"_old");
                if(paramvalue==null)
                {
                    paramvalue=lstDeletedCValues.get(0).get(colParamname);
                }
                paramvalue=paramBean.getParamValue(paramvalue,rrequest,rbean);
            }else
            {
                paramvalue="";
            }
        }else
        {
            List<Map<String,String>> lstInsertedCValues=rrequest.getLstInsertedData(referredColBean.getReportBean());
            if(lstInsertedCValues!=null&&lstInsertedCValues.size()>0)
            {
                paramvalue=paramBean.getParamValue(lstInsertedCValues.get(0).get(colParamname),rrequest,rbean);
            }else
            {
                List<Map<String,String>> lstUpdatedCValues=rrequest.getLstUpdatedData(referredColBean.getReportBean());
                if(lstUpdatedCValues!=null&&lstUpdatedCValues.size()>0)
                {
                    paramvalue=paramBean.getParamValue(lstUpdatedCValues.get(0).get(colParamname),rrequest,rbean);
                }else
                {
                    List<Map<String,String>> lstDeletedCValues=rrequest.getLstDeletedData(referredColBean.getReportBean());
                    if(lstDeletedCValues!=null&&lstDeletedCValues.size()>0)
                    {
                        paramvalue=lstDeletedCValues.get(0).get(colParamname+"_old");
                        if(paramvalue==null)
                        {
                            paramvalue=lstDeletedCValues.get(0).get(colParamname);
                        }
                        paramvalue=paramBean.getParamValue(paramvalue,rrequest,rbean);
                    }else
                    {
                        paramvalue="";
                    }
                }
            }
        }
        return paramvalue;
    }*/

#Code:

    /**private String getReferedOtherExternalValue(ReportBean rbean,ReportRequest rrequest,EditableReportParamBean paramBean,String paramvalue)
    {
        EditableReportExternalValueBean referredEValueBean=(EditableReportExternalValueBean)((EditableReportExternalValueBean)paramBean.getOwner())
                .getRefObj();
        ReportBean rbeanRefered=referredEValueBean.getOwner().getOwner().getOwner().getReportBean();
        if(paramvalue.indexOf(".insert.")>0)
        {//是引用其它报表在<insert/>中定义的变量的值
            List<Map<String,String>> lstInsertedEValues=rrequest.getLstInsertedExternalValues(rbeanRefered);//取到被引用的报表本次保存时所有变量的数据
            if(lstInsertedEValues!=null&&lstInsertedEValues.size()>0)
            {
                paramvalue=paramBean.getParamValue(lstInsertedEValues.get(0).get(referredEValueBean.getName()),rrequest,rbean);
            }else
            {
                paramvalue="";
            }
        }else if(paramvalue.indexOf(".update.")>0)
        {//是引用其它报表在<update/>中定义的变量的值
            List<Map<String,String>> lstUpdatedEValues=rrequest.getLstUpdatedExternalValues(rbeanRefered);
            if(lstUpdatedEValues!=null&&lstUpdatedEValues.size()>0)
            {
                paramvalue=paramBean.getParamValue(lstUpdatedEValues.get(0).get(referredEValueBean.getName()),rrequest,rbean);
            }else
            {
                paramvalue="";
            }
        }else if(paramvalue.indexOf(".delete.")>0)
        {//是引用其它报表在<delete/>中定义的变量的值
            List<Map<String,String>> lstDeletedEValues=rrequest.getLstDeletedExternalValues(rbeanRefered);
            if(lstDeletedEValues!=null&&lstDeletedEValues.size()>0)
            {
                paramvalue=paramBean.getParamValue(lstDeletedEValues.get(0).get(referredEValueBean.getName()),rrequest,rbean);
            }else
            {
                paramvalue="";
            }
        }
        return paramvalue;
    }*/    

#No. 255
#File: E:\bishe\1\AbsRationalDBUpdateAction.java
#Comment:
//    /**
//     * @param paramBean
//     */

#Code:
//        if(((EditableReportParamBean)paramBean).getOwner() instanceof EditableReportExternalValueBean)
//        {//是从<params/>中定义的变量中取值
//        }

#No. 256
#File: E:\bishe\1\AbsRecyclerViewFastScroller.java
#Comment:
    /**
     * Takes a touch event and determines how much scroll progress this translates into
     * @param event touch event received by the layout
     * @return scroll progress, or fraction by which list is scrolled [0 to 1]
     */

#Code:
    public float getScrollProgress(MotionEvent event) {
        ScrollProgressCalculator scrollProgressCalculator = getScrollProgressCalculator();
        if (scrollProgressCalculator != null) {
            return getScrollProgressCalculator().calculateScrollProgress(event);
        }
        return 0;
    }

#No. 257
#File: E:\bishe\1\AbsRecyclerViewFastScroller.java
#Comment:
    /**
     * Moves the handle of the scroller by specific progress amount
     * @param scrollProgress fraction by which to move scroller [0 to 1]
     */

#Code:
    public abstract void moveHandleToPosition(float scrollProgress);

}
#No. 258
#File: E:\bishe\1\AbsRefreshLayout.java
#Comment:
    /**
     * @see ViewGroup#generateDefaultLayoutParams()
     */

#Code:
    @Override
    protected LayoutParams generateDefaultLayoutParams() {
        return new LayoutParams(LayoutParams.MATCH_PARENT,
                LayoutParams.WRAP_CONTENT);
    }

#No. 259
#File: E:\bishe\1\AbsResource.java
#Comment:
//    /**
//     */

#Code:
//    {
    public abstract Object getValue(Element itemElement);
}

#No. 260
#File: E:\bishe\1\AbstactScriptDaemonGenerator.java
#Comment:
/**
 * The abstract script daemon generator which contains all common parameters and methods for
 * AbstractBooterDaemonGenerator, UnixScriptDaemonGenerator and WindowsScriptDaemonGenerator
 *
 * @author <a href="mailto:khmarbaise@soebes.de">Karl-Heinz Marbaise</a>
 */

#Code:
public abstract class AbstactScriptDaemonGenerator
    implements DaemonGenerator
{
    /**
     * @plexus.requirement
     */
    protected ScriptGenerator scriptGenerator;

    private final String platformName;

    public AbstactScriptDaemonGenerator( String platformName )
    {
        this.platformName = platformName;
    }

    public String getPlatformName()
    {
        return platformName;
    }
}

#No. 261
#File: E:\bishe\1\AbstarctController.java
#Comment:
  /**
   * <ul>
   * 判断方向的基本原则：每当用户按下一个方向键，就把它的keyCode存进数组（数组里不可以有重复）；每当一个方向键弹起，则把keyCode从数组里清除。
   * <li>若数组里只有一个键,那就是轴方向运动;</li>
   * <li>两个键，两种情况：如果是复合键，就是斜方向运动；如果是一个A一个D这样一组相反键，则只响应先按的那个，物体只做轴方向运动;</li>
   * <li>三个或四个键只响应数组里最先按的那一组复合键，做斜方向运动.</li>
   * </ul>
   * <p>
   * 使用数组的好处在于可以处理复杂的多按键情况（无论是玩家有意乱按还是无意多按的），大大提高手感。
   * </p>
   * <p>
   * 例如这样一组输入：先后按下A、W、D再释放A，之后按下S并释放W、D。玩家最可能的意图是，先左上走，然后改为右上，最后改为下。
   * 这样的按键手感方便但是就造成一般的if ...else判断方法很难响应。
   * </p>
   * <p>
   * 因为Javafx里始终只不断给出最后一个键按下的消息.
   * 新的按键消息会不断把以前的按键消息“冲”掉。而且同时按3个或4个键在if...else里判断很麻烦，
   * 即使建立了类似Ctrl+Shift这样的变量来追踪以前的按键。 而使用有序且不重复的数组则可以完美解决这些问题。
   * </p>
   */

#Code:

  protected void preKeyEvent(Event event){
    if(!(event instanceof KeyEvent)) return;

    KeyEvent ke = (KeyEvent) event;
    if(event.getEventType() == KeyEvent.KEY_PRESSED && keys.size() < 4){
      keys.add(ke.getCode());
    }else if(event.getEventType() == KeyEvent.KEY_PRESSED){
      keys.remove(ke);
    }
  }

#No. 262
#File: E:\bishe\1\AbstarctController.java
#Comment:
  /**
   * 处理鼠标移动和退出事件
   * 
   * @param event
   */

#Code:
  protected void preMouseEvent(Event event){
    if(!(event instanceof MouseEvent)) return;

    MouseEvent me = (MouseEvent) event;
    if(event.getEventType() == MouseEvent.MOUSE_MOVED){
      mouse = new Point((int) me.getX(), (int) me.getY());
    }else if(event.getEventType() == MouseEvent.MOUSE_EXITED){
      mouse = null;
    }
  }

#No. 263
#File: E:\bishe\1\AbsThemeActivity.java
#Comment:
    /**
     * This will set the color of the view with the id "status_bar" on KitKat and Lollipop.
     * On Lollipop if no such view is found it will set the statusbar color using the native method.
     *
     * @param color the new statusbar color (will be shifted down on Lollipop and above)
     */

#Code:
    public void setStatusbarColor(int color) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
            final View statusBar = getWindow().getDecorView().getRootView().findViewById(R.id.status_bar);
            if (statusBar != null) {
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
                    statusBar.setBackgroundColor(ColorUtil.darkenColor(color));
                    setLightStatusbarAuto(color);
                } else {
                    statusBar.setBackgroundColor(color);
                }
            } else if (Build.VERSION.SDK_INT >= 21) {
                getWindow().setStatusBarColor(ColorUtil.darkenColor(color));
                setLightStatusbarAuto(color);
            }
        }
    }

#No. 264
#File: E:\bishe\1\AbsTipAdapter.java
#Comment:
            /*Log.e("heheda", "Saving itemId: " + itemId + " for listview child " + i + " Top: "
                    + child.getTop() + " Left: "
                    + child.getLeft());*/

#Code:

            mItemIdTopMap.put(itemId, child.getTop());
            mItemIdLeftMap.put(itemId, child.getLeft());
        }
    }

}
}

#No. 265
#File: E:\bishe\1\AbstractAccess.java
#Comment:
    /**
     * Fields
     */

#Code:

    @Override
    public List<Field> getFields() {
        List<Field> fields = new ArrayList<>();

        if (forceAccess) {
            fields.addAll(getAllFields(this.clazz));
        } else {
            fields.addAll(getFields(this.clazz));
        }

        return fields;
    }

#No. 266
#File: E:\bishe\1\AbstractAccess.java
#Comment:
    /**
     * Methods
     */

#Code:

    @Override
    public List<Method> getMethods() {
        List<Method> methods = new ArrayList<>();

        if (forceAccess) {
            methods.addAll(getAllMethods(this.clazz));
        } else {
            methods.addAll(getMethods(this.clazz));
        }

        return methods;
    }

#No. 267
#File: E:\bishe\1\AbstractAccess.java
#Comment:
    /**
     * Constructors
     */

#Code:

    @Override
    public List<Constructor> getConstructors() {
        List<Constructor> constructors = new ArrayList<>();

        if (forceAccess) {
            constructors.addAll(getAllConstructors(this.clazz));
        } else {
            constructors.addAll(getConstructors(this.clazz));
        }

        return constructors;
    }

#No. 268
#File: E:\bishe\1\AbstractAccess.java
#Comment:
    /**
     * Other things
     */

#Code:

    @Override
    public boolean isAssignableFrom(final Class<?> clazz) {
        return this.getReflectedClass().isAssignableFrom(clazz);
    }

#No. 269
#File: E:\bishe\1\AbstractAccess.java
#Comment:
    /**
     * Utility methods...
     */

#Code:

    protected static List<Class<?>> getAllSuperClasses(final Class<?> clazz) {
        List<Class<?>> result = new ArrayList<>();
        if (clazz != null && (INCLUDE_OBJECT || !clazz.equals(Object.class))) {
            result.add(clazz);
            result.addAll(getAllSuperClasses(clazz.getSuperclass()));
            for (Class<?> iface : clazz.getInterfaces()) {
                result.addAll(getAllSuperClasses(iface));
            }
        }
        return result;
    }

#No. 270
#File: E:\bishe\1\AbstractAccessibleUnloader.java
#Comment:
	/**
	 * The object is deleted only if its submission timestamp matches the one passed to this class constructor.
	 *
	 */

#Code:
	@SuppressWarnings("unchecked")
	public boolean queueByAcc ( String acc ) 
	{
		AT object = ( (AccessibleDAO<AT>) dao ).getByAcc ( acc );
		
		if ( object == null ) {
			unloadManager.addMessage ( "Object #" + acc + "not found, no unloading done for this accession." );
			return false;
		}
		return queue ( object );
	}

#No. 271
#File: E:\bishe\1\AbstractAccountHandler.java
#Comment:
    /*
     * callback handling
     */

#Code:

    protected void fireOnLoginStarted(LoginCallback loginCallback) {
        if (loginCallback != null) {
            loginCallback.onLoginStarted();
        }
    }

#No. 272
#File: E:\bishe\1\AbstractActionManager.java
#Comment:
  /**
   * ActionManager factory used to create new ActionManager
   */

#Code:
  protected ActionManagerFactory actionFact = null;
  /**
   * Action name in a Additional Action dictionary
   */
  protected String aaKey = null;
  /**
   * The action dictionary checked by this class
   */
  protected COSDictionary actionDictionnary = null;
  /**
   * The COSDocument from which the action comes from
   */
  protected COSDocument cDoc = null;

  /**
   * 
   * @param amFact
   *          Instance of ActionManagerFactory used to create ActionManager to
   *          check Next actions.
   * @param adict
   *          the COSDictionary of the action wrapped by this class.
   * @param cDoc
   *          the COSDocument from which the action comes from.
   * @param aaKey
   *          The name of the key which identify the action in a additional
   *          action dictionary.
   */
  AbstractActionManager(ActionManagerFactory amFact, COSDictionary adict,
      COSDocument cDoc, String aaKey) {
    this.actionFact = amFact;
    this.actionDictionnary = adict;
    this.aaKey = aaKey;
    this.cDoc = cDoc;
  }

#No. 273
#File: E:\bishe\1\AbstractActionManager.java
#Comment:
  /**
   * @return the isAdditionalAction
   */

#Code:
  public boolean isAdditionalAction() {
    return this.aaKey != null;
  }

#No. 274
#File: E:\bishe\1\AbstractActionManager.java
#Comment:
  /**
   * @return the actionDictionnary
   */

#Code:
  public COSDictionary getActionDictionnary() {
    return actionDictionnary;
  }

#No. 275
#File: E:\bishe\1\AbstractActionManager.java
#Comment:
  /**
   * @return the aaKey
   */

#Code:
  public String getAdditionalActionKey() {
    return aaKey;
  }

#No. 276
#File: E:\bishe\1\AbstractActionManager.java
#Comment:
  /**
   * This method create a list of Action Managers which represent actions in the
   * Next entry of the current action dictionary. For each Next Action, the
   * innerValid is called and the method returns false if a validation fails.
   * 
   * @param error
   *          the validation error list to updated if the validation fails.
   * @return True if all Next Action are valid, false otherwise.
   * @throws ValidationException
   */

#Code:
  protected boolean validNextActions(List<ValidationError> error)
      throws ValidationException {
    List<AbstractActionManager> lActions = this.actionFact.getNextActions(
        this.actionDictionnary, this.cDoc);
    for (AbstractActionManager nAction : lActions) {
      if (!nAction.innerValid(error)) {
        return false;
      }
    }
    return true;
  }

#No. 277
#File: E:\bishe\1\AbstractActionManager.java
#Comment:
  /**
   * Call the valid(boolean, List) method with the additonalActionAuth set to
   * false.
   * 
   * @param error
   *          the validation error list to updated if the validation fails.
   * @return
   * @throws ValidationException
   */

#Code:
  public boolean valid(List<ValidationError> error) throws ValidationException {
    return valid(false, error);
  }

#No. 278
#File: E:\bishe\1\AbstractActionManager.java
#Comment:
  /**
   * Validate an Action dictionary.
   * 
   * Return false if the dictionary is invalid (ex : missing key). If the
   * ActionManager represents an AdditionalAction, this method returns false and
   * updates the error list when the additonalActionAuth parameter is set to
   * false.
   * 
   * This method call the innerValid method to process specific checks according
   * to the action type.
   * 
   * If innerValid successes, all actions contained in the Next entry of the
   * Action dictionary are validated.
   * 
   * @param additonalActionAuth
   *          boolean to know if an additional action is authorized.
   * @param error
   *          the validation error list to updated if the validation fails.
   * @return 
   * @throws ValidationException
   */

#Code:
  public boolean valid(boolean additonalActionAuth, List<ValidationError> error)
      throws ValidationException {
    if (isAdditionalAction() && !additonalActionAuth) {
      error.add(new ValidationError(ERROR_ACTION_FORBIDDEN_ADDITIONAL_ACTION, "Additional Action are forbidden" ));
      return false;
    }

    if (innerValid(error)) {
      return validNextActions(error);
    }

    return true;
  }

#No. 279
#File: E:\bishe\1\AbstractActionType.java
#Comment:
	/**
	 * 判断动作是否合法。<br>
	 * 默认实现为：先检查前提条件、相关牌数量、相关牌范围，如果满足再调用{@link #isLegalActionWithPreconition}。
	 */

#Code:
	protected boolean isLegalActionTiles(GameContext.PlayerView context,
			Set<Tile> tiles) {
		PlayerLocation location = context.getMyLocation();
		if (!meetPrecondition(context)) {
			return false;
		}

		int legalTilesSize = getActionTilesSize();
		if (legalTilesSize > 0
				&& (tiles == null || tiles.size() != legalTilesSize)) {
			return false;
		}

		Set<Tile> legalTilesRange = getActionTilesRange(context, location);
		if (tiles != null && legalTilesRange != null
				&& !legalTilesRange.containsAll(tiles)) {
			return false;
		}

		boolean legal = isLegalActionWithPreconition(context, tiles);
		return legal;
	}

#No. 280
#File: E:\bishe\1\AbstractActionVO.java
#Comment:
    /**
     * Copies a vo
     * @return Copy of this vo
     */

#Code:
    @SuppressWarnings("unchecked")
    public VO copy() {
        // TODO make sure this works
        try {
            return (VO) super.clone();
        }
        catch (CloneNotSupportedException e) {
            throw new ShouldNeverHappenException(e);
        }
    }

#No. 281
#File: E:\bishe\1\AbstractActionVoModel.java
#Comment:
	/**
	 * @param data
	 */

#Code:
	public AbstractActionVoModel(T data) {
		super(data);
	}

#No. 282
#File: E:\bishe\1\AbstractActiveModule.java
#Comment:
  /**
   * Implement the internal start logic.
   *
   * @throws OpenAS2Exception
   *         In case of an error.
   */

#Code:
  public abstract void doStart () throws OpenAS2Exception;

  public void start () throws OpenAS2Exception
  {
    _setRunning (true);
    doStart ();
  }

#No. 283
#File: E:\bishe\1\AbstractActiveModule.java
#Comment:
  /**
   * Implement the internal stop logic.
   *
   * @throws OpenAS2Exception
   *         In case of an error.
   */

#Code:
  public abstract void doStop () throws OpenAS2Exception;

  public void stop () throws OpenAS2Exception
  {
    _setRunning (false);
    doStop ();
  }

#No. 284
#File: E:\bishe\1\AbstractActivitiTestCase.java
#Comment:
  /** Each test is assumed to clean up all DB content it entered.
   * After a test method executed, this method scans all tables to see if the DB is completely clean. 
   * It throws AssertionFailed in case the DB is not clean.
   * If the DB is not clean, it is cleaned by performing a create a drop. */

#Code:
  protected void assertAndEnsureCleanDb() throws Throwable {
    log.debug("verifying that db is clean after test");
    Map<String, Long> tableCounts = managementService.getTableCount();
    StringBuilder outputMessage = new StringBuilder();
    for (String tableName : tableCounts.keySet()) {
      String tableNameWithoutPrefix = tableName.replace(processEngineConfiguration.getDatabaseTablePrefix(), "");
      if (!TABLENAMES_EXCLUDED_FROM_DB_CLEAN_CHECK.contains(tableNameWithoutPrefix)) {
        Long count = tableCounts.get(tableName);
        if (count!=0L) {
          outputMessage.append("  "+tableName + ": " + count + " record(s) ");
        }
      }
    }
    if (outputMessage.length() > 0) {
      outputMessage.insert(0, "DB NOT CLEAN: \n");
      log.error(EMPTY_LINE);
      log.error(outputMessage.toString());
      
      log.info("dropping and recreating db");
      
      CommandExecutor commandExecutor = ((ProcessEngineImpl)processEngine).getProcessEngineConfiguration().getCommandExecutorTxRequired();
      commandExecutor.execute(new Command<Object>() {
        public Object execute(CommandContext commandContext) {
          DbSqlSession session = commandContext.getSession(DbSqlSession.class);
          session.dbSchemaDrop();
          session.dbSchemaCreate();
          return null;
        }
      });

      if (exception!=null) {
        throw exception;
      } else {
        Assert.fail(outputMessage.toString());
      }
    } else {
      log.info("database was clean");
    }
  }

#No. 285
#File: E:\bishe\1\AbstractActivity.java
#Comment:
	/**
	 * Displays a simple dialog wich will contain the message and the error code provided as parameters.
	 * Defaul action on OK is dismissing the dialog.
	 * @param message
	 * @param errorCode
	 */

#Code:
	public void displayGeneralErrorDialog(int resourceID, String errorCode) {
        String errorText = application.getApplicationContext().getResources().getString(resourceID);
        displayGeneralErrorDialog(errorText, errorCode);
        
    }

#No. 286
#File: E:\bishe\1\AbstractActivity.java
#Comment:
	/**
     * Displays a simple dialog wich will contain the message and the error code provided as parameters.
     * Defaul action on OK is dismissing the dialog.
     * @param message
     * @param errorCode
     */

#Code:
    public void displayGeneralErrorDialog(String message, String errorCode) {
        String errorText = message;
        if (errorCode != null && errorCode.length() > 0) {
            errorText+= "(" + errorCode +")"; 
        }
        generalErrorMessage = errorText;
        if(isApplicationActive()) {
            showDialog(DIALOG_GENERAL_NETWORK_ERROR);
        } else {
            Toast.makeText(this, generalErrorMessage, Toast.LENGTH_LONG);
        }
    }

#No. 287
#File: E:\bishe\1\AbstractActivity.java
#Comment:
	/**
	 * @param roamingPositiveAction the roamingPositiveAction to set
	 */

#Code:
	protected void setRoamingPositiveAction(Runnable roamingPositiveAction) {
		this.roamingPositiveAction = roamingPositiveAction;
	}

#No. 288
#File: E:\bishe\1\AbstractActivity.java
#Comment:
	/**
	 * @return the roamingWarningDisplayed
	 */

#Code:
	public boolean isRoamingWarningDisplayed() {
		return application.isRoamingWarningDisplayed();
	}

#No. 289
#File: E:\bishe\1\AbstractActorAction.java
#Comment:
	/**
	 * 处理分配的角色
	 */

#Code:
	protected void dealRoles4Save() {
		Set<Role> roles = null;
		if (this.assignRoleIds != null && this.assignRoleIds.length() > 0) {
			roles = new HashSet<Role>();
			String[] rids = this.assignRoleIds.split(",");
			Role r;
			for (String rid : rids) {
				r = new Role();
				r.setId(new Long(rid));
				roles.add(r);
			}
		}
		if (this.getE().getRoles() != null) {
			this.getE().getRoles().clear();
			this.getE().getRoles().addAll(roles);
		} else {
			this.getE().setRoles(roles);
		}
	}

#No. 290
#File: E:\bishe\1\AbstractActorAction.java
#Comment:
	/**
	 * 加载直接分配的角色和从上级继承的角色
	 */

#Code:
	protected void dealRoles4Edit() {
		// 加载直接分配的角色信息
		this.ownedRoles = this.getActorService().load(this.getId()).getRoles();

		this.inheritRolesFromOU = new HashSet<Role>();
		if (belongIds != null && belongIds.length() > 0) {
			// 加载从上级组织继承的角色信息
			List<Actor> belongs = this.getActorService().findBelong(
					this.getId(), getBelongTypes());
			for (Actor belong : belongs) {
				inheritRolesFromOU.addAll(belong.getRoles());
			}

			// 加载从上级的上级继承的角色信息
			for (Actor belong : belongs) {
				List<Actor> ancestorOU = this.getActorService()
						.findAncestorOrganization(
								belong.getId(),
								new Integer[] { Actor.TYPE_UNIT,
										Actor.TYPE_DEPARTMENT });
				for (Actor ou : ancestorOU) {
					inheritRolesFromOU.addAll(ou.getRoles());
				}
			}
		}
	}

#No. 291
#File: E:\bishe\1\AbstractActorLight.java
#Comment:
	/**
	 * Translate actor in a direction of speed without stopping. Actor moves in
	 * constants speed set without acceleration
	 * 
	 * @param speedX
	 *            axis-X speed
	 * @param speedY
	 *            axis-Y speed
	 * @param delta
	 *            the delta time for accurate speed
	 * */

#Code:
	public void translateWithoutAcc(float speedX, float speedY, float delta) {
		setPosition(getX() + (speedX * delta), getY() + (speedY * delta));
	}

#No. 292
#File: E:\bishe\1\AbstractActorLight.java
#Comment:
	/**
	 * Get textureRegion of the actor
	 * 
	 * @return TextureRegion
	 * 
	 * */

#Code:
	public TextureRegion getTextureRegion() {
		return textureRegion;
	}

#No. 293
#File: E:\bishe\1\AbstractActorLight.java
#Comment:
	/**
	 * Set texture region for the actor, it will be drawn only if texture region
	 * is set and active
	 * 
	 * @param textureRegion
	 *            texture region of the actor
	 * @param isTextureRegionActive
	 *            set texture region active to be drawn or not
	 * */

#Code:
	public void setTextureRegion(TextureRegion textureRegion,
			boolean isTextureRegionActive) {
		this.textureRegion = textureRegion;
		this.isTextureRegionActive = isTextureRegionActive;
	}

#No. 294
#File: E:\bishe\1\AbstractActualIdentityToolFunction.java
#Comment:
  /**
   * Execute this Identity tool function.
   */

#Code:
  public void execute() {
    open();
    Ticket t = null;
    try {
      t = connection.getService().login(loginUser, loginPassword);
      doExecute(t, connection.getService());
    } catch (IllegalStateException | TException e) {
      throw new RuntimeException("Could not interact with identity service", e);
    } finally {
      if (t != null) {
        try {
          connection.getService().logout(t);
        } catch (IllegalStateException | TException e) {
          logger.warn("Could not logout.", e);
        }
      }
      close();
    }
  }

#No. 295
#File: E:\bishe\1\AbstractAddThirdPartyMojo.java
#Comment:
    /**
     * @return list of license to exclude.
     */

#Code:
    public List<String> getExcludedLicenses()
    {
        return excludedLicenses.getData();
    }

#No. 296
#File: E:\bishe\1\AbstractAddThirdPartyMojo.java
#Comment:
    /**
     * @return list of license to include.
     */

#Code:
    public List<String> getIncludedLicenses()
    {
        return includedLicenses.getData();
    }

#No. 297
#File: E:\bishe\1\AbstractAddThirdPartyMojo.java
#Comment:
    /**
     * Fill the {@link #includedLicenses} parameter from a simple string to split.
     *
     * @param includedLicenses license to excludes separated by a {@code |}.
     */

#Code:
    public void setIncludedLicenses( String includedLicenses )
    {
        this.includedLicenses = new IncludedLicenses( includedLicenses );
    }

#No. 298
#File: E:\bishe\1\AbstractAddThirdPartyMojo.java
#Comment:
    /**
     * Fill the {@link #excludedLicenses} parameter from a simple string to split.
     *
     * @param excludedLicenses license to excludes separated by a {@code |}.
     */

#Code:
    public void setExcludedLicenses( String excludedLicenses )
    {
        this.excludedLicenses = new ExcludedLicenses( excludedLicenses );
    }

#No. 299
#File: E:\bishe\1\AbstractAddThirdPartyMojo.java
#Comment:
    /**
     * Class to fill the {@link #includedLicenses} parameter, from a simple string to split, or a list of string.
     * <p>
     * TODO-tchemit We should find a way to create a plexus convertor.
     *
     * @since 1.4
     */

#Code:
    public static class IncludedLicenses
            extends StringToList
    {

        /**
         * Default constructor used when {@link #includedLicenses} parameter is configured by a list.
         */
        public IncludedLicenses()
        {
        }

        /**
         * Constructor used when {@link #includedLicenses} parameter is configured by a string to split.
         *
         * @param data the string to split to fill the list of data of the object.
         */
        public IncludedLicenses( String data )
        {
            super( data );
        }

        /**
         * Add a simple a include license to the list.
         *
         * @param includeLicense the include license to add.
         */
        public void setIncludedLicense( String includeLicense )
        {
            addEntryToList( includeLicense );
        }
    }

#No. 300
#File: E:\bishe\1\AbstractAddThirdPartyMojo.java
#Comment:
    /**
     * Class to fill the {@link #excludedLicenses} parameter, from a simple string to split, or a list of string.
     * <p>
     * TODO-tchemit We should find a way to create a plexus convertor.
     *
     * @since 1.4
     */

#Code:
    public static class ExcludedLicenses
            extends StringToList
    {

        /**
         * Default constructor used when {@link #excludedLicenses} parameter is configured by a list.
         */
        public ExcludedLicenses()
        {
        }

        /**
         * Constructor used when {@link #excludedLicenses} parameter is configured by a string to split.
         *
         * @param data the string to split to fill the list of data of the object.
         */
        public ExcludedLicenses( String data )
        {
            super( data );
        }

        /**
         * Add a simple exclude License to the list.
         *
         * @param excludeLicense the excludelicense to add.
         */
        public void setExcludedLicense( String excludeLicense )
        {
            addEntryToList( excludeLicense );
        }
    }

#No. 301
#File: E:\bishe\1\AbstractAdtMojo.java
#Comment:
    /**
     * Location of the file.
     */

#Code:
    @Parameter(property = "project.build.directory", required = true)
    protected File outputDirectory;

    protected MojoFailureException failWith(String msg) {
        return new MojoFailureException(this, msg, msg);
    }

#No. 302
#File: E:\bishe\1\AbstractAgent.java
#Comment:
        /*
          default value for pushMemoryBufferLimit is 16 * pushFlushMaxPoints, but no more than 25% of available heap
          memory. 25% is chosen heuristically as a safe number for scenarios with limited system resources (4 CPU cores
          or less, heap size less than 4GB) to prevent OOM. this is a conservative estimate, budgeting 200 characters
          (400 bytes) per per point line. Also, it shouldn't be less than 1 batch size (pushFlushMaxPoints).
         */

#Code:
        int listeningPorts = Iterables.size(Splitter.on(",").omitEmptyStrings().trimResults().split(pushListenerPorts));
        long calculatedMemoryBufferLimit = Math.max(Math.min(16 * pushFlushMaxPoints.get(),
            Runtime.getRuntime().maxMemory() / listeningPorts / 4 / flushThreads / 400), pushFlushMaxPoints.get());
        logger.fine("Calculated pushMemoryBufferLimit: " + calculatedMemoryBufferLimit);
        pushMemoryBufferLimit.set(Integer.parseInt(
            config.getRawProperty("pushMemoryBufferLimit", String.valueOf(pushMemoryBufferLimit.get())).trim()));
        config.reportSettingAsGauge(pushMemoryBufferLimit, "pushMemoryBufferLimit");
        logger.fine("Configured pushMemoryBufferLimit: " + pushMemoryBufferLimit);

        logger.warning("Loaded configuration file " + pushConfigFile);
      } catch (Throwable exception) {
        logger.severe("Could not load configuration file " + pushConfigFile);
        throw exception;
      }

#No. 303
#File: E:\bishe\1\AbstractAgent.java
#Comment:
  /**
   * Actual agents can do additional configuration.
   *
   * @param config The configuration to process.
   */

#Code:
  protected void processConfiguration(AgentConfiguration config) {
    try {
      agentAPI.agentConfigProcessed(agentId);
    } catch (RuntimeException e) {
      // cannot throw or else configuration update thread would die.
    }
  }

#No. 304
#File: E:\bishe\1\AbstractAgentClient.java
#Comment:
    /**
     * Make the call through the current VM 
     */

#Code:
    protected static final String LOCAL_JVM = "local";

    protected final String        atsAgent;
    protected final String        component;

    protected AbstractAgentClient( String atsAgent, String component ) {

        this.log = Logger.getLogger( this.getClass() );

        if( LOCAL_JVM.equals( atsAgent ) ) {
            // we will work in the local JVM, so no running external instance of ATS Agent
            this.atsAgent = atsAgent;
        } else {
            // add default port in case none is not provided by the user
            this.atsAgent = HostUtils.getAtsAgentIpAndPort( atsAgent );
        }

        this.component = component;
    }

#No. 305
#File: E:\bishe\1\AbstractAjcCompiler.java
#Comment:
    /**
     * Checks modifications that would make us need a build
     *
     * @return <code>true</code> if build is needed, otherwise <code>false</code>
     * @throws MojoExecutionException
     */

#Code:
    protected boolean isBuildNeeded()
            throws MojoExecutionException {
        File outDir = getOutputDirectory();
        return hasNoPreviousBuild(outDir) || hasArgumentsChanged(outDir) ||
                hasSourcesChanged(outDir) || hasNonWeavedClassesChanged(outDir);

    }

#No. 306
#File: E:\bishe\1\AbstractAjcCompiler.java
#Comment:
    /**
     * Not entirely safe, assembleArguments() must be run
     */

#Code:
    private boolean hasSourcesToCompile() {
        return resolvedIncludes.size() > 0;
    }

#No. 307
#File: E:\bishe\1\AbstractAjcCompiler.java
#Comment:
    /**
     * Setters which when called sets compiler arguments
     *
     * @param complianceLevel the complianceLevel
     */

#Code:
    public void setComplianceLevel(String complianceLevel) {
        if (AjcHelper.isValidComplianceLevel(complianceLevel)) {
            ajcOptions.add("-" + complianceLevel);
        }
    }

#No. 308
#File: E:\bishe\1\AbstractAlfrescoSessionImpl.java
#Comment:
    /**
     * @return Returns repository unique identifier.
     */

#Code:
    public String getRepositoryIdentifier()
    {
        return repositoryInfo.getIdentifier();
    }

#No. 309
#File: E:\bishe\1\AbstractAlfrescoSessionImpl.java
#Comment:
    /**
     * @return Returns the root folder of the repository.
     */

#Code:
    public Folder getRootFolder()
    {
        return rootNode;
    }

#No. 310
#File: E:\bishe\1\AbstractAlfrescoSessionImpl.java
#Comment:
    /**
     * @return Returns the base URL associated to the repository </br> For
     *         example : <i>http://hostname:port/alfresco</i>
     */

#Code:
    public String getBaseUrl()
    {
        return baseUrl;
    }

#No. 311
#File: E:\bishe\1\AbstractAlfrescoSessionImpl.java
#Comment:
    /**
     * @return Returns the username with which we have created the session.
     */

#Code:
    public String getPersonIdentifier()
    {
        return userIdentifier;
    }

#No. 312
#File: E:\bishe\1\AbstractAlfrescoSessionImpl.java
#Comment:
    /**
     * @return Returns the authenticationProvider associated to the session.
     */

#Code:
    public AuthenticationProvider getAuthenticationProvider()
    {
        return authenticator;
    }

#No. 313
#File: E:\bishe\1\AbstractAlfrescoSessionImpl.java
#Comment:
    /**
     * Direct access to the underlying cmis session. Use with caution.
     * 
     * @return the cmisSession
     */

#Code:
    public Session getCmisSession()
    {
        return cmisSession;
    }

#No. 314
#File: E:\bishe\1\AbstractAlfrescoSessionImpl.java
#Comment:
    /**
     * Extension Point to use a specific serviceRegistry.
     * 
     * @param className : ClassName of the serviceRegistry to implement
     * @return an instance of serviceRegistry.
     */

#Code:
    protected ServiceRegistry createServiceRegistry(String className)
    {
        ServiceRegistry s = null;
        try
        {
            Class<?> c = Class.forName(className);
            Constructor<?> t = c.getDeclaredConstructor(AlfrescoSession.class);
            s = (ServiceRegistry) t.newInstance(this);
        }
        catch (Exception e)
        {
            throw new AlfrescoSessionException(ErrorCodeRegistry.SESSION_SERVICEREGISTRY, e);
        }
        return s;
    }

#No. 315
#File: E:\bishe\1\AbstractAliasMappingBuilder.java
#Comment:
    /**
     * Aliases with filters provide an easy way to create different “views” of the same index.
     * The filter can be defined using Query DSL and is applied to all Search, Count,
     * Delete By Query and More Like This operations with this alias.
     */

#Code:
    public K setFilter(Map<String, Object> source) {
        this.filter = source;
        return (K) this;
    }

#No. 316
#File: E:\bishe\1\AbstractAliasMappingBuilder.java
#Comment:
    /**
     * This method will add the given routing as both search & index routing.
     */

#Code:
    public K addRouting(String routing) {
        this.indexRouting.add(routing);
        this.searchRouting.add(routing);
        return (K) this;
    }

#No. 317
#File: E:\bishe\1\AbstractAliasMappingBuilder.java
#Comment:
    /**
     * This method will add the given routings as both search & index routing.
     */

#Code:
    public K addRouting(List<String> routings) {
        this.indexRouting.addAll(routings);
        this.searchRouting.addAll(routings);
        return (K) this;
    }

#No. 318
#File: E:\bishe\1\AbstractAndroidMojoTestCase.java
#Comment:
    /**
     * Get the project directory used for this mojo.
     * 
     * @param mojo the mojo to query.
     * @return the project directory.
     * @throws IllegalAccessException if unable to get the project directory.
     */

#Code:
    public File getProjectDir(AbstractMojo mojo) throws IllegalAccessException {
        MavenProject project = (MavenProject) getVariableValueFromObject(mojo, "project");
        return project.getFile().getParentFile();
    }

#No. 319
#File: E:\bishe\1\AbstractAndroidSerialCommunicator.java
#Comment:
	/**
	 * Finds "serialEvent(Serial)" method from the parent.
	 * 
	 * @param parent
	 * @return
	 */

#Code:
	static Method resolveSerialEventMethod(PApplet parent) {
		for (Method method : parent.getClass().getMethods()) {
			if ("serialEvent".equals(method.getName())) {
				final Class<?>[] paramTypes = method.getParameterTypes();
				if (paramTypes != null
						&& paramTypes.length == 1
						&& (SerialCommunicator.class
								.isAssignableFrom(paramTypes[0]) || Serial.class
								.isAssignableFrom(paramTypes[0]))) {
					return method;
				}
			}
		}
		LOGGER.info("serialEvent(Serial) is missing in the parent.");
		return null;
	}

#No. 320
#File: E:\bishe\1\AbstractAndroidSerialCommunicator.java
#Comment:
	/**
	 * @return the serialEventMethod
	 */

#Code:
	private Method getSerialEventMethod() {
		return serialEventMethod;
	}

#No. 321
#File: E:\bishe\1\AbstractAndroidSerialCommunicator.java
#Comment:
	/**
	 * Invoked when a serial event occurs from the subclass.
	 */

#Code:
	protected void serialEvent() {
		if (getSerialEventMethod() == null) {
			return;
		}
		try {
			getSerialEventMethod().invoke(parent, this);
		} catch (IllegalAccessException unexpected) {
			throw new IllegalStateException(unexpected);
		} catch (InvocationTargetException unexpected) {
			throw new IllegalStateException(unexpected);
		}
	}

#No. 322
#File: E:\bishe\1\AbstractAndroidSerialCommunicator.java
#Comment:
	/**
	 * @return the parent
	 */

#Code:
	protected PApplet getParent() {
		return parent;
	}

#No. 323
#File: E:\bishe\1\AbstractAndroidSerialCommunicator.java
#Comment:
	/**
	 * @return the applicatoinContext
	 */

#Code:
	protected Context getApplicatoinContext() {
		return applicatoinContext;
	}

#No. 324
#File: E:\bishe\1\AbstractAndroidSerialCommunicator.java
#Comment:
	/**
	 * @return the bufferDelimieter
	 */

#Code:
	protected int getBufferDelimieter() {
		return bufferDelimieter;
	}

#No. 325
#File: E:\bishe\1\AbstractAndroidSerialCommunicator.java
#Comment:
	/**
	 * @return the portIdentifier
	 */

#Code:
	protected String getPortIdentifier() {
		return portIdentifier;
	}

#No. 326
#File: E:\bishe\1\AbstractAndroidSerialCommunicator.java
#Comment:
	/**
	 * @return the baudrate
	 */

#Code:
	protected int getBaudrate() {
		return baudrate;
	}

#No. 327
#File: E:\bishe\1\AbstractAndroidSerialCommunicator.java
#Comment:
	/**
	 * @return the parity
	 */

#Code:
	protected char getParity() {
		return parity;
	}

#No. 328
#File: E:\bishe\1\AbstractAndroidSerialCommunicator.java
#Comment:
	/**
	 * @return the dataBits
	 */

#Code:
	protected int getDataBits() {
		return dataBits;
	}

#No. 329
#File: E:\bishe\1\AbstractAndroidSerialCommunicator.java
#Comment:
	/**
	 * @return the stopBits
	 */

#Code:
	protected float getStopBits() {
		return stopBits;
	}

#No. 330
#File: E:\bishe\1\AbstractAndroidSerialCommunicator.java
#Comment:
	/**
	 * {@inheritDoc}
	 * 
	 * @see SerialCommunicator#buffer(int)
	 */

#Code:
	@Override
	public void buffer(int count) {
		if (count < 1) {
			this.buffer = null;
		} else {
			this.buffer = new byte[count];
		}
		this.currentBufferCount = 0;
		this.bufferDelimieter = Integer.MIN_VALUE;
	}

#No. 331
#File: E:\bishe\1\AbstractAndroidSerialCommunicator.java
#Comment:
	/**
	 * {@inheritDoc}
	 * 
	 * @see SerialCommunicator#bufferUntil(int)
	 */

#Code:
	@Override
	public void bufferUntil(int what) {
		this.bufferDelimieter = what;
		this.buffer = null;
		this.currentBufferCount = 0;
	}

#No. 332
#File: E:\bishe\1\AbstractAndroidSerialCommunicator.java
#Comment:
	/**
	 * Sends the data into the buffer.
	 * 
	 * @param data
	 */

#Code:
	protected void sendBuffer(byte[] data) {
		if (this.buffer != null) {
			int dataLength = data.length;
			int offset = this.currentBufferCount;
			while (true) {
				final int bufferLength = this.buffer.length - offset;
				if (dataLength < bufferLength) {
					System.arraycopy(data, 0, this.buffer, offset, dataLength);
					offset += dataLength;
					break;

				} else {
					System.arraycopy(data, 0, this.buffer, offset, bufferLength);
					doSendBuffer(this.buffer.clone());
					offset = 0;
					if (dataLength == bufferLength) {
						break;
					}
				}
			}
			this.currentBufferCount = offset;

		} else if (this.bufferDelimieter > 0) {
			final int delim = this.bufferDelimieter;
			try {
				for (int i = 0; i < data.length; i++) {
					this.readBufferOutputStream.write(data[i]);
					if (data[i] == delim) {
						serialEvent();
					}
				}
			} catch (IOException e) {
				throw new IllegalStateException(e);
			}

		} else {
			doSendBuffer(data);
		}
	}

#No. 333
#File: E:\bishe\1\AbstractAndroidSerialCommunicator.java
#Comment:
	/**
	 * 
	 * @param data
	 */

#Code:
	protected void doSendBuffer(byte[] data) {
		if (readBufferOutputStream == null) {
			LOGGER.info("[doSendBuffer] Skipped data =>{}",
					HexDump.dumpHexString(data));
			return;
		}
		try {
			this.readBufferOutputStream.write(data);
			serialEvent();
		} catch (IOException e) {
			throw new IllegalStateException(e);
		}
	}

#No. 334
#File: E:\bishe\1\AbstractAndroidSerialCommunicator.java
#Comment:
	/**
	 * {@inheritDoc}
	 * 
	 * @see SerialCommunicator#start(java.lang.String)
	 */

#Code:
	@Override
	public void start(String portIdentifier) {
		start(portIdentifier, 9600);
	}

#No. 335
#File: E:\bishe\1\AbstractAndroidSerialCommunicator.java
#Comment:
	/**
	 * {@inheritDoc}
	 * 
	 * @see SerialCommunicator#start(java.lang.String,
	 *      int)
	 */

#Code:
	@Override
	public void start(String portIdentifier, int baudrate) {
		start(portIdentifier, baudrate, 'N', 8, 1.0f);
	}

#No. 336
#File: E:\bishe\1\AbstractAndroidSerialCommunicator.java
#Comment:
	/**
	 * {@inheritDoc}
	 * 
	 * @see SerialCommunicator#start(java.lang.String,
	 *      int, char, int, float)
	 */

#Code:
	@Override
	public final void start(String portIdentifier, int baudrate, char parity,
			int dataBits, float stopBits) {
		final PipedInputStream pipedInputStream = new PipedInputStream();
		this.readBufferInputStream = pipedInputStream;
		try {
			this.readBufferOutputStream = new PipedOutputStream(
					pipedInputStream);
		} catch (IOException exception) {
			throw new IllegalStateException(exception);
		}
		this.portIdentifier = portIdentifier;
		this.baudrate = baudrate;
		this.parity = parity;
		this.dataBits = dataBits;
		this.stopBits = stopBits;
		doStart(portIdentifier, baudrate, parity, dataBits, stopBits);
	}

#No. 337
#File: E:\bishe\1\AbstractAndroidSerialCommunicator.java
#Comment:
	/**
	 * {@inheritDoc}
	 * 
	 * @see SerialCommunicator#stop()
	 */

#Code:
	@Override
	public final void stop() {
		try {
			doStop();
		} finally {
			if (readBufferOutputStream != null) {
				try {
					readBufferOutputStream.close();
				} catch (IOException ignored) {
				}
				readBufferOutputStream = null;
			}
			if (readBufferInputStream != null) {
				try {
					readBufferInputStream.close();
				} catch (IOException ignored) {
				}
				readBufferOutputStream = null;
			}
		}
	}

#No. 338
#File: E:\bishe\1\AbstractAndroidSerialCommunicator.java
#Comment:
	/**
	 * {@inheritDoc}
	 * 
	 * @see SerialCommunicator#available()
	 */

#Code:
	@Override
	public int available() {
		try {
			return this.readBufferInputStream.available();
		} catch (IOException e) {
			throw new IllegalStateException(e);
		}
	}

#No. 339
#File: E:\bishe\1\AbstractAndroidSerialCommunicator.java
#Comment:
	/**
	 * {@inheritDoc}
	 * 
	 * @see SerialCommunicator#clear()
	 */

#Code:
	@Override
	public synchronized void clear() {
		try {
			this.readBufferOutputStream.flush();
		} catch (IOException e) {
			throw new IllegalStateException(e);
		}
		readBytes();
		if (this.buffer != null) {
			this.currentBufferCount = 0;
		}
	}

#No. 340
#File: E:\bishe\1\AbstractAndroidSerialCommunicator.java
#Comment:
	/**
	 * {@inheritDoc}
	 * 
	 * @see SerialCommunicator#read()
	 */

#Code:
	@Override
	public synchronized int read() {
		try {
			final int b = this.readBufferInputStream.read();
			this.last = b;
			return b;
		} catch (IOException e) {
			throw new IllegalStateException(e);
		}
	}

#No. 341
#File: E:\bishe\1\AbstractAndroidSerialCommunicator.java
#Comment:
	/**
	 * {@inheritDoc}
	 * 
	 * @see SerialCommunicator#readBytes()
	 */

#Code:
	@Override
	public synchronized byte[] readBytes() {
		final ByteArrayOutputStream out = new ByteArrayOutputStream();
		int readByte = -1;
		final byte[] buff = new byte[1024];
		try {
			if (this.readBufferInputStream.available() > 0) {
				while ((readByte = this.readBufferInputStream.read(buff)) >= 0) {
					out.write(buff, 0, readByte);
					if (this.readBufferInputStream.available() < 1) {
						break;
					}
				}
				return out.toByteArray();
			} else {
				return null;
			}
		} catch (IOException e) {
			throw new IllegalStateException(e);
		}
	}

#No. 342
#File: E:\bishe\1\AbstractAndroidSerialCommunicator.java
#Comment:
	/**
	 * {@inheritDoc}
	 * 
	 * @see SerialCommunicator#readBytes(byte[])
	 */

#Code:
	@Override
	public synchronized int readBytes(byte[] byteBuffer) {
		try {
			return this.readBufferInputStream.read(byteBuffer);
		} catch (IOException e) {
			throw new IllegalStateException(e);
		}
	}

#No. 343
#File: E:\bishe\1\AbstractAndroidSerialCommunicator.java
#Comment:
	/**
	 * {@inheritDoc}
	 * 
	 * @see SerialCommunicator#readBytesUntil(int)
	 */

#Code:
	@Override
	public synchronized byte[] readBytesUntil(int interesting) {
		final ByteArrayOutputStream out = new ByteArrayOutputStream();
		int readByte = -1;
		if (available() > 0) {
			while ((readByte = read()) >= 0) {
				out.write(readByte);
				if (readByte == interesting) {
					return out.toByteArray();
				} else if (available() < 1) {
					break;
				}
			}
		}
		return null;
	}

#No. 344
#File: E:\bishe\1\AbstractAndroidSerialCommunicator.java
#Comment:
	/**
	 * {@inheritDoc}
	 * 
	 * @see SerialCommunicator#readBytesUntil(int,
	 *      byte[])
	 */

#Code:
	@Override
	public synchronized int readBytesUntil(int interesting, byte[] byteBuffer) {
		int readByte = -1;
		for (int i = 0; i < byteBuffer.length; i++) {
			readByte = read();
			if (readByte < 0) {
				break;
			}
			byteBuffer[i] = (byte) readByte;
			if (readByte == interesting) {
				return i + 1;
			}
		}
		LOGGER.error("Insufficient byteBuffer size ({}).", byteBuffer.length);
		return -1;
	}

#No. 345
#File: E:\bishe\1\AbstractAndroidSerialCommunicator.java
#Comment:
	/**
	 * {@inheritDoc}
	 * 
	 * @see SerialCommunicator#readString()
	 */

#Code:
	@Override
	public String readString() {
		return new String(readBytes());
	}

#No. 346
#File: E:\bishe\1\AbstractAndroidSerialCommunicator.java
#Comment:
	/**
	 * {@inheritDoc}
	 * 
	 * @see SerialCommunicator#readStringUntil(int)
	 */

#Code:
	@Override
	public String readStringUntil(int interesting) {
		final byte[] readBytes = readBytesUntil(interesting);
		if (readBytes != null) {
			return new String(readBytes);
		}
		return null;
	}

#No. 347
#File: E:\bishe\1\AbstractAndroidTestCase.java
#Comment:
    /**
     * Create the {@link DbApp} by calling {@link DbApp#setupDatabase(Context)}.
     * If init failed (often the database not ready, then we wait for 1 sec and recall the same function.
     * Will try 5 times.
     */

#Code:
    private void createApplication() {
        if (numberOfTry >= 5) {
            throw new RuntimeException("Could not create application database in five times");
        }

        try {
            DbApp.setupDatabase(getContext());
        } catch (Exception e) {
            Log.e(TAG, "Error creating the app, retry in 1sec");
            numberOfTry++;
            try {
                Thread.sleep(500);
            } catch (InterruptedException e1) {
                Log.e(TAG, "Error waiting to create the app");
            }
            createApplication();
        }
    }

#No. 348
#File: E:\bishe\1\AbstractAndroidTestCase.java
#Comment:
    /**
     * Returns the app file path
     */

#Code:
    public String getFileDir() {
        PackageManager m = getContext().getPackageManager();
        String s = getContext().getPackageName();
        try {
            PackageInfo p = m.getPackageInfo(s, 0);
            s = p.applicationInfo.dataDir;
        } catch (PackageManager.NameNotFoundException e) {
            Log.w("yourtag", "Error Package name not found ", e);
        }

        return s;
    }

#No. 349
#File: E:\bishe\1\AbstractAndroidTestCase.java
#Comment:
    /**
     * Returns the length of a file (its size)
     */

#Code:
    public static long getFileSize(File f) {
        return f.length();
    }

#No. 350
#File: E:\bishe\1\AbstractAnnotation.java
#Comment:
    /**
     * Sets the file name to the specified value.
     *
     * @param fileName the value to set
     */

#Code:
    @Override
    public final void setFileName(final String fileName) {
        this.fileName = TreeString.of(StringUtils.strip(fileName).replace('\\', '/'));
    }

#No. 351
#File: E:\bishe\1\AbstractAnnotation.java
#Comment:
    /**
     * Sets the module name to the specified value.
     *
     * @param moduleName the value to set
     */

#Code:
    @Override
    public final void setModuleName(final String moduleName) {
        this.moduleName = TreeString.of(moduleName);
    }

#No. 352
#File: E:\bishe\1\AbstractAnnotation.java
#Comment:
    /**
     * Sets the package name to the specified value.
     *
     * @param packageName the value to set
     */

#Code:
    public final void setPackageName(final String packageName) {
        this.packageName = TreeString.of(packageName);
    }

#No. 353
#File: E:\bishe\1\AbstractAnnotation.java
#Comment:
    /**
     * Returns the line number that should be shown on top of the source code view.
     *
     * @return the line number
     */

#Code:
    public final int getLinkLineNumber() {
        return Math.max(1, primaryLineNumber - 10);
    }

#No. 354
#File: E:\bishe\1\AbstractAnnotation.java
#Comment:
    /**
     * Adds another line range to this annotation.
     *
     * @param lineRange
     *            the line range to add
     */

#Code:
    public void addLineRange(final LineRange lineRange) {
        if (!lineRanges.contains(lineRange)) {
            lineRanges.add(lineRange);
        }
    }

#No. 355
#File: E:\bishe\1\AbstractAnnotation.java
#Comment:
    /**
     * Gets the associated file name of this bug (without path).
     *
     * @return the short file name
     */

#Code:
    @Override
    public String getShortFileName() {
        if (isInConsoleLog()) {
            return Messages.ConsoleLog_Name();
        }
        return FilenameUtils.getName(TreeString.toString(fileName));
    }

#No. 356
#File: E:\bishe\1\AbstractAnnotation.java
#Comment:
    /**
     * Checks if the file exists and the user is authorized to see the contents of the file.
     *
     * @return <code>true</code>, if successful
     */

#Code:
    @Override
    public final boolean canDisplayFile(final Run<?, ?> owner) {
        if (owner.hasPermission(Item.WORKSPACE)) {
            return isInConsoleLog() || new File(getFileName()).exists() || new File(getTempName(owner)).exists();
        }
        return false;
    }

#No. 357
#File: E:\bishe\1\AbstractAnnotation.java
#Comment:
    /**
     * @deprecated use {@link #getTempName(Run)} instead
     */

#Code:
    @Deprecated
    public String getTempName(final AbstractBuild<?, ?> owner) {
        return getTempName((Run<?, ?>) owner);
    }

#No. 358
#File: E:\bishe\1\AbstractAnnotationBasedDeclarativeScopeProvider.java
#Comment:
	/**
	 * Returns a {@link Predicate} which checks whether a {@link Method} is a
	 * correct target for scoping based on annotations it might have.
	 */

#Code:
	@Override
	protected Predicate<Method> getPredicate(EObject context, EClass type) {
		final int classId = type.getClassifierID();
		final Predicate<Method> nameBasedPredicate = super.getPredicate(context, type);
		return new Predicate<Method>() {
			@Override
			public boolean apply(Method method) {
				if( method.getParameterTypes().length != 2 ) {
					return false;
				}
				ScopeForType annotation = method.getAnnotation(ScopeForType.class);
				if( annotation == null ) {
					if( nameBasedPredicate.apply(method) ) {
						logger.warn(strategyWarning(method));
					}
					return false;
				}
				return( classId == annotation.classId() );
			}
		};
	}

#No. 359
#File: E:\bishe\1\AbstractAnnotationBasedDeclarativeScopeProvider.java
#Comment:
	/**
	 * Annotation for methods which provide scoping for specific
	 * {@link EClass}es. The {@link #classId()} is the classifier ID of the
	 * {@link EClass} containing the {@link EReference} to scope for.
	 */

#Code:
	@Target(ElementType.METHOD)
	@Retention(RetentionPolicy.RUNTIME)
	protected @interface ScopeForType {

		/**
		 * The classifier ID of the {@link EClass} to scope for.
		 * @return
		 */
		int classId();

	}

	private static String strategyWarning(Method method) {
		return String.format( "method %s complies to name-based declarative strategy while using annotation-based declarative strategy", method.getName() ); //$NON-NLS-1$
	}

#No. 360
#File: E:\bishe\1\AbstractAnnotationCatalogAccessorProvider.java
#Comment:
/**
 * Abstract {@link CatalogAccessorProvider} that guests that a certain bean offers
 * a certain service which has annotated methods. So, the {@link BrokerServiceAccessor}
 * will be based on annotations.
 *
 * @author Sebastien Gerard
 */

#Code:
public abstract class AbstractAnnotationCatalogAccessorProvider implements CatalogAccessorProvider,
      ApplicationContextAware {

    protected ApplicationContext context;

    protected AbstractAnnotationCatalogAccessorProvider() {
    }

    /**
     * Returns the accessor used to access the specified service of the
     * specified broker.
     *
     * @param serviceBrokerName the name of the broker offering the specified service
     * @param description the service description
     */
    protected BrokerServiceAccessor getMethodAccessor(String serviceBrokerName, CatalogService description) {
        return new AnnotationBrokerServiceAccessor(description, serviceBrokerName, getBeanClass(serviceBrokerName),
              context.getBean(serviceBrokerName));
    }

    /**
     * Returns the class of the specified bean name.
     */
    protected Class<?> getBeanClass(String beanName) {
        Class<?> clazz = context.getType(beanName);
        while (Proxy.isProxyClass(clazz) || Enhancer.isEnhanced(clazz)) {
            clazz = clazz.getSuperclass();
        }
        return clazz;
    }

    @Override
    public void setApplicationContext(ApplicationContext applicationContext) {
        this.context = applicationContext;
    }
}

#No. 361
#File: E:\bishe\1\AbstractAnnotationValueVisitor6.java
#Comment:
/**
 * A skeletal visitor for annotation values with default behavior
 * appropriate for the {@link SourceVersion#RELEASE_6 RELEASE_6}
 * source version.
 *
 * <p> <b>WARNING:</b> The {@code AnnotationValueVisitor} interface
 * implemented by this class may have methods added to it in the
 * future to accommodate new, currently unknown, language structures
 * added to future versions of the Java&trade; programming language.
 * Therefore, methods whose names begin with {@code "visit"} may be
 * added to this class in the future; to avoid incompatibilities,
 * classes which extend this class should not declare any instance
 * methods with names beginning with {@code "visit"}.
 * 
 * <p>When such a new visit method is added, the default
 * implementation in this class will be to call the {@link
 * #visitUnknown visitUnknown} method.  A new abstract annotation
 * value visitor class will also be introduced to correspond to the
 * new language level; this visitor will have different default
 * behavior for the visit method in question.  When the new visitor is
 * introduced, all or portions of this visitor may be deprecated.
 *
 * @param <R> the return type of this visitor's methods
 * @param <P> the type of the additional parameter to this visitor's methods.
 *
 * @author Joseph D. Darcy
 * @author Scott Seligman
 * @author Peter von der Ah&eacute;
 * @since 1.6
 */

#Code:
@SupportedSourceVersion(RELEASE_6)
public abstract class AbstractAnnotationValueVisitor6<R, P> 
    implements AnnotationValueVisitor<R, P> {

    /**
     * Constructor for concrete subclasses to call.
     */
    protected AbstractAnnotationValueVisitor6() {}

    /**
     * Visits an annotation value as if by passing itself to that
     * value's {@link AnnotationValue#accept accept}.  The invocation
     * {@code v.visit(av)} is equivalent to {@code av.accept(v, p)}.
     * @param av {@inheritDoc}
     * @param p  {@inheritDoc}
     */
    public final R visit(AnnotationValue av, P p) {
	return av.accept(this, p);
    }

    /**
     * Visits an annotation value as if by passing itself to that
     * value's {@link AnnotationValue#accept accept} method passing
     * {@code null} for the additional parameter.  The invocation
     * {@code v.visit(av)} is equivalent to {@code av.accept(v,
     * null)}.

#No. 362
#File: E:\bishe\1\AbstractAnnotationValueVisitor6.java
#Comment:
    /**
     * {@inheritDoc}
     *
     * <p>The default implementation of this method in {@code
     * AbstractAnnotationValueVisitor6} will always throw {@code
     * UnknownAnnotationValueException}.  This behavior is not
     * required of a subclass.
     *
     * @param av {@inheritDoc}
     * @param p  {@inheritDoc}
     */

#Code:
    public R visitUnknown(AnnotationValue av, P p) {
	throw new UnknownAnnotationValueException(av, p);
    }

#No. 363
#File: E:\bishe\1\AbstractApiInterceptor.java
#Comment:
    /**
     * 全部完成
     *
     * @param mapping
     * @param request
     * @param response
     */

#Code:
    @Override
    public void afterCompletion(ApiMethodMapping mapping, HttpContextRequest request, HttpContextResponse response, Throwable throwable){
    }

#No. 364
#File: E:\bishe\1\AbstractAppDeployerIntegrationTests.java
#Comment:
	/**
	 * Subclasses should call this method to interact with the AppDeployer under test.
	 * Returns a wrapper around the deployer returned by {@link #provideAppDeployer()}, that keeps
	 * track of which apps have been deployed and undeployed.
	 */

#Code:
	protected AppDeployer appDeployer() {
		return deployerWrapper;
	}

#No. 365
#File: E:\bishe\1\AbstractAppDeployerIntegrationTests.java
#Comment:
	/**
	 * Tests a simple deploy-undeploy cycle.
	 */

#Code:
	@Test
	public void testSimpleDeployment() {
		AppDefinition definition = new AppDefinition(randomName(), null);
		Resource resource = testApplication();
		AppDeploymentRequest request = new AppDeploymentRequest(definition, resource);

		log.info("Deploying {}...", request.getDefinition().getName());

		String deploymentId = appDeployer().deploy(request);
		Timeout timeout = deploymentTimeout();
		assertThat(deploymentId, eventually(hasStatusThat(
				Matchers.<AppStatus>hasProperty("state", is(deployed))), timeout.maxAttempts, timeout.pause));

		log.info("Deploying {} again...", request.getDefinition().getName());

		try {
			appDeployer().deploy(request);
			fail("Should have thrown an IllegalStateException");
		}
		catch (IllegalStateException ok) {
		}

		log.info("Undeploying {}...", deploymentId);

		timeout = undeploymentTimeout();
		appDeployer().undeploy(deploymentId);
		assertThat(deploymentId, eventually(hasStatusThat(
				Matchers.<AppStatus>hasProperty("state", is(unknown))), timeout.maxAttempts, timeout.pause));
		try {
			appDeployer().undeploy(deploymentId);
			fail("Should have thrown an IllegalStateException");
		}
		catch (IllegalStateException ok) {
		}
	}

#No. 366
#File: E:\bishe\1\AbstractAppDeployerIntegrationTests.java
#Comment:
	/**
	 * Tests that an app which takes a long time to deploy is correctly reported as deploying.
	 * Test that such an app can be undeployed.
	 */

#Code:
	@Test
	public void testDeployingStateCalculationAndCancel() {
		Map<String, String> properties = new HashMap<>();
		properties.put("initDelay", "" + 1000 * 60 * 60); // 1hr
		AppDefinition definition = new AppDefinition(randomName(), properties);
		Resource resource = testApplication();
		AppDeploymentRequest request = new AppDeploymentRequest(definition, resource, properties);

		log.info("Deploying {}...", request.getDefinition().getName());

		String deploymentId = appDeployer().deploy(request);
		Timeout timeout = deploymentTimeout();
		assertThat(deploymentId, eventually(hasStatusThat(
				Matchers.<AppStatus>hasProperty("state", is(deploying))), timeout.maxAttempts, timeout.pause));

		log.info("Undeploying {}...", deploymentId);

		timeout = undeploymentTimeout();
		appDeployer().undeploy(deploymentId);
		assertThat(deploymentId, eventually(hasStatusThat(
				Matchers.<AppStatus>hasProperty("state", is(unknown))), timeout.maxAttempts, timeout.pause));

	}

#No. 367
#File: E:\bishe\1\AbstractAppDeployerIntegrationTests.java
#Comment:
	/**
	 * Tests support for instance count support and individual instance status report.
	 */

#Code:
	@Test
	public void testMultipleInstancesDeploymentAndPartialState() {
		Map<String, String> appProperties = new HashMap<>();
		appProperties.put("matchInstances", "1"); // Only instance n°1 will kill itself
		appProperties.put("killDelay", "0");
		AppDefinition definition = new AppDefinition(randomName(), appProperties);
		Resource resource = testApplication();

		Map<String, String> deploymentProperties = new HashMap<>();
		deploymentProperties.put(AppDeployer.COUNT_PROPERTY_KEY, "3");
		deploymentProperties.put(AppDeployer.INDEXED_PROPERTY_KEY, "true");
		AppDeploymentRequest request = new AppDeploymentRequest(definition, resource, deploymentProperties);

		log.info("Deploying {}...", request.getDefinition().getName());

		String deploymentId = appDeployer().deploy(request);
		Timeout timeout = deploymentTimeout();
		assertThat(deploymentId, eventually(hasStatusThat(
				Matchers.<AppStatus>hasProperty("state", is(partial))), timeout.maxAttempts, timeout.pause));

		// Assert individual instance state
		// Note we can't rely on instances order, neither on their id indicating their ordinal number
		List<DeploymentState> individualStates = new ArrayList<>();
		for (AppInstanceStatus status : appDeployer().status(deploymentId).getInstances().values()) {
			individualStates.add(status.getState());
		}
		assertThat(individualStates, containsInAnyOrder(
				is(deployed),
				is(deployed),
				is(failed)
		));

		log.info("Undeploying {}...", deploymentId);

		timeout = undeploymentTimeout();
		appDeployer().undeploy(deploymentId);
		assertThat(deploymentId, eventually(hasStatusThat(
				Matchers.<AppStatus>hasProperty("state", is(unknown))), timeout.maxAttempts, timeout.pause));
	}

#No. 368
#File: E:\bishe\1\AbstractAppDeployerIntegrationTests.java
#Comment:
	/**
	 * Tests support for DeployerEnvironmentInfo is implemented.
	 */

#Code:
	@Test
	public void testEnvironmentInfo() {
		RuntimeEnvironmentInfo info = appDeployer().environmentInfo();
		assertNotNull(info.getImplementationVersion());
		assertNotNull(info.getPlatformType());
		assertNotNull(info.getPlatformClientVersion());
		assertNotNull(info.getPlatformHostVersion());
	}

#No. 369
#File: E:\bishe\1\AbstractAppDeployerIntegrationTests.java
#Comment:
	/**
	 * A Hamcrest Matcher that queries the deployment status for some app id.
	 *
	 * @author Eric Bottard
	 */

#Code:
	protected Matcher<String> hasStatusThat(final Matcher<AppStatus> statusMatcher) {
		return new BaseMatcher<String>() {

			private AppStatus status;

			@Override
			public boolean matches(Object item) {
				status = appDeployer().status((String) item);
				return statusMatcher.matches(status);
			}

			@Override
			public void describeMismatch(Object item, Description mismatchDescription) {
				mismatchDescription.appendText("status of ").appendValue(item).appendText(" ");
				statusMatcher.describeMismatch(status, mismatchDescription);
			}


			@Override
			public void describeTo(Description description) {
				statusMatcher.describeTo(description);
			}
		};
	}

#No. 370
#File: E:\bishe\1\AbstractAppDeployment.java
#Comment:
    /**
     * The target directory the application to be deployed is located.
     */

#Code:
    @Parameter(defaultValue = "${project.build.directory}/", property = PropertyNames.DEPLOYMENT_TARGET_DIR)
    private File targetDir;

    /**
     * The file name of the application to be deployed.
     * <p>
     * The {@code filename} property does have a default of <code>${project.build.finalName}.${project.packaging}</code>.
     * The default value is not injected as it normally would be due to packaging types like {@code ejb} that result in
     * a file with a {@code .jar} extension rather than an {@code .ejb} extension.
     * </p>
     */
    @Parameter(property = PropertyNames.DEPLOYMENT_FILENAME)
    private String filename;

    /**
     * By default certain package types are ignored when processing, e.g. {@code maven-project} and {@code pom}. Set
     * this value to {@code false} if this check should be bypassed.
     */
    @Parameter(alias = "check-packaging", property = PropertyNames.CHECK_PACKAGING, defaultValue = "true")
    private boolean checkPackaging;

    @Override
    protected boolean skipExecution() {
        boolean skip = super.skipExecution();
        if (!skip) {
            final PackageType packageType = PackageType.resolve(project);
            if (checkPackaging && packageType.isIgnored()) {
                getLog().debug(String.format("Ignoring packaging type %s.", packageType.getPackaging()));
                skip = true;
            }
        }
        return skip;
    }

#No. 371
#File: E:\bishe\1\AbstractAppender.java
#Comment:
    /**
     * Abstract to force subclasses to re-implement.
     */

#Code:
    @Override
    public abstract boolean equals( Object obj );

    /**
     * Abstract to force subclasses to re-implement.
     */
    @Override
    public abstract int hashCode();

    /**
     * @return original chunk
     */
    @Override
    public final String toString()
    {
        return chunk;
    }

#No. 372
#File: E:\bishe\1\AbstractAppletServiceServlet.java
#Comment:
		/*
		 * First retrieve the HTTP headers. The unmarshaller may digest the
		 * body, which makes it impossible to retrieve the headers afterwards.
		 */

#Code:
		Map<String, String> httpHeaders = new HashMap<String, String>();
		Enumeration<String> headerNamesEnum = request.getHeaderNames();
		while (headerNamesEnum.hasMoreElements()) {
			String headerName = headerNamesEnum.nextElement();
			httpHeaders.put(headerName, request.getHeader(headerName));
		}

#No. 373
#File: E:\bishe\1\AbstractAppletServiceServlet.java
#Comment:
		/*
		 * Incoming message unmarshaller.
		 */

#Code:
		HttpServletRequestHttpReceiver httpReceiver = new HttpServletRequestHttpReceiver(request,
				this.skipSecureConnectionCheck);
		Object transferObject;
		try {
			transferObject = this.unmarshaller.receive(httpReceiver);
		} catch (Exception e) {
			LOG.debug("unmarshaller error: " + e.getMessage(), e);
			throw new RuntimeException("unmarshaller error: " + e.getMessage(), e);
		}

#No. 374
#File: E:\bishe\1\AbstractAppletServiceServlet.java
#Comment:
		/*
		 * Protocol state checker for incoming message.
		 */

#Code:
		HttpServletProtocolContext protocolContext = new HttpServletProtocolContext(request);
		ProtocolStateMachine protocolStateMachine = new ProtocolStateMachine(protocolContext);
		CleanSessionProtocolStateListener cleanSessionProtocolStateListener = new CleanSessionProtocolStateListener(
				request);
		protocolStateMachine.addProtocolStateListener(cleanSessionProtocolStateListener);
		RequestContext requestContext = new RequestContext(request);
		protocolStateMachine.addProtocolStateListener(requestContext);
		protocolStateMachine.checkRequestMessage(transferObject);

		/*
		 * Message dispatcher
		 */
		Class<?> messageClass = transferObject.getClass();
		MessageHandler messageHandler = getMessageHandler(messageClass);
		if (null == messageHandler) {
			throw new ServletException("unsupported message");
		}

#No. 375
#File: E:\bishe\1\AbstractAppletServiceServlet.java
#Comment:
		/*
		 * Check outgoing messages for protocol constraints.
		 */

#Code:
		ResponsesAllowed responsesAllowedAnnotation = messageClass.getAnnotation(ResponsesAllowed.class);
		if (null != responsesAllowedAnnotation) {
			/*
			 * Make sure the message handlers respect the protocol.
			 */
			if (null == responseMessage) {
				throw new ServletException("null response message while @ResponsesAllowed constraint was set");
			}
			Class<?>[] responsesAllowed = responsesAllowedAnnotation.value();
			if (false == isOfClass(responseMessage, responsesAllowed)) {
				throw new ServletException("response message type incorrect");
			}
		}

#No. 376
#File: E:\bishe\1\AbstractAppletServiceServlet.java
#Comment:
		/*
		 * Protocol state checker for outgoing message.
		 */

#Code:
		protocolStateMachine.checkResponseMessage(responseMessage);

		/*
		 * Marshall outgoing message.
		 */
		if (null != responseMessage) {
			HttpServletResponseHttpTransmitter httpTransmitter = new HttpServletResponseHttpTransmitter(response);
			Transport.transfer(responseMessage, httpTransmitter);
		}

#No. 377
#File: E:\bishe\1\AbstractApplicationContextLifecycleHandler.java
#Comment:
    /**
     * <p>The before class event handler.</p>
     *
     * <p>Delegates to the registered {@link ApplicationContextProducer} instances in order to create the application
     * context.</p>
     *
     * @param event the before class event
     */

#Code:
    public void beforeClass(@Observes BeforeClass event) {

        createTestApplicationContext(event.getTestClass());
    }

    /**
     * <p>The before test event handler.</p>
     *
     * <p>Delegates to the registered {@link ApplicationContextProducer} instances in order to create the application
     * context.</p>
     *
     * @param event the before test event
     */
    public void beforeTest(@Observes Before event) {

        createTestApplicationContext(event.getTestClass());
    }

    /**
     * <p>The after test event handler.</p>
     *
     * <p>Delegates to the registered {@link ApplicationContextProducer} instances in order to create the application
     * context.</p>
     *
     * @param event the after test event
     */
    public void afterTest(@Observes After event) {

        ContextLifeCycleMode mode = getContextLifeCycleMode(event.getTestClass());
        if (mode == ContextLifeCycleMode.TEST) {

            destroyTestApplicationContext();
        }

#No. 378
#File: E:\bishe\1\AbstractApplicationContextLifecycleHandler.java
#Comment:
    /**
     * <p>The before test event handler.</p>
     *
     * <p>Delegates to the registered {@link ApplicationContextProducer} instances in order to create the application
     * context.</p>
     *
     * @param event the after suite event
     */

#Code:
    public void afterSuite(@Observes AfterSuite event) {

        destroyTestApplicationContext();
    }

    /**
     * <p>Instantiates the application context if needed base on the meta data provided on the test class.</p>
     *
     * <p>The actual instances creation is being delegated to the registered </p>
     *
     * @param testClass the instance of the test class
     */
    private void createTestApplicationContext(TestClass testClass) {

        if (getApplicationContext() != null &&
                getApplicationContext().getTestClass().getJavaClass().equals(testClass.getJavaClass())) {

            return;
        }

        // creates the application context instance
        T applicationContext = createApplicationContext(testClass);

        if (applicationContext != null) {

            // triggers the application context created event
            applicationContextEvent.fire(new ApplicationContextCreatedEvent(applicationContext));

            setApplicationContext(applicationContext);
        }
    }

#No. 379
#File: E:\bishe\1\AbstractApplicationContextLifecycleHandler.java
#Comment:
    /**
     * <p>Creates the application context. The application context creation is being delegates to the registered
     * instances of {@link ApplicationContextProducer}.</p>
     *
     * @param testClass the test class
     *
     * @return the application context
     */

#Code:
    private T createApplicationContext(TestClass testClass) {

        ServiceLoader serviceLoader = serviceLoaderInstance.get();

        // retrieves the list of all registered application context producers
        Collection<TProd> applicationContextProducers = serviceLoader.all(getProducerClass());

        for (TProd applicationContextProducer : applicationContextProducers) {

            if (applicationContextProducer.supports(testClass)) {

                return applicationContextProducer.createApplicationContext(testClass);
            }
        }

        // the given test is not supported
        return null;
    }

#No. 380
#File: E:\bishe\1\AbstractApplicationContextLifecycleHandler.java
#Comment:
    /**
     * <p>Destroys the application context if it exists.</p>
     */

#Code:
    private void destroyTestApplicationContext() {
        T applicationContext = getApplicationContext();

        if (applicationContext != null) {
            destroyApplicationContext(applicationContext);

            // triggers the application context destroyed event
            applicationContextEvent.fire(new ApplicationContextDestroyedEvent(applicationContext));
        }
    }

#No. 381
#File: E:\bishe\1\AbstractApplicationContextLifecycleHandler.java
#Comment:
    /**
     * <p>Destroys the application context.</p>
     *
     * <p>The implementation by default delegates to the registered {@link ApplicationContextDestroyer} to perform the
     * application context clean up.</p>
     *
     * @param applicationContext the application context to be destroyed
     */

#Code:
    private void destroyApplicationContext(TestScopeApplicationContext applicationContext) {

        // single service is expected
        getService(ApplicationContextDestroyer.class).destroyApplicationContext(applicationContext);
    }

#No. 382
#File: E:\bishe\1\AbstractApplicationContextLifecycleHandler.java
#Comment:
    /**
     * <p>Retrieves the context life cycle mode.</p>
     *
     * @param testClass the test class
     *
     * @return the {@link ContextLifeCycleMode} defined for the test
     */

#Code:
    private ContextLifeCycleMode getContextLifeCycleMode(TestClass testClass) {

        ContextLifeCycle contextLifeCycle = testClass.getAnnotation(ContextLifeCycle.class);

        if (contextLifeCycle != null) {

            return contextLifeCycle.value();
        }

        return DEFAULT_LIFE_CYCLE_MODE;
    }

#No. 383
#File: E:\bishe\1\AbstractApplicationContextLifecycleHandler.java
#Comment:
    /**
     * <p>Retrieves the service by it's type. <p/> The implementation uses {@link ServiceLoader} in order to retrieve
     * first instance of specified kind. Any other registered instance in given scope is being discarded.</p>
     *
     * @param clazz the class of the service
     * @param <T>   the service type
     *
     * @return the service instance
     */

#Code:
    private <T> T getService(Class<T> clazz) {

        Collection<T> collection = serviceLoaderInstance.get().all(clazz);
        return collection.iterator().next();
    }

#No. 384
#File: E:\bishe\1\AbstractApplicationController.java
#Comment:
    /**
     * Execute post start/stop/install/upgrade shell command, if any
     *
     * @param applicationInfo application information
     * @throws AtsManagerException
     */

#Code:
    protected void executePostActionShellCommand( AbstractApplicationInfo applicationInfo, String actionName,
                                                  String shellCommand ) throws AtsManagerException {

        if( !StringUtils.isNullOrEmpty( shellCommand ) ) {

            log.info( "Executing post '" + actionName + "' shell command: " + shellCommand );
            JschSshClient sshClient = new JschSshClient();
            try {
                sshClient.connect( applicationInfo.systemUser, applicationInfo.systemPassword,
                                   applicationInfo.host, applicationInfo.sshPort );
                int exitCode = sshClient.execute( shellCommand, true );
                if( exitCode != 0 ) {
                    throw new AtsManagerException( "Unable to execute the post '" + actionName
                                                   + "' shell command '" + shellCommand + "' on application '"
                                                   + applicationInfo.getAlias() + "'. The error output is"
                                                   + ( StringUtils.isNullOrEmpty( sshClient.getErrorOutput() )
                                                                                                               ? " empty."
                                                                                                               : ":\n"
                                                                                                                 + sshClient.getErrorOutput() ) );
                }
                log.info( "The output of shell command \"" + shellCommand + "\" is"
                          + ( StringUtils.isNullOrEmpty( sshClient.getStandardOutput() )
                                                                                         ? " empty."
                                                                                         : ":\n"
                                                                                           + sshClient.getStandardOutput() ) );
            } finally {
                sshClient.disconnect();
            }
        }
    }

#No. 385
#File: E:\bishe\1\AbstractApplicationsAggregate.java
#Comment:
    /**
     * Name of Aggregate
     */

#Code:
    protected static final String NAME = "Applications";

    /**
     * Constructor to be used.
     *
     * @param eventBus
     * @param eventStore
     */
    public AbstractApplicationsAggregate(final EventBus eventBus, final EventStore eventStore) {
        super(eventBus, eventStore);
    }

#No. 386
#File: E:\bishe\1\AbstractApplicationsAggregate.java
#Comment:
    /**
     * Constructor to be used.
     *
     * @param eventBus
     * @param eventStore
     * @param userProvider
     */

#Code:
    public AbstractApplicationsAggregate(final EventBus eventBus, final EventStore eventStore,
                                         final UserProvider userProvider) {
        super(eventBus, eventStore, userProvider);
    }

#No. 387
#File: E:\bishe\1\AbstractApplicationsAggregate.java
#Comment:
    /**
     * Get an application with its name.
     * The application is not actually stored so we create it by assembling all the platforms corresponding to that application
     *
     * @param applicationName
     * @return the matching application or empty
     */

#Code:
    @Override
    public Optional<ApplicationData> getApplication(final String applicationName) {
        final List<PlatformData> platforms = getPlatformRegistry().getPlatformsForApplication(applicationName);

        if (platforms.size() > 0) {
            return Optional.of(new ApplicationData(
                    applicationName,
                    platforms
            ));
        } else {
            return Optional.empty();
        }
    }

#No. 388
#File: E:\bishe\1\AbstractApplicationsAggregate.java
#Comment:
    /**
     * Get a platform with its name and its application name.
     *
     * @param platformKey
     * @return The corresponding platform or empty
     */

#Code:
    @Override
    public Optional<PlatformData> getPlatform(final PlatformKey platformKey) {
        return getPlatformRegistry().getPlatform(platformKey);
    }

#No. 389
#File: E:\bishe\1\AbstractApplicationsAggregate.java
#Comment:
    /**
     * Get a platform at a specific moment in time defined by timestamp param
     *
     * @param platformKey
     * @param timestamp
     * @return
     */

#Code:
    @Override
    public Optional<TimeStampedPlatformData> getPlatform(final PlatformKey platformKey, final long timestamp) {

        final Optional<PlatformData> plt = getPlatformRegistry().getPlatform(
                new PlatformTimelineKey(platformKey, timestamp));

        if (plt.isPresent()) {
            return Optional.of(TimeStampedPlatformData
                    .withPlatform(plt.get())
                    .withTimestamp(timestamp).build());
        } else {
            return Optional.empty();
        }
    }

#No. 390
#File: E:\bishe\1\AbstractApplicationsAggregate.java
#Comment:
    /**
     * Creates a platform with given modules.
     * It will provide an id to all modules that have no id or id set to 0
     *
     * @param platform
     * @return the created platform value object (with a versionID at 1)
     */

#Code:
    @Override
    public PlatformData createPlatform(final PlatformData platform) {
        final PlatformCreatedCommand hc = new PlatformCreatedCommand(getPlatformRegistry(), platform);

        final PlatformCreatedEvent createdPlatformEventTry = this.tryAtomic(platform.getKey().getEntityName(), hc);

        return createdPlatformEventTry.getPlatform();
    }

#No. 391
#File: E:\bishe\1\AbstractApplicationsAggregate.java
#Comment:
    /**
     * Method to create a platform from another
     * We also need to copy the properties
     * This implementation is not atomic and creates as many events as if we did the operation manually by single steps
     * It should be sufficient for the use case, but it can fail if the new platform is concurrently modified, which is pretty much impossible
     *
     * @param platform
     * @param fromPlatformKey
     * @return
     */

#Code:
    @Override
    public PlatformData createPlatformFromExistingPlatform(final PlatformData platform, final PlatformKey fromPlatformKey) {
        // Getting existing platform
        PlatformData existingPlatform = getPlatform(fromPlatformKey).orElseThrow(() -> new MissingResourceException("There is no existing platform " + fromPlatformKey + " to build from"));

        // new platform's key
        PlatformKey key = platform.getKey();

        // Building the platform to be created, this contains all the stuff
        PlatformData newPlatformToBeCreated = PlatformData.withPlatformName(key.getName())
                .withApplicationName(key.getApplicationName())
                .withApplicationVersion(platform.getApplicationVersion())
                .withModules(existingPlatform.getModules())
                .withVersion(1L)
                .setProduction(platform.isProduction())
                .build();

        // Get the properties by path
        Map<String, PropertiesData> existingPropertiesByPath = getPropertiesRegistry().getProperties(fromPlatformKey.getApplicationName(), fromPlatformKey.getName());

        return createPlatformFromExistingPlatformHandler(newPlatformToBeCreated, existingPlatform, existingPropertiesByPath);
    }

#No. 392
#File: E:\bishe\1\AbstractApplicationsAggregate.java
#Comment:
    /**
     *  Handler
     * @param platform
     * @return
     */

#Code:
    private PlatformData createPlatformFromExistingPlatformHandler(final PlatformData platform,
                                                                   final PlatformData originPlatform,
                                                                   final Map<String, PropertiesData> originProperties){
        final PlatformCreatedFromExistingCommand hc = new PlatformCreatedFromExistingCommand(getPlatformRegistry(),
                getPropertiesRegistry(), platform, originPlatform, originProperties);

        this.tryAtomic(platform.getKey().getEntityName(), hc);

        //We return the platform from get method, this way we are sure to get the platform from the registry, ie the way it has been modified.
        return getPlatform(platform.getKey()).orElseThrow(() -> new MissingResourceException("Cannot get the created platform. This is not expected and should be reported"));
    }

#No. 393
#File: E:\bishe\1\AbstractApplicationsAggregate.java
#Comment:
    /**
     * Get properties for a platform with the specific path (example GSTWDI#WAS).
     *
     * @param platformKey
     * @param path
     * @return the properties or an empty property wrapper if none found
     */

#Code:
    public PropertiesData getProperties(final PlatformKey platformKey, final String path) {
        return getPropertiesRegistry().getProperties(platformKey.getApplicationName(), platformKey.getName(), path).orElse(PropertiesData.empty());
    }

#No. 394
#File: E:\bishe\1\AbstractApplicationsAggregate.java
#Comment:
    /**
     * Create or Update properties for a platform at the given path.
     *
     * @param platformKey
     * @param path
     * @param properties
     * @param platformVersionId
     * @return the properties value object
     */

#Code:
    @Override
    public PropertiesData createOrUpdatePropertiesInPlatform(final PlatformKey platformKey, final String path,
                                                             final PropertiesData properties,
                                                             final long platformVersionId, final String comment) {
        final PropertiesSavedCommand hc = new PropertiesSavedCommand(getPlatformRegistry(), getPropertiesRegistry(),
                platformKey, path, properties, platformVersionId, comment);

        final PropertiesSavedEvent propertiesSavedEvent = this.tryAtomic(platformKey.getEntityName(), hc);

        return propertiesSavedEvent.getProperties();
    }

#No. 395
#File: E:\bishe\1\AbstractApplicationsAggregate.java
#Comment:
    /**
     * Find the model of properties to be evaluated for a given instance.
     *
     * @param platformKey
     * @param propertiesPath
     * @return the corresponding model
     */

#Code:
    @Override
    public InstanceModel getInstanceModel(final PlatformKey platformKey, final String propertiesPath) {

        final String applicationName = platformKey.getApplicationName();
        final String platformName = platformKey.getName();

        this.getPlatform(platformKey).orElseThrow(() -> new MissingResourceException("Application/Platform " + applicationName + "/" + platformName + " does not exist"));

        final PropertiesData properties = this.getProperties(platformKey, propertiesPath);
        final PropertiesData globalProperties = this.getProperties(platformKey, "#");

        return properties.generateInstanceModel(globalProperties.getKeyValueProperties());
    }

#No. 396
#File: E:\bishe\1\AbstractApplicationsAggregate.java
#Comment:
    /**
     * Take a snapshot of the platform, the timestamp will be System.currentMillisecond
     *
     * @param key
     * @return the timestamp of the snapshot
     */

#Code:
    @Override
    public long takeSnapshot(PlatformKey key) {
        final long timestamp = System.currentTimeMillis();
        return takeSnapshot(key, timestamp);
    }

#No. 397
#File: E:\bishe\1\AbstractApplicationsAggregate.java
#Comment:
    /**
     * Used to replay the event specifying a timestamp
     *
     * @return
     */

#Code:
    private long takeSnapshot(PlatformKey key, long timestamp) {
        final PlatformSnapshotCommand hc = new PlatformSnapshotCommand(getPlatformRegistry(), getPropertiesRegistry(),
                getSnapshotRegistry(), key, timestamp);

        final PlatformSnapshotEvent snapshotEvent = this.tryAtomic(key.getEntityName(), hc);

        return snapshotEvent.getTimestamp();
    }

#No. 398
#File: E:\bishe\1\AbstractApplicationsAggregate.java
#Comment:
    /*
     * REPLAY LISTENERS
     */

#Code:

    @Subscribe
    @Override
    public void replayPlatformCreatedEvent(final PlatformCreatedEvent event) {
        try {
            final PlatformData platform = event.getPlatform();
            this.createPlatform(platform);
        } catch (Exception e) {
            LOGGER.error("Error while replaying platform created event {}", e.getMessage());
        }
    }

#No. 399
#File: E:\bishe\1\AbstractApplicationsAggregate.java
#Comment:
    /**
     * Get a set containing all platforms
     * @return an {@link java.util.Set} of {@link PlatformData}s
     */

#Code:
    public Collection<PlatformData> getAll() {
        return getPlatformRegistry().getAllPlatforms();
    }

#No. 400
#File: E:\bishe\1\AbstractApplicationsAggregate.java
#Comment:
    /**
     * Gets the number of platforms
     *
     * @return {@link Integer}
     */

#Code:
    @Override
    public Collection<PlatformData> getAllPlatforms() {
        return getPlatformRegistry().getAllPlatforms();
    }

#No. 401
#File: E:\bishe\1\AbstractAptConfiguratorDelegate.java
#Comment:
  /**
   * Returns the {@link IClasspathEntryDescriptor} in the specified {@link IClasspathDescriptor} that is a prefix of the
   * specified {@link IPath}.
   *
   * @param classpath the {@link IClasspathDescriptor} to be searched for a matching {@link IClasspathEntryDescriptor}
   * @param path the {@link IPath} to find a matching {@link IClasspathEntryDescriptor} for
   * @return the {@link IClasspathEntryDescriptor} in the specified {@link IClasspathDescriptor} that is a prefix of the
   *         specified {@link IPath}
   */

#Code:
  private static IClasspathEntryDescriptor getEnclosingEntryDescriptor(IClasspathDescriptor classpath, IPath path) {
    for(IClasspathEntryDescriptor cped : classpath.getEntryDescriptors()) {
      if(cped.getPath().isPrefixOf(path)) {
        return cped;
      }
    }
    return null;
  }

#No. 402
#File: E:\bishe\1\AbstractAptProjectConfigurator.java
#Comment:
  /**
   * {@inheritDoc}
   */

#Code:
  @Override
  public void configure(ProjectConfigurationRequest request, IProgressMonitor monitor) throws CoreException {
    // This method may be called with null parameters to ensure its API is correct. We
    // can ignore such calls.

    if((request == null) || (monitor == null)) {
      return;
    }

    // Get the objects needed for APT configuration
    IMavenProjectFacade mavenProjectFacade = request.getMavenProjectFacade();

    AnnotationProcessingMode mode = getAnnotationProcessorMode(mavenProjectFacade);

    MavenSession mavenSession = request.getMavenSession();

    AptConfiguratorDelegate configuratorDelegate = getDelegate(mode);
    configuratorDelegate.setSession(mavenSession);
    configuratorDelegate.setFacade(mavenProjectFacade);

    // Configure APT
    if(!configuratorDelegate.isIgnored(monitor)) {
      configuratorDelegate.configureProject(monitor);
    }

    configureAptReconcile(mavenProjectFacade.getProject());

  }

#No. 403
#File: E:\bishe\1\AbstractAptProjectConfigurator.java
#Comment:
  /**
   * reconcile is enabled by default while enabling apt for maven-compiler-plugin, As Annotation processing usually
   * takes a long time for even a java file change, and what's more, validate a jsp also triggers apt reconcile as jsp
   * compiles into java, this option is provided to switch off the "Processing on Edit" feature.
   *
   * @throws CoreException
   */

#Code:
  private void configureAptReconcile(IProject project) throws CoreException {
    if(project.hasNature(JavaCore.NATURE_ID)) {
      IJavaProject jp = JavaCore.create(project);
      if((jp != null) && AptConfig.isEnabled(jp)) {
        boolean shouldEnable = MavenJdtAptPlugin.getDefault().getPreferencesManager()
            .shouldEnableAnnotationProcessDuringReconcile(project);
        if(shouldEnable && !AptConfig.shouldProcessDuringReconcile(jp)) {
          AptConfig.setProcessDuringReconcile(jp, true);
        }
        if(!shouldEnable && AptConfig.shouldProcessDuringReconcile(jp)) {
          AptConfig.setProcessDuringReconcile(jp, false);
        }
      }
    }
  }

#No. 404
#File: E:\bishe\1\AbstractAptProjectConfigurator.java
#Comment:
  /**
   * {@inheritDoc}
   */

#Code:
  @Override
  public void configureClasspath(IMavenProjectFacade facade, IClasspathDescriptor classpath, IProgressMonitor monitor) {
    /*
     * Implementations of this method are supposed to configure the Maven project
     * classpath: the "Maven Dependencies" container. We don't have any need to do
     * that here.
     */
  }

#No. 405
#File: E:\bishe\1\AbstractAptProjectConfigurator.java
#Comment:
  /**
   * {@inheritDoc}
   */

#Code:
  @Override
  public void configureRawClasspath(ProjectConfigurationRequest request, IClasspathDescriptor classpath,
      IProgressMonitor monitor) throws CoreException {
    /*
     * We need to prevent/recover from the JavaProjectConfigurator removing the
     * generated annotation sources directory from the classpath: it will be added
     * when we configure the Eclipse APT preferences and then removed when the
     * JavaProjectConfigurator runs.
     */
    // Get the various project references we'll need
    IProject eclipseProject = request.getProject();
    if(!eclipseProject.hasNature(JavaCore.NATURE_ID)) {
      return;
    }

    AptConfiguratorDelegate delegate = getDelegate(request.getMavenProjectFacade());
    delegate.setFacade(request.getMavenProjectFacade());
    delegate.setSession(request.getMavenSession());
    // If this isn't a Java project, we have nothing to do

    if(!delegate.isIgnored(monitor)) {
      delegate.configureClasspath(classpath, monitor);
    }

  }

#No. 406
#File: E:\bishe\1\AbstractArc.java
#Comment:
    /**
     * creates a shape based on bounds, start and end
     *
     * @param renderer EMFRenderer storing the drawing session data
     * @param arcType type of arc, e.g. {@link Arc2D#OPEN}
     * @return shape to render 
     */

#Code:
    protected Shape getShape(EMFRenderer renderer, int arcType) {
        // normalize start and end point to a circle
        double nx0 = start.getX() / bounds.getWidth();

        // double ny0 = arc.getStart().y / arc.getBounds().height;
        double nx1 = end.getX() / bounds.getWidth();

        // double ny1 = arc.getEnd().y / arc.getBounds().height;
        // calculate angle of start point
        double alpha0, alpha1;
        if (renderer.getArcDirection() == EMFConstants.AD_CLOCKWISE) {
            alpha0 = Math.acos(nx0);
            alpha1 = Math.acos(nx1);
        } else {
            alpha0 = Math.acos(nx1);
            alpha1 = Math.acos(nx0);
        }

        return new Arc2D.Double(
            start.getX(),
            start.getY(),
            bounds.getWidth(),
            bounds.getHeight(),
            alpha0,
            alpha1 - alpha0,
            arcType);
    }

#No. 407
#File: E:\bishe\1\AbstractArchiver.java
#Comment:
    /**
     * @deprecated Use {@link Archiver#getDefaultFileMode()}.
     */

#Code:
    public final int getRawDefaultFileMode()
    {
        return getDefaultFileMode();
    }

#No. 408
#File: E:\bishe\1\AbstractArchiver.java
#Comment:
    /**
     * Adds a resource collection to the archive.
     */

#Code:
    public void addResources( final PlexusIoResourceCollection collection )
        throws ArchiverException
    {
        doAddResource( collection );
    }

#No. 409
#File: E:\bishe\1\AbstractArchiver.java
#Comment:
    /**
     * @since 1.0-alpha-7
     */

#Code:
    public void addArchivedFileSet( @Nonnull final File archiveFile, final String prefix, final String[] includes,
                                    final String[] excludes )
        throws ArchiverException
    {
        addArchivedFileSet(
            archivedFileSet( archiveFile ).prefixed( prefix ).includeExclude( includes, excludes ).includeEmptyDirs(
                includeEmptyDirs ) );
    }

#No. 410
#File: E:\bishe\1\AbstractArchiver.java
#Comment:
    /**
     * @since 1.0-alpha-7
     */

#Code:
    public void addArchivedFileSet( @Nonnull final File archiveFile, final String prefix )
        throws ArchiverException
    {
        addArchivedFileSet( archivedFileSet( archiveFile ).prefixed( prefix ).includeEmptyDirs( includeEmptyDirs ) );
    }

#No. 411
#File: E:\bishe\1\AbstractArchiver.java
#Comment:
    /**
     * @since 1.0-alpha-7
     */

#Code:
    public void addArchivedFileSet( @Nonnull final File archiveFile, final String[] includes, final String[] excludes )
        throws ArchiverException
    {
        addArchivedFileSet(
            archivedFileSet( archiveFile ).includeExclude( includes, excludes ).includeEmptyDirs( includeEmptyDirs ) );
    }

#No. 412
#File: E:\bishe\1\AbstractArchiver.java
#Comment:
    /**
     * @since 1.0-alpha-7
     */

#Code:
    public void addArchivedFileSet( @Nonnull final File archiveFile )
        throws ArchiverException
    {
        addArchivedFileSet( archivedFileSet( archiveFile ).includeEmptyDirs( includeEmptyDirs ) );
    }

#No. 413
#File: E:\bishe\1\AbstractArchiver.java
#Comment:
    /**
     * Allows us to pull the ArchiverManager instance out of the container without causing a chicken-and-egg
     * instantiation/composition problem.
     */

#Code:
    public void contextualize( final Context context )
        throws ContextException
    {
        final PlexusContainer container = (PlexusContainer) context.get( PlexusConstants.PLEXUS_KEY );

        try
        {
            archiverManager = (ArchiverManager) container.lookup( ArchiverManager.ROLE );
        }
        catch ( final ComponentLookupException e )
        {
            throw new ContextException( "Error retrieving ArchiverManager instance: " + e.getMessage(), e );
        }
    }

#No. 414
#File: E:\bishe\1\AbstractArchiver.java
#Comment:
    /**
     * @since 1.1
     */

#Code:
    public boolean isUseJvmChmod()
    {
        return useJvmChmod;
    }

#No. 415
#File: E:\bishe\1\AbstractArchiver.java
#Comment:
    /**
     * @since 1.1
     */

#Code:
    public void setUseJvmChmod( final boolean useJvmChmod )
    {
        this.useJvmChmod = useJvmChmod;
    }

#No. 416
#File: E:\bishe\1\AbstractArchiver.java
#Comment:
    /**
     * @since 1.1
     */

#Code:
    public boolean isIgnorePermissions()
    {
        return ignorePermissions;
    }

#No. 417
#File: E:\bishe\1\AbstractArchiver.java
#Comment:
    /**
     * @since 1.1
     */

#Code:
    public void setIgnorePermissions( final boolean ignorePermissions )
    {
        this.ignorePermissions = ignorePermissions;
    }

#No. 418
#File: E:\bishe\1\AbstractArrayEncodedNgramLanguageModel.java
#Comment:
/**
 * Default implementation of all NGramLanguageModel functionality except
 * {@link #getLogProb(int[], int, int)}.
 * 
 * 
 * 
 * @author adampauls
 * 
 * @param <W>
 */

#Code:
public abstract class AbstractArrayEncodedNgramLanguageModel<W> extends AbstractNgramLanguageModel<W> implements ArrayEncodedNgramLanguageModel<W>,
	Serializable
{

	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;

	public AbstractArrayEncodedNgramLanguageModel(final int lmOrder, final WordIndexer<W> wordIndexer, final float oovWordLogProb) {
		super(lmOrder, wordIndexer, oovWordLogProb);
	}

	@Override
	public float scoreSentence(final List<W> sentence) {
		return ArrayEncodedNgramLanguageModel.DefaultImplementations.scoreSentence(sentence, this);
	}

	@Override
	public float getLogProb(final List<W> phrase) {
		return ArrayEncodedNgramLanguageModel.DefaultImplementations.getLogProb(phrase, this);
	}

	@Override
	public float getLogProb(final int[] ngram) {
		return ArrayEncodedNgramLanguageModel.DefaultImplementations.getLogProb(ngram, this);
	}

	@Override
	public abstract float getLogProb(final int[] ngram, int startPos, int endPos);
	
	


}

#No. 419
#File: E:\bishe\1\AbstractArrayState.java
#Comment:
	/**
	 * May return null if array has been collected.
	 */

#Code:
	final public Object getArray() {
		Object l = array.get();
		if (l == null) {
			Yikes.yikes("Getting array of AbstractArrayState after array has been gc'd.");
		}
		return l;
	}

#No. 420
#File: E:\bishe\1\AbstractArrayState.java
#Comment:
	/*
	 * A version to use in caches where getting null can be expected.
	 */

#Code:
	final Object getArrayNoCheck() {
		return array.get();
	}

#No. 421
#File: E:\bishe\1\AbstractArrayState.java
#Comment:
	/** 
	 * Update the shadow state for index.  Optimistic implementations can
	 * fail and return false if the expected value is not found.
	 */

#Code:
	public abstract boolean putState(int index, ShadowVar expected, ShadowVar v);
	
	/* 
	 * Return the shadow state for a give index.
	 */
	public abstract ShadowVar getState(int index);

	/** @RRInternal */
	public abstract AbstractArrayState getShadowForNextDim(ShadowThread td, Object element, int i);

	/** @RRInternal */
	public abstract void setShadowForNextDim(int i, AbstractArrayState s);

	/** @RRInternal */
	public void specialize() {
		if (warned) return;
		warned = true;
		Util.log("Can't specialize array state " + this.getClass());
	}	

#No. 422
#File: E:\bishe\1\AbstractArrayState.java
#Comment:
	/**
	 * Called when the array state is created by not needed due to a concurrent
	 * creation of another array state for an array.
	 */

#Code:
	public void forget() {
		 
	 }

#No. 423
#File: E:\bishe\1\AbstractArt.java
#Comment:
	/*
	public ByteBuffer loadData(int rawResource)
	{
		// TODO: rewrite data loader
		ByteBuffer romData;
		InputStream input = getResources().openRawResource(rawResource);
		ByteArrayOutputStream output = new ByteArrayOutputStream();//131072); // currently, largest file is a bit over 120kb... trying to avoid over allocating heap
		
		int bytesRead;
		byte[] buffer = new byte[16384];
		
		try {
			while((bytesRead = input.read(buffer)) != -1) {
				output.write(buffer, 0, bytesRead);
			}
		} catch (IOException e) {
			e.printStackTrace();
		}
		
		romData = ByteBuffer.wrap(output.toByteArray());
		
		return romData;
	}
	*/

#Code:
}
}

#No. 424
#File: E:\bishe\1\AbstractArticleControl.java
#Comment:
    /**
     * Updates pin state.
     */

#Code:
    public void updateState()
    {
        boolean selected = article != null && getCurrentState(article);
        setIcon(selected ? iconSel : iconUnsel);
        setToolTipText(selected ? msgUnsel : msgSel);
    }

#No. 425
#File: E:\bishe\1\AbstractArtifactHandler.java
#Comment:
    /**
     * Returns true if the target Class is a class artifact
     * handled by this object.<p>
     * This implementation performs an equality check on class.name
     */

#Code:
    public boolean isArtifact(@Nonnull Class<A> clazz) {
        requireNonNull(clazz, ERROR_CLASS_NULL);
        return classesByName.get(clazz.getName()) != null;
    }

    public boolean isArtifact(@Nonnull BasiliskClass clazz) {
        requireNonNull(clazz, ERROR_CLASS_NULL);
        for (BasiliskClass basiliskClass : basiliskClasses) {
            if (basiliskClass.equals(clazz)) return true;
        }

#No. 426
#File: E:\bishe\1\AbstractArtifactoryConfiguration.java
#Comment:
/**
 * Base class for all {@link com.atlassian.bamboo.task.TaskConfigurator}s that are used by the plugin. It sets the
 * {@link ServerConfigManager} to be used for populating the Artifactory relevant fields. It also serves as a common
 * ground for setting common fields in the context of the build.
 *
 * @author Tomer Cohen
 */

#Code:
public abstract class AbstractArtifactoryConfiguration extends AbstractTaskConfigurator implements
        TaskTestResultsSupport, BuildTaskRequirementSupport {

    protected I18nResolver i18nResolver;
    public static final String CFG_TEST_RESULTS_FILE_PATTERN_OPTION_CUSTOM = "customTestDirectory";
    public static final String CFG_TEST_RESULTS_FILE_PATTERN_OPTION_STANDARD = "standardTestDirectory";
    private static final Map TEST_RESULTS_FILE_PATTERN_TYPES = ImmutableMap
            .of(CFG_TEST_RESULTS_FILE_PATTERN_OPTION_STANDARD, "Look in the standard test results directory.",
                    CFG_TEST_RESULTS_FILE_PATTERN_OPTION_CUSTOM, "Specify custom results directories");
    public static final Map<String, String> SIGN_METHOD_MAP = ImmutableMap.of(
            "false", "Don't Sign", "true", "Sign");
    public static final String SIGN_METHOD_MAP_KEY = "signMethods";
    protected transient ServerConfigManager serverConfigManager;
    protected AdministrationConfiguration administrationConfiguration;
    protected UIConfigSupport uiConfigSupport;
    private String builderContextPrefix;
    private String capabilityPrefix;
    private static final Logger log = Logger.getLogger(AbstractArtifactoryConfiguration.class);

    protected AbstractArtifactoryConfiguration() {
        this(null, null);
    }

    protected AbstractArtifactoryConfiguration(String builderContextPrefix) {
        this(builderContextPrefix, null);
    }

    protected AbstractArtifactoryConfiguration(String builderContextPrefix, @Nullable String capabilityPrefix) {
        serverConfigManager = ServerConfigManager.getInstance();
        if (administrationConfiguration == null) {
            administrationConfiguration =
                    (AdministrationConfiguration) ContainerManager.getComponent("administrationConfiguration");
        }
        this.builderContextPrefix = builderContextPrefix;
        this.capabilityPrefix = capabilityPrefix;
    }

#No. 427
#File: E:\bishe\1\AbstractArtifactoryConfiguration.java
#Comment:
    /**
     * Sets the UI config bean from bamboo. NOTE: This method is called from Bamboo upon instantiation of this class by
     * reflection.
     *
     * @param uiConfigSupport The UI config bean for select values.
     */

#Code:
    public void setUiConfigSupport(UIConfigSupport uiConfigSupport) {
        this.uiConfigSupport = uiConfigSupport;
    }

#No. 428
#File: E:\bishe\1\AbstractArtifactoryConfiguration.java
#Comment:
    /**
     * This method is used by the encryptFields and decryptFields methods.
     * It encrypts or decrypts the task config fields, if their key ends with 'password'.
     * While encrypting / decrypting, if the keys are already encrypted / decrypted,
     * the keys values will not change.
     *
     * @param taskConfigMap The task config fields map.
     * @param enc           If true - encrypt, else - decrypt.
     */

#Code:
    private void encOrDecFields(Map<String, String> taskConfigMap, boolean enc) {
        for (Map.Entry<String, String> entry : taskConfigMap.entrySet()) {
            String key = entry.getKey().toLowerCase();
            if (shouldEncrypt(key)) {
                String value = entry.getValue();
                if (isEncrypted(value)) {
                    try {
                        value = URLDecoder.decode(value, "UTF-8");
                    } catch (Exception ignore) {
                    /* Ignore. Trying to decode password that was not encoded. */
                    }
                    value = TaskUtils.decryptIfNeeded(value);
                }
                if (enc) {
                    value = EncryptionHelper.encrypt(value);
                    try {
                        value = URLEncoder.encode(value, "UTF-8");
                    } catch (UnsupportedEncodingException e) {
                        throw new RuntimeException(e);
                    }
                }
                entry.setValue(value);
            }
        }
    }

#No. 429
#File: E:\bishe\1\AbstractArtifactoryConfiguration.java
#Comment:
    /**
     * Encrypt the task config fields, if their key ends with 'password'.
     * If the keys are already encrypted, their value will not change.
     *
     * @param taskConfigMap The task config fields map.
     */

#Code:
    private void encryptFields(Map<String, String> taskConfigMap) {
        encOrDecFields(taskConfigMap, true);
    }

#No. 430
#File: E:\bishe\1\AbstractArtifactoryConfiguration.java
#Comment:
    /**
     * Decrypt the task config fields, if their key ends with 'password'.
     * If the keys are already decrypted, their value will not change.
     *
     * @param taskConfigMap The task config fields map.
     */

#Code:
    protected void decryptFields(Map<String, String> taskConfigMap) {
        encOrDecFields(taskConfigMap, false);
    }

#No. 431
#File: E:\bishe\1\AbstractArtifactoryConfiguration.java
#Comment:
    /**
     * Reset the build context configuration back to the default values if no server id was selected
     *
     * @param buildContext The build context which holds the environment for the configuration.
     */

#Code:
    protected void resetConfigIfNeeded(AbstractBuildContext buildContext) {
        long serverId = buildContext.getArtifactoryServerId();
        if (serverId == -1) {
            buildContext.resetContextToDefault();
        }
    }

#No. 432
#File: E:\bishe\1\AbstractArtifactoryConfiguration.java
#Comment:
    /**
     * In version 1.8.1 the key containing the Artifactory Server ID was changed
     * in the Generic Resolve and Deploy configurations.
     * This method migrates to the new name.
     */

#Code:
    protected void migrateServerKeyIfNeeded(Map<String, String> configuration) {
        String oldServerId = configuration.get("artifactory.generic.artifactoryServerId");
        String newServerId = configuration.get("builder.artifactoryGenericBuilder.artifactoryServerId");
        if (StringUtils.isNotBlank(oldServerId)) {
            configuration.put("builder.artifactoryGenericBuilder.artifactoryServerId", oldServerId);
        }
        if (StringUtils.isNotBlank(newServerId)) {
            configuration.put("artifactory.generic.artifactoryServerId", newServerId);
        }
    }

#No. 433
#File: E:\bishe\1\AbstractASBase.java
#Comment:
    /**
     * check if a specific character can be used in a legal
     * variable/method/class name
     *
     * @param ch
     * @return
     */

#Code:
    protected boolean isLegalNameChar(char ch)
    {
        if (Character.isWhitespace(ch))
        {
            return false;
        }

        if (ch > 127)
        {
            return false;
        }

        return java.lang.Character.isLetterOrDigit(ch) || ch == '.' || ch == '_' || (isJavaStyle() && ch == '$') || (isSharpStyle() && ch == '@'); // may be used as a prefix
    }

#No. 434
#File: E:\bishe\1\AbstractAssetRepository.java
#Comment:
    /**
     * A map with all the loaded assets.
     */

#Code:
    final Map<Path, Optional<Asset>> loadedAssets = new ConcurrentHashMap<>();

    private final PluginManager pluginManager;

    protected AbstractAssetRepository(PluginManager pluginManager) {
        checkNotNull(pluginManager, "pluginManager");
        this.pluginManager = pluginManager;
    }

#No. 435
#File: E:\bishe\1\AbstractAssets.java
#Comment:
	/**
	 * Play sound effect, it will only play if SettingsManager.isSoundOn is true
	 * 
	 * @param sound to play
	 * @param volume is the volume setting (Range [0.0 - 1.0])
	 * @see SettingsManager.isSoundOn 
	 * 
	 * */

#Code:
	public static void playSound(Sound sound, float volume){
		if(SettingsManager.isSoundOn){
			sound.play(volume);
		}
	}

#No. 436
#File: E:\bishe\1\AbstractAssets.java
#Comment:
	/**
	 * Play music, it will only play if SettingsManager.isMusicOn is true
	 * 
	 * @param music to play
	 * @param isLooping to loop or not
	 * @param volume is the volume setting (Range [0.0 - 1.0])
	 * @see SettingsManager.isMusicOn 
	 * 
	 * */

#Code:
	public static void playMusic(Music music, boolean isLooping, float volume){
		if(SettingsManager.isMusicOn){
			music.setLooping(isLooping);
			music.setVolume(volume);
			music.play();
		}
	}

#No. 437
#File: E:\bishe\1\AbstractAsyncComponent.java
#Comment:
    /**
     * Takes from the local concurrent queue and hands them off to be processed
     *
     */

#Code:
    protected class LocalQueueProcessor implements Runnable
    {
        private final BlockingQueue<RQ> localProcessorQueue;
        
        public LocalQueueProcessor(BlockingQueue<RQ> localProcessorQueue)
        {
            this.localProcessorQueue = localProcessorQueue;
        }
        
        @Override
        public void run()
        {
            logger.debug("Starting local queue processing");
            while(true)
            {
                try
                {
                    RQ request = localProcessorQueue.take();
                    logger.debug("Processing local queue message");
                    processRequest(request);
                    logger.debug("Processing local queue message complete");
                }
                catch (InterruptedException e)
                {
                }
            }
        }
    }

#No. 438
#File: E:\bishe\1\AbstractAsyncSqliteLoader.java
#Comment:
    /**
     * Uses a specific context.
     * 
     * @param context
     */

#Code:
    public AbstractAsyncSqliteLoader(Context context) {
        super(context);
    }

#No. 439
#File: E:\bishe\1\AbstractAttributeSpi.java
#Comment:
    /**
     * Determines if the annotation should be commented.<br>
     * By default annotation are commented if the attribute is set as transient in the configuration.
     */

#Code:
    protected boolean isCommentMode() {
        return attribute.getColumnConfig() != null && attribute.getColumnConfig().getAsTransient() == TRUE;
    }

#No. 440
#File: E:\bishe\1\AbstractAuthDao.java
#Comment:
    /**
     * DB Connection Open.
     * @param dbServer     DB Server
     * @param port         Database Port
     * @param databaseName Database Name
     * @param dbUserName   Database UserName
     * @param dbPassword   Database Password
     * @throws RedmineAuthenticationException
     */

#Code:
    public abstract void open(String dbServer, String port, String databaseName, String dbUserName, String dbPassword)
            throws RedmineAuthenticationException;

    /**
     * DB Conncetion Close.
     */
    public void close() {
        if (conn != null) {
            try { conn.close(); } catch (Exception e) {}
        }
    }

#No. 441
#File: E:\bishe\1\AbstractAuthDao.java
#Comment:
    /**
     * Table Check.
     * @param  table
     * @return
     * @throws RedmineAuthenticationException
     */

#Code:
    public abstract boolean isTable(String table) throws RedmineAuthenticationException;

    /**
     * Field Check.
     * @param  table
     * @param  field
     * @return
     * @throws RedmineAuthenticationException
     */
    public abstract boolean isField(String table, String field) throws RedmineAuthenticationException;

    /**
     * Get RedmineUserData.
     * @param  loginTable
     * @param  userField
     * @param  passField
     * @param  saltField
     * @param  username
     * @return
     * @throws RedmineAuthenticationException
     */
    public abstract RedmineUserData getRedmineUserData(String loginTable, String userField, String passField, String saltField, String username) throws RedmineAuthenticationException;

}
}

#No. 442
#File: E:\bishe\1\AbstractAuthenticator.java
#Comment:
    /**
     * @return Activity that will be filled AccountManager.KEY_ACCOUNT_AUTHENTICATOR_RESPONSE
     */

#Code:
    public abstract Class<? extends Activity> getActivityType();

    /**
     * @return accessToken
     */
    public abstract String login(String username, String password, String authTokenType);

    @Override
    public String getAuthTokenLabel(String authTokenType) {
        return null;
    }

#No. 443
#File: E:\bishe\1\AbstractAutoCompletionSource.java
#Comment:
    /**
     * Returns a normalized string used by filtering criteria.<br>Default
     * behavior uses {@link AutoCompletionSources#normalize(java.lang.String)}.
     *
     * @param input the string to be normalized
     * @return a normalized string
     */

#Code:
    @Nonnull
    protected String getNormalizedString(@Nonnull String input) {
        return AutoCompletionSources.normalize(input);
    }

    /**
     * Checks if a normalized input matches a normalized term.<br>Default
     * behavior uses {@link String#contains(java.lang.CharSequence)}.
     *
     * @param normalizedTerm
     * @param normalizedInput
     * @return true if the input matches the term
     */
    protected boolean matches(@Nonnull String normalizedTerm, @Nonnull String normalizedInput) {
        return normalizedInput.contains(normalizedTerm);
    }

    /**
     * Checks if an input matches a term matcher.<br>Default behavior uses
     * {@link #getValueAsString(java.lang.Object)}.
     *
     * @param termMatcher
     * @param input
     * @return true if the input matches the term matcher
     */
    protected boolean matches(@Nonnull TermMatcher termMatcher, @Nonnull T input) {
        return termMatcher.matches(getValueAsString(input));
    }

    /**
     * Returns the size used to limit the number of values provided by this
     * source.<br>Default behavior uses {@link Integer#MAX_VALUE}.
     *
     * @return
     */
    @Nonnegative
    protected int getLimitSize() {
        return Integer.MAX_VALUE;
    }

#No. 444
#File: E:\bishe\1\AbstractAutoCompletionSource.java
#Comment:
    /**
     * Compares two values in order to sort them.<br>Default behavior uses
     * {@link #getValueAsString(java.lang.Object)}.
     *
     * @param left
     * @param right
     * @return
     */

#Code:
    @Override
    public int compare(T left, T right) {
        return getValueAsString(left).compareTo(getValueAsString(right));
    }

#No. 445
#File: E:\bishe\1\AbstractAutoSaver.java
#Comment:
    /**
     * Returns common executor.
     *
     * @return executor.
     */

#Code:
    protected synchronized ExecutorService getExecutor()
    {
        if (executor == null)
        {
            executor = Executors.newFixedThreadPool(getExecutorThreadsNumber(), new ThreadFactory()
            {
                /**
                 * Constructs a new <tt>Thread</tt>.  Implementations may also initialize priority, name, daemon status,
                 * <tt>ThreadGroup</tt>, etc.
                 *
                 * @param r a runnable to be executed by new thread instance
                 *
                 * @return constructed thread
                 */
                public Thread newThread(Runnable r)
                {
                    return new Thread(r, getExecutorThreadName());
                }
            });
        }
        return executor;
    }

#No. 446
#File: E:\bishe\1\AbstractAutoSaver.java
#Comment:
    /**
     * Returns the number of threads for executor. The default is <code>1</code>.
     *
     * @return the number of threads.
     */

#Code:
    protected int getExecutorThreadsNumber()
    {
        return 1;
    }

#No. 447
#File: E:\bishe\1\AbstractAutoSaver.java
#Comment:
    /**
     * Makes sure all directories are present and creates those that are not.
     *
     * @param file file.
     */

#Code:
    static void ensureAllDirsPresent(File file)
    {
        // Create all sub-directories if necessary
        File parentFile = file.getParentFile();
        if (!parentFile.exists()) parentFile.mkdirs();
    }

#No. 448
#File: E:\bishe\1\AbstractAvroSerDesProtocolHandler.java
#Comment:
    /**
     * Property name for writer schema
     */

#Code:
    public static final String WRITER_SCHEMA = "writer.schema";

    /**
     * Property name for reader schema
     */
    public static final String READER_SCHEMA = "reader.schema";

    private final AvroSerDesHandler avroSerDesHandler;

    protected final Byte protocolId;

    protected AbstractAvroSerDesProtocolHandler(Byte protocolId, AvroSerDesHandler avroSerDesHandler) {
        this.protocolId = protocolId;
        this.avroSerDesHandler = avroSerDesHandler;
    }

#No. 449
#File: E:\bishe\1\AbstractAxis3D.java
#Comment:
    /**
     * Returns a hash code for this instance.
     * 
     * @return A hash code. 
     */

#Code:
    @Override
    public int hashCode() {
        int hash = 5;
        hash = 83 * hash + (this.visible ? 1 : 0);
        hash = 83 * hash + ObjectUtils.hashCode(this.label);
        hash = 83 * hash + ObjectUtils.hashCode(this.labelFont);
        hash = 83 * hash + ObjectUtils.hashCode(this.labelColor);
        hash = 83 * hash + ObjectUtils.hashCode(this.lineStroke);
        hash = 83 * hash + ObjectUtils.hashCode(this.lineColor);
        hash = 83 * hash + (this.tickLabelsVisible ? 1 : 0);
        hash = 83 * hash + ObjectUtils.hashCode(this.tickLabelFont);
        hash = 83 * hash + ObjectUtils.hashCode(this.tickLabelColor);
        return hash;
    }

#No. 450
#File: E:\bishe\1\AbstractAxis3D.java
#Comment:
    /**
     * Registers a listener so that it will receive axis change events.
     * 
     * @param listener  the listener ({@code null} not permitted). 
     */

#Code:
    @Override
    public void addChangeListener(Axis3DChangeListener listener) {
        this.listenerList.add(Axis3DChangeListener.class, listener);   
    }

#No. 451
#File: E:\bishe\1\AbstractAxis3D.java
#Comment:
    /**
     * Deregisters a listener so that it will no longer receive axis
     * change events.
     * 
     * @param listener  the listener ({@code null} not permitted). 
     */

#Code:
    @Override
    public void removeChangeListener(Axis3DChangeListener listener) {
        this.listenerList.remove(Axis3DChangeListener.class, listener);  
    }

#No. 452
#File: E:\bishe\1\AbstractAxis3D.java
#Comment:
    /**
     * Notifies all registered listeners that the plot has been modified.
     *
     * @param event  information about the change event.
     */

#Code:
    public void notifyListeners(Axis3DChangeEvent event) {
        Object[] listeners = this.listenerList.getListenerList();
        for (int i = listeners.length - 2; i >= 0; i -= 2) {
            if (listeners[i] == Axis3DChangeListener.class) { 
                ((Axis3DChangeListener) listeners[i + 1]).axisChanged(event);
            }
        }
    }

#No. 453
#File: E:\bishe\1\AbstractAxis3D.java
#Comment:
    /**
     * Sends an {@link Axis3DChangeEvent} to all registered listeners.
     * 
     * @param requiresWorldUpdate   a flag indicating whether or not this change
     *     requires the 3D world to be updated.
     */

#Code:
    protected void fireChangeEvent(boolean requiresWorldUpdate) {
        notifyListeners(new Axis3DChangeEvent(this, requiresWorldUpdate));
    }

#No. 454
#File: E:\bishe\1\AbstractAxis3D.java
#Comment:
    /**
     * Receives notification of a change to a marker managed by this axis - the
     * response is to fire a change event for the axis (to eventually trigger
     * a repaint of the chart).  Marker changes don't require the world model
     * to be updated.
     * 
     * @param event  the event.
     * 
     * @since 1.2
     */

#Code:
    @Override
    public void markerChanged(MarkerChangeEvent event) {
        fireChangeEvent(false);
    }

#No. 455
#File: E:\bishe\1\AbstractAxis3D.java
#Comment:
    /**
     * Provides serialization support.
     *
     * @param stream  the output stream.
     *
     * @throws IOException  if there is an I/O error.
     */

#Code:
    private void writeObject(ObjectOutputStream stream) throws IOException {
        stream.defaultWriteObject();
        SerialUtils.writeStroke(this.lineStroke, stream);
    }

#No. 456
#File: E:\bishe\1\AbstractAxis3D.java
#Comment:
    /**
     * Provides serialization support.
     *
     * @param stream  the input stream.
     *
     * @throws IOException  if there is an I/O error.
     * @throws ClassNotFoundException  if there is a classpath problem.
     */

#Code:
    private void readObject(ObjectInputStream stream)
        throws IOException, ClassNotFoundException {
        stream.defaultReadObject();
        this.lineStroke = SerialUtils.readStroke(stream);
    }

#No. 457
#File: E:\bishe\1\AbstractBackendHelper.java
#Comment:
    /**
     * Call this in {@link org.microg.nlp.api.LocationBackendService#onOpen()}.
     */

#Code:
    public synchronized void onOpen() {
        if (state == State.WAITING || state == State.SCANNING)
            throw new IllegalStateException("Do not call onOpen if not closed before");
        currentDataUsed = true;
        state = State.WAITING;
    }

#No. 458
#File: E:\bishe\1\AbstractBackendHelper.java
#Comment:
    /**
     * Call this in {@link org.microg.nlp.api.LocationBackendService#onClose()}.
     */

#Code:
    public synchronized void onClose() {
        if (state == State.DISABLED || state == State.DISABLING)
            throw new IllegalStateException("Do not call onClose if not opened before");
        if (state == State.WAITING) {
            state = State.DISABLED;
        } else {
            state = State.DISABLING;
        }
    }

#No. 459
#File: E:\bishe\1\AbstractBackendService.java
#Comment:
    /**
     * Called after a connection was setup
     */

#Code:
    protected void onOpen() {

    }

#No. 460
#File: E:\bishe\1\AbstractBackendService.java
#Comment:
    /**
     * Called before connection closure
     */

#Code:
    protected void onClose() {

    }

#No. 461
#File: E:\bishe\1\AbstractBahaviorHookCallBack.java
#Comment:
		/*int length = param.args.length;
		Object[] m = param.args;
		String args = "/";
		for(int i = 0; i < length;i++)
		{
			args+=(String)m[i]+"/";
		}*/

#Code:
		Logger.logD("Invoke "+ param.method.getDeclaringClass().getName()+"->"+param.method.getName());
		this.descParam(param);
		//this.printStackInfo();
	}

	@Override
	public void afterHookedMethod(HookParam param) {
		// TODO Auto-generated method stub
		//Logger.log_behavior("End Invoke "+ param.method.toString());
	}

#No. 462
#File: E:\bishe\1\AbstractBalancedBinarySearchTree.java
#Comment:
	/**
	 * Rotates the specific node to the left.
	 * @param node the node to be rotated.
	 */

#Code:
	protected void rotateLeft(N node)
	{
		N child = node.getRightChild();
		
		node.setRightChild(child.getLeftChild());
		
		if (node.hasParent())
			node.getParent().replaceChild(node, child);
		else
			setRoot(child);
		
		child.setLeftChild(node);
	}

#No. 463
#File: E:\bishe\1\AbstractBalancedBinarySearchTree.java
#Comment:
	/**
	 * Rotates the specific node to the right.
	 * @param node the node to be rotated.
	 */

#Code:
	protected void rotateRight(N node)
	{
		N child = node.getLeftChild();
		
		node.setLeftChild(child.getRightChild());
		
		if (node.hasParent())
			node.getParent().replaceChild(node, child);
		else
			setRoot(child);
		
		child.setRightChild(node);
	}

#No. 464
#File: E:\bishe\1\AbstractBankServiceTest.java
#Comment:
    /**
     * Tests that hashcode, equals and toString are not mapped to a remote
     * service
     */

#Code:
    @Test
    public void testNonMappedMethods() {
	assertTrue(bankService.equals(bankService));
	assertFalse(bankService.equals(this));
	assertEquals(bankService.hashCode(), bankService.hashCode());
	assertTrue(bankService.toString().contains(getExpectedServiceName()));
    }

#No. 465
#File: E:\bishe\1\AbstractBankServiceTest.java
#Comment:
    /**
     * Test mapping arguments to cookies
     */

#Code:
    @Test
    public void testCookieParams() throws Exception {
	// setup test
	response("recordedmessages/authenticate_response.txt");

	// execute test
	Customer customer = bankService.authenticate("Customer 1", "password",
		"1234");
	assertEquals("Customer 1", customer.getName());
	MockRequest request = requestFactory.getLastRequest();
	assertEquals(sget("recordedmessages/authenticate_request.txt"),
		request.serializeToString());
    }

#No. 466
#File: E:\bishe\1\AbstractBankServiceTest.java
#Comment:
    /**
     * Test a simple http GET
     */

#Code:
    @Test
    public void testPathVariables() throws Exception{
	// setup test
	response("recordedmessages/getaccount_response.txt");

	// execute test
	Account account = bankService.getAccount(1234);
	assertEquals("1234", account.getAccountNumber());
	assertEquals("Customer 1", account.getOwner().getName());
	
	// validate request
	MockRequest request = requestFactory.getLastRequest();
	assertEquals(sget("recordedmessages/getaccount_request.txt"),
		request.serializeToString());
	
    }

#No. 467
#File: E:\bishe\1\AbstractBankServiceTest.java
#Comment:
    /**
     * Tests that parameters can be passed as headers
     * @throws Exception
     */

#Code:
    @Test
    public void testArgumentToHeaders() throws Exception{
	// setup test
	response("recordedmessages/issessionalive_response.txt");

	// execute test
	boolean value = bankService.isSessionAlive("56789");
	assertEquals(true, value);

	// validate request
	MockRequest request = requestFactory.getLastRequest();
	assertEquals(sget("recordedmessages/issessionalive_request.txt"),
		request.serializeToString());
	
    }

#No. 468
#File: E:\bishe\1\AbstractBankServiceTest.java
#Comment:
    /**
     * Checks whether SPEL is resolved properly
     * @throws Exception
     */

#Code:
    @Test
    public void testSPEL() throws Exception{
	// setup test
	response("recordedmessages/doescustomerexist_response.txt");

	// execute test
	boolean value = bankService.doesCustomerExist("56789");
	assertEquals(true, value);

	// validate request
	MockRequest request = requestFactory.getLastRequest();
	assertEquals(sget("recordedmessages/doescustomerexist_request.txt"),
		request.serializeToString());
	
    }

#No. 469
#File: E:\bishe\1\AbstractBase32IDGenerator.java
#Comment:
    /**
     * 
     * @param processInstanceSeed   
     * @param len                   length of non seed component
     */

#Code:
    public AbstractBase32IDGenerator( ZString processInstanceSeed, int len ) {
        _prefix = processInstanceSeed.getBytes();
        
        _totalLen = len + _prefix.length;
        _prefixLen = _prefix.length;
        
        _counter = seed();
    }

#No. 470
#File: E:\bishe\1\AbstractBaseActivity.java
#Comment:
    /**
     */

#Code:
    public AbstractBaseActivity(final Application application) {
        super();
        this.application = application;
        this.shell = application.getShell();
        this.eventBus = application.getEventBus();
        this.requests = application.getRequestFactory();
        this.placeController = application.getPlaceController();
        this.currentPlace = placeController.getWhere();
        this.proxyFactory = application.getProxyFactory();
        this.validatorFactory = application.getValidatorFactory();
        this.i18n = application.getI18n();
    }

#No. 471
#File: E:\bishe\1\AbstractBaseActivity.java
#Comment:
    /**
     * 
     * @return
     */

#Code:
    protected Validator getValidator() {
        return validatorFactory.getValidator();
    }

#No. 472
#File: E:\bishe\1\AbstractBaseGraph.java
#Comment:
    /**
     * @see Graph#addEdge(Object, Object)
     */

#Code:
    public E addEdge(V sourceVertex, V targetVertex)
    {
        assertVertexExist(sourceVertex);
        assertVertexExist(targetVertex);

        if (!allowingMultipleEdges
            && containsEdge(sourceVertex, targetVertex))
        {
            return null;
        }

        if (!allowingLoops && sourceVertex.equals(targetVertex)) {
            throw new IllegalArgumentException(LOOPS_NOT_ALLOWED);
        }

        E e = edgeFactory.createEdge(sourceVertex, targetVertex);

        if (containsEdge(e)) { // this restriction should stay!

            return null;
        } else {
            IntrusiveEdge intrusiveEdge =
                createIntrusiveEdge(e, sourceVertex, targetVertex);

            edgeMap.put(e, intrusiveEdge);
            specifics.addEdgeToTouchingVertices(e);

            return e;
        }
    }

#No. 473
#File: E:\bishe\1\AbstractBaseGraph.java
#Comment:
    /**
     * @see Graph#addEdge(Object, Object, Object)
     */

#Code:
    public boolean addEdge(V sourceVertex, V targetVertex, E e)
    {
        if (e == null) {
            throw new NullPointerException();
        } else if (containsEdge(e)) {
            return false;
        }

        assertVertexExist(sourceVertex);
        assertVertexExist(targetVertex);

        if (!allowingMultipleEdges
            && containsEdge(sourceVertex, targetVertex))
        {
            return false;
        }

        if (!allowingLoops && sourceVertex.equals(targetVertex)) {
            throw new IllegalArgumentException(LOOPS_NOT_ALLOWED);
        }

        IntrusiveEdge intrusiveEdge =
            createIntrusiveEdge(e, sourceVertex, targetVertex);

        edgeMap.put(e, intrusiveEdge);
        specifics.addEdgeToTouchingVertices(e);

        return true;
    }

#No. 474
#File: E:\bishe\1\AbstractBaseGraph.java
#Comment:
    /**
     * @see Graph#addVertex(Object)
     */

#Code:
    public boolean addVertex(V v)
    {
        if (v == null) {
            throw new NullPointerException();
        } else if (containsVertex(v)) {
            return false;
        } else {
            specifics.addVertex(v);

            return true;
        }
    }

#No. 475
#File: E:\bishe\1\AbstractBaseGraph.java
#Comment:
    /**
     * @see Graph#getEdgeSource(Object)
     */

#Code:
    public V getEdgeSource(E e)
    {
        return TypeUtil.uncheckedCast(
            getIntrusiveEdge(e).source,
            vertexTypeDecl);
    }

#No. 476
#File: E:\bishe\1\AbstractBaseGraph.java
#Comment:
    /**
     * @see Graph#getEdgeTarget(Object)
     */

#Code:
    public V getEdgeTarget(E e)
    {
        return TypeUtil.uncheckedCast(
            getIntrusiveEdge(e).target,
            vertexTypeDecl);
    }

#No. 477
#File: E:\bishe\1\AbstractBaseGraph.java
#Comment:
    /**
     * Returns a shallow copy of this graph instance. Neither edges nor vertices
     * are cloned.
     *
     * @return a shallow copy of this set.
     *
     * @throws RuntimeException
     *
     * @see java.lang.Object#clone()
     */

#Code:
    public Object clone()
    {
        /*try {
            TypeUtil<AbstractBaseGraph<V, E>> typeDecl = null;

            AbstractBaseGraph<V, E> newGraph =
                TypeUtil.uncheckedCast(super.clone(), typeDecl);

            newGraph.edgeMap = new LinkedHashMap<E, IntrusiveEdge>();

            newGraph.edgeFactory = this.edgeFactory;
            newGraph.unmodifiableEdgeSet = null;
            newGraph.unmodifiableVertexSet = null;

            // NOTE:  it's important for this to happen in an object
            // method so that the new inner class instance gets associated with
            // the right outer class instance
            newGraph.specifics = newGraph.createSpecifics();

            Graphs.addGraph(newGraph, this);

            return newGraph;
        } catch (Throwable e) {
            e.printStackTrace();
            throw new RuntimeException();
        } */

        throw new RuntimeException("Clone is not supported");
    }

#No. 478
#File: E:\bishe\1\AbstractBaseGraph.java
#Comment:
    /**
     * @see Graph#containsEdge(Object)
     */

#Code:
    public boolean containsEdge(E e)
    {
        return edgeMap.containsKey(e);
    }

#No. 479
#File: E:\bishe\1\AbstractBaseGraph.java
#Comment:
    /**
     * @see Graph#containsVertex(Object)
     */

#Code:
    public boolean containsVertex(V v)
    {
        return specifics.getVertexSet().contains(v);
    }

#No. 480
#File: E:\bishe\1\AbstractBaseGraph.java
#Comment:
    /**
     * @see UndirectedGraph#degreeOf(Object)
     */

#Code:
    public int degreeOf(V vertex)
    {
        return specifics.degreeOf(vertex);
    }

#No. 481
#File: E:\bishe\1\AbstractBaseGraph.java
#Comment:
    /**
     * @see Graph#edgeSet()
     */

#Code:
    public Set<E> edgeSet()
    {
        if (unmodifiableEdgeSet == null) {
            unmodifiableEdgeSet = Collections.unmodifiableSet(edgeMap.keySet());
        }

        return unmodifiableEdgeSet;
    }

#No. 482
#File: E:\bishe\1\AbstractBaseGraph.java
#Comment:
    /**
     * @see Graph#edgesOf(Object)
     */

#Code:
    public Set<E> edgesOf(V vertex)
    {
        return specifics.edgesOf(vertex);
    }

#No. 483
#File: E:\bishe\1\AbstractBaseGraph.java
#Comment:
    /**
     * @see DirectedGraph#inDegreeOf(Object)
     */

#Code:
    public int inDegreeOf(V vertex)
    {
        return specifics.inDegreeOf(vertex);
    }

#No. 484
#File: E:\bishe\1\AbstractBaseGraph.java
#Comment:
    /**
     * @see DirectedGraph#incomingEdgesOf(Object)
     */

#Code:
    public Set<E> incomingEdgesOf(V vertex)
    {
        return specifics.incomingEdgesOf(vertex);
    }

#No. 485
#File: E:\bishe\1\AbstractBaseGraph.java
#Comment:
    /**
     * @see DirectedGraph#outDegreeOf(Object)
     */

#Code:
    public int outDegreeOf(V vertex)
    {
        return specifics.outDegreeOf(vertex);
    }

#No. 486
#File: E:\bishe\1\AbstractBaseGraph.java
#Comment:
    /**
     * @see DirectedGraph#outgoingEdgesOf(Object)
     */

#Code:
    public Set<E> outgoingEdgesOf(V vertex)
    {
        return specifics.outgoingEdgesOf(vertex);
    }

#No. 487
#File: E:\bishe\1\AbstractBaseGraph.java
#Comment:
    /**
     * @see Graph#removeEdge(Object, Object)
     */

#Code:
    public E removeEdge(V sourceVertex, V targetVertex)
    {
        E e = getEdge(sourceVertex, targetVertex);

        if (e != null) {
            specifics.removeEdgeFromTouchingVertices(e);
            edgeMap.remove(e);
        }

        return e;
    }

#No. 488
#File: E:\bishe\1\AbstractBaseGraph.java
#Comment:
    /**
     * @see Graph#removeEdge(Object)
     */

#Code:
    public boolean removeEdge(E e)
    {
        if (containsEdge(e)) {
            specifics.removeEdgeFromTouchingVertices(e);
            edgeMap.remove(e);

            return true;
        } else {
            return false;
        }
    }

#No. 489
#File: E:\bishe\1\AbstractBaseGraph.java
#Comment:
    /**
     * @see Graph#removeVertex(Object)
     */

#Code:
    public boolean removeVertex(V v)
    {
        if (containsVertex(v)) {
            Set<E> touchingEdgesList = edgesOf(v);

            // cannot iterate over list - will cause
            // ConcurrentModificationException
            removeAllEdges(new ArrayList<E>(touchingEdgesList));

            specifics.getVertexSet().remove(v); // remove the vertex itself

            return true;
        } else {
            return false;
        }
    }

#No. 490
#File: E:\bishe\1\AbstractBaseGraph.java
#Comment:
    /**
     * @see Graph#vertexSet()
     */

#Code:
    public Set<V> vertexSet()
    {
        if (unmodifiableVertexSet == null) {
            unmodifiableVertexSet =
                Collections.unmodifiableSet(specifics.getVertexSet());
        }

        return unmodifiableVertexSet;
    }

#No. 491
#File: E:\bishe\1\AbstractBaseGraph.java
#Comment:
    /**
     * @see Graph#getEdgeWeight(Object)
     */

#Code:
    public double getEdgeWeight(E e)
    {
        if (e instanceof DefaultWeightedEdge) {
            return ((DefaultWeightedEdge) e).getWeight();
        } else if (e == null) {
            throw new NullPointerException();
        } else {
            return WeightedGraph.DEFAULT_EDGE_WEIGHT;
        }
    }

#No. 492
#File: E:\bishe\1\AbstractBaseGraph.java
#Comment:
    /**
     * @see WeightedGraph#setEdgeWeight(Object, double)
     */

#Code:
    public void setEdgeWeight(E e, double weight)
    {
        assert (e instanceof DefaultWeightedEdge) : e.getClass();
        ((DefaultWeightedEdge) e).weight = weight;
    }

#No. 493
#File: E:\bishe\1\AbstractBaseGraph.java
#Comment:
        /**
         * @see EdgeSetFactory.createEdgeSet
         */

#Code:
        public Set<EE> createEdgeSet(VV vertex)
        {
            // NOTE:  use size 1 to keep memory usage under control
            // for the common case of vertices with low degree
            return new ArrayUnenforcedSet<EE>(1);
        }

#No. 494
#File: E:\bishe\1\AbstractBaseRedisDao.java
#Comment:
    /**
     * 设置redisTemplate
     */

#Code:
    public void setRedisTemplate(RedisTemplate<K, V> redisTemplate) {
        this.redisTemplate = redisTemplate;
    }

#No. 495
#File: E:\bishe\1\AbstractBaseRedisDao.java
#Comment:
    /**
     * 获取 RedisSerializer
     */

#Code:
    protected RedisSerializer<String> getRedisSerializer() {
        return redisTemplate.getStringSerializer();
    }

#No. 496
#File: E:\bishe\1\AbstractBaseRequest.java
#Comment:
    /**
     * CXF JAX-RS MessageContext
     */

#Code:
    public MessageContext messageContext;

    @Override
    public void setServletContext(final ServletContext servletContext) {
        this.servletContext = servletContext;
    }

#No. 497
#File: E:\bishe\1\AbstractBaseRequest.java
#Comment:
    /**
     * Convenience method for getting a i18n key's value. Calling
     * getMessageSourceAccessor() is used because the RequestContext variable is
     * not set in unit tests b/c there's no DispatchServlet Request.
     *
     * @param msgKey
     * @param locale
     *            the current locale
     * @return
     */

#Code:
    public String getText(final String msgKey, final Locale locale) {
        return messages.getMessage(msgKey, null, locale);
    }

#No. 498
#File: E:\bishe\1\AbstractBaseRequest.java
#Comment:
    /**
     * Convenience method for getting a i18n key's value with arguments.
     *
     * @param msgKey
     * @param args
     * @param locale
     *            the current locale
     * @return
     */

#Code:
    public String getText(final String msgKey, final Object[] args, final Locale locale) {
        return messages.getMessage(msgKey, args, locale);
    }

#No. 499
#File: E:\bishe\1\AbstractBaseRequest.java
#Comment:
    /**
     * Convenience message to send messages to users, includes app URL as
     * footer.
     * 
     * @param user
     *            the user to send a message to.
     * @param msg
     *            the message to send.
     * @param url
     *            the URL of the application.
     */

#Code:
    protected void sendUserMessage(final User user, final String templateName, final String msg, final String url) {
        if (log.isDebugEnabled()) {
            log.debug("sending e-mail to user [" + user.getEmail() + "]...");
        }

        message.setTo(user.getFullName() + "<" + user.getEmail() + ">");

        final Map<String, Serializable> model = new HashMap<String, Serializable>();
        model.put("user", user);

        // TODO: once you figure out how to get the global resource bundle in
        // WebWork, then figure it out here too. In the meantime, the Username
        // and Password labels are hard-coded into the template.
        // model.put("bundle", getTexts());
        model.put("message", msg);
        model.put("applicationURL", url);
        mailEngine.sendMessage(message, templateName, model);
    }

#No. 500
#File: E:\bishe\1\AbstractBaseRequest.java
#Comment:
    /**
     * 
     * @return
     */

#Code:
    protected HttpServletRequest getServletRequest() {
        final HttpServletRequest request = RequestFactoryServlet.getThreadLocalRequest();
        if (request == null) { // jax-rs
            return messageContext.getHttpServletRequest();
        }
        return request;
    }

#No. 501
#File: E:\bishe\1\AbstractBaseRequest.java
#Comment:
    /**
     * 
     * @return
     */

#Code:
    protected HttpServletResponse getServletResponse() {
        final HttpServletResponse response = RequestFactoryServlet.getThreadLocalResponse();
        if (response == null) { // jax-rs
            return messageContext.getHttpServletResponse();
        }
        return response;
    }

#No. 502
#File: E:\bishe\1\AbstractBaseSource.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public Extractor getExtractor(String propertyName) {
        Extractor extractor = m_extractors.get(propertyName);
        if (extractor == null) {
            extractor = createDefaultExtractor(propertyName);
            m_extractors.put(propertyName, extractor);
        }
        return extractor;
    }

#No. 503
#File: E:\bishe\1\AbstractBaseSource.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public void setExtractor(String propertyName, Extractor extractor) {
        m_extractors.put(propertyName, extractor);
    }

#No. 504
#File: E:\bishe\1\AbstractBaseSource.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public Source map(String targetField, String sourceField) {
        setExtractor(targetField, createDefaultExtractor(sourceField));
        return this;
    }

#No. 505
#File: E:\bishe\1\AbstractBaseSource.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public Source map(String targetField, Extractor sourceExtractor) {
        setExtractor(targetField, sourceExtractor);
        return this;
    }

#No. 506
#File: E:\bishe\1\AbstractBaseSource.java
#Comment:
    /**
     * Return a Resource represented by the specified location.
     *
     * @param location resource location
     *
     * @return a resource
     */

#Code:
    protected Resource getResource(String location) {
        return new DefaultResourceLoader().getResource(location);
    }

#No. 507
#File: E:\bishe\1\AbstractBaseSource.java
#Comment:
    /**
     * Create a reader for the specified resource.
     *
     * @param resource resource to create reader for
     *
     * @return reader for the specified resource
     */

#Code:
    protected Reader createResourceReader(Resource resource) {
        try {
            return new InputStreamReader(resource.getInputStream());
        }
        catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

#No. 508
#File: E:\bishe\1\AbstractBaseSource.java
#Comment:
    /**
     * A map of registered property extractors for this source.
     */

#Code:
    private Map<String, Extractor> m_extractors;
}
}

#No. 509
#File: E:\bishe\1\AbstractBaseTarget.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public void beginImport()
        {
        // default implementation
        }

#No. 510
#File: E:\bishe\1\AbstractBaseTarget.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public void endImport()
        {
        // default implementation
        }

#No. 511
#File: E:\bishe\1\AbstractBaseTarget.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public Updater getUpdater(String propertyName)
        {
        Updater updater = m_updaters.get(propertyName);
        if (updater == null)
            {
            updater = createDefaultUpdater(propertyName);
            m_updaters.put(propertyName, updater);
            }
        return updater;
        }

#No. 512
#File: E:\bishe\1\AbstractBaseTarget.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public void setUpdater(String targetProperty, Updater updater)
        {
        m_updaters.put(targetProperty, updater);
        }

#No. 513
#File: E:\bishe\1\AbstractBaseTarget.java
#Comment:
    /**
     * Returns a list of all writeable properties of a class.
     *
     * @param cls  class to obtain a list of writeable properties for
     *
     * @return a list of writeable properties of the specified class
     */

#Code:
    protected static List<PropertyDescriptor> getWriteableProperties(Class cls)
        {
        BeanWrapper beanWrapper = new BeanWrapperImpl(cls);
        List<PropertyDescriptor> writeableProperties =
                new ArrayList<PropertyDescriptor>();
        PropertyDescriptor[] props = beanWrapper.getPropertyDescriptors();
        for (PropertyDescriptor prop : props)
            {
            if (isWriteable(prop))
                {
                writeableProperties.add(prop);
                }
            }
        return writeableProperties;
        }

#No. 514
#File: E:\bishe\1\AbstractBaseTarget.java
#Comment:
    /**
     * Return true if the specified property is writeable, false otherwise.
     *
     * @param property  property to check
     *
     * @return true if the specified property is writeable, false otherwise
     */

#Code:
    private static boolean isWriteable(PropertyDescriptor property)
        {
        return property.getWriteMethod() != null;
        }

#No. 515
#File: E:\bishe\1\AbstractBaseTarget.java
#Comment:
    /**
     * A map of registered property updaters for this target.
     */

#Code:
    private Map<String, Updater> m_updaters;
    }
#No. 516
#File: E:\bishe\1\AbstractBasicDao.java
#Comment:
	/**
	 * 
	 * @param def - Definition of Websocket
	 * @param tablePrefix -  Provide a table prefix to use for complex queries. Ie. Joins Do not include the . at the end of the prefix
	 * @param extraProperties - Other SQL for use in Queries
	 */

#Code:
	@SuppressWarnings("unchecked")
	public AbstractBasicDao(WebSocketDefinition def, String tablePrefix, String[] extraProperties) {
		this((DaoNotificationWebSocketHandler<T>) (def != null ? def.getHandlerInstance() : null), tablePrefix, extraProperties,
				false, null);
	}

#No. 517
#File: E:\bishe\1\AbstractBasicDao.java
#Comment:
	/**
	 * Override as necessary Can be null if no Pk Exists
	 * 
	 * @return String name of Pk Column
	 */

#Code:
	public String getPkColumnName() {
		return "id";
	}

#No. 518
#File: E:\bishe\1\AbstractBasicDao.java
#Comment:
	/**
	 * Gets the row mapper for converting the retrieved database values into a
	 * VO object
	 * 
	 * @return row mapper
	 */

#Code:
	public abstract RowMapper<T> getRowMapper();

	/**
	 * Get a map of the Joined tables with table prefix --> Join SQL To be
	 * overridden as necessary
	 * 
	 * @return
	 */
	protected List<JoinClause> getJoins() {
		return new ArrayList<JoinClause>();
	}

#No. 519
#File: E:\bishe\1\AbstractBasicDao.java
#Comment:
	/**
	 * Optionally return a list of Indexes for this table for Query optimization
	 * 
	 * @return
	 */

#Code:
	protected List<Index> getIndexes() {
		return new ArrayList<Index>();
	}

#No. 520
#File: E:\bishe\1\AbstractBasicDao.java
#Comment:
	/**
	 * Persist the vo or if it already exists update it
	 * 
	 * @param vo
	 *            to save
	 */

#Code:
	public void save(T vo) {
		if (vo.getId() == Common.NEW_ID) {
			insert(vo);
		} else {
			update(vo);
		}
	}

#No. 521
#File: E:\bishe\1\AbstractBasicDao.java
#Comment:
	/**
	 * 
	 * @param vo
	 * @param initiatorId
	 */

#Code:
	public void save(T vo, String initiatorId) {
		if (vo.getId() == Common.NEW_ID) {
			insert(vo, initiatorId);
		} else {
			update(vo, initiatorId);
		}
	}

#No. 522
#File: E:\bishe\1\AbstractBasicDao.java
#Comment:
	/**
	 * Insert a new vo and assign the ID
	 * 
	 * @param vo
	 *            to insert
	 */

#Code:
	protected void insert(T vo) {
		int id = -1;
		if (insertStatementPropertyTypes == null)
			id = ejt.doInsert(INSERT, voToObjectArray(vo));
		else
			id = ejt.doInsert(INSERT, voToObjectArray(vo), insertStatementPropertyTypes);
		vo.setId(id);
		if(handler != null)
			handler.notify("add", vo, null);
		if(this.countMonitor != null)
			this.countMonitor.increment();
	}

#No. 523
#File: E:\bishe\1\AbstractBasicDao.java
#Comment:
	/**
	 * 
	 * @param vo
	 * @param initiatorId - For Websocket Notifications
	 */

#Code:
	protected void insert(T vo, String initiatorId) {
		int id = -1;
		if (insertStatementPropertyTypes == null)
			id = ejt.doInsert(INSERT, voToObjectArray(vo));
		else
			id = ejt.doInsert(INSERT, voToObjectArray(vo), insertStatementPropertyTypes);
		vo.setId(id);
		if(handler != null)
			handler.notify("add", vo, initiatorId);
		if(this.countMonitor != null)
			this.countMonitor.increment();
	}

#No. 524
#File: E:\bishe\1\AbstractBasicDao.java
#Comment:
	/**
	 * Update a vo
	 *
	 * @param vo
	 *            to update
	 */

#Code:
	protected void update(T vo) {
		List<Object> list = new ArrayList<>();
		list.addAll(Arrays.asList(voToObjectArray(vo)));
		list.add(vo.getId());

		if (updateStatementPropertyTypes == null)
			ejt.update(UPDATE, list.toArray());
		else
			ejt.update(UPDATE, list.toArray(), updateStatementPropertyTypes);
		if(handler != null)
			handler.notify("update", vo, null);
	}

#No. 525
#File: E:\bishe\1\AbstractBasicDao.java
#Comment:
	/**
	 * 
	 * @param vo
	 * @param initiatorId
	 */

#Code:
	protected void update(T vo, String initiatorId) {
		List<Object> list = new ArrayList<>();
		list.addAll(Arrays.asList(voToObjectArray(vo)));
		list.add(vo.getId());

		if (updateStatementPropertyTypes == null)
			ejt.update(UPDATE, list.toArray());
		else
			ejt.update(UPDATE, list.toArray(), updateStatementPropertyTypes);
		if(handler != null)
			handler.notify("update", vo, initiatorId);
	}

#No. 526
#File: E:\bishe\1\AbstractBasicDao.java
#Comment:
	/**
	 * Return a VO with FKs populated
	 * 
	 * @param id
	 * @return
	 */

#Code:
	public T getFull(int id) {
		return get(id);
	}

#No. 527
#File: E:\bishe\1\AbstractBasicDao.java
#Comment:
	/**
	 * Get All from table
	 * 
	 * @return
	 */

#Code:
	public List<T> getAll() {
		return query(SELECT_ALL_FIXED_SORT, getRowMapper());
	}

#No. 528
#File: E:\bishe\1\AbstractBasicDao.java
#Comment:
	/**
	 * Count all from table
	 * 
	 * @return
	 */

#Code:
	public int count() {
		return ejt.queryForInt(COUNT, new Object[0], 0);
	}

#No. 529
#File: E:\bishe\1\AbstractBasicDao.java
#Comment:
	/**
	 * Return all VOs with FKs Populated
	 * 
	 * @return
	 */

#Code:
	public List<T> getAllFull() {
		return getAll();
	}

#No. 530
#File: E:\bishe\1\AbstractBasicDao.java
#Comment:
	/**
	 * 
	 * @param root
	 * @param selectCallback
	 * @param countCallback
	 * @param modelMap
	 * @param modifiers
	 * @param applyLimitToSelectSql
	 * @return
	 */

#Code:
	public StreamableSqlQuery<T> createQuery(ASTNode root, StreamableRowCallback<T> selectCallback,
			StreamableRowCallback<Long> countCallback, Map<String, String> modelMap,
			Map<String, SQLColumnQueryAppender> modifiers, boolean applyLimitToSelectSql) {

		SQLStatement statement;
		if (useSubQuery) {
			statement = new SQLSubQuery(SELECT_ALL_BASE, COUNT_BASE, joins, getTableName(), TABLE_PREFIX,
					applyLimitToSelectSql, Common.envProps.getBoolean("db.forceUseIndex", false), null, this.indexes, this.databaseType);
		} else {
			statement = new SQLStatement(SELECT_ALL_BASE, COUNT_BASE, joins, getTableName(), TABLE_PREFIX,
					applyLimitToSelectSql, Common.envProps.getBoolean("db.forceUseIndex", false), this.indexes, this.databaseType);
		}
		if (root != null)
			root.accept(new RQLToSQLSelect<T>(this, modelMap, modifiers), statement);

		statement.build();
		return new StreamableSqlQuery<T>(this, Common.envProps.getBoolean("db.stream", false), statement, selectCallback, countCallback);
	}

#No. 531
#File: E:\bishe\1\AbstractBasicDao.java
#Comment:
	/**
	 * 
	 * @param root
	 * @param applyLimitToSelectSql
	 * @return
	 */

#Code:
	public BaseSqlQuery<T> createQuery(ASTNode root, boolean applyLimitToSelectSql) {

		SQLStatement statement = new SQLStatement(SELECT_ALL_BASE, COUNT_BASE, joins, getTableName(), TABLE_PREFIX,
				applyLimitToSelectSql, Common.envProps.getBoolean("db.forceUseIndex", false), this.indexes, this.databaseType);
		if (root != null)
			root.accept(new RQLToSQLSelect<T>(this), statement);

		statement.build();
		return new BaseSqlQuery<T>(this, statement);
	}

#No. 532
#File: E:\bishe\1\AbstractBasicDao.java
#Comment:
	/**
	 * @return
	 */

#Code:
	public TableModel getTableModel() {
		return tableModel;
	}

#No. 533
#File: E:\bishe\1\AbstractBasicDao.java
#Comment:
	/**
	 * @param argument
	 * @return
	 */

#Code:
	public SQLQueryColumn getQueryColumn(String prop) {
		boolean mapped = false;

		Set<String> properties = this.propertyTypeMap.keySet();
		String dbCol = prop;

		Integer sqlType;
		if (propertiesMap.containsKey(prop)) {
			IntStringPair pair = propertiesMap.get(prop);
			dbCol = pair.getValue();
			sqlType = pair.getKey();
			mapped = true;
		} else {
			sqlType = this.propertyTypeMap.get(dbCol);
		}

		if (mapped || properties.contains(dbCol)) {
			if (mapped)
				return new SQLQueryColumn(dbCol, sqlType);
			else
				return new SQLQueryColumn(this.tablePrefix + dbCol, sqlType);
		}

		// No Column matches...
		throw new ShouldNeverHappenException("No column found for: " + prop);
	}

#No. 534
#File: E:\bishe\1\AbstractBasicDao.java
#Comment:
	/**
	 * Helper to prepare a statement
	 * 
	 * @param sql
	 * @param args
	 * @return
	 * @throws SQLException
	 */

#Code:
	public PreparedStatement createPreparedStatement(String sql, List<Object> args, boolean stream) throws SQLException {
		
		PreparedStatement stmt;
		if(stream){
			if(this.databaseType == DatabaseType.MYSQL){
				stmt = this.dataSource.getConnection().prepareStatement(sql, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);
				stmt.setFetchSize(Integer.MIN_VALUE);
			}else{
				//TODO Choose settings for other types to stream
				stmt = this.dataSource.getConnection().prepareStatement(sql);
			}
		}else{
			stmt = this.dataSource.getConnection().prepareStatement(sql);
			int fetchSize = Common.envProps.getInt("db.fetchSize", -1);
			if(fetchSize > 0)
				stmt.setFetchSize(fetchSize);
		}


		
		int index = 1;
		for (Object o : args) {
			stmt.setObject(index, o);
			index++;
		}

		return stmt;
	}

#No. 535
#File: E:\bishe\1\AbstractBasicDao.java
#Comment:
	/**
	 * Get the Select statement up to just before the FROM 'table'
	 * @return
	 */

#Code:
	public String getSelectBaseSql(){
		return SELECT_ALL_BASE;
	}

#No. 536
#File: E:\bishe\1\AbstractBasicDao.java
#Comment:
	/**
	 * Get the Select All Statment to be used with row mapper
	 * @return
	 */

#Code:
	public String getSelectAllSql(){
		return SELECT_ALL;
	}

#No. 537
#File: E:\bishe\1\AbstractBasicDao.java
#Comment:
	/**
	 * Get the Insert SQL Statement
	 * @return
	 */

#Code:
	public String getInsertSql(){
		return INSERT;
	}

#No. 538
#File: E:\bishe\1\AbstractBasicDao.java
#Comment:
	/**
	 * Get the Update SQL Statement
	 * @return
	 */

#Code:
	public String getUpdateSql(){
		return UPDATE;
	}

#No. 539
#File: E:\bishe\1\AbstractBasicDao.java
#Comment:
	/**
	 * Get the count statment
	 * @return
	 */

#Code:
	public String getCountSql(){
		return COUNT;
	}

#No. 540
#File: E:\bishe\1\AbstractBasicDwr.java
#Comment:
    /**
     * Get a VO 
     * @param id
     * @return
     */

#Code:
    @DwrPermission(user = true)
    public ProcessResult get(int id) {
        VO vo = dao.get(id);
        ProcessResult response = new ProcessResult();
        response.addData("vo", vo);
        
        return response;
    }

#No. 541
#File: E:\bishe\1\AbstractBasicDwr.java
#Comment:
    /**
     * Get a VO with FK values populated
     * @param id
     * @return
     */

#Code:
    @DwrPermission(user = true)
    public ProcessResult getFull(int id) {
        VO vo = dao.getFull(id);
        ProcessResult response = new ProcessResult();
        response.addData("vo", vo);
        
        return response;
    }

#No. 542
#File: E:\bishe\1\AbstractBasicDwr.java
#Comment:
    /**
     * Load a list of VOs
     * @return
     */

#Code:
    @DwrPermission(user = true)
    public ProcessResult load() {
        ProcessResult response = new ProcessResult();
        
        List<VO> voList = dao.getAll();
        response.addData("list", voList);
                
        return response;
    }

#No. 543
#File: E:\bishe\1\AbstractBasicDwr.java
#Comment:
    /**
     * Load a list of VOs
     * with the FK values populated
     * @return
     */

#Code:
    @DwrPermission(user = true)
    public ProcessResult loadFull() {
        ProcessResult response = new ProcessResult();
        
        List<VO> voList = dao.getAllFull();
        response.addData("list", voList);
                
        return response;
    }

#No. 544
#File: E:\bishe\1\AbstractBasicDwr.java
#Comment:
    /**
     * Load a list of VOs
     * @return
     */

#Code:
    @DwrPermission(user = true)
    public ProcessResult dojoQuery(Map<String, String> query, List<SortOption> sort, Integer start, Integer count, boolean or) {
        ProcessResult response = new ProcessResult();
        
        ResultsWithTotal results = dao.dojoQuery(query, sort, start, count, or);
        response.addData("list", results.getResults());
        response.addData("total", results.getTotal());
        
        return response;
    }

#No. 545
#File: E:\bishe\1\AbstractBasicMojo.java
#Comment:
  /**
   * Documentation
   */

#Code:
  @Parameter
  private String parameter;

}
}

#No. 546
#File: E:\bishe\1\AbstractBasicVO.java
#Comment:
    /*
     * Mango properties
     */

#Code:
    protected int id = Common.NEW_ID;

    public int getId() {
        return id;
    }

#No. 547
#File: E:\bishe\1\AbstractBasicVO.java
#Comment:
    /**
     * Useful For Debugging
     */

#Code:
    @Override
    public String toString() {
        return "id: " + this.id;
    }

#No. 548
#File: E:\bishe\1\AbstractBasicVoModel.java
#Comment:
	/**
	 * @param data
	 */

#Code:
	public AbstractBasicVoModel(T data) {
		super(data);
	}

#No. 549
#File: E:\bishe\1\AbstractBasiliskClass.java
#Comment:
    /**
     * Returns an array of property names that are backed by a filed with a matching
     * name.<p>
     * Fields must be private and non-static. Names will be returned in the order
     * they are declared in the class, starting from the deepest class in the
     * class hierarchy up to the topmost superclass != null
     */

#Code:
    public String[] getPropertiesWithFields() {
        return classPropertyFetcher.getPropertiesWithFields();
    }

#No. 550
#File: E:\bishe\1\AbstractBasiliskClass.java
#Comment:
    /**
     * <p>Looks for a property of the reference instance with a given name and type.</p>
     * <p>If found its value is returned. We follow the Java bean conventions with augmentation for groovy support
     * and static fields/properties. We will therefore match, in this order:
     * </p>
     * <ol>
     * <li>Public static field
     * <li>Public static property with getter method
     * <li>Standard public bean property (with getter or just public field, using normal introspection)
     * </ol>
     *
     * @return property value or null if no property or static field was found
     */

#Code:
    protected Object getPropertyOrStaticPropertyOrFieldValue(@SuppressWarnings("hiding") @Nonnull String name, @Nonnull Class<?> type) {
        requireNonBlank(name, ERROR_NAME_BLANK);
        requireNonNull(type, ERROR_TYPE_NULL);
        Object value = classPropertyFetcher.getPropertyValue(name);
        return classPropertyFetcher.returnOnlyIfInstanceOf(value, type);
    }
}
}

#No. 551
#File: E:\bishe\1\AbstractBatcher.java
#Comment:
    /**
     * To be called after construction of any subclass to instantiate the batching thread.
     */

#Code:
    protected AbstractBatcher<T> start() {
        batchService.submit(new BatchRunnable());
        return this;
    }

#No. 552
#File: E:\bishe\1\AbstractBatcher.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final boolean add(T item) {
        checkNotNull(item);
        checkState(!isClosed, "The batcher has been closed");

        return backingQueue.offer(item);
    }

#No. 553
#File: E:\bishe\1\AbstractBatcher.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final boolean add(T item, long timeout, TimeUnit unit) throws InterruptedException {
        checkNotNull(item);
        checkNotNull(unit);
        checkState(!isClosed, "The batcher has been closed");

        return backingQueue.offer(item, timeout, unit);
    }

#No. 554
#File: E:\bishe\1\AbstractBatcher.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final boolean addOrWait(T item) throws InterruptedException {
        checkNotNull(item);
        checkState(!isClosed, "The batcher has been closed");

        backingQueue.put(item);
        return true;
    }

#No. 555
#File: E:\bishe\1\AbstractBatcher.java
#Comment:
    /**
     * Used to shutdown the batching thread in case of an error or user requested close.
     */

#Code:
    private void stopRunnable() {
        isClosed = true;
        //Force an interrupt on running thread and shutdown executor cleanly.
        batchService.shutdownNow();
    }

#No. 556
#File: E:\bishe\1\AbstractBatcher.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public void close() {
        stopRunnable();
        try {
            batchService.awaitTermination(MAX_VALUE, MILLISECONDS);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }

        handler.shutdown();
        try {
            handler.awaitTermination(MAX_VALUE, MILLISECONDS);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    }

#No. 557
#File: E:\bishe\1\AbstractBatcher.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public List<T> closeAndFlush() {
        close();
        //Must wait until after close to drain
        ArrayList<T> remaining = new ArrayList<>();
        backingQueue.drainTo(remaining);

        return remaining;
    }

#No. 558
#File: E:\bishe\1\AbstractBeanConverter.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final boolean match(Class<?> sourceClass, Class<?> targetClass) {
        return isMatchingSource(sourceClass) && isMatchingTarget(targetClass);
    }

#No. 559
#File: E:\bishe\1\AbstractBeanPropertyBinder.java
#Comment:
	/**
	 * Helper class returned from the
	 * {@link AbstractBeanPropertyBinder#convertFrom} method.
	 */

#Code:
	protected static class Conversion
	{
		public final Object result;

		public Conversion(Object result)
		{
			this.result = result;
		}
	}

#No. 560
#File: E:\bishe\1\AbstractBeanPropertyValueBinder.java
#Comment:
/**
 * Abstract {@link IValueBinder} implementation. Exists for ease of subclassing.
 * 
 * @author Michael de Hoog (michael.dehoog@ga.gov.au)
 */

#Code:
public abstract class AbstractBeanPropertyValueBinder extends
		AbstractBeanPropertyBinder<String, Object, Value<?>> implements IValueBinder<Object>
{
}

#No. 561
#File: E:\bishe\1\AbstractBillingActivity.java
#Comment:
	/**
	 * <p>
	 * Returns the in-app product billing support status, and checks it
	 * asynchronously if it is currently unknown.
	 * {@link AbstractBillingActivity#onBillingChecked(boolean)} will be called
	 * eventually with the result.
	 * </p>
	 * <p>
	 * In-app product support does not imply subscription support. To check if
	 * subscriptions are supported, use
	 * {@link AbstractBillingActivity#checkSubscriptionSupported()}.
	 * </p>
	 * 
	 * @return the current in-app product billing support status (unknown,
	 *         supported or unsupported). If it is unsupported, subscriptions
	 *         are also unsupported.
	 * @see AbstractBillingActivity#onBillingChecked(boolean)
	 * @see AbstractBillingActivity#checkSubscriptionSupported()
	 */

#Code:
	public BillingStatus checkBillingSupported() {
		return BillingController.checkBillingSupported(this);
	}

#No. 562
#File: E:\bishe\1\AbstractBillingActivity.java
#Comment:
	/**
	 * <p>
	 * Returns the subscription billing support status, and checks it
	 * asynchronously if it is currently unknown.
	 * {@link AbstractBillingActivity#onSubscriptionChecked(boolean)} will be
	 * called eventually with the result.
	 * </p>
	 * <p>
	 * No support for subscriptions does not imply that in-app products are also
	 * unsupported. To check if subscriptions are supported, use
	 * {@link AbstractBillingActivity#checkSubscriptionSupported()}.
	 * </p>
	 * 
	 * @return the current in-app product billing support status (unknown,
	 *         supported or unsupported). If it is unsupported, subscriptions
	 *         are also unsupported.
	 * @see AbstractBillingActivity#onBillingChecked(boolean)
	 * @see AbstractBillingActivity#checkSubscriptionSupported()
	 */

#Code:
	public BillingStatus checkSubscriptionSupported() {
		return BillingController.checkSubscriptionSupported(this);
	}

#No. 563
#File: E:\bishe\1\AbstractBillingActivity.java
#Comment:
	/**
	 * Requests the purchase of the specified item. The transaction will not be
	 * confirmed automatically; such confirmation could be handled in
	 * {@link AbstractBillingActivity#onPurchaseExecuted(String)}. If automatic
	 * confirmation is preferred use
	 * {@link BillingController#requestPurchase(android.content.Context, String, boolean)}
	 * instead.
	 * 
	 * @param itemId
	 *            id of the item to be purchased.
	 */

#Code:
	public void requestPurchase(String itemId) {
		BillingController.requestPurchase(this, itemId);
	}

#No. 564
#File: E:\bishe\1\AbstractBillingActivity.java
#Comment:
	/**
	 * Requests the purchase of the specified subscription item. The transaction
	 * will not be confirmed automatically; such confirmation could be handled
	 * in {@link AbstractBillingActivity#onPurchaseExecuted(String)}. If
	 * automatic confirmation is preferred use
	 * {@link BillingController#requestPurchase(android.content.Context, String, boolean)}
	 * instead.
	 * 
	 * @param itemId
	 *            id of the item to be purchased.
	 */

#Code:
	public void requestSubscription(String itemId) {
		BillingController.requestSubscription(this, itemId);
	}

#No. 565
#File: E:\bishe\1\AbstractBillingActivity.java
#Comment:
	/**
	 * Requests to restore all transactions.
	 */

#Code:
	public void restoreTransactions() {
		BillingController.restoreTransactions(this);
	}

#No. 566
#File: E:\bishe\1\AbstractBillingFragment.java
#Comment:
	/**
	 * <p>
	 * Returns the in-app product billing support status, and checks it
	 * asynchronously if it is currently unknown.
	 * {@link AbstractBillingActivity#onBillingChecked(boolean)} will be called
	 * eventually with the result.
	 * </p>
	 * <p>
	 * In-app product support does not imply subscription support. To check if
	 * subscriptions are supported, use
	 * {@link AbstractBillingActivity#checkSubscriptionSupported()}.
	 * </p>
	 * 
	 * @return the current in-app product billing support status (unknown,
	 *         supported or unsupported). If it is unsupported, subscriptions
	 *         are also unsupported.
	 * @see AbstractBillingActivity#onBillingChecked(boolean)
	 * @see AbstractBillingActivity#checkSubscriptionSupported()
	 */

#Code:
	public BillingStatus checkBillingSupported() {
		return BillingController.checkBillingSupported(getActivity());
	}

#No. 567
#File: E:\bishe\1\AbstractBillingFragment.java
#Comment:
	/**
	 * <p>
	 * Returns the subscription billing support status, and checks it
	 * asynchronously if it is currently unknown.
	 * {@link AbstractBillingActivity#onSubscriptionChecked(boolean)} will be
	 * called eventually with the result.
	 * </p>
	 * <p>
	 * No support for subscriptions does not imply that in-app products are also
	 * unsupported. To check if subscriptions are supported, use
	 * {@link AbstractBillingActivity#checkSubscriptionSupported()}.
	 * </p>
	 * 
	 * @return the current in-app product billing support status (unknown,
	 *         supported or unsupported). If it is unsupported, subscriptions
	 *         are also unsupported.
	 * @see AbstractBillingActivity#onBillingChecked(boolean)
	 * @see AbstractBillingActivity#checkSubscriptionSupported()
	 */

#Code:
	public BillingStatus checkSubscriptionSupported() {
		return BillingController.checkSubscriptionSupported(getActivity());
	}

#No. 568
#File: E:\bishe\1\AbstractBillingFragment.java
#Comment:
	/**
	 * Requests the purchase of the specified item. The transaction will not be
	 * confirmed automatically; such confirmation could be handled in
	 * {@link AbstractBillingActivity#onPurchaseExecuted(String)}. If automatic
	 * confirmation is preferred use
	 * {@link BillingController#requestPurchase(android.content.Context, String, boolean)}
	 * instead.
	 * 
	 * @param itemId
	 *            id of the item to be purchased.
	 */

#Code:
	public void requestPurchase(String itemId) {
		BillingController.requestPurchase(getActivity(), itemId);
	}

#No. 569
#File: E:\bishe\1\AbstractBillingFragment.java
#Comment:
	/**
	 * Requests the purchase of the specified subscription item. The transaction
	 * will not be confirmed automatically; such confirmation could be handled
	 * in {@link AbstractBillingActivity#onPurchaseExecuted(String)}. If
	 * automatic confirmation is preferred use
	 * {@link BillingController#requestPurchase(android.content.Context, String, boolean)}
	 * instead.
	 * 
	 * @param itemId
	 *            id of the item to be purchased.
	 */

#Code:
	public void requestSubscription(String itemId) {
		BillingController.requestSubscription(getActivity(), itemId);
	}

#No. 570
#File: E:\bishe\1\AbstractBillingFragment.java
#Comment:
	/**
	 * Requests to restore all transactions.
	 */

#Code:
	public void restoreTransactions() {
		BillingController.restoreTransactions(getActivity());
	}

#No. 571
#File: E:\bishe\1\AbstractBiMap.java
#Comment:
/**
 * A general-purpose bimap implementation using any two backing {@code Map}
 * instances.
 *
 * <p>Note that this class contains {@code equals()} calls that keep it from
 * supporting {@code IdentityHashMap} backing maps.
 *
 * @author Kevin Bourrillion
 * @author Mike Bostock
 */

#Code:
@GwtCompatible(emulated = true)
abstract class AbstractBiMap<K, V> extends ForwardingMap<K, V>
    implements BiMap<K, V>, Serializable {

  private transient Map<K, V> delegate;
  transient AbstractBiMap<V, K> inverse;

  /** Package-private constructor for creating a map-backed bimap. */
  AbstractBiMap(Map<K, V> forward, Map<V, K> backward) {
    setDelegates(forward, backward);
  }

  /** Private constructor for inverse bimap. */
  private AbstractBiMap(Map<K, V> backward, AbstractBiMap<V, K> forward) {
    delegate = backward;
    inverse = forward;
  }

  @Override protected Map<K, V> delegate() {
    return delegate;
  }

#No. 572
#File: E:\bishe\1\AbstractBiMap.java
#Comment:
  /**
   * Returns its input, or throws an exception if this is not a valid key.
   */

#Code:
  K checkKey(@Nullable K key) {
    return key;
  }

  /**
   * Returns its input, or throws an exception if this is not a valid value.
   */
  V checkValue(@Nullable V value) {
    return value;
  }

  /**
   * Specifies the delegate maps going in each direction. Called by the
   * constructor and by subclasses during deserialization.
   */
  void setDelegates(Map<K, V> forward, Map<V, K> backward) {
    checkState(delegate == null);
    checkState(inverse == null);
    checkArgument(forward.isEmpty());
    checkArgument(backward.isEmpty());
    checkArgument(forward != backward);
    delegate = forward;
    inverse = new Inverse<V, K>(backward, this);
  }

#No. 573
#File: E:\bishe\1\AbstractBiMap.java
#Comment:
      /*
       * Remove the mapping in inverse before removing from esDelegate because
       * if entry is part of esDelegate, entry might be invalidated after the
       * mapping is removed from esDelegate.
       */

#Code:
      esDelegate.remove(entry);
      return true;
    }

    @Override public Iterator<Entry<K, V>> iterator() {
      final Iterator<Entry<K, V>> iterator = esDelegate.iterator();
      return new Iterator<Entry<K, V>>() {
        Entry<K, V> entry;

        @Override public boolean hasNext() {
          return iterator.hasNext();
        }

#No. 574
#File: E:\bishe\1\AbstractBiMap.java
#Comment:
    /*
     * Serialization stores the forward bimap, the inverse of this inverse.
     * Deserialization calls inverse() on the forward bimap and returns that
     * inverse.
     *
     * If a bimap and its inverse are serialized together, the deserialized
     * instances have inverse() methods that return the other.
     */

#Code:

    @Override
    K checkKey(K key) {
      return inverse.checkValue(key);
    }

#No. 575
#File: E:\bishe\1\AbstractBiMap.java
#Comment:
    /**
     * @serialData the forward bimap
     */

#Code:
    @GwtIncompatible("java.io.ObjectOuputStream")
    private void writeObject(ObjectOutputStream stream) throws IOException {
      stream.defaultWriteObject();
      stream.writeObject(inverse());
    }

#No. 576
#File: E:\bishe\1\AbstractBinaryDecoder.java
#Comment:
    /**
     * the caller should of already checked the fixVersion and len, so skip tags 8 and 9 
     * 
     * @param fixMsg
     * @param offset
     * @param maxIdx
     * @return
     */

#Code:
    @Override
    public abstract int parseHeader( final byte[] fixMsg, final int offset, final int bytesRead );

    @Override
    public final ResyncCode resync( final byte[] fixMsg, final int offset, final int maxIdx ) {

        throwDecodeException( "Binary protocols dont support resync after corrupt message" );
        
        return null; 
    }

#No. 577
#File: E:\bishe\1\AbstractBinaryFactory.java
#Comment:
  /**
   * Advanced protocols - compare and swap functionality
   */

#Code:

  @Override
  public CompareAndSwapProtocol getCompareAndSwapProtocol(SBool[] left, SBool[] right) {
    return new CompareAndSwapProtocolImpl(left, right, this);
  }

#No. 578
#File: E:\bishe\1\AbstractBinaryFactory.java
#Comment:
  /**
   * simple protocols - basic functionality
   */

#Code:
  @Override
  public SBool[] getSBools(int amount) {
    SBool[] res = new SBool[amount];
    for (int i = 0; i < amount; i++) {
      res[i] = this.getSBool();
    }
    return res;
  }

#No. 579
#File: E:\bishe\1\AbstractBinaryFactory.java
#Comment:
  /**
   * Advanced protocols - addition
   */

#Code:

  @Override
  public OneBitFullAdderProtocol getOneBitFullAdderProtocol(SBool left, SBool right, SBool carry,
      SBool outS,
      SBool outCarry) {
    return new OneBitFullAdderProtocolImpl(left, right, carry, outS, outCarry, this);
  }

#No. 580
#File: E:\bishe\1\AbstractBinaryFactory.java
#Comment:
  /**
   * Advanced protocols - multiplication
   */

#Code:

  @Override
  public BinaryMultProtocol getBinaryMultProtocol(SBool[] lefts, SBool[] rights, SBool[] outs) {
    return new BinaryMultProtocolImpl(lefts, rights, outs, this, this);
  }

#No. 581
#File: E:\bishe\1\AbstractBinaryFactory.java
#Comment:
  /**
   * Advanced protocols - comparisons
   */

#Code:

  @Override
  public BinaryGreaterThanProtocol getBinaryComparisonProtocol(SBool[] inLeft, SBool[] inRight,
      SBool out) {
    return new BinaryGreaterThanProtocolImpl(inLeft, inRight, out, this);
    // return new BinaryComparisonprotocolNextProtocolsImpl(inLeft, inRight, out,
    // this);
    // return new GenericBinaryComparisonprotocol2(this, inLeft, inRight,
    // out);
  }

#No. 582
#File: E:\bishe\1\AbstractBinaryFactory.java
#Comment:
  /**
   * Advanced protocols - sorting
   */

#Code:

  @Override
  public OddEvenMergeProtocol getOddEvenMergeProtocol(List<Pair<SBool[], SBool[]>> left,
      List<Pair<SBool[], SBool[]>> right, List<Pair<SBool[], SBool[]>> sorted) {
    return new OddEvenMergeProtocolRec(left, right, sorted, this);
  }

#No. 583
#File: E:\bishe\1\AbstractBinaryFunction.java
#Comment:
/** An abstract function requires two arguments in X.
 * @author uniker9
 *
 * @param <X> A set forms a field.
 */

#Code:
public abstract class AbstractBinaryFunction<X extends Field<X>> extends
		DifferentialFunction<X> {

	private DifferentialFunction<X> m_x1;
	private DifferentialFunction<X> m_x2;

	/** Constructs a new AbstractBinaryFunction.
	 * @param i_v1 the 1st (left) argument.
	 * @param i_v2 the 2nd (right) argument.
	 */
	public AbstractBinaryFunction(DifferentialFunction<X> i_v1,
			DifferentialFunction<X> i_v2) {

		if (i_v1 != null && i_v2 != null) {
			m_x1 = i_v1;
			m_x2 = i_v2;
		} else {
			throw new IllegalArgumentException("Input not null variables.");
		}
	}
	
	/** Returns the 1st (left) argument of this function.
	 * @return the 1st (left) argument.
	 */
	public DifferentialFunction<X> larg() {
		return m_x1;
	}
	/** Returns the 2nd (right) argument of this function.
	 * @return the 2nd (right) argument.
	 */
	public DifferentialFunction<X> rarg() {
		return m_x2;
	}
}
#No. 584
#File: E:\bishe\1\AbstractBinaryMemcacheDecoder.java
#Comment:
    /**
     * Contains all states this decoder can possibly be in.
     * <p/>
     * Note that most of the states can be optional, the only one required is reading
     * the header ({@link #READ_HEADER}. All other steps depend on the length fields
     * in the header and will be executed conditionally.
     */

#Code:
    enum State {
        /**
         * Currently reading the header portion.
         */
        READ_HEADER,

        /**
         * Currently reading the extras portion (optional).
         */
        READ_EXTRAS,

        /**
         * Currently reading the key portion (optional).
         */
        READ_KEY,

        /**
         * Currently reading the value chunks (optional).
         */
        READ_CONTENT,

        /**
         * Something went wrong while decoding the message or chunks.
         */
        BAD_MESSAGE
    }

#No. 585
#File: E:\bishe\1\AbstractBinaryProcessor.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public Object process(InvocableMap.Entry entry) {
        return process((BinaryEntry) entry);
    }

#No. 586
#File: E:\bishe\1\AbstractBinaryProcessor.java
#Comment:
    /**
     * Return PofContext to use.
     *
     * @return PofContext to use
     */

#Code:
    public PofContext getPofContext() {
        return pofContext;
    }

#No. 587
#File: E:\bishe\1\AbstractBinaryProcessor.java
#Comment:
    /**
     * Return binary value with the specified name.
     *
     * @param name name of the binary value
     *
     * @return binary value with the specified name
     */

#Code:
    protected Binary getBinaryValue(String name) {
        return binValues.get(name);
    }

#No. 588
#File: E:\bishe\1\AbstractBinaryProcessor.java
#Comment:
    /**
     * Associate binary value with the specified name.
     *
     * @param name  name to associate value with
     * @param value binary value
     */

#Code:
    protected void setBinaryValue(String name, Binary value) {
        binValues.put(name, value);
    }

#No. 589
#File: E:\bishe\1\AbstractBinaryProcessor.java
#Comment:
    /**
     * Return PofValue for the specified binary value.
     *
     * @param binValue binary value to parse
     *
     * @return parsed PofValue
     */

#Code:
    protected PofValue getPofValue(Binary binValue) {
        return PofValueParser.parse(binValue, pofContext);
    }

#No. 590
#File: E:\bishe\1\AbstractBinaryProcessor.java
#Comment:
    /**
     * Return PofValue for the specified binary value's name.
     *
     * @param name name of the binary value to parse
     *
     * @return parsed PofValue
     *
     * @see #setBinaryValue(String, Binary)
     */

#Code:
    protected PofValue getPofValue(String name) {
        return getPofValue(getBinaryValue(name));
    }

#No. 591
#File: E:\bishe\1\AbstractBinaryProcessor.java
#Comment:
    /**
     * Return deserialized object for the specified binary value.
     *
     * @param binValue binary value to deserialize
     *
     * @return deserialized object
     */

#Code:
    protected Object fromBinary(Binary binValue) {
        return ExternalizableHelper.fromBinary(binValue, pofContext);
    }

#No. 592
#File: E:\bishe\1\AbstractBinaryProcessor.java
#Comment:
    /**
     * Return deserialized object for the specified binary value's name.
     *
     * @param name name of the binary value to parse
     *
     * @return deserialized object
     *
     * @see #setBinaryValue(String, Binary)
     */

#Code:
    protected Object fromBinary(String name) {
        return fromBinary(getBinaryValue(name));
    }

#No. 593
#File: E:\bishe\1\AbstractBinaryProcessor.java
#Comment:
    /**
     * Serialize specified object into binary value.
     *
     * @param o object to serialize
     *
     * @return serialized binary value
     */

#Code:
    protected Binary toBinary(Object o) {
        return ExternalizableHelper.toBinary(o, pofContext);
    }

#No. 594
#File: E:\bishe\1\AbstractBinaryProcessor.java
#Comment:
    /**
     * Deserialize this object from a POF stream.
     *
     * @param reader POF reader to use
     *
     * @throws IOException if an error occurs during deserialization
     */

#Code:
    public void readExternal(PofReader reader)
            throws IOException {
        pofContext = reader.getPofContext();
    }

#No. 595
#File: E:\bishe\1\AbstractBinaryProcessor.java
#Comment:
    /**
     * Serialize this object into a POF stream.
     *
     * @param writer POF writer to use
     *
     * @throws IOException if an error occurs during serialization
     */

#Code:
    public void writeExternal(PofWriter writer)
            throws IOException {
        pofContext = writer.getPofContext();
    }

#No. 596
#File: E:\bishe\1\AbstractBinaryProcessor.java
#Comment:
    /**
     * Test objects for equality.
     *
     * @param o object to compare this object with
     *
     * @return <tt>true</tt> if the specified object is equal to this object
     *         <tt>false</tt> otherwise
     */

#Code:
    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || !(o instanceof AbstractBinaryProcessor)) {
            return false;
        }

        AbstractBinaryProcessor processor = (AbstractBinaryProcessor) o;

        return (binValues == null
                ? processor.binValues == null
                : binValues.equals(processor.binValues));
    }

#No. 597
#File: E:\bishe\1\AbstractBinaryProcessor.java
#Comment:
    /**
     * Return hash code for this object.
     *
     * @return this object's hash code
     */

#Code:
    @Override
    public int hashCode() {
        return binValues != null ? binValues.hashCode() : 0;
    }

#No. 598
#File: E:\bishe\1\AbstractBinaryProcessor.java
#Comment:
    /**
     * Return string representation of this object.
     *
     * @return string representation of this object
     */

#Code:
    @Override
    public String toString() {
        return "AbstractBinaryProcessor{" +
               "pofContext=" + pofContext +
               "binValues=" + binValues +
               '}';
    }

#No. 599
#File: E:\bishe\1\AbstractBinarySearchTree.java
#Comment:
	/**
	 * @return the new node that is added to this tree.
	 * If this tree already contains the key, nothing is added.
	 */

#Code:
	public N add(T key)
	{
		N node = null;
		
		if (root == null)
			setRoot(node = createNode(key));
		else
			node = addAux(root, key);
		
		return node;
	}

#No. 600
#File: E:\bishe\1\AbstractBindTest.java
#Comment:
        /**
         * Default constructor
         */

#Code:
        public EchoProtocolHandler() {
            super();
        }

#No. 601
#File: E:\bishe\1\AbstractBitcoinFileInputFormat.java
#Comment:
/**
*
* This method is experimental and derived from TextInputFormat. It is not necessary and not recommended to compress the blockchain files. Instead it is recommended to extract relevant data from the blockchain files once and store them in a format suitable for analytics (including compression), such as ORC or Parquet.
*
*/

#Code:
@Override
  protected boolean isSplitable(FileSystem fs, Path file) {
    if (!(this.isSplitable)) {
		return false;
    }
    final CompressionCodec codec = compressionCodecs.getCodec(file);
    if (null == codec) {
      return true;
    }
    return codec instanceof SplittableCompressionCodec;

  }

#No. 602
#File: E:\bishe\1\AbstractBitcoinRecordReader.java
#Comment:
/**
* Get the current file position in a compressed or uncompressed file.
*
* @return file position
*
* @throws java.io.IOException in case of errors reading from the filestream provided by Hadoop
*
*/

#Code:

public long getFilePosition() throws IOException {
	return  filePosition.getPos();
}

#No. 603
#File: E:\bishe\1\AbstractBitcoinRecordReader.java
#Comment:
/**
* Get the end of file
*
* @return end of file position
*
*/

#Code:

public long getEnd() {
	return end;
}

#No. 604
#File: E:\bishe\1\AbstractBitcoinRecordReader.java
#Comment:
/**
* Get the current Block Reader
*
* @return end of file position
*
*/

#Code:
public BitcoinBlockReader getBbr() {
	return this.bbr;
}

#No. 605
#File: E:\bishe\1\AbstractBitcoinRecordReader.java
#Comment:
/*
* Returns how much of the file has been processed in terms of bytes
*
* @return progress percentage
*
* @throws java.io.IOException in case of errors reading from the filestream provided by Hadoop
*
*/

#Code:
@Override
public synchronized float getProgress() throws IOException {
if (start == end) {
      return 0.0f;
    } else {
      return Math.min(1.0f, (getFilePosition() - start) / (float)(end - start));
    }
}

#No. 606
#File: E:\bishe\1\AbstractBitcoinRecordReader.java
#Comment:
/*
* Determines if the input is compressed or not
*
* @return true if compressed, false if not
*/

#Code:
private boolean  isCompressedInput() {
    return codec != null;
  }

#No. 607
#File: E:\bishe\1\AbstractBitcoinRecordReader.java
#Comment:
/*
* Get current position in the stream
*
* @return position
*
* @throws java.io.IOException in case of errors reading from the filestream provided by Hadoop
*
*/

#Code:
@Override
public  synchronized long getPos() throws IOException {
	return filePosition.getPos();
}

#No. 608
#File: E:\bishe\1\AbstractBitcoinRecordReader.java
#Comment:
/*
* Clean up InputStream and Decompressor after use
*
*
* @throws java.io.IOException in case of errors reading from the filestream provided by Hadoop
*
*/

#Code:
@Override
public synchronized void  close() throws IOException {
try {
   if (bbr != null) {
        bbr.close();
      }
    } finally {
      if (decompressor != null) {
        CodecPool.returnDecompressor(decompressor);
        decompressor = null;
      }
    }
  }

#No. 609
#File: E:\bishe\1\AbstractBitmapRGB.java
#Comment:
/**
 * <p>
 * Parent class for RGB (16, 24, and 32 bits per pixel) bitmaps.
 * </p>
 * 
 * @author &copy; Christian Treber, ct@ctreber.com
 */

#Code:
public abstract class AbstractBitmapRGB extends AbstractBitmap
	{
	protected int[] samples;

	/**
	 * Create a RGB bitmap.
	 * 
	 * @param pDescriptor
	 */
	public AbstractBitmapRGB(final BitmapDescriptor pDescriptor)
		{
		super(pDescriptor);

		samples = new int[getWidth() * getHeight()];
		}

	void read(final StreamDecoder in) throws IOException
		{
		readBitmap(in);
		readMask(in);
		}

	void write(StreamEncoder out) throws IOException
		{
		writeBitmap(out);
		writeMask(out);
		}

	/**
	 * This functions is needed b/c all classes read the bitmap, but not always a color table and a
	 * mask.
	 * 
	 * @param pDec The decoder.
	 * @throws IOException
	 */
	abstract void readBitmap(final StreamDecoder pDec) throws IOException;

	abstract void writeBitmap(final StreamEncoder pDec) throws IOException;
	}

#No. 610
#File: E:\bishe\1\AbstractBlankNodeTest.java
#Comment:
	/**
	 * Test method for
	 * {@link BlankNode#equals(java.lang.Object)}.
	 */

#Code:
	@Test
	public final void testEquals() {
		BlankNode testNull = new BlankNode() {
			@Override
			public String ntriplesString() {
				return null;
			}

			@Override
			public String internalIdentifier() {
				return null;
			}
		};
		BlankNode testAutomatic1 = getBlankNode();
		BlankNode testAutomatic2 = getBlankNode();
		BlankNode testManual3a = getBlankNode("3");
		BlankNode testManual3b = getBlankNode("3");
		BlankNode testManual4 = getBlankNode("4");

		// Test against our fake stub
		assertNotEquals(testNull, testAutomatic1);
		assertNotEquals(testAutomatic1, testNull);
		assertNotEquals(testNull, testManual3a);
		assertNotEquals(testManual3a, testNull);

		// Test the two imported instances against each other
		assertEquals(testAutomatic1, testAutomatic1);
		assertEquals(testAutomatic2, testAutomatic2);
		assertNotEquals(testAutomatic1, testAutomatic2);
		assertNotEquals(testAutomatic2, testAutomatic1);
		assertNotEquals(testAutomatic1, testManual3a);
		assertEquals(testManual3b, testManual3a);
		assertNotEquals(testManual3a, testManual4);
	}

#No. 611
#File: E:\bishe\1\AbstractBlankNodeTest.java
#Comment:
	/**
	 * Test method for {@link BlankNode#hashCode()}.
	 */

#Code:
	@Test
	public final void testHashCode() {
		BlankNode testNull = new BlankNode() {
			@Override
			public String ntriplesString() {
				return null;
			}

			@Override
			public String internalIdentifier() {
				return null;
			}
		};
		BlankNode testAutomatic1 = getBlankNode();
		BlankNode testAutomatic2 = getBlankNode();
		BlankNode testManual3a = getBlankNode("3");
		BlankNode testManual3b = getBlankNode("3");
		BlankNode testManual4 = getBlankNode("4");

		// Test against our fake stub
		assertNotEquals(testNull.hashCode(), testAutomatic1.hashCode());
		assertNotEquals(testAutomatic1.hashCode(), testNull.hashCode());
		assertNotEquals(testNull.hashCode(), testManual3a.hashCode());
		assertNotEquals(testManual3a.hashCode(), testNull.hashCode());

		// Test the two imported instances against each other
		assertEquals(testAutomatic1.hashCode(), testAutomatic1.hashCode());
		assertEquals(testAutomatic2.hashCode(), testAutomatic2.hashCode());
		assertNotEquals(testAutomatic1.hashCode(), testAutomatic2.hashCode());
		assertNotEquals(testAutomatic2.hashCode(), testAutomatic1.hashCode());
		assertNotEquals(testAutomatic1.hashCode(), testManual3a.hashCode());
		assertEquals(testManual3b.hashCode(), testManual3a.hashCode());
		assertNotEquals(testManual3a.hashCode(), testManual4.hashCode());
	}

#No. 612
#File: E:\bishe\1\AbstractBlockBasedDataStore.java
#Comment:
    /**
     * Serialize allocation block at index blockIndex
     * @param blockIndex the block index
     * @return the serialized allocation block
     */

#Code:
    protected final byte[] serializeAllocationBlock( int blockIndex )
    {
    	byte[] allocationBlock = new byte[AT_BLOCK_SIZE];

        // Regroup I/O to improve performance
        allocationBlock[AB_FLAGS_OFFSET]       = flags[blockIndex];
        allocationBlock[AB_ALLOCSIZE_OFFSET]   = (byte)((allocatedSize[blockIndex] >>> 24) & 0xFF);
        allocationBlock[AB_ALLOCSIZE_OFFSET+1] = (byte)((allocatedSize[blockIndex] >>> 16) & 0xFF);
        allocationBlock[AB_ALLOCSIZE_OFFSET+2] = (byte)((allocatedSize[blockIndex] >>>  8) & 0xFF);
        allocationBlock[AB_ALLOCSIZE_OFFSET+3] = (byte)((allocatedSize[blockIndex] >>>  0) & 0xFF);
        allocationBlock[AB_PREVBLOCK_OFFSET]   = (byte)((previousBlock[blockIndex] >>> 24) & 0xFF);
        allocationBlock[AB_PREVBLOCK_OFFSET+1] = (byte)((previousBlock[blockIndex] >>> 16) & 0xFF);
        allocationBlock[AB_PREVBLOCK_OFFSET+2] = (byte)((previousBlock[blockIndex] >>>  8) & 0xFF);
        allocationBlock[AB_PREVBLOCK_OFFSET+3] = (byte)((previousBlock[blockIndex] >>>  0) & 0xFF);
        allocationBlock[AB_NEXTBLOCK_OFFSET]   = (byte)((nextBlock[blockIndex] >>> 24) & 0xFF);
        allocationBlock[AB_NEXTBLOCK_OFFSET+1] = (byte)((nextBlock[blockIndex] >>> 16) & 0xFF);
        allocationBlock[AB_NEXTBLOCK_OFFSET+2] = (byte)((nextBlock[blockIndex] >>>  8) & 0xFF);
        allocationBlock[AB_NEXTBLOCK_OFFSET+3] = (byte)((nextBlock[blockIndex] >>>  0) & 0xFF);
        
        return allocationBlock;
    }

#No. 613
#File: E:\bishe\1\AbstractBlockPositionWrapper.java
#Comment:
	/**
	 * The constructor
	 *
	 * @param location location object
	 */

#Code:
	public AbstractBlockPositionWrapper(Location location) {
		this(location.getBlockX(), location.getBlockY(), location.getBlockZ());
	}

#No. 614
#File: E:\bishe\1\AbstractBlockPositionWrapper.java
#Comment:
	/**
	 * The constructor
	 *
	 * @param x x coordinate
	 * @param y y coordinate
	 * @param z z coordinate
	 */

#Code:
	public AbstractBlockPositionWrapper(int x, int y, int z) {
		this.x = x;
		this.y = y;
		this.z = z;
	}

#No. 615
#File: E:\bishe\1\AbstractBlockPositionWrapper.java
#Comment:
	/**
	 * The constructor
	 *
	 * @param blockPosition NMS BlockPosition object
	 */

#Code:
	public AbstractBlockPositionWrapper(Object blockPosition) {

	}

#No. 616
#File: E:\bishe\1\AbstractBlogProxy.java
#Comment:
	/**
	 * @param exists
	 * @param comment
	 * @return
	 */

#Code:
	protected boolean isExistedComment(List<PageComment> exists, PageComment comment) {
		if(exists == null)
			return false;
		
		//for performance consideration, this does not compara content, only createData and content length
		for (PageComment exist : exists) {
			if(exist.getCreatedDate().equals(comment.getCreatedDate()) && exist.getBody().length() == comment.getBody().length())
				return true;
		}
		return false;
	}

#No. 617
#File: E:\bishe\1\AbstractBlogProxy.java
#Comment:
	/**
	 * @param blog
	 * @param space
	 * @param categories
	 * @throws BlogSyncException
	 */

#Code:
	protected void saveCategories(BlogMeta blog, Space space, List<BlogCategory> categories) throws BlogSyncException {
		//always replace old categories
		SpaceSetting setting = space.getSetting();
		BlogMeta meta = setting.getBlogMeta(blog.getKey());
		if(meta != null){
			meta.setCategories(categories);
			settingService.saveOrUpdateSpaceSetting(space, setting);
		}else{
			throw new BlogSyncException("Unlinked blog can not update categories " + blog.getXmlrpc());
		}
	}

#No. 618
#File: E:\bishe\1\AbstractBlogProxy.java
#Comment:
	/**
	 * @param xmlrpc
	 * @param command
	 * @param params
	 * @return
	 * @throws MalformedURLException
	 * @throws XmlRpcException
	 */

#Code:
	protected Object callService(String xmlrpc, String command, Object[] params) throws BlogSyncException{
		try {
			XmlRpcClientConfigImpl config = new XmlRpcClientConfigImpl();
			config.setServerURL(new URL(xmlrpc));
			XmlRpcClient client = new XmlRpcClient();
			client.setConfig(config);

			return client.execute(command, params);
		} catch (XmlRpcHttpTransportException e) {
			throw new BlogSyncException("Blog transport error.", e);
		} catch (XmlRpcException e) {
			log.error("Request blog download failed:" + xmlrpc, e);
			throw new BlogSyncException(e.getMessage(), e);
		} catch (MalformedURLException e) {
			log.error("Request blog download failed:" + xmlrpc, e);
			throw new BlogSyncException(e);
		}
	}

#No. 619
#File: E:\bishe\1\AbstractBlogProxy.java
#Comment:
	/**
	 * @param page
	 * @return
	 */

#Code:
	protected String getBlogContent(Page page) {
		List<RenderPiece> pieces = renderService.renderHTML(page);
		return renderService.renderNativeHTML(page.getSpace().getUnixName(), page.getPageUuid(), pieces);
	}

#No. 620
#File: E:\bishe\1\AbstractBloomFilter.java
#Comment:
	/**
	 * Add the given byte array to the bloom filter
	 * 
	 * @param bytes
	 *            the byte array to be added to the bloom filter, cannot be null
	 * 
	 * @return <code>true</code> if the value was added to the bloom filter,
	 *         <code>false</code> otherwise
	 * 
	 * @throws IllegalArgumentException
	 *             if the byte array is <code>null</code>
	 */

#Code:
	@Override
	public final boolean add(byte[] bytes) {
		long hash64 = getLongHash64(bytes);
		
		// apply the less hashing technique
		int hash1 = (int) hash64;
		int hash2 = (int) (hash64 >>> 32);
		
		boolean bitsChanged = false;
		for (int i = 1; i <= this.kOrNumberOfHashFunctions; i++) {
			int nextHash = hash1 + i * hash2;
			if (nextHash < 0) {
				nextHash = ~nextHash;
			}
			bitsChanged |= this.bitArray.setBit(nextHash % this.bitArray.bitSize());
		}
		
		return bitsChanged;
	}

#No. 621
#File: E:\bishe\1\AbstractBloomFilter.java
#Comment:
	/**
	 * Check if the given byte array item exists in the bloom filter
	 * 
	 * @param bytes
	 *            the byte array to be tested for existence in the bloom filter,
	 *            cannot be null
	 * 
	 * @return <code>true</code> if the value exists in the bloom filter,
	 *         <code>false</code> otherwise
	 * 
	 * @throws IllegalArgumentException
	 *             if the byte array is <code>null</code>
	 */

#Code:
	@Override
	public final boolean contains(byte[] bytes) {
		long hash64 = getLongHash64(bytes);
		
		int hash1 = (int) hash64;
		int hash2 = (int) (hash64 >>> 32);
		for (int i = 1; i <= this.kOrNumberOfHashFunctions; i++) {
			int nextHash = hash1 + i * hash2;
			if (nextHash < 0) {
				nextHash = ~nextHash;
			}
			if (!this.bitArray.getBit(nextHash % this.bitArray.bitSize())) {
				return false;
			}
		}
		return true;
	}

#No. 622
#File: E:\bishe\1\AbstractBloomFilter.java
#Comment:
	/**
	 * Compute one 64-bit hash from the given byte-array using the specified
	 * {@link HashFunction}.
	 * 
	 * @param bytes
	 *            the byte-array to use for hash computation
	 * 
	 * @return the 64-bit hash
	 */

#Code:
	protected long getLongHash64(byte[] bytes) {
		if(bytes == null) {
			throw new IllegalArgumentException("Bytes to add to bloom filter cannot be null");
		}
		
		if(this.hasher.isSingleValued()) {
			return this.hasher.hash(bytes);
		}
		
		return this.hasher.hashMultiple(bytes)[0];
	}

#No. 623
#File: E:\bishe\1\AbstractBloomFilter.java
#Comment:
	/**
	 * Given the value object, decompose it into a byte-array so that hashing
	 * can be done over the returned bytes. If a custom {@link Decomposer} has
	 * been specified, it will be used, otherwise the {@link DefaultDecomposer}
	 * will be used.
	 * 
	 * @param value
	 *            the value to be decomposed
	 * 
	 * @return the decomposed byte array
	 */

#Code:
	protected byte[] decomposedValue(T value) {
		ByteSink sink = new ByteSink();
		
		if(value instanceof Decomposable) {
			((Decomposable) value).decompose(sink);
			
			return sink.getByteArray();
		}
		
		if(this.customDecomposer != null) {
			this.customDecomposer.decompose(value, sink);
			return sink.getByteArray();
		}
		
		DEFAULT_COMPOSER.decompose(value, sink);
		return sink.getByteArray();
	}

#No. 624
#File: E:\bishe\1\AbstractBloomFilter.java
#Comment:
	/**
	 * Add the given value to the bloom filter.
	 * 
	 * @param value
	 *            the value to be added
	 * 
	 * @return <code>true</code> if the value was added to the bloom filter,
	 *         <code>false</code> otherwise
	 */

#Code:
	@Override
	public boolean add(T value) {
		if(value == null) {
			return false;
		}
		
		return add(decomposedValue(value));
	}

#No. 625
#File: E:\bishe\1\AbstractBloomFilter.java
#Comment:
	/**
	 * Add all given value in the collection to the bloom filter
	 * 
	 * @param values
	 *            the collection of values to be inserted
	 * 
	 * @return <code>true</code> if all values were successfully inserted into
	 *         the bloom filter, <code>false</code> otherwise
	 */

#Code:
	@Override
	public boolean addAll(Collection<T> values) {
		if(values == null || values.isEmpty()) {
			return false;
		}
		
		boolean success = true;
		for(T value : values) {
			success = add(value) && success; 
		}
		
		return success;
	}

#No. 626
#File: E:\bishe\1\AbstractBloomFilter.java
#Comment:
	/**
	 * Check if the given value exists in the bloom filter. Note that this
	 * method may return <code>true</code>, indicating a false positive - but
	 * this is the property of the bloom filter and is not a bug.
	 * 
	 * @return <code>false</code> if the value is definitely (100% surety) not
	 *         contained in the bloom filter, <code>true</code> otherwise.
	 */

#Code:
	@Override
	public boolean contains(T value) {
		if(value == null) {
			return false;
		}
		
		return contains(value.toString().getBytes(this.currentCharset));
	}

#No. 627
#File: E:\bishe\1\AbstractBloomFilter.java
#Comment:
	/**
	 * Check if all the given values exists in the bloom filter or not.
	 * 
	 * @return <code>true</code> only if all values are believed to be existing
	 *         in the bloom filter, <code>false</code> otherwise
	 */

#Code:
	@Override
	public boolean containsAll(Collection<T> values) {
		if(values == null || values.isEmpty()) {
			return false;
		}
		
		for(T value : values) {
			if(!contains(value)) {
				return false;
			}
		}
		
		return true;
	}

#No. 628
#File: E:\bishe\1\AbstractBloomFilter.java
#Comment:
	/**
	 * Override the default charset that will be used when decomposing the
	 * {@link String} values into byte arrays. The default {@link Charset} used
	 * in the platform's default {@link Charset}.
	 * 
	 * @param charsetName
	 *            the name of the charset that needs to be set
	 * 
	 * @throws IllegalArgumentException
	 *             if the charsetName is null
	 * 
	 * @throws IllegalCharsetNameException
	 *             If the given charset name is illegal
	 * 
	 * @throws UnsupportedCharsetException
	 *             If no support for the named charset is available in this
	 *             instance of the Java virtual machine
	 */

#Code:
	@Override
	public void setCharset(String charsetName) {
		if(charsetName == null) {
			throw new IllegalArgumentException("Charset to be changed to cannot be null");
		}
		
		setCharset(Charset.forName(charsetName));
	}

#No. 629
#File: E:\bishe\1\AbstractBloomFilter.java
#Comment:
	/**
	 * Override the default charset that will be used when decomposing the
	 * {@link String} values into byte arrays. The default {@link Charset} used
	 * in the platform's default {@link Charset}.
	 * 
	 * @param charset
	 *            the {@link Charset} to be used
	 * 
	 * @throws IllegalArgumentException
	 *             if the charset is null
	 * 
	 */

#Code:
	@Override
	public void setCharset(Charset charset) {
		if(charset == null) {
			throw new IllegalArgumentException("Charset to be changed to cannot be null");
		}
		
		this.currentCharset = charset;
	}

#No. 630
#File: E:\bishe\1\AbstractBloomFilter.java
#Comment:
	/**
	 * Get the current custom decomposer that is being used. If no custom
	 * decomposer is specified, <code>null</code> is returned to signify that we
	 * are using the {@link AbstractBloomFilter#DEFAULT_HASHER} hash function.
	 * 
	 * @return the current custom decomposer being used, if any
	 */

#Code:
	@Override
	public Decomposer<T> getObjectDecomposer() {
		if(this.customDecomposer != null) {
			return this.customDecomposer;
		}
		
		return null;
	}

#No. 631
#File: E:\bishe\1\AbstractBloomFilter.java
#Comment:
	/**
	 * @see BloomFilter#getNumberOfBits()
	 */

#Code:
	@Override
	public int getNumberOfBits() {
		return this.numBitsRequired;
	}

#No. 632
#File: E:\bishe\1\AbstractBloomFilter.java
#Comment:
	/**
	 * Estimate the current false positive rate (approximated) when given number
	 * of elements have been inserted in to the filter.
	 * 
	 * @param numInsertedElements
	 *            the number of elements inserted into the filter
	 * 
	 * @return the approximated false positive rate
	 */

#Code:
	@Override
	public double getFalsePositiveProbability(int numInsertedElements) {
		return Math.pow((1 - Math.exp((- this.kOrNumberOfHashFunctions) * (double) numInsertedElements / (double) this.numBitsRequired)), this.kOrNumberOfHashFunctions);
	}

#No. 633
#File: E:\bishe\1\AbstractBloomFilter.java
#Comment:
	/**
	 * @see com.sangupta.bloomfilter.BloomFilter#close()
	 */

#Code:
	@Override
	public void close() {
		if(this.bitArray instanceof Closeable) {
			try {
				((Closeable) this.bitArray).close();
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
	}

#No. 634
#File: E:\bishe\1\AbstractBlueprintBeanDefinitionParser.java
#Comment:
    /**
     * <p>parse.</p>
     *
     * @param element a {@link org.w3c.dom.Element} object.
     * @param context a {@link org.apache.aries.blueprint.ParserContext} object.
     * @return a {@link org.osgi.service.blueprint.reflect.Metadata} object.
     * @throws java.lang.Exception if any.
     */

#Code:
    public Metadata parse(Element element, ParserContext context) throws Exception {
        MutableBeanMetadata beanMetadata = context.createMetadata(MutableBeanMetadata.class);
        beanMetadata.setRuntimeClass(getRuntimeClass());
        beanMetadata.setActivation(BeanMetadata.ACTIVATION_EAGER);
        beanMetadata.setScope(BeanMetadata.SCOPE_SINGLETON);
        beanMetadata.setId(getId(element));
        beanMetadata.setInitMethod("start");
        beanMetadata.setDestroyMethod("stop");
        beanMetadata.addProperty("bundleContext", createRef(context, "blueprintBundleContext"));
        extractRemainingMetaData(element, context, beanMetadata);
        return beanMetadata;
    }

#No. 635
#File: E:\bishe\1\AbstractBlueprintBeanDefinitionParser.java
#Comment:
    /**
     * <p>addPropertyValueFromElement.</p>
     *
     * @param id a {@link java.lang.String} object.
     * @param node a {@link org.w3c.dom.Element} object.
     * @param context a {@link org.apache.aries.blueprint.ParserContext} object.
     * @param beanMetadata a {@link org.apache.aries.blueprint.mutable.MutableBeanMetadata} object.
     */

#Code:
    protected void addPropertyValueFromElement(String id, Element node, ParserContext context,
            MutableBeanMetadata beanMetadata) {
        String attribute = node.getAttribute(id);
        beanMetadata.addProperty(id, createStringValue(context, attribute));
    }

#No. 636
#File: E:\bishe\1\AbstractBlueprintBeanDefinitionParser.java
#Comment:
    /**
     * <p>addPropertyValueFromElement.</p>
     *
     * @param id a {@link java.lang.String} object.
     * @param injectionId a {@link java.lang.String} object.
     * @param node a {@link org.w3c.dom.Element} object.
     * @param context a {@link org.apache.aries.blueprint.ParserContext} object.
     * @param beanMetadata a {@link org.apache.aries.blueprint.mutable.MutableBeanMetadata} object.
     */

#Code:
    protected void addPropertyValueFromElement(String id, String injectionId, Element node, ParserContext context,
            MutableBeanMetadata beanMetadata) {
        String attribute = node.getAttribute(id);
        beanMetadata.addProperty(injectionId, createStringValue(context, attribute));
    }

#No. 637
#File: E:\bishe\1\AbstractBlueprintBeanDefinitionParser.java
#Comment:
    /**
     * <p>addPropertyReferenceFromElement.</p>
     *
     * @param id a {@link java.lang.String} object.
     * @param node a {@link org.w3c.dom.Element} object.
     * @param context a {@link org.apache.aries.blueprint.ParserContext} object.
     * @param beanMetadata a {@link org.apache.aries.blueprint.mutable.MutableBeanMetadata} object.
     */

#Code:
    protected void addPropertyReferenceFromElement(String id, Element node, ParserContext context,
            MutableBeanMetadata beanMetadata) {
        String attribute = node.getAttribute(id);
        beanMetadata.addProperty(id, createRef(context, attribute));
    }

#No. 638
#File: E:\bishe\1\AbstractBlueprintBeanDefinitionParser.java
#Comment:
    /**
     * <p>addPropertyReferenceForMap.</p>
     *
     * @param id a {@link java.lang.String} object.
     * @param context a {@link org.apache.aries.blueprint.ParserContext} object.
     * @param beanMetadata a {@link org.apache.aries.blueprint.mutable.MutableBeanMetadata} object.
     * @param values a {@link java.util.Map} object.
     */

#Code:
    protected void addPropertyReferenceForMap(String id, ParserContext context, MutableBeanMetadata beanMetadata,
            Map<String, String> values) {
        MutableMapMetadata mapMetadata = context.createMetadata(MutableMapMetadata.class);
        for (Entry<String, String> value : values.entrySet()) {
            mapMetadata.addEntry(createStringValue(context, value.getKey()),
                createStringValue(context, value.getValue()));
        }
        beanMetadata.addProperty(id, mapMetadata);
    }

#No. 639
#File: E:\bishe\1\AbstractBlueprintBeanDefinitionParser.java
#Comment:
    /**
     * <p>addPropertyReferenceForList.</p>
     *
     * @param id a {@link java.lang.String} object.
     * @param context a {@link org.apache.aries.blueprint.ParserContext} object.
     * @param beanMetadata a {@link org.apache.aries.blueprint.mutable.MutableBeanMetadata} object.
     * @param values a {@link java.util.List} object.
     */

#Code:
    protected void addPropertyReferenceForList(String id, ParserContext context, MutableBeanMetadata beanMetadata,
            List<String> values) {
        MutableCollectionMetadata collectionMetadata = context.createMetadata(MutableCollectionMetadata.class);
        collectionMetadata.setCollectionClass(List.class);
        for (String value : values) {
            collectionMetadata.addValue(createStringValue(context, value));
        }
        beanMetadata.addProperty(id, collectionMetadata);
    }

#No. 640
#File: E:\bishe\1\AbstractBlueprintBeanDefinitionParser.java
#Comment:
    /**
     * <p>createStringValue.</p>
     *
     * @param context a {@link org.apache.aries.blueprint.ParserContext} object.
     * @param str a {@link java.lang.String} object.
     * @return a {@link org.osgi.service.blueprint.reflect.ValueMetadata} object.
     */

#Code:
    protected ValueMetadata createStringValue(ParserContext context, String str) {
        MutableValueMetadata value = context.createMetadata(MutableValueMetadata.class);
        value.setStringValue(str);
        return value;
    }

#No. 641
#File: E:\bishe\1\AbstractBlueprintBeanDefinitionParser.java
#Comment:
    /**
     * <p>createRef.</p>
     *
     * @param context a {@link org.apache.aries.blueprint.ParserContext} object.
     * @param id a {@link java.lang.String} object.
     * @return a {@link org.osgi.service.blueprint.reflect.RefMetadata} object.
     */

#Code:
    protected RefMetadata createRef(ParserContext context, String id) {
        MutableRefMetadata idref = context.createMetadata(MutableRefMetadata.class);
        idref.setComponentId(id);
        return idref;
    }

#No. 642
#File: E:\bishe\1\AbstractBooleanList.java
#Comment:
    /**
     * Returns the index of the first occurrence of the specified element.
     * Returns <code>-1</code> if the receiver does not contain this element.
     * 
     * @param element
     *            the element to be searched for.
     * @return the index of the first occurrence of the element in the receiver;
     *         returns <code>-1</code> if the element is not found.
     */

#Code:
    public int indexOf(boolean element) { // delta
        return indexOfFromTo(element, 0, size - 1);
    }

#No. 643
#File: E:\bishe\1\AbstractBooleanList.java
#Comment:
    /**
     * Returns the index of the first occurrence of the specified element.
     * Returns <code>-1</code> if the receiver does not contain this element.
     * Searches between <code>from</code>, inclusive and <code>to</code>,
     * inclusive. Tests for identity.
     * 
     * @param element
     *            element to search for.
     * @param from
     *            the leftmost search position, inclusive.
     * @param to
     *            the rightmost search position, inclusive.
     * @return the index of the first occurrence of the element in the receiver;
     *         returns <code>-1</code> if the element is not found.
     * @exception IndexOutOfBoundsException
     *                index is out of range (
     *                <tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>
     *                ).
     */

#Code:
    public int indexOfFromTo(boolean element, int from, int to) {
        checkRangeFromTo(from, to, size);

        for (int i = from; i <= to; i++) {
            if (element == getQuick(i))
                return i; // found
        }
        return -1; // not found
    }

#No. 644
#File: E:\bishe\1\AbstractBooleanList.java
#Comment:
    /**
     * Returns the index of the last occurrence of the specified element.
     * Returns <code>-1</code> if the receiver does not contain this element.
     * 
     * @param element
     *            the element to be searched for.
     * @return the index of the last occurrence of the element in the receiver;
     *         returns <code>-1</code> if the element is not found.
     */

#Code:
    public int lastIndexOf(boolean element) {
        return lastIndexOfFromTo(element, 0, size - 1);
    }

#No. 645
#File: E:\bishe\1\AbstractBooleanList.java
#Comment:
    /**
     * Returns the index of the last occurrence of the specified element.
     * Returns <code>-1</code> if the receiver does not contain this element.
     * Searches beginning at <code>to</code>, inclusive until <code>from</code>,
     * inclusive. Tests for identity.
     * 
     * @param element
     *            element to search for.
     * @param from
     *            the leftmost search position, inclusive.
     * @param to
     *            the rightmost search position, inclusive.
     * @return the index of the last occurrence of the element in the receiver;
     *         returns <code>-1</code> if the element is not found.
     * @exception IndexOutOfBoundsException
     *                index is out of range (
     *                <tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>
     *                ).
     */

#Code:
    public int lastIndexOfFromTo(boolean element, int from, int to) {
        checkRangeFromTo(from, to, size());

        for (int i = to; i >= from; i--) {
            if (element == getQuick(i))
                return i; // found
        }
        return -1; // not found
    }

#No. 646
#File: E:\bishe\1\AbstractBooleanList.java
#Comment:
    /**
     * Returns a new list of the part of the receiver between <code>from</code>,
     * inclusive, and <code>to</code>, inclusive.
     * 
     * @param from
     *            the index of the first element (inclusive).
     * @param to
     *            the index of the last element (inclusive).
     * @return a new list
     * @exception IndexOutOfBoundsException
     *                index is out of range (
     *                <tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>
     *                ).
     */

#Code:
    public AbstractBooleanList partFromTo(int from, int to) {
        checkRangeFromTo(from, to, size);

        int length = to - from + 1;
        BooleanArrayList part = new BooleanArrayList(length);
        part.addAllOfFromTo(this, from, to);
        return part;
    }

#No. 647
#File: E:\bishe\1\AbstractBooleanList.java
#Comment:
    /**
     * Removes from the receiver all elements that are contained in the
     * specified list. Tests for identity.
     * 
     * @param other
     *            the other list.
     * @return <code>true</code> if the receiver changed as a result of the
     *         call.
     */

#Code:
    public boolean removeAll(AbstractBooleanList other) {
        if (other.size() == 0)
            return false; // nothing to do
        int limit = other.size() - 1;
        int j = 0;

        for (int i = 0; i < size; i++) {
            if (other.indexOfFromTo(getQuick(i), 0, limit) < 0)
                setQuick(j++, getQuick(i));
        }

        boolean modified = (j != size);
        setSize(j);
        return modified;
    }

#No. 648
#File: E:\bishe\1\AbstractBooleanList.java
#Comment:
    /**
     * Removes from the receiver all elements whose index is between
     * <code>from</code>, inclusive and <code>to</code>, inclusive. Shifts any
     * succeeding elements to the left (reduces their index). This call
     * booleanens the list by <tt>(to - from + 1)</tt> elements.
     * 
     * @param from
     *            index of first element to be removed.
     * @param to
     *            index of last element to be removed.
     * @exception IndexOutOfBoundsException
     *                index is out of range (
     *                <tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>
     *                ).
     */

#Code:

    public void removeFromTo(int from, int to) {
        checkRangeFromTo(from, to, size);
        int numMoved = size - to - 1;
        if (numMoved > 0) {
            replaceFromToWithFrom(from, from - 1 + numMoved, this, to + 1);
            // fillFromToWith(from+numMoved, size-1, 0.0f); //delta
        }
        int width = to - from + 1;
        if (width > 0)
            setSizeRaw(size - width);
    }

#No. 649
#File: E:\bishe\1\AbstractBooleanList.java
#Comment:
    /**
     * Replaces a number of elements in the receiver with the same number of
     * elements of another list. Replaces elements in the receiver, between
     * <code>from</code> (inclusive) and <code>to</code> (inclusive), with
     * elements of <code>other</code>, starting from <code>otherFrom</code>
     * (inclusive).
     * 
     * @param from
     *            the position of the first element to be replaced in the
     *            receiver
     * @param to
     *            the position of the last element to be replaced in the
     *            receiver
     * @param other
     *            list holding elements to be copied into the receiver.
     * @param otherFrom
     *            position of first element within other list to be copied.
     */

#Code:
    public void replaceFromToWithFrom(int from, int to, AbstractBooleanList other, int otherFrom) {
        int length = to - from + 1;
        if (length > 0) {
            checkRangeFromTo(from, to, size());
            checkRangeFromTo(otherFrom, otherFrom + length - 1, other.size());

            // unambiguous copy (it may hold other==this)
            if (from <= otherFrom) {
                for (; --length >= 0;)
                    setQuick(from++, other.getQuick(otherFrom++));
            } else {
                int otherTo = otherFrom + length - 1;
                for (; --length >= 0;)
                    setQuick(to--, other.getQuick(otherTo--));
            }

        }
    }

#No. 650
#File: E:\bishe\1\AbstractBooleanList.java
#Comment:
    /**
     * Replaces the part between <code>from</code> (inclusive) and
     * <code>to</code> (inclusive) with the other list's part between
     * <code>otherFrom</code> and <code>otherTo</code>. Powerful (and tricky)
     * method! Both parts need not be of the same size (part A can both be
     * smaller or larger than part B). Parts may overlap. Receiver and other
     * list may (but most not) be identical. If <code>from &gt; to</code>, then
     * inserts other part before <code>from</code>.
     * 
     * @param from
     *            the first element of the receiver (inclusive)
     * @param to
     *            the last element of the receiver (inclusive)
     * @param other
     *            the other list (may be identical with receiver)
     * @param otherFrom
     *            the first element of the other list (inclusive)
     * @param otherTo
     *            the last element of the other list (inclusive)
     * 
     *            <p>
     *            <b>Examples:</b>
     * 
     *            <pre>
     * a=[0, 1, 2, 3, 4, 5, 6, 7]
     * b=[50, 60, 70, 80, 90]
     * a.R(...)=a.replaceFromToWithFromTo(...)
     * 
     * a.R(3,5,b,0,4)--&gt;[0, 1, 2, 50, 60, 70, 80, 90, 6, 7]
     * a.R(1,6,b,0,4)--&gt;[0, 50, 60, 70, 80, 90, 7]
     * a.R(0,6,b,0,4)--&gt;[50, 60, 70, 80, 90, 7]
     * a.R(3,5,b,1,2)--&gt;[0, 1, 2, 60, 70, 6, 7]
     * a.R(1,6,b,1,2)--&gt;[0, 60, 70, 7]
     * a.R(0,6,b,1,2)--&gt;[60, 70, 7]
     * a.R(5,3,b,0,4)--&gt;[0, 1, 2, 3, 4, 50, 60, 70, 80, 90, 5, 6, 7]
     * a.R(5,0,b,0,4)--&gt;[0, 1, 2, 3, 4, 50, 60, 70, 80, 90, 5, 6, 7]
     * a.R(5,3,b,1,2)--&gt;[0, 1, 2, 3, 4, 60, 70, 5, 6, 7]
     * a.R(5,0,b,1,2)--&gt;[0, 1, 2, 3, 4, 60, 70, 5, 6, 7]
     * 
     * Extreme cases:
     * a.R(5,3,b,0,0)--&gt;[0, 1, 2, 3, 4, 50, 5, 6, 7]
     * a.R(5,3,b,4,4)--&gt;[0, 1, 2, 3, 4, 90, 5, 6, 7]
     * a.R(3,5,a,0,1)--&gt;[0, 1, 2, 0, 1, 6, 7]
     * a.R(3,5,a,3,5)--&gt;[0, 1, 2, 3, 4, 5, 6, 7]
     * a.R(3,5,a,4,4)--&gt;[0, 1, 2, 4, 6, 7]
     * a.R(5,3,a,0,4)--&gt;[0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 5, 6, 7]
     * a.R(0,-1,b,0,4)--&gt;[50, 60, 70, 80, 90, 0, 1, 2, 3, 4, 5, 6, 7]
     * a.R(0,-1,a,0,4)--&gt;[0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 5, 6, 7]
     * a.R(8,0,a,0,4)--&gt;[0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4]
     * </pre>
     */

#Code:
    public void replaceFromToWithFromTo(int from, int to, AbstractBooleanList other, int otherFrom, int otherTo) {
        if (otherFrom > otherTo) {
            throw new IndexOutOfBoundsException("otherFrom: " + otherFrom + ", otherTo: " + otherTo);
        }

        if (this == other && to - from != otherTo - otherFrom) { // avoid
            // stumbling
            // over my
            // own feet
            replaceFromToWithFromTo(from, to, partFromTo(otherFrom, otherTo), 0, otherTo - otherFrom);
            return;
        }

        int length = otherTo - otherFrom + 1;
        int diff = length;
        int theLast = from - 1;

        if (to >= from) {
            diff -= (to - from + 1);
            theLast = to;
        }

        if (diff > 0) {
            beforeInsertDummies(theLast + 1, diff);
        } else {
            if (diff < 0) {
                removeFromTo(theLast + diff, theLast - 1);
            }
        }

        if (length > 0) {
            replaceFromToWithFrom(from, from + length - 1, other, otherFrom);
        }
    }

#No. 651
#File: E:\bishe\1\AbstractBooleanList.java
#Comment:
    /**
     * Replaces the part of the receiver starting at <code>from</code>
     * (inclusive) with all the elements of the specified collection. Does not
     * alter the size of the receiver. Replaces exactly
     * <tt>Math.max(0,Math.min(size()-from, other.size()))</tt> elements.
     * 
     * @param from
     *            the index at which to copy the first element from the
     *            specified collection.
     * @param other
     *            Collection to replace part of the receiver
     * @exception IndexOutOfBoundsException
     *                index is out of range (index &lt; 0 || index &gt;=
     *                size()).
     */

#Code:

    public void replaceFromWith(int from, java.util.Collection other) {
        checkRange(from, size());
        java.util.Iterator e = other.iterator();
        int index = from;
        int limit = Math.min(size() - from, other.size());
        for (int i = 0; i < limit; i++)
            set(index++, ((Boolean) e.next()).booleanValue()); // delta
    }

#No. 652
#File: E:\bishe\1\AbstractBooleanList.java
#Comment:
    /**
     * Retains (keeps) only the elements in the receiver that are contained in
     * the specified other list. In other words, removes from the receiver all
     * of its elements that are not contained in the specified other list.
     * 
     * @param other
     *            the other list to test against.
     * @return <code>true</code> if the receiver changed as a result of the
     *         call.
     */

#Code:
    public boolean retainAll(AbstractBooleanList other) {
        if (other.size() == 0) {
            if (size == 0)
                return false;
            setSize(0);
            return true;
        }

        int limit = other.size() - 1;
        int j = 0;
        for (int i = 0; i < size; i++) {
            if (other.indexOfFromTo(getQuick(i), 0, limit) >= 0)
                setQuick(j++, getQuick(i));
        }

        boolean modified = (j != size);
        setSize(j);
        return modified;
    }

#No. 653
#File: E:\bishe\1\AbstractBooleanList.java
#Comment:
    /**
     * Reverses the elements of the receiver. Last becomes first, second last
     * becomes second first, and so on.
     */

#Code:

    public void reverse() {
        boolean tmp;
        int limit = size() / 2;
        int j = size() - 1;

        for (int i = 0; i < limit;) { // swap
            tmp = getQuick(i);
            setQuick(i++, getQuick(j));
            setQuick(j--, tmp);
        }
    }

#No. 654
#File: E:\bishe\1\AbstractBooleanList.java
#Comment:
    /**
     * Replaces the element at the specified position in the receiver with the
     * specified element.
     * 
     * @param index
     *            index of element to replace.
     * @param element
     *            element to be stored at the specified position.
     * @throws IndexOutOfBoundsException
     *             if <tt>index &lt; 0 || index &gt;= size()</tt>.
     */

#Code:
    public void set(int index, boolean element) {
        if (index >= size || index < 0)
            throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size);
        setQuick(index, element);
    }

#No. 655
#File: E:\bishe\1\AbstractBooleanList.java
#Comment:
    /**
     * Sets the size of the receiver without modifying it otherwise. This method
     * should not release or allocate new memory but simply set some instance
     * variable like <tt>size</tt>.
     * 
     * If your subclass overrides and delegates size changing methods to some
     * other object, you must make sure that those overriding methods not only
     * update the size of the delegate but also of this class. For example:
     * public DatabaseList extends AbstractBooleanList { ... public void
     * removeFromTo(int from,int to) { myDatabase.removeFromTo(from,to);
     * this.setSizeRaw(size-(to-from+1)); } }
     */

#Code:
    protected void setSizeRaw(int newSize) {
        size = newSize;
    }

#No. 656
#File: E:\bishe\1\AbstractBooleanList.java
#Comment:
    /**
     * Randomly permutes the part of the receiver between <code>from</code>
     * (inclusive) and <code>to</code> (inclusive).
     * 
     * @param from
     *            the index of the first element (inclusive) to be permuted.
     * @param to
     *            the index of the last element (inclusive) to be permuted.
     * @exception IndexOutOfBoundsException
     *                index is out of range (
     *                <tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>
     *                ).
     */

#Code:

    public void shuffleFromTo(int from, int to) {
        checkRangeFromTo(from, to, size());

        cern.jet.random.tdouble.DoubleUniform gen = new cern.jet.random.tdouble.DoubleUniform(
                new cern.jet.random.tdouble.engine.DRand(new java.util.Date()));
        for (int i = from; i < to; i++) {
            int random = gen.nextIntFromTo(i, to);

            // swap(i, random)
            boolean tmpElement = getQuick(random);
            setQuick(random, getQuick(i));
            setQuick(i, tmpElement);
        }
    }

#No. 657
#File: E:\bishe\1\AbstractBooleanList.java
#Comment:
    /**
     * Returns the number of elements contained in the receiver.
     * 
     * @return the number of elements contained in the receiver.
     */

#Code:

    public int size() {
        return size;
    }

#No. 658
#File: E:\bishe\1\AbstractBooleanList.java
#Comment:
    /**
     * Returns a list which is a concatenation of <code>times</code> times the
     * receiver.
     * 
     * @param times
     *            the number of times the receiver shall be copied.
     */

#Code:
    public AbstractBooleanList times(int times) {
        AbstractBooleanList newList = new BooleanArrayList(times * size());
        for (int i = times; --i >= 0;) {
            newList.addAllOfFromTo(this, 0, size() - 1);
        }
        return newList;
    }

#No. 659
#File: E:\bishe\1\AbstractBooleanList.java
#Comment:
    /**
     * Transforms a boolean value to an integer (false --> 0, true --> 1)
     */

#Code:
    protected static int toInt(boolean value) {
        return value ? 1 : 0;
    }

#No. 660
#File: E:\bishe\1\AbstractBooleanList.java
#Comment:
    /**
     * Returns a <code>java.util.ArrayList</code> containing all the elements in
     * the receiver.
     */

#Code:

    public java.util.ArrayList toList() {
        int mySize = size();
        java.util.ArrayList list = new java.util.ArrayList(mySize);
        for (int i = 0; i < mySize; i++)
            list.add(new Boolean(get(i)));
        return list;
    }

#No. 661
#File: E:\bishe\1\AbstractBooleanList.java
#Comment:
    /**
     * Returns a string representation of the receiver, containing the String
     * representation of each element.
     */

#Code:

    public String toString() {
        return cern.colt.Arrays.toString(partFromTo(0, size() - 1).elements());
    }

#No. 662
#File: E:\bishe\1\AbstractBox.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @DoNotParseDetail
    public void parse(ReadableByteChannel dataSource, ByteBuffer header, long contentSize, BoxParser boxParser) throws IOException {
        content = ByteBuffer.allocate(l2i(contentSize));

        while ((content.position() < contentSize)) {
            if (dataSource.read(content) == -1) {
                LOG.error("{} might have been truncated by file end. bytesRead={} contentSize={}", this, content.position(), contentSize);
                break;
            }
        }

        content.position(0);
        isParsed = false;
    }

#No. 663
#File: E:\bishe\1\AbstractBox.java
#Comment:
    /**
     * Parses the raw content of the box. It surrounds the actual parsing
     * which is done
     */

#Code:
    public synchronized final void parseDetails() {
        LOG.debug("parsing details of {}", this.getType());
        if (content != null) {
            ByteBuffer content = this.content;
            isParsed = true;
            content.rewind();
            _parseDetails(content);
            if (content.remaining() > 0) {
                deadBytes = content.slice();
            }
            this.content = null;
            assert verify(content);
        }
    }

#No. 664
#File: E:\bishe\1\AbstractBox.java
#Comment:
    /**
     * Gets the full size of the box including header and content.
     *
     * @return the box's size
     */

#Code:
    public long getSize() {
        long size = isParsed ? getContentSize() : content.limit();
        size += (8 + // size|type
                (size >= ((1L << 32) - 8) ? 8 : 0) + // 32bit - 8 byte size and type
                (UserBox.TYPE.equals(getType()) ? 16 : 0));
        size += (deadBytes == null ? 0 : deadBytes.limit());
        return size;
    }

#No. 665
#File: E:\bishe\1\AbstractBox.java
#Comment:
    /**
     * Check if details are parsed.
     *
     * @return <code>true</code> whenever the content <code>ByteBuffer</code> is not <code>null</code>
     */

#Code:
    public boolean isParsed() {
        return isParsed;
    }

#No. 666
#File: E:\bishe\1\AbstractBox.java
#Comment:
    /**
     * Verifies that a box can be reconstructed byte-exact after parsing.
     *
     * @param content the raw content of the box
     * @return <code>true</code> if raw content exactly matches the reconstructed content
     */

#Code:
    private boolean verify(ByteBuffer content) {
        ByteBuffer bb = ByteBuffer.allocate(l2i(getContentSize() + (deadBytes != null ? deadBytes.limit() : 0)));
        getContent(bb);
        if (deadBytes != null) {
            deadBytes.rewind();
            while (deadBytes.remaining() > 0) {
                bb.put(deadBytes);
            }
        }
        content.rewind();
        bb.rewind();


        if (content.remaining() != bb.remaining()) {
            LOG.error("{}: remaining differs {}  vs. {}", this.getType(), content.remaining(), bb.remaining());
            return false;
        }
        int p = content.position();
        for (int i = content.limit() - 1, j = bb.limit() - 1; i >= p; i--, j--) {
            byte v1 = content.get(i);
            byte v2 = bb.get(j);
            if (v1 != v2) {
                LOG.error("{}: buffers differ at {}: {}/{}", this.getType(), i, v1, v2);
                byte[] b1 = new byte[content.remaining()];
                byte[] b2 = new byte[bb.remaining()];
                content.get(b1);
                bb.get(b2);
                LOG.error("original      : {}", Hex.encodeHex(b1, 4));
                LOG.error("reconstructed : {}", Hex.encodeHex(b2, 4));
                return false;
            }
        }
        return true;

    }

#No. 667
#File: E:\bishe\1\AbstractBpmn2PropertiesComposite.java
#Comment:
	/**
	 * NB! Must call setEObject for updating contents and rebuild the UI.
	 * 
	 * @param parent
	 * @param style
	 */

#Code:
	public AbstractBpmn2PropertiesComposite(Composite parent, int style) {
		super(parent, style);
		this.parent = parent;
		bindingContext = new DataBindingContext();
		addDisposeListener(new DisposeListener() {
			@Override
			public void widgetDisposed(DisposeEvent e) {
				toolkit.dispose();
			}
		});
		toolkit.adapt(this);
		toolkit.paintBordersFor(this);
		setLayout(new GridLayout(3, false));
	}

#No. 668
#File: E:\bishe\1\AbstractBpmn2PropertiesComposite.java
#Comment:
	/**
	 * This method is called when setEObject is called and this should recreate all bindings and widgets for the
	 * component.
	 */

#Code:
	public abstract void createBindings();

	protected Text createTextInput(String name, boolean multiLine) {
		createLabel(name);

		int flag = SWT.BORDER;
		if (multiLine) {
			flag |= SWT.BORDER | SWT.WRAP | SWT.MULTI;
		}
		Text text = new Text(this, flag);
		GridData data = new GridData(SWT.FILL, SWT.CENTER, true, false, 2, 1);
		if (multiLine) {
			data.heightHint = 50;
		}
		text.setLayoutData(data);
		toolkit.adapt(text, true, true);
		widgets.add(text);

		return text;
	}

#No. 669
#File: E:\bishe\1\AbstractBpmn2PropertiesComposite.java
#Comment:
			/**
			 * taken from
			 * http://dev.eclipse.org/viewcvs/viewvc.cgi/org.eclipse.swt.snippets/src/org/eclipse/swt/snippets
			 * /Snippet19.java?view=co
			 */

#Code:
			@Override
			public void verifyText(VerifyEvent e) {
				String string = e.text;
				char[] chars = new char[string.length()];
				string.getChars(0, chars.length, chars, 0);
				for (int i = 0; i < chars.length; i++) {
					if (!('0' <= chars[i] && chars[i] <= '9')) {
						e.doit = false;
						return;
					}
				}
			}

#No. 670
#File: E:\bishe\1\AbstractBreakOnThrowable.java
#Comment:
/**
 * Abstract composite that enables the service to use the @BreakCircuitOnThrowable annotation
 * on methods.
 */

#Code:
@Concerns(BreakCircuitConcern.class)
@Mixins(ServiceCircuitBreakerMixin.class)
public interface AbstractBreakOnThrowable
   extends ServiceCircuitBreaker
{
}

#No. 671
#File: E:\bishe\1\AbstractBringAndGoPlugin.java
#Comment:
    	/*if(getWorkspace()==null)
    		return false;
    	else if(getWorkspace().isLayer2())
    		return false;
    	else*/

#Code:
    		return true;
    }
    
    protected void setupRendering(IBoundedItem item, List<IBoundedItem> neighbours) {
        layered.getBringAndGoLayer().setCurrentItem(item);
        layered.getBringAndGoLayer().setNeighbours(neighbours);

        grayPolicy.apply(layered.getMainHierarchicalRenderer());
        
        layered.setVisible(layered.getMainHierarchicalRenderer(), false);
        layered.setHittable(layered.getMainHierarchicalRenderer(), false);
        layered.setOperational(layered.getLouposcopeLayer(), false);
        layered.setOperational(layered.getBringAndGoLayer(), true);
    }

#No. 672
#File: E:\bishe\1\AbstractBTreePartition.java
#Comment:
    /**
     * Gets the path in which this Partition stores data.
     *
     * @return the path in which this Partition stores data.
     */

#Code:
    public URI getPartitionPath()
    {
        return partitionPath;
    }

#No. 673
#File: E:\bishe\1\AbstractBTreePartition.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public void repair() throws Exception
    {
        // Do nothing by default
        doRepair();
    }

#No. 674
#File: E:\bishe\1\AbstractBTreePartition.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    protected void doInit() throws Exception
    {
        // First, inject the indexed attributes if any
        if ( ( indexedAttributes != null ) && ( indexedAttributes.size() > 0 ) )
        {
            for ( Index index : indexedAttributes )
            {
                addIndex( index );
            }
        }

        // Now, initialize the configured index
        setupSystemIndices();
        setupUserIndices();

        if ( cacheService != null )
        {
            aliasCache = cacheService.getCache( "alias" );
    
            int cacheSizeConfig = aliasCache.getCacheConfiguration().getMaxElementsInMemory();
    
            if ( cacheSizeConfig < cacheSize )
            {
                aliasCache.getCacheConfiguration().setMaxElementsInMemory( cacheSize );
            }
            
            piarCache = cacheService.getCache( "piar" );
            
            cacheSizeConfig = piarCache.getCacheConfiguration().getMaxElementsInMemory();
    
            if ( cacheSizeConfig < cacheSize )
            {
                piarCache.getCacheConfiguration().setMaxElementsInMemory( cacheSize * 3 );
            }
            
            entryDnCache = cacheService.getCache( "entryDn" );
            entryDnCache.setMemoryStoreEvictionPolicy( new LruPolicy() );
            entryDnCache.getCacheConfiguration().setMaxElementsInMemory( cacheSize );
        }
    }

#No. 675
#File: E:\bishe\1\AbstractBTreePartition.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public EntryFilteringCursor search( SearchOperationContext searchContext ) throws LdapException
    {
        try
        {
            setRWLock( searchContext );

            if ( ctxCsnChanged && getSuffixDn().getNormName().equals( searchContext.getDn().getNormName() ) )
            {
                try
                {
                    ctxCsnSemaphore.acquire();
                    saveContextCsn();
                }
                catch ( Exception e )
                {
                    throw new LdapOperationErrorException( e.getMessage(), e );
                }
                finally
                {
                    ctxCsnSemaphore.release();
                }
            }
            
            PartitionSearchResult searchResult = searchEngine.computeResult( schemaManager, searchContext );

            Cursor<Entry> result = new EntryCursorAdaptor( this, searchResult );

            return new EntryFilteringCursorImpl( result, searchContext, schemaManager );
        }
        catch ( LdapException le )
        {
            // TODO: SearchEngine.cursor() should only throw LdapException, then the exception handling here can be removed
            throw le;
        }
        catch ( Exception e )
        {
            throw new LdapOperationErrorException( e.getMessage(), e );
        }
    }

#No. 676
#File: E:\bishe\1\AbstractBTreePartition.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public Entry lookup( LookupOperationContext lookupContext ) throws LdapException
    {
        setRWLock( lookupContext );
        String id = getEntryId( lookupContext.getDn() );

        if ( id == null )
        {
            return null;
        }

        if ( ctxCsnChanged && getSuffixDn().getNormName().equals( lookupContext.getDn().getNormName() ) )
        {
            try
            {
                ctxCsnSemaphore.acquire();
                saveContextCsn();
            }
            catch ( Exception e )
            {
                throw new LdapOperationErrorException( e.getMessage(), e );
            }
            finally
            {
                ctxCsnSemaphore.release();
            }
        }

        Entry entry = fetch( id, lookupContext.getDn() );

        return entry;
    }

#No. 677
#File: E:\bishe\1\AbstractBTreePartition.java
#Comment:
    /**
     * Get back an entry knowing its UUID
     *
     * @param id The Entry UUID we want to get back
     * @return The found Entry, or null if not found
     * @throws Exception If the lookup failed for any reason (except a not found entry)
     */

#Code:
    public Entry fetch( String id ) throws LdapException
    {
        try
        {
            rwLock.readLock().lock();

            Dn dn = buildEntryDn( id );

            return fetch( id, dn );
        }
        catch ( Exception e )
        {
            throw new LdapOperationErrorException( e.getMessage(), e );
        }
        finally
        {
            rwLock.readLock().unlock();
        }
    }

#No. 678
#File: E:\bishe\1\AbstractBTreePartition.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public void modify( ModifyOperationContext modifyContext ) throws LdapException
    {
        try
        {
            setRWLock( modifyContext );

            Entry modifiedEntry = modify( modifyContext.getDn(),
                modifyContext.getModItems().toArray( new Modification[]
                    {} ) );

            modifyContext.setAlteredEntry( modifiedEntry );

            updateCache( modifyContext );
        }
        catch ( Exception e )
        {
            throw new LdapOperationErrorException( e.getMessage(), e );
        }
    }

#No. 679
#File: E:\bishe\1\AbstractBTreePartition.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public void move( MoveOperationContext moveContext ) throws LdapException
    {
        if ( moveContext.getNewSuperior().isDescendantOf( moveContext.getDn() ) )
        {
            throw new LdapUnwillingToPerformException( ResultCodeEnum.UNWILLING_TO_PERFORM,
                "cannot place an entry below itself" );
        }

        try
        {
            setRWLock( moveContext );
            Dn oldDn = moveContext.getDn();
            Dn newSuperior = moveContext.getNewSuperior();
            Dn newDn = moveContext.getNewDn();
            Entry modifiedEntry = moveContext.getModifiedEntry();

            move( oldDn, newSuperior, newDn, modifiedEntry );
            updateCache( moveContext );
        }
        catch ( Exception e )
        {
            throw new LdapOperationErrorException( e.getMessage(), e );
        }
    }

#No. 680
#File: E:\bishe\1\AbstractBTreePartition.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public void moveAndRename( MoveAndRenameOperationContext moveAndRenameContext ) throws LdapException
    {
        if ( moveAndRenameContext.getNewSuperiorDn().isDescendantOf( moveAndRenameContext.getDn() ) )
        {
            throw new LdapUnwillingToPerformException( ResultCodeEnum.UNWILLING_TO_PERFORM,
                "cannot place an entry below itself" );
        }

        try
        {
            setRWLock( moveAndRenameContext );
            Dn oldDn = moveAndRenameContext.getDn();
            Dn newSuperiorDn = moveAndRenameContext.getNewSuperiorDn();
            Rdn newRdn = moveAndRenameContext.getNewRdn();
            boolean deleteOldRdn = moveAndRenameContext.getDeleteOldRdn();
            Entry modifiedEntry = moveAndRenameContext.getModifiedEntry();

            moveAndRename( oldDn, newSuperiorDn, newRdn, modifiedEntry, deleteOldRdn );
            updateCache( moveAndRenameContext );
        }
        catch ( LdapException le )
        {
            // In case we get an LdapException, just rethrow it as is to
            // avoid having it lost
            throw le;
        }
        catch ( Exception e )
        {
            throw new LdapOperationErrorException( e.getMessage(), e );
        }
    }

#No. 681
#File: E:\bishe\1\AbstractBTreePartition.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public void rename( RenameOperationContext renameContext ) throws LdapException
    {
        try
        {
            setRWLock( renameContext );
            Dn oldDn = renameContext.getDn();
            Rdn newRdn = renameContext.getNewRdn();
            boolean deleteOldRdn = renameContext.getDeleteOldRdn();

            if ( renameContext.getEntry() != null )
            {
                Entry modifiedEntry = renameContext.getModifiedEntry();
                rename( oldDn, newRdn, deleteOldRdn, modifiedEntry );
            }
            else
            {
                rename( oldDn, newRdn, deleteOldRdn, null );
            }

            updateCache( renameContext );
        }
        catch ( Exception e )
        {
            throw new LdapOperationErrorException( e.getMessage(), e );
        }
    }

#No. 682
#File: E:\bishe\1\AbstractBTreePartition.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @SuppressWarnings("unchecked")
    public final synchronized void rename( Dn dn, Rdn newRdn, boolean deleteOldRdn, Entry entry ) throws Exception
    {
        String oldId = getEntryId( dn );

        rename( oldId, newRdn, deleteOldRdn, entry );

        /*
         * H A N D L E   D N   C H A N G E
         * ====================================================================
         * We only need to update the Rdn index.
         * No need to calculate the new Dn.
         */
        String parentId = getParentId( oldId );

        // Get the old parentIdAndRdn to get the nb of children and descendant
        ParentIdAndRdn parentIdAndRdn = rdnIdx.reverseLookup( oldId );

        // Now we can drop it
        rdnIdx.drop( oldId );

        // Update the descendants
        parentIdAndRdn.setParentId( parentId );
        parentIdAndRdn.setRdns( newRdn );

        rdnIdx.add( parentIdAndRdn, oldId );

        entryDnCache.removeAll();
        
        if ( isSyncOnWrite.get() )
        {
            sync();
        }
    }

#No. 683
#File: E:\bishe\1\AbstractBTreePartition.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public final void unbind( UnbindOperationContext unbindContext ) throws LdapException
    {
        // does nothing
    }

#No. 684
#File: E:\bishe\1\AbstractBTreePartition.java
#Comment:
    /**
     * This method calls {@link Partition#lookup(LookupOperationContext)} and return <tt>true</tt>
     * if it returns an entry by default.  Please override this method if
     * there is more effective way for your implementation.
     */

#Code:
    public boolean hasEntry( HasEntryOperationContext entryContext ) throws LdapException
    {
        try
        {
            setRWLock( entryContext );

            String id = getEntryId( entryContext.getDn() );

            Entry entry = fetch( id, entryContext.getDn() );

            return entry != null;
        }
        catch ( LdapException e )
        {
            return false;
        }
    }

#No. 685
#File: E:\bishe\1\AbstractBTreePartition.java
#Comment:
    /**
     * updates the CSN index
     *
     * @param entry the entry having entryCSN attribute
     * @param id UUID of the entry
     * @throws Exception
     */

#Code:
    private void updateCsnIndex( Entry entry, String id ) throws Exception
    {
        String entryCsn = entry.get( SchemaConstants.ENTRY_CSN_AT ).getString();
        entryCsnIdx.drop( id );
        entryCsnIdx.add( entryCsn, id );
    }

#No. 686
#File: E:\bishe\1\AbstractBTreePartition.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public long count() throws Exception
    {
        return master.count();
    }

#No. 687
#File: E:\bishe\1\AbstractBTreePartition.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public final long getChildCount( String id ) throws LdapException
    {
        try
        {
            ParentIdAndRdn parentIdAndRdn = rdnIdx.reverseLookup( id );

            return parentIdAndRdn.getNbChildren();
        }
        catch ( Exception e )
        {
            throw new LdapOperationErrorException( e.getMessage(), e );
        }
    }

#No. 688
#File: E:\bishe\1\AbstractBTreePartition.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public final Dn getEntryDn( String id ) throws Exception
    {
        return buildEntryDn( id );
    }

#No. 689
#File: E:\bishe\1\AbstractBTreePartition.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public final String getEntryId( String parentId, Rdn rdn ) throws LdapException
    {
        try
        {
            ParentIdAndRdn suffixKey = new ParentIdAndRdn( parentId, rdn );

            // Check into the Rdn index
            try
            {
                rwLock.readLock().lock();
                String currentId = rdnIdx.forwardLookup( suffixKey );

                return currentId;
            }
            finally
            {
                rwLock.readLock().unlock();
            }
        }
        catch ( Exception e )
        {
            throw new LdapException( e.getMessage(), e );
        }
    }

#No. 690
#File: E:\bishe\1\AbstractBTreePartition.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public String getParentId( String childId ) throws Exception
    {
        try
        {
            rwLock.readLock().lock();
            ParentIdAndRdn key = rdnIdx.reverseLookup( childId );

            if ( key == null )
            {
                return null;
            }

            return key.getParentId();
        }
        finally
        {
            rwLock.readLock().unlock();
        }
    }

#No. 691
#File: E:\bishe\1\AbstractBTreePartition.java
#Comment:
    /**
     * Retrieve the SuffixID
     */

#Code:
    protected String getSuffixId() throws Exception
    {
        if ( suffixId == null )
        {
            ParentIdAndRdn key = new ParentIdAndRdn( Partition.ROOT_ID, suffixDn.getRdns() );

            try
            {
                rwLock.readLock().lock();
                suffixId = rdnIdx.forwardLookup( key );
            }
            finally
            {
                rwLock.readLock().unlock();
            }
        }

        return suffixId;
    }

#No. 692
#File: E:\bishe\1\AbstractBTreePartition.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public void addIndex( Index<?, String> index ) throws Exception
    {
        checkInitialized( "addIndex" );

        // Check that the index String is valid
        AttributeType attributeType = null;

        try
        {
            attributeType = schemaManager.lookupAttributeTypeRegistry( index.getAttributeId() );
        }
        catch ( LdapNoSuchAttributeException lnsae )
        {
            LOG.error( "Cannot initialize the index for AttributeType {}, this value does not exist",
                index.getAttributeId() );

            return;
        }

        String oid = attributeType.getOid();

        if ( SYS_INDEX_OIDS.contains( oid ) )
        {
            if ( !systemIndices.containsKey( oid ) )
            {
                systemIndices.put( oid, index );
            }
        }
        else
        {
            if ( !userIndices.containsKey( oid ) )
            {
                userIndices.put( oid, index );
            }
        }
    }

#No. 693
#File: E:\bishe\1\AbstractBTreePartition.java
#Comment:
    /**
     * Add some new indexes
     * @param indexes The added indexes
     */

#Code:
    public void addIndexedAttributes( Index<?, String>... indexes )
    {
        for ( Index<?, String> index : indexes )
        {
            indexedAttributes.add( index );
        }
    }

#No. 694
#File: E:\bishe\1\AbstractBTreePartition.java
#Comment:
    /**
     * Set the list of indexes for this partition
     * @param indexedAttributes The list of indexes
     */

#Code:
    public void setIndexedAttributes( Set<Index<?, String>> indexedAttributes )
    {
        this.indexedAttributes = indexedAttributes;
    }

#No. 695
#File: E:\bishe\1\AbstractBTreePartition.java
#Comment:
    /**
     * @return The list of indexed attributes
     */

#Code:
    public Set<Index<?, String>> getIndexedAttributes()
    {
        return indexedAttributes;
    }

#No. 696
#File: E:\bishe\1\AbstractBTreePartition.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public Iterator<String> getUserIndices()
    {
        return userIndices.keySet().iterator();
    }

#No. 697
#File: E:\bishe\1\AbstractBTreePartition.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public Iterator<String> getSystemIndices()
    {
        return systemIndices.keySet().iterator();
    }

#No. 698
#File: E:\bishe\1\AbstractBTreePartition.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public Index<?, String> getIndex( AttributeType attributeType ) throws IndexNotFoundException
    {
        String id = attributeType.getOid();

        if ( userIndices.containsKey( id ) )
        {
            return userIndices.get( id );
        }

        if ( systemIndices.containsKey( id ) )
        {
            return systemIndices.get( id );
        }

        throw new IndexNotFoundException( I18n.err( I18n.ERR_3, id, id ) );
    }

#No. 699
#File: E:\bishe\1\AbstractBTreePartition.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public Index<?, String> getUserIndex( AttributeType attributeType ) throws IndexNotFoundException
    {
        if ( attributeType == null )
        {
            throw new IndexNotFoundException( I18n.err( I18n.ERR_3, attributeType, attributeType ) );
        }

        String oid = attributeType.getOid();

        if ( userIndices.containsKey( oid ) )
        {
            return userIndices.get( oid );
        }

        throw new IndexNotFoundException( I18n.err( I18n.ERR_3, attributeType, attributeType ) );
    }

#No. 700
#File: E:\bishe\1\AbstractBTreePartition.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public Index<?, String> getSystemIndex( AttributeType attributeType ) throws IndexNotFoundException
    {
        if ( attributeType == null )
        {
            throw new IndexNotFoundException( I18n.err( I18n.ERR_2, attributeType, attributeType ) );
        }

        String oid = attributeType.getOid();

        if ( systemIndices.containsKey( oid ) )
        {
            return systemIndices.get( oid );
        }

        throw new IndexNotFoundException( I18n.err( I18n.ERR_2, attributeType, attributeType ) );
    }

#No. 701
#File: E:\bishe\1\AbstractBTreePartition.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @SuppressWarnings("unchecked")
    public Index<Dn, String> getAliasIndex()
    {
        return ( Index<Dn, String> ) systemIndices.get( ApacheSchemaConstants.APACHE_ALIAS_AT_OID );
    }

#No. 702
#File: E:\bishe\1\AbstractBTreePartition.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @SuppressWarnings("unchecked")
    public Index<String, String> getOneAliasIndex()
    {
        return ( Index<String, String> ) systemIndices.get( ApacheSchemaConstants.APACHE_ONE_ALIAS_AT_OID );
    }

#No. 703
#File: E:\bishe\1\AbstractBTreePartition.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @SuppressWarnings("unchecked")
    public Index<String, String> getSubAliasIndex()
    {
        return ( Index<String, String> ) systemIndices.get( ApacheSchemaConstants.APACHE_SUB_ALIAS_AT_OID );
    }

#No. 704
#File: E:\bishe\1\AbstractBTreePartition.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @SuppressWarnings("unchecked")
    public Index<String, String> getObjectClassIndex()
    {
        return ( Index<String, String> ) systemIndices.get( SchemaConstants.OBJECT_CLASS_AT_OID );
    }

#No. 705
#File: E:\bishe\1\AbstractBTreePartition.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @SuppressWarnings("unchecked")
    public Index<String, String> getEntryCsnIndex()
    {
        return ( Index<String, String> ) systemIndices.get( SchemaConstants.ENTRY_CSN_AT_OID );
    }

#No. 706
#File: E:\bishe\1\AbstractBTreePartition.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @SuppressWarnings("unchecked")
    public Index<String, String> getAdministrativeRoleIndex()
    {
        return ( Index<String, String> ) systemIndices.get( SchemaConstants.ADMINISTRATIVE_ROLE_AT_OID );
    }

#No. 707
#File: E:\bishe\1\AbstractBTreePartition.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @SuppressWarnings("unchecked")
    public Index<String, String> getPresenceIndex()
    {
        return ( Index<String, String> ) systemIndices.get( ApacheSchemaConstants.APACHE_PRESENCE_AT_OID );
    }

#No. 708
#File: E:\bishe\1\AbstractBTreePartition.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @SuppressWarnings("unchecked")
    public Index<ParentIdAndRdn, String> getRdnIndex()
    {
        return ( Index<ParentIdAndRdn, String> ) systemIndices.get( ApacheSchemaConstants.APACHE_RDN_AT_OID );
    }

#No. 709
#File: E:\bishe\1\AbstractBTreePartition.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public boolean hasUserIndexOn( AttributeType attributeType ) throws LdapException
    {
        return userIndices.containsKey( attributeType.getOid() );
    }

#No. 710
#File: E:\bishe\1\AbstractBTreePartition.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public boolean hasSystemIndexOn( AttributeType attributeType ) throws LdapException
    {
        return systemIndices.containsKey( attributeType.getOid() );
    }

#No. 711
#File: E:\bishe\1\AbstractBTreePartition.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public boolean hasIndexOn( AttributeType attributeType ) throws LdapException
    {
        return hasUserIndexOn( attributeType ) || hasSystemIndexOn( attributeType );
    }

#No. 712
#File: E:\bishe\1\AbstractBTreePartition.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public void dumpIndex( OutputStream stream, String name ) throws IOException
    {
        try
        {
            AttributeType attributeType = schemaManager.lookupAttributeTypeRegistry( name );

            if ( attributeType == null )
            {
                stream.write( Strings.getBytesUtf8( "Cannot find an index for AttributeType names " + name ) );

                return;
            }

            if ( attributeType.getOid().equals( ApacheSchemaConstants.APACHE_RDN_AT_OID ) )
            {
                dumpIndex( stream, rdnIdx );
            }
        }
        catch ( LdapException le )
        {
            stream.write( Strings.getBytesUtf8( "Cannot find an index for AttributeType names " + name ) );
        }
    }

#No. 713
#File: E:\bishe\1\AbstractBTreePartition.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public String toString()
    {
        return "Partition<" + id + ">";
    }

#No. 714
#File: E:\bishe\1\AbstractBTreePartition.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public MasterTable getMasterTable()
    {
        return master;
    }

#No. 715
#File: E:\bishe\1\AbstractBTreePartition.java
#Comment:
    /**
     * Acquire a Read lock
     */

#Code:
    private void lockRead()
    {
        rwLock.readLock().lock();
    }

#No. 716
#File: E:\bishe\1\AbstractBTreePartition.java
#Comment:
    /**
     * Release a Read lock
     */

#Code:
    private void unlockRead()
    {
        rwLock.readLock().unlock();
    }

#No. 717
#File: E:\bishe\1\AbstractBTreePartition.java
#Comment:
    /**
     * Acquire a Write lock
     */

#Code:
    private void lockWrite()
    {
        rwLock.writeLock().lock();
    }

#No. 718
#File: E:\bishe\1\AbstractBTreePartition.java
#Comment:
    /**
     * Release a Write lock
     */

#Code:
    private void unlockWrite()
    {
        rwLock.writeLock().unlock();
    }

#No. 719
#File: E:\bishe\1\AbstractBTreePartition.java
#Comment:
    /**
     * updates the cache based on the type of OperationContext
     * 
     * @param opCtx the operation's context
     */

#Code:
    public void updateCache( OperationContext opCtx )
    {
        // partition implementations should override this if they want to use cache
    }

#No. 720
#File: E:\bishe\1\AbstractBTreePartition.java
#Comment:
    /**
     * looks up for the entry with the given ID in the cache
     *
     * @param id the ID of the entry
     * @return the Entry if exists, null otherwise
     */

#Code:
    public Entry lookupCache( String id )
    {
        return null;
    }

#No. 721
#File: E:\bishe\1\AbstractBTreePartition.java
#Comment:
    /**
     * adds the given entry to cache
     *  
     * Note: this method is not called during add operation to avoid filling the cache
     *       with all the added entries
     *       
     * @param id ID of the entry
     * @param entry the Entry
     */

#Code:
    public void addToCache( String id, Entry entry )
    {
    }

#No. 722
#File: E:\bishe\1\AbstractBTreePartition.java
#Comment:
    /**
     * @return the optimizer
     */

#Code:
    public Optimizer getOptimizer()
    {
        return optimizer;
    }

#No. 723
#File: E:\bishe\1\AbstractBTreePartition.java
#Comment:
    /**
     * @param optimizer the optimizer to set
     */

#Code:
    public void setOptimizer( Optimizer optimizer )
    {
        this.optimizer = optimizer;
    }

#No. 724
#File: E:\bishe\1\AbstractBTreePartition.java
#Comment:
    /**
     * @param searchEngine the searchEngine to set
     */

#Code:
    public void setSearchEngine( SearchEngine searchEngine )
    {
        this.searchEngine = searchEngine;
    }

#No. 725
#File: E:\bishe\1\AbstractBTreePartition.java
#Comment:
    /**
     * Set and return the ReadWrite lock we use to protect the backend against concurrent modifications
     * 
     * @param operationContext The OperationContext which contain the reference to the OperationManager
     */

#Code:
    private void setRWLock( OperationContext operationContext )
    {
        if ( operationContext.getSession() != null )
        {
            rwLock = operationContext.getSession().getDirectoryService().getOperationManager().getRWLock();
        }
        else
        {
            if ( rwLock == null )
            {
                // Create a ReadWrite lock from scratch
                rwLock = new ReentrantReadWriteLock();
            }
        }
    }

#No. 726
#File: E:\bishe\1\AbstractBTreePartition.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public ReadWriteLock getReadWriteLock()
    {
        return rwLock;
    }

#No. 727
#File: E:\bishe\1\AbstractBTreePartition.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public Cache getAliasCache()
    {
        return aliasCache;
    }

#No. 728
#File: E:\bishe\1\AbstractBTreePartition.java
#Comment:
    /**
     * Loads the current context CSN present in the context entry of the partition
     *
     * @throws LdapException
     */

#Code:
    protected void loadContextCsn()
    {
        try
        {
            if ( rwLock == null )
            {
                // Create a ReadWrite lock from scratch
                rwLock = new ReentrantReadWriteLock();
            }

            // load the last stored valid CSN value
            String contextEntryId = getEntryId( getSuffixDn() );
            
            if ( contextEntryId == null )
            {
                return;
            }
            
            Entry entry = fetch( contextEntryId );
            
            Attribute ctxCsnAt = entry.get( contextCsnAT );
            
            if ( ctxCsnAt != null )
            {
                setContextCsn( ctxCsnAt.getString() );
                ctxCsnChanged = false; // this is just loaded, not new
            }
        }
        catch ( LdapException e )
        {
            throw new RuntimeException( e );
        }
    }

#No. 729
#File: E:\bishe\1\AbstractBTreePartition.java
#Comment:
    /**
     * Return the number of children and subordinates for a given entry
     *
     * @param dn The entry's DN
     * @return The Subordinate instance that contains the values.
     * @throws LdapException If we had an issue while processing the request
     */

#Code:
    public Subordinates getSubordinates( Entry entry ) throws LdapException
    {
        Subordinates subordinates = new Subordinates();
        
        try
        {
            // Check into the Rdn index, starting with the partition Suffix
            try
            {
                rwLock.readLock().lock();
                ParentIdAndRdn parentIdAndRdn = rdnIdx.reverseLookup( entry.get( SchemaConstants.ENTRY_UUID_AT ).getString() );

                subordinates.setNbChildren( parentIdAndRdn.getNbChildren() );
                subordinates.setNbSubordinates( parentIdAndRdn.getNbDescendants() );
            }
            finally
            {
                rwLock.readLock().unlock();
            }
        }
        catch ( Exception e )
        {
            throw new LdapException( e.getMessage(), e );
        }

        return subordinates;
    }

#No. 730
#File: E:\bishe\1\AbstractBucketConfig.java
#Comment:
    /**
     * Helper method to create the {@link NodeInfo}s from from the extended node information.
     *
     * In older server versions (< 3.0.2) the nodesExt part does not carry a hostname, so as a fallback the hostname
     * is loaded from the node info if needed.
     *
     * @param nodesExt the extended information.
     * @return the generated node infos.
     */

#Code:
    private List<NodeInfo> nodeInfoFromExtended(final List<PortInfo> nodesExt, final List<NodeInfo> nodeInfos) {
        List<NodeInfo> converted = new ArrayList<NodeInfo>(nodesExt.size());
        for (int i = 0; i < nodesExt.size(); i++) {
            NetworkAddress hostname = nodesExt.get(i).hostname();
            if (hostname == null) {
                hostname = nodeInfos.get(i).hostname();
            }
            Map<ServiceType, Integer> ports = nodesExt.get(i).ports();
            Map<ServiceType, Integer> sslPorts = nodesExt.get(i).sslPorts();

            // this is an ephemeral bucket (not supporting views), don't enable views!
            if (!bucketCapabilities.contains(BucketCapabilities.COUCHAPI)) {
                ports.remove(ServiceType.VIEW);
                sslPorts.remove(ServiceType.VIEW);
            }

            converted.add(new DefaultNodeInfo(hostname, ports, sslPorts));
        }
        return converted;
    }

#No. 731
#File: E:\bishe\1\AbstractBufferedInputStream.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public int read() throws IOException {
        while (available() < 1) {
            if (isEOF())
                return EOF;
            else
                loadBuffer();
        }

        return buf[curr++] & 0xff;
    }

#No. 732
#File: E:\bishe\1\AbstractBufferedInputStream.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public int available() throws IOException {
        checkClosed();
        if (buf == null)
            return 0;

        return buf.length - curr;
    }

#No. 733
#File: E:\bishe\1\AbstractBufferedInputStream.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public void close() throws IOException {
        if (!closed) {
            closed = true;
            super.close();
        }
    }

#No. 734
#File: E:\bishe\1\AbstractBufferedInputStream.java
#Comment:
    /**
     * Retrieves the next set of data and resets the current index.
     *
     * @throws java.io.IOException
     */

#Code:
    private void loadBuffer() throws IOException {
        buf = getNextBuffer();
        curr = 0;
    }

#No. 735
#File: E:\bishe\1\AbstractBufferedInputStream.java
#Comment:
    /**
     * Check if the stream has been closed.  If it has, it will throw an {@link java.io.IOException}.
     *
     * @throws java.io.IOException
     */

#Code:
    private void checkClosed() throws IOException {
        if (closed)
            throw new IOException("Cannot read from stream anymore.  It has been closed");
    }

#No. 736
#File: E:\bishe\1\AbstractBufferedOutputStream.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public void write(int b) throws IOException {
        checkClosed();
        if (available() < 1)
            flush();

        buf[curr++] = (byte) b;
    }

#No. 737
#File: E:\bishe\1\AbstractBufferedOutputStream.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public void flush() throws IOException {
        if (curr > 0) {
            writeBuffer(Arrays.copyOf(buf, curr));
            curr = 0;
        }
    }

#No. 738
#File: E:\bishe\1\AbstractBufferedOutputStream.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public void close() throws IOException {
        if (!closed) {
            closed = true;
            flush();
            super.close();
        }
    }

#No. 739
#File: E:\bishe\1\AbstractBufferedOutputStream.java
#Comment:
    /**
     * Provides the amount of buffer that is left to be written to.
     *
     * @return number of bytes available in the buffer
     */

#Code:
    protected int available() {
        return buf.length - curr;
    }

#No. 740
#File: E:\bishe\1\AbstractBufferedOutputStream.java
#Comment:
    /**
     * Check if the stream has been closed.  If it has, it will throw an {@link java.io.IOException}.
     *
     * @throws java.io.IOException
     */

#Code:
    private void checkClosed() throws IOException {
        if (closed)
            throw new IOException("Cannot read from stream anymore.  It has been closed");
    }

#No. 741
#File: E:\bishe\1\AbstractBufferOutput.java
#Comment:
    /**
     * total capacity.
     */

#Code:
    protected int             limit;

    public void writeBoolean(boolean b) {
        _write(b ? (byte) 1 : (byte) 0);
    }

#No. 742
#File: E:\bishe\1\AbstractBuffers.java
#Comment:
    /**
     * @return Returns the buffer size in bytes.
     */

#Code:
    public int getBufferSize()
    {
        return _bufferSize;
    }

#No. 743
#File: E:\bishe\1\AbstractBuffers.java
#Comment:
    /**
     * @return Returns the header size in bytes.
     */

#Code:
    public int getHeaderSize()
    {
        return _headerSize;
    }

#No. 744
#File: E:\bishe\1\AbstractBuffers.java
#Comment:
    /**
     * Create a new header Buffer
     * @return new Buffer
     */

#Code:
    final protected Buffer newHeader()
    {
        switch(_headerType)
        {
            case BYTE_ARRAY:
                return new ByteArrayBuffer(_headerSize);
            case DIRECT:
                return new DirectNIOBuffer(_headerSize);
            case INDIRECT:
                return new IndirectNIOBuffer(_headerSize);
        }
        throw new IllegalStateException();
    }

#No. 745
#File: E:\bishe\1\AbstractBuffers.java
#Comment:
    /**
     * Create a new content Buffer
     * @return new Buffer
     */

#Code:
    final protected Buffer newBuffer()
    {
       switch(_bufferType)
       {
           case BYTE_ARRAY:
               return new ByteArrayBuffer(_bufferSize);
           case DIRECT:
               return new DirectNIOBuffer(_bufferSize);
           case INDIRECT:
               return new IndirectNIOBuffer(_bufferSize);
       }
       throw new IllegalStateException();
    }

#No. 746
#File: E:\bishe\1\AbstractBuffers.java
#Comment:
    /**
     * Create a new content Buffer
     * @param size
     * @return new Buffer
     */

#Code:
    final protected Buffer newBuffer(int size)
    {
       switch(_otherType)
       {
           case BYTE_ARRAY:
               return new ByteArrayBuffer(size);
           case DIRECT:
               return new DirectNIOBuffer(size);
           case INDIRECT:
               return new IndirectNIOBuffer(size);
       }
       throw new IllegalStateException();
    }

#No. 747
#File: E:\bishe\1\AbstractBuffers.java
#Comment:
    /**
     * @param buffer
     * @return True if the buffer is the correct type to be a Header buffer
     */

#Code:
    public final boolean isHeader(Buffer buffer)
    {
        if (buffer.capacity()==_headerSize)
        {
            switch(_headerType)
            {
                case BYTE_ARRAY:
                    return buffer instanceof ByteArrayBuffer && !(buffer instanceof  IndirectNIOBuffer);
                case DIRECT:
                    return buffer instanceof  DirectNIOBuffer;
                case INDIRECT:
                    return buffer instanceof  IndirectNIOBuffer;
            }
        }
        return false;
    }

#No. 748
#File: E:\bishe\1\AbstractBuffers.java
#Comment:
    /**
     * @param buffer
     * @return True if the buffer is the correct type to be a Header buffer
     */

#Code:
    public final boolean isBuffer(Buffer buffer)
    {
        if (buffer.capacity()==_bufferSize)
        {
            switch(_bufferType)
            {
                case BYTE_ARRAY:
                    return buffer instanceof ByteArrayBuffer && !(buffer instanceof  IndirectNIOBuffer);
                case DIRECT:
                    return buffer instanceof  DirectNIOBuffer;
                case INDIRECT:
                    return buffer instanceof  IndirectNIOBuffer;
            }
        }
        return false;
    }

#No. 749
#File: E:\bishe\1\AbstractBuilderGenerator.java
#Comment:
    /**
     * Creates a builder method for the given getter method.
     *
     * @param property the getter method
     * @return a list of builder methods - this will allow us later to create additional builder methods for collection types
     */

#Code:
    protected List<MethodSpec> createBuilderMethods(final TypeElement returnType, final PropertyGenModel property) {
        final String builderMethodName = property.getJavaIdentifier();
        final List<MethodSpec> builderMethods = new ArrayList<>();
        builderMethods.add(createBuilderMethod(returnType, property));

        if (property.getType().equals(ClassName.get(Boolean.class)) && !builderMethodName.startsWith("is")) {
            final String additionalBooleanBuilderMethodName = "is" + StringUtils.capitalize(property.getName());
            builderMethods.add(createBuilderMethod(additionalBooleanBuilderMethodName, returnType, property));
        }
        return builderMethods;
    }

#No. 750
#File: E:\bishe\1\AbstractBuildFileNode.java
#Comment:
/**
 * Abstract class implementation for {@link IJSBuildFileNode}.
 *
 */

#Code:
public abstract class AbstractBuildFileNode extends PlatformObject implements
		IJSBuildFileNode {

	@Override
	public String getLabel() {
		return getName();
	}

	@Override
	public boolean hasChildren() {
		return getChildNodes().size() > 0;
	}

	@Override
	public Location getLocation(String text) {
		return null;
	}

}

#No. 751
#File: E:\bishe\1\AbstractBundle.java
#Comment:
	/**
	 * @see org.osgi.framework.Bundle#getBundleId()
	 * @category Bundle
	 */

#Code:
	public final long getBundleId() {
		return bundleId;
	}

#No. 752
#File: E:\bishe\1\AbstractBundle.java
#Comment:
	/**
	 * get the bundle location.
	 * 
	 * @return the bundle location.
	 * @see org.osgi.framework.Bundle#getLocation()
	 * @category Bundle
	 */

#Code:
	public final String getLocation() {
		if (isSecurityEnabled()) {
			// TODO: check AdminPermission(this,METADATA)
		}
		return location;
	}

#No. 753
#File: E:\bishe\1\AbstractBundle.java
#Comment:
	/**
	 * get the registered services of the bundle.
	 * 
	 * @return the service reference array.
	 * @see org.osgi.framework.Bundle#getRegisteredServices()
	 * @category Bundle
	 */

#Code:
	public final ServiceReference<?>[] getRegisteredServices() {
		if (state == UNINSTALLED) {
			throw new IllegalStateException("Bundle " + toString()
					+ "has been uninstalled.");
		}
		if (registeredServices == null) {
			return null;
		}

		/*
		 * FIXME: not the same page anymore --> core specifications page=91: If
		 * the Java runtime supports permissions, a ServiceReference object to a
		 * service is included in the returned list only if the caller has the
		 * ServicePermission to get the service using at least one of the names
		 * classes the service was registered under.
		 */
		if (isSecurityEnabled()) {
			return checkPermissions(registeredServices
					.toArray(new ServiceReferenceImpl[registeredServices.size()]));
		} else {
			return registeredServices
					.toArray(new ServiceReference[registeredServices.size()]);
		}
	}

#No. 754
#File: E:\bishe\1\AbstractBundle.java
#Comment:
	/**
	 * check if the bundle has a certain permission.
	 * 
	 * @param permission
	 *            the permission object
	 * @return true if the bundle has the permission.
	 * @see org.osgi.framework.Bundle#hasPermission(java.lang.Object)
	 * @category Bundle
	 */

#Code:
	public final boolean hasPermission(final Object permission) {
		checkBundleNotUninstalled();

		if (isSecurityEnabled()) {
			return permission instanceof Permission ? domain.getPermissions()
					.implies((Permission) permission) : false;
		} else {
			return true;
		}
	}

#No. 755
#File: E:\bishe\1\AbstractBundle.java
#Comment:
	/**
	 * 
	 * @see org.osgi.framework.Bundle#getLastModified()
	 * @category Bundle
	 */

#Code:
	public final long getLastModified() {
		return lastModified;
	}

#No. 756
#File: E:\bishe\1\AbstractBundle.java
#Comment:
	/**
	 * get bundle context
	 * 
	 * @return the bundle context if it exists, null otherwise
	 * @see org.osgi.framework.Bundle#getBundleContext()
	 * @category Bundle
	 */

#Code:
	public final BundleContext getBundleContext() {
		// check permissions
		if (isSecurityEnabled()) {
			// TODO: check AdminPermission(this,CONTEXT)
		}
		if (state == STARTING || state == ACTIVE || state == STOPPING) {
			return context;
		}
		return null;
	}

#No. 757
#File: E:\bishe\1\AbstractBundle.java
#Comment:
	/**
	 * @see java.lang.Comparable#compareTo(java.lang.Object)
	 * @category Bundle
	 */

#Code:
	public final int compareTo(final Bundle o) {
		return (int) (o.getBundleId() - bundleId);
	}

#No. 758
#File: E:\bishe\1\AbstractBundle.java
#Comment:
	/**
	 * @see org.osgi.framework.wiring.BundleRevisions#getRevisions()
	 * @category BundleRevisions
	 */

#Code:
	public final List<BundleRevision> getRevisions() {
		return Collections.unmodifiableList(revisions);
	}

#No. 759
#File: E:\bishe\1\AbstractBundle.java
#Comment:
	/**
	 * @see org.osgi.framework.BundleReference#getBundle()
	 * @category BundleReference
	 */

#Code:
	public final Bundle getBundle() {
		return this;
	}

#No. 760
#File: E:\bishe\1\AbstractBundle.java
#Comment:
	/**
	 * @see org.osgi.framework.Bundle#getDataFile(java.lang.String)
	 * @category Bundle
	 */

#Code:
	public final File getDataFile(final String filename) {
		// according to OSGi R5 spec 10.1.6.16: return null if fragment
		if (context != null) {
			return context.getDataFile(filename);
		} else {
			return null;
		}
	}

#No. 761
#File: E:\bishe\1\AbstractBundle.java
#Comment:
	/**
	 * remove all ServiceReferences for which the requesting bundle does not
	 * have appropriate permissions
	 * 
	 * @param refs
	 *            the references.
	 * @return the permitted references.
	 */

#Code:
	protected static final ServiceReference<?>[] checkPermissions(
			final ServiceReferenceImpl<?>[] refs) {
		final List<ServiceReferenceImpl<?>[]> results = new ArrayList<ServiceReferenceImpl<?>[]>(
				refs.length);
		final AccessControlContext controller = AccessController.getContext();
		for (int i = 0; i < refs.length; i++) {
			final String[] interfaces = (String[]) refs[i].properties
					.get(Constants.OBJECTCLASS);
			for (int j = 0; j < interfaces.length; j++) {
				try {
					controller.checkPermission(new ServicePermission(
							interfaces[j], ServicePermission.GET));
					results.add(refs);
					break;
				} catch (final SecurityException se) {
					// does not have the permission, try with the next interface
				}
			}
		}
		return results.toArray(new ServiceReference[results.size()]);
	}

#No. 762
#File: E:\bishe\1\AbstractBundleExecCommandBuilder.java
#Comment:
    /**
     * Will conditionally add bundle exec if bundle flag is "true".
     *
     * @param bundleFlag String which takes null or "true".
     * @return T command builder.
     */

#Code:
    @SuppressWarnings( "unchecked" )
    public T addIfBundleExec( @Nullable String bundleFlag ) {

        if ( BooleanUtils.toBoolean( bundleFlag ) ) {
            getCommandList().add(
                    getRubyLocator().buildExecutablePath( getRubyRuntime().getRubyRuntimeName(), getRubyExecutablePath(), BUNDLE_COMMAND ) );
            getCommandList().add( BUNDLE_EXEC_ARG );
        }

#No. 763
#File: E:\bishe\1\AbstractBundleExecCommandBuilder.java
#Comment:
    /**
     * Will conditionally append the verbose switch if verbose flag is "true".
     *
     * @param verboseFlag String which takes null or "true".
     * @return T command builder.
     */

#Code:
    @SuppressWarnings( "unchecked" )
    public T addIfVerbose( @Nullable String verboseFlag ) {

        if ( BooleanUtils.toBoolean( verboseFlag ) ) {
            getCommandList().add( VERBOSE_ARG );
        }

#No. 764
#File: E:\bishe\1\AbstractBurpMojo.java
#Comment:
        /*getLog().info("Starting headless burp " + getBurpExtenderToRun() + "...");
        getLog().info(StringUtils.join(burp.command().iterator(), " "));
        executeAndRedirectOutput(burp);*/

#Code:
    }

    protected ProcessBuilder createBurpProcessBuilder() throws MojoExecutionException {
        List<String> burpCommandLine = createBurpCommandLine();

        String extensionClassPath = getBurpExtensionClasspath();
        ProcessBuilder builder = new ProcessBuilder("java", "-Xmx1G", "-Djava.awt.headless=" + headless, "-classpath", extensionClassPath, "burp.StartBurp");
        builder.command().addAll(burpCommandLine);
        builder.redirectErrorStream(true);

        return builder;
    }

#No. 765
#File: E:\bishe\1\AbstractBurpMojo.java
#Comment:
         /*final InputStream is = burp.getInputStream();
        Thread infoLogThread = new Thread(() -> {
            try {
                BufferedReader burpOutputReader = new BufferedReader(new InputStreamReader(burp.getInputStream()));

                for (String line = burpOutputReader.readLine(); line != null; line = burpOutputReader.readLine()) {
                    getLog().info(line);
                    getLog().info("\033[0m ");
                }
            } catch (IOException e) {
                throw new RuntimeException("There was an error reading the output from Burp.", e);
            } finally {
                IOUtil.close(is);
            }
        });*/

#Code:

        Process process;
        try {
            process = processBuilder.start();
        } catch (IOException e) {
            throw new ProcessExecutionException(e);
        }

#No. 766
#File: E:\bishe\1\AbstractButtonBinder.java
#Comment:
	/**
	 * 
	 * @param buttonClass
	 * @param textID StringID member for label
	 * @return
	 */

#Code:
	protected AbstractButton createEmptyButton(
			Class<? extends AbstractButton> buttonClass, String textID) {

		ResourceHolder resourceHolder = ResourceHolder.getInstance();
	
		/*
		 * construct button
		 */
		AbstractButton button = null;
		try {
			button = buttonClass.newInstance();
		} catch (InstantiationException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IllegalAccessException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	
		/*
		 * set label
		 */
		try{
			button.setText(resourceHolder.getString(ResourceKey.LABEL, textID));
		}
		catch (Exception e) {
		}
	
		

		return button;
	}

#No. 767
#File: E:\bishe\1\AbstractButtonBuilder.java
#Comment:
    /**
     * Build the current builder
     * @return parent row builder
     */

#Code:
    public abstract InlineMenuRowBuilder<E> build();

    public abstract InlineMenuButton buildButton();

    /**
     * Set the text of the current button. Required call unless provided at init
     * @param text Text to be set
     * @return this
     */
    public T text(String text) {
        this.text = text;
        return instance();
    }

#No. 768
#File: E:\bishe\1\AbstractButtonBuilder.java
#Comment:
    /**
     * Set the button callback of this builder.
     * @param callback Callback to be set
     * @return this
     */

#Code:
    public T buttonCallback(ButtonCallback callback) {
        this.callback = callback;
        return instance();
    }

#No. 769
#File: E:\bishe\1\AbstractButtonBuilder.java
#Comment:
    /**
     * Build the current button, delegate to parent's newRow method
     * @return new row builder
     * @see InlineMenuRowBuilder#newRow()
     */

#Code:
    public InlineMenuRowBuilder<E> newRow() {
        build();
        return parent.newRow();
    }

#No. 770
#File: E:\bishe\1\AbstractButtonBuilder.java
#Comment:
    /**
     * Build the current button, delegate to parent's build method
     * @return current menu builder
     * @see InlineMenuRowBuilder#build()
     */

#Code:
    public E buildRow() {
        build();
        return parent.build();
    }

#No. 771
#File: E:\bishe\1\AbstractButtonBuilder.java
#Comment:
    /**
     * Build the button, build the parent's row, build the menu
     * @return built menu
     * @see InlineMenuRowBuilder#build()
     * @see AbstractInlineMenuBuilder#buildMenu()
     */

#Code:
    public InlineMenu buildMenu() {
        build();
        return parent.build().buildMenu();
    }

#No. 772
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final int minimumCapacity() {
        return minimumCapacity;
    }

#No. 773
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final ByteBuilder minimumCapacity(int minimumCapacity) {
        if (minimumCapacity < 0) {
            throw new IllegalArgumentException("minimumCapacity: " + minimumCapacity);
        }
        this.minimumCapacity = minimumCapacity;
        return this;
    }

#No. 774
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final int capacity() {
        return buf().capacity();
    }

#No. 775
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final ByteBuilder capacity(int newCapacity) {
        if (!recapacityAllowed) {
            throw new IllegalStateException("Derived buffers and their parent can't be expanded.");
        }

        // Allocate a new buffer and transfer all settings to it.
        if (newCapacity > capacity()) {
            // Expand:
            // // Save the state.
            int pos = position();
            int limit = limit();
            ByteOrder bo = order();

            // // Reallocate.
            ByteBuffer oldBuf = buf();
            ByteBuffer newBuf = getAllocator().allocateNioBuffer(newCapacity, isDirect());
            oldBuf.clear();
            newBuf.put(oldBuf);
            buf(newBuf);

            // // Restore the state.
            buf().limit(limit);
            if (mark >= 0) {
                buf().position(mark);
                buf().mark();
            }
            buf().position(pos);
            buf().order(bo);
        }

        return this;
    }

#No. 776
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final boolean isAutoExpand() {
        return autoExpand && recapacityAllowed;
    }

#No. 777
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final boolean isAutoShrink() {
        return autoShrink && recapacityAllowed;
    }

#No. 778
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final boolean isDerived() {
        return derived;
    }

#No. 779
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final ByteBuilder setAutoExpand(boolean autoExpand) {
        if (!recapacityAllowed) {
            throw new IllegalStateException("Derived buffers and their parent can't be expanded.");
        }
        this.autoExpand = autoExpand;
        return this;
    }

#No. 780
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final ByteBuilder setAutoShrink(boolean autoShrink) {
        if (!recapacityAllowed) {
            throw new IllegalStateException("Derived buffers and their parent can't be shrinked.");
        }
        this.autoShrink = autoShrink;
        return this;
    }

#No. 781
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final ByteBuilder expand(int expectedRemaining) {
        return expand(position(), expectedRemaining, false);
    }

#No. 782
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final ByteBuilder expand(int pos, int expectedRemaining) {
        return expand(pos, expectedRemaining, false);
    }

#No. 783
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final int position() {
        return buf().position();
    }

#No. 784
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final ByteBuilder position(int newPosition) {
        autoExpand(newPosition, 0);
        buf().position(newPosition);
        if (mark > newPosition) {
            mark = -1;
        }
        return this;
    }

#No. 785
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final int limit() {
        return buf().limit();
    }

#No. 786
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final ByteBuilder limit(int newLimit) {
        autoExpand(newLimit, 0);
        buf().limit(newLimit);
        if (mark > newLimit) {
            mark = -1;
        }
        return this;
    }

#No. 787
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final ByteBuilder mark() {
        ByteBuffer byteBuffer = buf();
        byteBuffer.mark();
        mark = byteBuffer.position();

        return this;
    }

#No. 788
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final int markValue() {
        return mark;
    }

#No. 789
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final ByteBuilder reset() {
        buf().reset();
        return this;
    }

#No. 790
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final ByteBuilder clear() {
        buf().clear();
        mark = -1;
        return this;
    }

#No. 791
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final ByteBuilder sweep() {
        clear();
        return fillAndReset(remaining());
    }

#No. 792
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final ByteBuilder sweep(byte value) {
        clear();
        return fillAndReset(value, remaining());
    }

#No. 793
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final ByteBuilder flip() {
        buf().flip();
        mark = -1;
        return this;
    }

#No. 794
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final ByteBuilder rewind() {
        buf().rewind();
        mark = -1;
        return this;
    }

#No. 795
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final int remaining() {
        ByteBuffer byteBuffer = buf();

        return byteBuffer.limit() - byteBuffer.position();
    }

#No. 796
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final boolean hasRemaining() {
        ByteBuffer byteBuffer = buf();

        return byteBuffer.limit() > byteBuffer.position();
    }

#No. 797
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final byte get() {
        return buf().get();
    }

#No. 798
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final short getUnsigned() {
        return (short) (get() & 0xff);
    }

#No. 799
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final ByteBuilder put(byte b) {
        autoExpand(1);
        buf().put(b);
        return this;
    }

#No. 800
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public ByteBuilder putUnsigned(byte value) {
        autoExpand(1);
        buf().put((byte) (value & 0xff));
        return this;
    }

#No. 801
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public ByteBuilder putUnsigned(int index, byte value) {
        autoExpand(index, 1);
        buf().put(index, (byte) (value & 0xff));
        return this;
    }

#No. 802
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public ByteBuilder putUnsigned(short value) {
        autoExpand(1);
        buf().put((byte) (value & 0x00ff));
        return this;
    }

#No. 803
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public ByteBuilder putUnsigned(int index, short value) {
        autoExpand(index, 1);
        buf().put(index, (byte) (value & 0x00ff));
        return this;
    }

#No. 804
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public ByteBuilder putUnsigned(int value) {
        autoExpand(1);
        buf().put((byte) (value & 0x000000ff));
        return this;
    }

#No. 805
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public ByteBuilder putUnsigned(int index, int value) {
        autoExpand(index, 1);
        buf().put(index, (byte) (value & 0x000000ff));
        return this;
    }

#No. 806
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public ByteBuilder putUnsigned(long value) {
        autoExpand(1);
        buf().put((byte) (value & 0x00000000000000ffL));
        return this;
    }

#No. 807
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public ByteBuilder putUnsigned(int index, long value) {
        autoExpand(index, 1);
        buf().put(index, (byte) (value & 0x00000000000000ffL));
        return this;
    }

#No. 808
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final byte get(int index) {
        return buf().get(index);
    }

#No. 809
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final short getUnsigned(int index) {
        return (short) (get(index) & 0xff);
    }

#No. 810
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final ByteBuilder put(int index, byte b) {
        autoExpand(index, 1);
        buf().put(index, b);
        return this;
    }

#No. 811
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final ByteBuilder get(byte[] dst, int offset, int length) {
        buf().get(dst, offset, length);
        return this;
    }

#No. 812
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final ByteBuilder put(ByteBuffer src) {
        autoExpand(src.remaining());
        buf().put(src);
        return this;
    }

#No. 813
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final ByteBuilder put(byte[] src, int offset, int length) {
        autoExpand(length);
        buf().put(src, offset, length);
        return this;
    }

#No. 814
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final ByteOrder order() {
        return buf().order();
    }

#No. 815
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final ByteBuilder order(ByteOrder bo) {
        buf().order(bo);
        return this;
    }

#No. 816
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final char getChar() {
        return buf().getChar();
    }

#No. 817
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final ByteBuilder putChar(char value) {
        autoExpand(2);
        buf().putChar(value);
        return this;
    }

#No. 818
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final char getChar(int index) {
        return buf().getChar(index);
    }

#No. 819
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final ByteBuilder putChar(int index, char value) {
        autoExpand(index, 2);
        buf().putChar(index, value);
        return this;
    }

#No. 820
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final CharBuffer asCharBuffer() {
        return buf().asCharBuffer();
    }

#No. 821
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final short getShort() {
        return buf().getShort();
    }

#No. 822
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final ByteBuilder putShort(short value) {
        autoExpand(2);
        buf().putShort(value);
        return this;
    }

#No. 823
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final short getShort(int index) {
        return buf().getShort(index);
    }

#No. 824
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final ByteBuilder putShort(int index, short value) {
        autoExpand(index, 2);
        buf().putShort(index, value);
        return this;
    }

#No. 825
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final ShortBuffer asShortBuffer() {
        return buf().asShortBuffer();
    }

#No. 826
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final int getInt() {
        return buf().getInt();
    }

#No. 827
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final ByteBuilder putInt(int value) {
        autoExpand(4);
        buf().putInt(value);
        return this;
    }

#No. 828
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final ByteBuilder putUnsignedInt(byte value) {
        autoExpand(4);
        buf().putInt((value & 0x00ff));
        return this;
    }

#No. 829
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final ByteBuilder putUnsignedInt(int index, byte value) {
        autoExpand(index, 4);
        buf().putInt(index, (value & 0x00ff));
        return this;
    }

#No. 830
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final ByteBuilder putUnsignedInt(short value) {
        autoExpand(4);
        buf().putInt((value & 0x0000ffff));
        return this;
    }

#No. 831
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final ByteBuilder putUnsignedInt(int index, short value) {
        autoExpand(index, 4);
        buf().putInt(index, (value & 0x0000ffff));
        return this;
    }

#No. 832
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final ByteBuilder putUnsignedInt(int value) {
        autoExpand(4);
        buf().putInt(value);
        return this;
    }

#No. 833
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final ByteBuilder putUnsignedInt(int index, int value) {
        autoExpand(index, 4);
        buf().putInt(index, value);
        return this;
    }

#No. 834
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final ByteBuilder putUnsignedInt(long value) {
        autoExpand(4);
        buf().putInt((int) (value & 0x00000000ffffffff));
        return this;
    }

#No. 835
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final ByteBuilder putUnsignedInt(int index, long value) {
        autoExpand(index, 4);
        buf().putInt(index, (int) (value & 0x00000000ffffffffL));
        return this;
    }

#No. 836
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final ByteBuilder putUnsignedShort(byte value) {
        autoExpand(2);
        buf().putShort((short) (value & 0x00ff));
        return this;
    }

#No. 837
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final ByteBuilder putUnsignedShort(int index, byte value) {
        autoExpand(index, 2);
        buf().putShort(index, (short) (value & 0x00ff));
        return this;
    }

#No. 838
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final ByteBuilder putUnsignedShort(short value) {
        autoExpand(2);
        buf().putShort(value);
        return this;
    }

#No. 839
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final ByteBuilder putUnsignedShort(int index, short value) {
        autoExpand(index, 2);
        buf().putShort(index, value);
        return this;
    }

#No. 840
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final ByteBuilder putUnsignedShort(int value) {
        autoExpand(2);
        buf().putShort((short) value);
        return this;
    }

#No. 841
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final ByteBuilder putUnsignedShort(int index, int value) {
        autoExpand(index, 2);
        buf().putShort(index, (short) value);
        return this;
    }

#No. 842
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final ByteBuilder putUnsignedShort(long value) {
        autoExpand(2);
        buf().putShort((short) (value));
        return this;
    }

#No. 843
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final ByteBuilder putUnsignedShort(int index, long value) {
        autoExpand(index, 2);
        buf().putShort(index, (short) (value));
        return this;
    }

#No. 844
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final int getInt(int index) {
        return buf().getInt(index);
    }

#No. 845
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final ByteBuilder putInt(int index, int value) {
        autoExpand(index, 4);
        buf().putInt(index, value);
        return this;
    }

#No. 846
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final IntBuffer asIntBuffer() {
        return buf().asIntBuffer();
    }

#No. 847
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final long getLong() {
        return buf().getLong();
    }

#No. 848
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final ByteBuilder putLong(long value) {
        autoExpand(8);
        buf().putLong(value);
        return this;
    }

#No. 849
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final long getLong(int index) {
        return buf().getLong(index);
    }

#No. 850
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final ByteBuilder putLong(int index, long value) {
        autoExpand(index, 8);
        buf().putLong(index, value);
        return this;
    }

#No. 851
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final LongBuffer asLongBuffer() {
        return buf().asLongBuffer();
    }

#No. 852
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final float getFloat() {
        return buf().getFloat();
    }

#No. 853
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final ByteBuilder putFloat(float value) {
        autoExpand(4);
        buf().putFloat(value);
        return this;
    }

#No. 854
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final float getFloat(int index) {
        return buf().getFloat(index);
    }

#No. 855
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final ByteBuilder putFloat(int index, float value) {
        autoExpand(index, 4);
        buf().putFloat(index, value);
        return this;
    }

#No. 856
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final FloatBuffer asFloatBuffer() {
        return buf().asFloatBuffer();
    }

#No. 857
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final double getDouble() {
        return buf().getDouble();
    }

#No. 858
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final ByteBuilder putDouble(double value) {
        autoExpand(8);
        buf().putDouble(value);
        return this;
    }

#No. 859
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final double getDouble(int index) {
        return buf().getDouble(index);
    }

#No. 860
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final ByteBuilder putDouble(int index, double value) {
        autoExpand(index, 8);
        buf().putDouble(index, value);
        return this;
    }

#No. 861
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final DoubleBuffer asDoubleBuffer() {
        return buf().asDoubleBuffer();
    }

#No. 862
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final ByteBuilder asReadOnlyBuffer() {
        recapacityAllowed = false;
        return asReadOnlyBuffer0();
    }

#No. 863
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final ByteBuilder duplicate() {
        recapacityAllowed = false;
        return duplicate0();
    }

#No. 864
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final ByteBuilder slice() {
        recapacityAllowed = false;
        return slice0();
    }

#No. 865
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final ByteBuilder getSlice(int index, int length) {
        if (length < 0) {
            throw new IllegalArgumentException("length: " + length);
        }

        int pos = position();
        int limit = limit();

        if (index > limit) {
            throw new IllegalArgumentException("index: " + index);
        }

        int endIndex = index + length;

        if (endIndex > limit) {
            throw new IndexOutOfBoundsException("index + length (" + endIndex + ") is greater " + "than limit ("
                    + limit + ").");
        }

        clear();
        position(index);
        limit(endIndex);

        ByteBuilder slice = slice();
        position(pos);
        limit(limit);

        return slice;
    }

#No. 866
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final ByteBuilder getSlice(int length) {
        if (length < 0) {
            throw new IllegalArgumentException("length: " + length);
        }
        int pos = position();
        int limit = limit();
        int nextPos = pos + length;
        if (limit < nextPos) {
            throw new IndexOutOfBoundsException("position + length (" + nextPos + ") is greater " + "than limit ("
                    + limit + ").");
        }

        limit(pos + length);
        ByteBuilder slice = slice();
        position(nextPos);
        limit(limit);
        return slice;
    }

#No. 867
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public int hashCode() {
        int h = 1;
        int p = position();
        for (int i = limit() - 1; i >= p; i--) {
            h = 31 * h + get(i);
        }
        return h;
    }

#No. 868
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public boolean equals(Object o) {
        if (!(o instanceof ByteBuilder)) {
            return false;
        }

        ByteBuilder that = (ByteBuilder) o;
        if (this.remaining() != that.remaining()) {
            return false;
        }

        int p = this.position();
        for (int i = this.limit() - 1, j = that.limit() - 1; i >= p; i--, j--) {
            byte v1 = this.get(i);
            byte v2 = that.get(j);
            if (v1 != v2) {
                return false;
            }
        }
        return true;
    }

#No. 869
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public int compareTo(ByteBuilder that) {
        int n = this.position() + Math.min(this.remaining(), that.remaining());
        for (int i = this.position(), j = that.position(); i < n; i++, j++) {
            byte v1 = this.get(i);
            byte v2 = that.get(j);
            if (v1 == v2) {
                continue;
            }
            if (v1 < v2) {
                return -1;
            }

            return +1;
        }
        return this.remaining() - that.remaining();
    }

#No. 870
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public String toString() {
        StringBuilder buf = new StringBuilder();
        if (isDirect()) {
            buf.append("DirectBuffer");
        } else {
            buf.append("HeapBuffer");
        }
        buf.append("[pos=");
        buf.append(position());
        buf.append(" lim=");
        buf.append(limit());
        buf.append(" cap=");
        buf.append(capacity());
        buf.append(": ");
        buf.append(getHexDump(16));
        buf.append(']');
        return buf.toString();
    }

#No. 871
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public ByteBuilder get(byte[] dst) {
        return get(dst, 0, dst.length);
    }

#No. 872
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public ByteBuilder put(ByteBuilder src) {
        return put(src.buf());
    }

#No. 873
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public ByteBuilder put(byte[] src) {
        return put(src, 0, src.length);
    }

#No. 874
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public int getUnsignedShort() {
        return getShort() & 0xffff;
    }

#No. 875
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public int getUnsignedShort(int index) {
        return getShort(index) & 0xffff;
    }

#No. 876
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public long getUnsignedInt() {
        return getInt() & 0xffffffffL;
    }

#No. 877
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public int getMediumInt() {
        byte b1 = get();
        byte b2 = get();
        byte b3 = get();
        if (ByteOrder.BIG_ENDIAN.equals(order())) {
            return getMediumInt(b1, b2, b3);
        }

        return getMediumInt(b3, b2, b1);
    }

#No. 878
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public int getUnsignedMediumInt() {
        int b1 = getUnsigned();
        int b2 = getUnsigned();
        int b3 = getUnsigned();
        if (ByteOrder.BIG_ENDIAN.equals(order())) {
            return b1 << 16 | b2 << 8 | b3;
        }

        return b3 << 16 | b2 << 8 | b1;
    }

#No. 879
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public int getMediumInt(int index) {
        byte b1 = get(index);
        byte b2 = get(index + 1);
        byte b3 = get(index + 2);
        if (ByteOrder.BIG_ENDIAN.equals(order())) {
            return getMediumInt(b1, b2, b3);
        }

        return getMediumInt(b3, b2, b1);
    }

#No. 880
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public int getUnsignedMediumInt(int index) {
        int b1 = getUnsigned(index);
        int b2 = getUnsigned(index + 1);
        int b3 = getUnsigned(index + 2);
        if (ByteOrder.BIG_ENDIAN.equals(order())) {
            return b1 << 16 | b2 << 8 | b3;
        }

        return b3 << 16 | b2 << 8 | b1;
    }

#No. 881
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    private int getMediumInt(byte b1, byte b2, byte b3) {
        int ret = b1 << 16 & 0xff0000 | b2 << 8 & 0xff00 | b3 & 0xff;
        // Check to see if the medium int is negative (high bit in b1 set)
        if ((b1 & 0x80) == 0x80) {
            // Make the the whole int negative
            ret |= 0xff000000;
        }
        return ret;
    }

#No. 882
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public ByteBuilder putMediumInt(int value) {
        byte b1 = (byte) (value >> 16);
        byte b2 = (byte) (value >> 8);
        byte b3 = (byte) value;

        if (ByteOrder.BIG_ENDIAN.equals(order())) {
            put(b1).put(b2).put(b3);
        } else {
            put(b3).put(b2).put(b1);
        }

        return this;
    }

#No. 883
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public ByteBuilder putMediumInt(int index, int value) {
        byte b1 = (byte) (value >> 16);
        byte b2 = (byte) (value >> 8);
        byte b3 = (byte) value;

        if (ByteOrder.BIG_ENDIAN.equals(order())) {
            put(index, b1).put(index + 1, b2).put(index + 2, b3);
        } else {
            put(index, b3).put(index + 1, b2).put(index + 2, b1);
        }

        return this;
    }

#No. 884
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public long getUnsignedInt(int index) {
        return getInt(index) & 0xffffffffL;
    }

#No. 885
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public OutputStream asOutputStream() {
        return new OutputStream() {
            @Override
            public void write(byte[] b, int off, int len) {
                AbstractByteBuilder.this.put(b, off, len);
            }

            @Override
            public void write(int b) {
                AbstractByteBuilder.this.put((byte) b);
            }
        };
    }

#No. 886
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public String getHexDump() {
        return this.getHexDump(Integer.MAX_VALUE);
    }

#No. 887
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public String getHexDump(int lengthLimit) {
        return IoBufferHexDumper.getHexdump(this, lengthLimit);
    }

#No. 888
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public String getPrefixedString(CharsetDecoder decoder) throws CharacterCodingException {
        return getPrefixedString(2, decoder);
    }

#No. 889
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public ByteBuilder putPrefixedString(CharSequence in, CharsetEncoder encoder) throws CharacterCodingException {
        return putPrefixedString(in, 2, 0, encoder);
    }

#No. 890
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public ByteBuilder putPrefixedString(CharSequence in, int prefixLength, CharsetEncoder encoder)
            throws CharacterCodingException {
        return putPrefixedString(in, prefixLength, 0, encoder);
    }

#No. 891
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public ByteBuilder putPrefixedString(CharSequence in, int prefixLength, int padding, CharsetEncoder encoder)
            throws CharacterCodingException {
        return putPrefixedString(in, prefixLength, padding, (byte) 0, encoder);
    }

#No. 892
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public Object getObject() throws ClassNotFoundException {
        return getObject(Thread.currentThread().getContextClassLoader());
    }

#No. 893
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public ByteBuilder putObject(Object o) {
        int oldPos = position();
        skip(4); // Make a room for the length field.
        try {
            ObjectOutputStream out = new ObjectOutputStream(asOutputStream()) {
                @Override
                protected void writeClassDescriptor(ObjectStreamClass desc) throws IOException {
                    try {
                        Class<?> clz = Class.forName(desc.getName());
                        if (!Serializable.class.isAssignableFrom(clz)) { // NON-Serializable
                                                                         // class
                            write(0);
                            super.writeClassDescriptor(desc);
                        } else { // Serializable class
                            write(1);
                            writeUTF(desc.getName());
                        }
                    } catch (ClassNotFoundException ex) { // Primitive types
                        write(0);
                        super.writeClassDescriptor(desc);
                    }
                }
            };
            out.writeObject(o);
            out.flush();
        } catch (IOException e) {
            throw new BufferDataException(e);
        }

        // Fill the length field
        int newPos = position();
        position(oldPos);
        putInt(newPos - oldPos - 4);
        position(newPos);
        return this;
    }

#No. 894
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public boolean prefixedDataAvailable(int prefixLength) {
        return prefixedDataAvailable(prefixLength, Integer.MAX_VALUE);
    }

#No. 895
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public boolean prefixedDataAvailable(int prefixLength, int maxDataLength) {
        if (remaining() < prefixLength) {
            return false;
        }

        int dataLength;
        switch (prefixLength) {
        case 1:
            dataLength = getUnsigned(position());
            break;
        case 2:
            dataLength = getUnsignedShort(position());
            break;
        case 4:
            dataLength = getInt(position());
            break;
        default:
            throw new IllegalArgumentException("prefixLength: " + prefixLength);
        }

        if (dataLength < 0 || dataLength > maxDataLength) {
            throw new BufferDataException("dataLength: " + dataLength);
        }

        return remaining() - prefixLength >= dataLength;
    }

#No. 896
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public int indexOf(byte b) {
        if (hasArray()) {
            int arrayOffset = arrayOffset();
            int beginPos = arrayOffset + position();
            int limit = arrayOffset + limit();
            byte[] array = array();

            for (int i = beginPos; i < limit; i++) {
                if (array[i] == b) {
                    return i - arrayOffset;
                }
            }
        } else {
            int beginPos = position();
            int limit = limit();

            for (int i = beginPos; i < limit; i++) {
                if (get(i) == b) {
                    return i;
                }
            }
        }

        return -1;
    }

#No. 897
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public ByteBuilder skip(int size) {
        autoExpand(size);
        return position(position() + size);
    }

#No. 898
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public ByteBuilder fill(byte value, int size) {
        autoExpand(size);
        int q = size >>> 3;
        int r = size & 7;

        if (q > 0) {
            int intValue = value | value << 8 | value << 16 | value << 24;
            long longValue = intValue;
            longValue <<= 32;
            longValue |= intValue;

            for (int i = q; i > 0; i--) {
                putLong(longValue);
            }
        }

        q = r >>> 2;
        r = r & 3;

        if (q > 0) {
            int intValue = value | value << 8 | value << 16 | value << 24;
            putInt(intValue);
        }

        q = r >> 1;
        r = r & 1;

        if (q > 0) {
            short shortValue = (short) (value | value << 8);
            putShort(shortValue);
        }

        if (r > 0) {
            put(value);
        }

        return this;
    }

#No. 899
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public ByteBuilder fillAndReset(byte value, int size) {
        autoExpand(size);
        int pos = position();
        try {
            fill(value, size);
        } finally {
            position(pos);
        }
        return this;
    }

#No. 900
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public ByteBuilder fill(int size) {
        autoExpand(size);
        int q = size >>> 3;
        int r = size & 7;

        for (int i = q; i > 0; i--) {
            putLong(0L);
        }

        q = r >>> 2;
        r = r & 3;

        if (q > 0) {
            putInt(0);
        }

        q = r >> 1;
        r = r & 1;

        if (q > 0) {
            putShort((short) 0);
        }

        if (r > 0) {
            put((byte) 0);
        }

        return this;
    }

#No. 901
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public ByteBuilder fillAndReset(int size) {
        autoExpand(size);
        int pos = position();
        try {
            fill(size);
        } finally {
            position(pos);
        }

        return this;
    }

#No. 902
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public <E extends Enum<E>> E getEnum(Class<E> enumClass) {
        return toEnum(enumClass, getUnsigned());
    }

#No. 903
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public <E extends Enum<E>> E getEnum(int index, Class<E> enumClass) {
        return toEnum(enumClass, getUnsigned(index));
    }

#No. 904
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public <E extends Enum<E>> E getEnumShort(Class<E> enumClass) {
        return toEnum(enumClass, getUnsignedShort());
    }

#No. 905
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public <E extends Enum<E>> E getEnumShort(int index, Class<E> enumClass) {
        return toEnum(enumClass, getUnsignedShort(index));
    }

#No. 906
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public <E extends Enum<E>> E getEnumInt(Class<E> enumClass) {
        return toEnum(enumClass, getInt());
    }

#No. 907
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public <E extends Enum<E>> E getEnumInt(int index, Class<E> enumClass) {
        return toEnum(enumClass, getInt(index));
    }

#No. 908
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public ByteBuilder putEnum(Enum<?> e) {
        if (e.ordinal() > BYTE_MASK) {
            throw new IllegalArgumentException(enumConversionErrorMessage(e, "byte"));
        }
        return put((byte) e.ordinal());
    }

#No. 909
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public ByteBuilder putEnum(int index, Enum<?> e) {
        if (e.ordinal() > BYTE_MASK) {
            throw new IllegalArgumentException(enumConversionErrorMessage(e, "byte"));
        }
        return put(index, (byte) e.ordinal());
    }

#No. 910
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public ByteBuilder putEnumShort(Enum<?> e) {
        if (e.ordinal() > SHORT_MASK) {
            throw new IllegalArgumentException(enumConversionErrorMessage(e, "short"));
        }
        return putShort((short) e.ordinal());
    }

#No. 911
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public ByteBuilder putEnumShort(int index, Enum<?> e) {
        if (e.ordinal() > SHORT_MASK) {
            throw new IllegalArgumentException(enumConversionErrorMessage(e, "short"));
        }
        return putShort(index, (short) e.ordinal());
    }

#No. 912
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public ByteBuilder putEnumInt(Enum<?> e) {
        return putInt(e.ordinal());
    }

#No. 913
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public ByteBuilder putEnumInt(int index, Enum<?> e) {
        return putInt(index, e.ordinal());
    }

#No. 914
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public <E extends Enum<E>> EnumSet<E> getEnumSet(Class<E> enumClass) {
        return toEnumSet(enumClass, get() & BYTE_MASK);
    }

#No. 915
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public <E extends Enum<E>> EnumSet<E> getEnumSet(int index, Class<E> enumClass) {
        return toEnumSet(enumClass, get(index) & BYTE_MASK);
    }

#No. 916
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public <E extends Enum<E>> EnumSet<E> getEnumSetShort(Class<E> enumClass) {
        return toEnumSet(enumClass, getShort() & SHORT_MASK);
    }

#No. 917
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public <E extends Enum<E>> EnumSet<E> getEnumSetShort(int index, Class<E> enumClass) {
        return toEnumSet(enumClass, getShort(index) & SHORT_MASK);
    }

#No. 918
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public <E extends Enum<E>> EnumSet<E> getEnumSetInt(Class<E> enumClass) {
        return toEnumSet(enumClass, getInt() & INT_MASK);
    }

#No. 919
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public <E extends Enum<E>> EnumSet<E> getEnumSetInt(int index, Class<E> enumClass) {
        return toEnumSet(enumClass, getInt(index) & INT_MASK);
    }

#No. 920
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public <E extends Enum<E>> EnumSet<E> getEnumSetLong(Class<E> enumClass) {
        return toEnumSet(enumClass, getLong());
    }

#No. 921
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public <E extends Enum<E>> EnumSet<E> getEnumSetLong(int index, Class<E> enumClass) {
        return toEnumSet(enumClass, getLong(index));
    }

#No. 922
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public <E extends Enum<E>> ByteBuilder putEnumSet(Set<E> set) {
        long vector = toLong(set);
        if ((vector & ~BYTE_MASK) != 0) {
            throw new IllegalArgumentException("The enum set is too large to fit in a byte: " + set);
        }
        return put((byte) vector);
    }

#No. 923
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public <E extends Enum<E>> ByteBuilder putEnumSet(int index, Set<E> set) {
        long vector = toLong(set);
        if ((vector & ~BYTE_MASK) != 0) {
            throw new IllegalArgumentException("The enum set is too large to fit in a byte: " + set);
        }
        return put(index, (byte) vector);
    }

#No. 924
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public <E extends Enum<E>> ByteBuilder putEnumSetShort(Set<E> set) {
        long vector = toLong(set);
        if ((vector & ~SHORT_MASK) != 0) {
            throw new IllegalArgumentException("The enum set is too large to fit in a short: " + set);
        }
        return putShort((short) vector);
    }

#No. 925
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public <E extends Enum<E>> ByteBuilder putEnumSetShort(int index, Set<E> set) {
        long vector = toLong(set);
        if ((vector & ~SHORT_MASK) != 0) {
            throw new IllegalArgumentException("The enum set is too large to fit in a short: " + set);
        }
        return putShort(index, (short) vector);
    }

#No. 926
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public <E extends Enum<E>> ByteBuilder putEnumSetInt(Set<E> set) {
        long vector = toLong(set);
        if ((vector & ~INT_MASK) != 0) {
            throw new IllegalArgumentException("The enum set is too large to fit in an int: " + set);
        }
        return putInt((int) vector);
    }

#No. 927
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public <E extends Enum<E>> ByteBuilder putEnumSetInt(int index, Set<E> set) {
        long vector = toLong(set);
        if ((vector & ~INT_MASK) != 0) {
            throw new IllegalArgumentException("The enum set is too large to fit in an int: " + set);
        }
        return putInt(index, (int) vector);
    }

#No. 928
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public <E extends Enum<E>> ByteBuilder putEnumSetLong(Set<E> set) {
        return putLong(toLong(set));
    }

#No. 929
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public <E extends Enum<E>> ByteBuilder putEnumSetLong(int index, Set<E> set) {
        return putLong(index, toLong(set));
    }

#No. 930
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * This method forwards the call to {@link #expand(int)} only when <tt>autoExpand</tt> property is <tt>true</tt>.
     */

#Code:
    private ByteBuilder autoExpand(int expectedRemaining) {
        if (isAutoExpand()) {
            expand(expectedRemaining, true);
        }
        return this;
    }

#No. 931
#File: E:\bishe\1\AbstractByteBuilder.java
#Comment:
    /**
     * This method forwards the call to {@link #expand(int)} only when <tt>autoExpand</tt> property is <tt>true</tt>.
     */

#Code:
    private ByteBuilder autoExpand(int pos, int expectedRemaining) {
        if (isAutoExpand()) {
            expand(pos, expectedRemaining, true);
        }
        return this;
    }

#No. 932
#File: E:\bishe\1\AbstractByteHasher.java
#Comment:
  /**
   * Updates this hasher with the given bytes.
   */

#Code:
  protected void update(byte[] b) {
    update(b, 0, b.length);
  }

#No. 933
#File: E:\bishe\1\AbstractByteHasher.java
#Comment:
  /**
   * Updates this hasher with {@code len} bytes starting at {@code off} in the given buffer.
   */

#Code:
  protected void update(byte[] b, int off, int len) {
    for (int i = off; i < off + len; i++) {
      update(b[i]);
    }
  }

#No. 934
#File: E:\bishe\1\AbstractByteHasher.java
#Comment:
  /**
   * Updates the sink with the given number of bytes from the buffer.
   */

#Code:
  private Hasher update(int bytes) {
    try {
      update(scratch.array(), 0, bytes);
    } finally {
      scratch.clear();
    }
    return this;
  }

#No. 935
#File: E:\bishe\1\AbstractByteList.java
#Comment:
    /**
     * Returns the index of the first occurrence of the specified element.
     * Returns <code>-1</code> if the receiver does not contain this element.
     * 
     * @param element
     *            the element to be searched for.
     * @return the index of the first occurrence of the element in the receiver;
     *         returns <code>-1</code> if the element is not found.
     */

#Code:
    public int indexOf(byte element) { // delta
        return indexOfFromTo(element, 0, size - 1);
    }

#No. 936
#File: E:\bishe\1\AbstractByteList.java
#Comment:
    /**
     * Returns the index of the first occurrence of the specified element.
     * Returns <code>-1</code> if the receiver does not contain this element.
     * Searches between <code>from</code>, inclusive and <code>to</code>,
     * inclusive. Tests for identity.
     * 
     * @param element
     *            element to search for.
     * @param from
     *            the leftmost search position, inclusive.
     * @param to
     *            the rightmost search position, inclusive.
     * @return the index of the first occurrence of the element in the receiver;
     *         returns <code>-1</code> if the element is not found.
     * @exception IndexOutOfBoundsException
     *                index is out of range (
     *                <tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>
     *                ).
     */

#Code:
    public int indexOfFromTo(byte element, int from, int to) {
        checkRangeFromTo(from, to, size);

        for (int i = from; i <= to; i++) {
            if (element == getQuick(i))
                return i; // found
        }
        return -1; // not found
    }

#No. 937
#File: E:\bishe\1\AbstractByteList.java
#Comment:
    /**
     * Returns the index of the last occurrence of the specified element.
     * Returns <code>-1</code> if the receiver does not contain this element.
     * 
     * @param element
     *            the element to be searched for.
     * @return the index of the last occurrence of the element in the receiver;
     *         returns <code>-1</code> if the element is not found.
     */

#Code:
    public int lastIndexOf(byte element) {
        return lastIndexOfFromTo(element, 0, size - 1);
    }

#No. 938
#File: E:\bishe\1\AbstractByteList.java
#Comment:
    /**
     * Returns the index of the last occurrence of the specified element.
     * Returns <code>-1</code> if the receiver does not contain this element.
     * Searches beginning at <code>to</code>, inclusive until <code>from</code>,
     * inclusive. Tests for identity.
     * 
     * @param element
     *            element to search for.
     * @param from
     *            the leftmost search position, inclusive.
     * @param to
     *            the rightmost search position, inclusive.
     * @return the index of the last occurrence of the element in the receiver;
     *         returns <code>-1</code> if the element is not found.
     * @exception IndexOutOfBoundsException
     *                index is out of range (
     *                <tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>
     *                ).
     */

#Code:
    public int lastIndexOfFromTo(byte element, int from, int to) {
        checkRangeFromTo(from, to, size());

        for (int i = to; i >= from; i--) {
            if (element == getQuick(i))
                return i; // found
        }
        return -1; // not found
    }

#No. 939
#File: E:\bishe\1\AbstractByteList.java
#Comment:
    /**
     * Sorts the specified range of the receiver into ascending order.
     * 
     * The sorting algorithm is a modified mergesort (in which the merge is
     * omitted if the highest element in the low sublist is less than the lowest
     * element in the high sublist). This algorithm offers guaranteed n*log(n)
     * performance, and can approach linear performance on nearly sorted lists.
     * 
     * <p>
     * <b>You should never call this method unless you are sure that this
     * particular sorting algorithm is the right one for your data set.</b> It
     * is generally better to call <tt>sort()</tt> or <tt>sortFromTo(...)</tt>
     * instead, because those methods automatically choose the best sorting
     * algorithm.
     * 
     * @param from
     *            the index of the first element (inclusive) to be sorted.
     * @param to
     *            the index of the last element (inclusive) to be sorted.
     * @exception IndexOutOfBoundsException
     *                index is out of range (
     *                <tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>
     *                ).
     */

#Code:

    public void mergeSortFromTo(int from, int to) {
        int mySize = size();
        checkRangeFromTo(from, to, mySize);

        byte[] myElements = elements();
        cern.colt.Sorting.mergeSort(myElements, from, to + 1);
        elements(myElements);
        setSizeRaw(mySize);
    }

#No. 940
#File: E:\bishe\1\AbstractByteList.java
#Comment:
    /**
     * Sorts the receiver according to the order induced by the specified
     * comparator. All elements in the range must be <i>mutually comparable</i>
     * by the specified comparator (that is, <tt>c.compare(e1, e2)</tt> must not
     * throw a <tt>ClassCastException</tt> for any elements <tt>e1</tt> and
     * <tt>e2</tt> in the range).
     * <p>
     * 
     * This sort is guaranteed to be <i>stable</i>: equal elements will not be
     * reordered as a result of the sort.
     * <p>
     * 
     * The sorting algorithm is a modified mergesort (in which the merge is
     * omitted if the highest element in the low sublist is less than the lowest
     * element in the high sublist). This algorithm offers guaranteed n*log(n)
     * performance, and can approach linear performance on nearly sorted lists.
     * 
     * @param from
     *            the index of the first element (inclusive) to be sorted.
     * @param to
     *            the index of the last element (inclusive) to be sorted.
     * @param c
     *            the comparator to determine the order of the receiver.
     * @throws ClassCastException
     *             if the array contains elements that are not <i>mutually
     *             comparable</i> using the specified comparator.
     * @throws IllegalArgumentException
     *             if <tt>fromIndex &gt; toIndex</tt>
     * @throws ArrayIndexOutOfBoundsException
     *             if <tt>fromIndex &lt; 0</tt> or
     *             <tt>toIndex &gt; a.length</tt>
     * @exception IndexOutOfBoundsException
     *                index is out of range (
     *                <tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>
     *                ).
     */

#Code:
    public void mergeSortFromTo(int from, int to, ByteComparator c) {
        int mySize = size();
        checkRangeFromTo(from, to, mySize);

        byte[] myElements = elements();
        cern.colt.Sorting.mergeSort(myElements, from, to + 1, c);
        elements(myElements);
        setSizeRaw(mySize);
    }

#No. 941
#File: E:\bishe\1\AbstractByteList.java
#Comment:
    /**
     * Returns a new list of the part of the receiver between <code>from</code>,
     * inclusive, and <code>to</code>, inclusive.
     * 
     * @param from
     *            the index of the first element (inclusive).
     * @param to
     *            the index of the last element (inclusive).
     * @return a new list
     * @exception IndexOutOfBoundsException
     *                index is out of range (
     *                <tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>
     *                ).
     */

#Code:
    public AbstractByteList partFromTo(int from, int to) {
        checkRangeFromTo(from, to, size);

        int length = to - from + 1;
        ByteArrayList part = new ByteArrayList(length);
        part.addAllOfFromTo(this, from, to);
        return part;
    }

#No. 942
#File: E:\bishe\1\AbstractByteList.java
#Comment:
    /**
     * Sorts the specified range of the receiver into ascending numerical order.
     * The sorting algorithm is a tuned quicksort, adapted from Jon L. Bentley
     * and M. Douglas McIlroy's "Engineering a Sort Function", Software-Practice
     * and Experience, Vol. 23(11) P. 1249-1265 (November 1993). This algorithm
     * offers n*log(n) performance on many data sets that cause other quicksorts
     * to degrade to quadratic performance.
     * 
     * <p>
     * <b>You should never call this method unless you are sure that this
     * particular sorting algorithm is the right one for your data set.</b> It
     * is generally better to call <tt>sort()</tt> or <tt>sortFromTo(...)</tt>
     * instead, because those methods automatically choose the best sorting
     * algorithm.
     * 
     * @param from
     *            the index of the first element (inclusive) to be sorted.
     * @param to
     *            the index of the last element (inclusive) to be sorted.
     * @exception IndexOutOfBoundsException
     *                index is out of range (
     *                <tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>
     *                ).
     */

#Code:

    public void quickSortFromTo(int from, int to) {
        int mySize = size();
        checkRangeFromTo(from, to, mySize);

        byte[] myElements = elements();
        java.util.Arrays.sort(myElements, from, to + 1);
        elements(myElements);
        setSizeRaw(mySize);
    }

#No. 943
#File: E:\bishe\1\AbstractByteList.java
#Comment:
    /**
     * Sorts the receiver according to the order induced by the specified
     * comparator. All elements in the range must be <i>mutually comparable</i>
     * by the specified comparator (that is, <tt>c.compare(e1, e2)</tt> must not
     * throw a <tt>ClassCastException</tt> for any elements <tt>e1</tt> and
     * <tt>e2</tt> in the range).
     * <p>
     * 
     * The sorting algorithm is a tuned quicksort, adapted from Jon L. Bentley
     * and M. Douglas McIlroy's "Engineering a Sort Function", Software-Practice
     * and Experience, Vol. 23(11) P. 1249-1265 (November 1993). This algorithm
     * offers n*log(n) performance on many data sets that cause other quicksorts
     * to degrade to quadratic performance.
     * 
     * @param from
     *            the index of the first element (inclusive) to be sorted.
     * @param to
     *            the index of the last element (inclusive) to be sorted.
     * @param c
     *            the comparator to determine the order of the receiver.
     * @throws ClassCastException
     *             if the array contains elements that are not <i>mutually
     *             comparable</i> using the specified comparator.
     * @throws IllegalArgumentException
     *             if <tt>fromIndex &gt; toIndex</tt>
     * @throws ArrayIndexOutOfBoundsException
     *             if <tt>fromIndex &lt; 0</tt> or
     *             <tt>toIndex &gt; a.length</tt>
     * @exception IndexOutOfBoundsException
     *                index is out of range (
     *                <tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>
     *                ).
     */

#Code:
    public void quickSortFromTo(int from, int to, ByteComparator c) {
        int mySize = size();
        checkRangeFromTo(from, to, mySize);

        byte[] myElements = elements();
        cern.colt.Sorting.quickSort(myElements, from, to + 1, c);
        elements(myElements);
        setSizeRaw(mySize);
    }

#No. 944
#File: E:\bishe\1\AbstractByteList.java
#Comment:
    /**
     * Removes from the receiver all elements that are contained in the
     * specified list. Tests for identity.
     * 
     * @param other
     *            the other list.
     * @return <code>true</code> if the receiver changed as a result of the
     *         call.
     */

#Code:
    public boolean removeAll(AbstractByteList other) {
        if (other.size() == 0)
            return false; // nothing to do
        int limit = other.size() - 1;
        int j = 0;

        for (int i = 0; i < size; i++) {
            if (other.indexOfFromTo(getQuick(i), 0, limit) < 0)
                setQuick(j++, getQuick(i));
        }

        boolean modified = (j != size);
        setSize(j);
        return modified;
    }

#No. 945
#File: E:\bishe\1\AbstractByteList.java
#Comment:
    /**
     * Removes from the receiver all elements whose index is between
     * <code>from</code>, inclusive and <code>to</code>, inclusive. Shifts any
     * succeeding elements to the left (reduces their index). This call byteens
     * the list by <tt>(to - from + 1)</tt> elements.
     * 
     * @param from
     *            index of first element to be removed.
     * @param to
     *            index of last element to be removed.
     * @exception IndexOutOfBoundsException
     *                index is out of range (
     *                <tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>
     *                ).
     */

#Code:

    public void removeFromTo(int from, int to) {
        checkRangeFromTo(from, to, size);
        int numMoved = size - to - 1;
        if (numMoved > 0) {
            replaceFromToWithFrom(from, from - 1 + numMoved, this, to + 1);
            // fillFromToWith(from+numMoved, size-1, 0.0f); //delta
        }
        int width = to - from + 1;
        if (width > 0)
            setSizeRaw(size - width);
    }

#No. 946
#File: E:\bishe\1\AbstractByteList.java
#Comment:
    /**
     * Replaces a number of elements in the receiver with the same number of
     * elements of another list. Replaces elements in the receiver, between
     * <code>from</code> (inclusive) and <code>to</code> (inclusive), with
     * elements of <code>other</code>, starting from <code>otherFrom</code>
     * (inclusive).
     * 
     * @param from
     *            the position of the first element to be replaced in the
     *            receiver
     * @param to
     *            the position of the last element to be replaced in the
     *            receiver
     * @param other
     *            list holding elements to be copied into the receiver.
     * @param otherFrom
     *            position of first element within other list to be copied.
     */

#Code:
    public void replaceFromToWithFrom(int from, int to, AbstractByteList other, int otherFrom) {
        int length = to - from + 1;
        if (length > 0) {
            checkRangeFromTo(from, to, size());
            checkRangeFromTo(otherFrom, otherFrom + length - 1, other.size());

            // unambiguous copy (it may hold other==this)
            if (from <= otherFrom) {
                for (; --length >= 0;)
                    setQuick(from++, other.getQuick(otherFrom++));
            } else {
                int otherTo = otherFrom + length - 1;
                for (; --length >= 0;)
                    setQuick(to--, other.getQuick(otherTo--));
            }

        }
    }

#No. 947
#File: E:\bishe\1\AbstractByteList.java
#Comment:
    /**
     * Replaces the part between <code>from</code> (inclusive) and
     * <code>to</code> (inclusive) with the other list's part between
     * <code>otherFrom</code> and <code>otherTo</code>. Powerful (and tricky)
     * method! Both parts need not be of the same size (part A can both be
     * smaller or larger than part B). Parts may overlap. Receiver and other
     * list may (but most not) be identical. If <code>from &gt; to</code>, then
     * inserts other part before <code>from</code>.
     * 
     * @param from
     *            the first element of the receiver (inclusive)
     * @param to
     *            the last element of the receiver (inclusive)
     * @param other
     *            the other list (may be identical with receiver)
     * @param otherFrom
     *            the first element of the other list (inclusive)
     * @param otherTo
     *            the last element of the other list (inclusive)
     * 
     *            <p>
     *            <b>Examples:</b>
     * 
     *            <pre>
     * a=[0, 1, 2, 3, 4, 5, 6, 7]
     * b=[50, 60, 70, 80, 90]
     * a.R(...)=a.replaceFromToWithFromTo(...)
     * 
     * a.R(3,5,b,0,4)--&gt;[0, 1, 2, 50, 60, 70, 80, 90, 6, 7]
     * a.R(1,6,b,0,4)--&gt;[0, 50, 60, 70, 80, 90, 7]
     * a.R(0,6,b,0,4)--&gt;[50, 60, 70, 80, 90, 7]
     * a.R(3,5,b,1,2)--&gt;[0, 1, 2, 60, 70, 6, 7]
     * a.R(1,6,b,1,2)--&gt;[0, 60, 70, 7]
     * a.R(0,6,b,1,2)--&gt;[60, 70, 7]
     * a.R(5,3,b,0,4)--&gt;[0, 1, 2, 3, 4, 50, 60, 70, 80, 90, 5, 6, 7]
     * a.R(5,0,b,0,4)--&gt;[0, 1, 2, 3, 4, 50, 60, 70, 80, 90, 5, 6, 7]
     * a.R(5,3,b,1,2)--&gt;[0, 1, 2, 3, 4, 60, 70, 5, 6, 7]
     * a.R(5,0,b,1,2)--&gt;[0, 1, 2, 3, 4, 60, 70, 5, 6, 7]
     * 
     * Extreme cases:
     * a.R(5,3,b,0,0)--&gt;[0, 1, 2, 3, 4, 50, 5, 6, 7]
     * a.R(5,3,b,4,4)--&gt;[0, 1, 2, 3, 4, 90, 5, 6, 7]
     * a.R(3,5,a,0,1)--&gt;[0, 1, 2, 0, 1, 6, 7]
     * a.R(3,5,a,3,5)--&gt;[0, 1, 2, 3, 4, 5, 6, 7]
     * a.R(3,5,a,4,4)--&gt;[0, 1, 2, 4, 6, 7]
     * a.R(5,3,a,0,4)--&gt;[0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 5, 6, 7]
     * a.R(0,-1,b,0,4)--&gt;[50, 60, 70, 80, 90, 0, 1, 2, 3, 4, 5, 6, 7]
     * a.R(0,-1,a,0,4)--&gt;[0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 5, 6, 7]
     * a.R(8,0,a,0,4)--&gt;[0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4]
     * </pre>
     */

#Code:
    public void replaceFromToWithFromTo(int from, int to, AbstractByteList other, int otherFrom, int otherTo) {
        if (otherFrom > otherTo) {
            throw new IndexOutOfBoundsException("otherFrom: " + otherFrom + ", otherTo: " + otherTo);
        }

        if (this == other && to - from != otherTo - otherFrom) { // avoid
            // stumbling
            // over my
            // own feet
            replaceFromToWithFromTo(from, to, partFromTo(otherFrom, otherTo), 0, otherTo - otherFrom);
            return;
        }

        int length = otherTo - otherFrom + 1;
        int diff = length;
        int theLast = from - 1;

        if (to >= from) {
            diff -= (to - from + 1);
            theLast = to;
        }

        if (diff > 0) {
            beforeInsertDummies(theLast + 1, diff);
        } else {
            if (diff < 0) {
                removeFromTo(theLast + diff, theLast - 1);
            }
        }

        if (length > 0) {
            replaceFromToWithFrom(from, from + length - 1, other, otherFrom);
        }
    }

#No. 948
#File: E:\bishe\1\AbstractByteList.java
#Comment:
    /**
     * Replaces the part of the receiver starting at <code>from</code>
     * (inclusive) with all the elements of the specified collection. Does not
     * alter the size of the receiver. Replaces exactly
     * <tt>Math.max(0,Math.min(size()-from, other.size()))</tt> elements.
     * 
     * @param from
     *            the index at which to copy the first element from the
     *            specified collection.
     * @param other
     *            Collection to replace part of the receiver
     * @exception IndexOutOfBoundsException
     *                index is out of range (index &lt; 0 || index &gt;=
     *                size()).
     */

#Code:

    public void replaceFromWith(int from, java.util.Collection other) {
        checkRange(from, size());
        java.util.Iterator e = other.iterator();
        int index = from;
        int limit = Math.min(size() - from, other.size());
        for (int i = 0; i < limit; i++)
            set(index++, ((Number) e.next()).byteValue()); // delta
    }

#No. 949
#File: E:\bishe\1\AbstractByteList.java
#Comment:
    /**
     * Retains (keeps) only the elements in the receiver that are contained in
     * the specified other list. In other words, removes from the receiver all
     * of its elements that are not contained in the specified other list.
     * 
     * @param other
     *            the other list to test against.
     * @return <code>true</code> if the receiver changed as a result of the
     *         call.
     */

#Code:
    public boolean retainAll(AbstractByteList other) {
        if (other.size() == 0) {
            if (size == 0)
                return false;
            setSize(0);
            return true;
        }

        int limit = other.size() - 1;
        int j = 0;
        for (int i = 0; i < size; i++) {
            if (other.indexOfFromTo(getQuick(i), 0, limit) >= 0)
                setQuick(j++, getQuick(i));
        }

        boolean modified = (j != size);
        setSize(j);
        return modified;
    }

#No. 950
#File: E:\bishe\1\AbstractByteList.java
#Comment:
    /**
     * Reverses the elements of the receiver. Last becomes first, second last
     * becomes second first, and so on.
     */

#Code:

    public void reverse() {
        byte tmp;
        int limit = size() / 2;
        int j = size() - 1;

        for (int i = 0; i < limit;) { // swap
            tmp = getQuick(i);
            setQuick(i++, getQuick(j));
            setQuick(j--, tmp);
        }
    }

#No. 951
#File: E:\bishe\1\AbstractByteList.java
#Comment:
    /**
     * Replaces the element at the specified position in the receiver with the
     * specified element.
     * 
     * @param index
     *            index of element to replace.
     * @param element
     *            element to be stored at the specified position.
     * @exception IndexOutOfBoundsException
     *                if <tt>index &lt; 0 || index &gt;= size()</tt>.
     */

#Code:
    public void set(int index, byte element) {
        if (index >= size || index < 0)
            throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size);
        setQuick(index, element);
    }

#No. 952
#File: E:\bishe\1\AbstractByteList.java
#Comment:
    /**
     * Sets the size of the receiver without modifying it otherwise. This method
     * should not release or allocate new memory but simply set some instance
     * variable like <tt>size</tt>.
     * 
     * If your subclass overrides and delegates size changing methods to some
     * other object, you must make sure that those overriding methods not only
     * update the size of the delegate but also of this class. For example:
     * public DatabaseList extends AbstractByteList { ... public void
     * removeFromTo(int from,int to) { myDatabase.removeFromTo(from,to);
     * this.setSizeRaw(size-(to-from+1)); } }
     */

#Code:
    protected void setSizeRaw(int newSize) {
        size = newSize;
    }

#No. 953
#File: E:\bishe\1\AbstractByteList.java
#Comment:
    /**
     * Randomly permutes the part of the receiver between <code>from</code>
     * (inclusive) and <code>to</code> (inclusive).
     * 
     * @param from
     *            the index of the first element (inclusive) to be permuted.
     * @param to
     *            the index of the last element (inclusive) to be permuted.
     * @exception IndexOutOfBoundsException
     *                index is out of range (
     *                <tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>
     *                ).
     */

#Code:

    public void shuffleFromTo(int from, int to) {
        checkRangeFromTo(from, to, size());

        cern.jet.random.tdouble.DoubleUniform gen = new cern.jet.random.tdouble.DoubleUniform(
                new cern.jet.random.tdouble.engine.DRand(new java.util.Date()));
        for (int i = from; i < to; i++) {
            int random = gen.nextIntFromTo(i, to);

            // swap(i, random)
            byte tmpElement = getQuick(random);
            setQuick(random, getQuick(i));
            setQuick(i, tmpElement);
        }
    }

#No. 954
#File: E:\bishe\1\AbstractByteList.java
#Comment:
    /**
     * Returns the number of elements contained in the receiver.
     * 
     * @return the number of elements contained in the receiver.
     */

#Code:

    public int size() {
        return size;
    }

#No. 955
#File: E:\bishe\1\AbstractByteList.java
#Comment:
    /**
     * Returns a list which is a concatenation of <code>times</code> times the
     * receiver.
     * 
     * @param times
     *            the number of times the receiver shall be copied.
     */

#Code:
    public AbstractByteList times(int times) {
        AbstractByteList newList = new ByteArrayList(times * size());
        for (int i = times; --i >= 0;) {
            newList.addAllOfFromTo(this, 0, size() - 1);
        }
        return newList;
    }

#No. 956
#File: E:\bishe\1\AbstractByteList.java
#Comment:
    /**
     * Returns a <code>java.util.ArrayList</code> containing all the elements in
     * the receiver.
     */

#Code:

    public java.util.ArrayList toList() {
        int mySize = size();
        java.util.ArrayList list = new java.util.ArrayList(mySize);
        for (int i = 0; i < mySize; i++)
            list.add(new Byte(get(i)));
        return list;
    }

#No. 957
#File: E:\bishe\1\AbstractByteList.java
#Comment:
    /**
     * Returns a string representation of the receiver, containing the String
     * representation of each element.
     */

#Code:

    public String toString() {
        return cern.colt.Arrays.toString(partFromTo(0, size() - 1).elements());
    }

#No. 958
#File: E:\bishe\1\AbstractBytesToBytesMapSuite.java
#Comment:
/*
  private static final class CompressStream extends AbstractFunction1<OutputStream, OutputStream> {
    @Override
    public OutputStream apply(OutputStream stream) {
      return stream;
    }
  }
*/

#Code:
  @Before
  public void setup() {
  }

#No. 959
#File: E:\bishe\1\AbstractBytesToBytesMapSuite.java
#Comment:
  /**
   * Fast equality checking for byte arrays, since these comparisons are a bottleneck
   * in our stress tests.
   */

#Code:
  private static boolean arrayEquals(
      byte[] expected,
      Object base,
      long offset,
      long actualLengthBytes) {
    return (actualLengthBytes == expected.length) && ByteArrayMethods.arrayEquals(
      expected,
      Platform.BYTE_ARRAY_OFFSET,
      base,
      offset,
      expected.length
    );
  }

#No. 960
#File: E:\bishe\1\AbstractBytesToBytesMapSuite.java
#Comment:
/**
      for (Map.Entry<ByteBuffer, byte[]> entry : expected.entrySet()) {
        final byte[] key = JavaUtils.bufferToArray(entry.getKey());
        final byte[] value = entry.getValue();
        final BytesToBytesMap.Location loc =
          map.lookup(key, Platform.BYTE_ARRAY_OFFSET, key.length);
        Assert.assertTrue(loc.isDefined());
        Assert.assertTrue(
          arrayEquals(key, loc.getKeyBase(), loc.getKeyOffset(), loc.getKeyLength()));
        Assert.assertTrue(
          arrayEquals(value, loc.getValueBase(), loc.getValueOffset(), loc.getValueLength()));
 }
*/

#Code:
    } finally {
      map.free();
    }

#No. 961
#File: E:\bishe\1\AbstractBytesToBytesMapSuite.java
#Comment:
/**
      for (Map.Entry<ByteBuffer, byte[]> entry : expected.entrySet()) {
        final byte[] key = JavaUtils.bufferToArray(entry.getKey());
        final byte[] value = entry.getValue();
        final BytesToBytesMap.Location loc =
          map.lookup(key, Platform.BYTE_ARRAY_OFFSET, key.length);
        Assert.assertTrue(loc.isDefined());
        Assert.assertTrue(
          arrayEquals(key, loc.getKeyBase(), loc.getKeyOffset(), loc.getKeyLength()));
        Assert.assertTrue(
          arrayEquals(value, loc.getValueBase(), loc.getValueOffset(), loc.getValueLength()));
      }
*/

#Code:
    } finally {
      map.free();
    }

#No. 962
#File: E:\bishe\1\AbstractCache.java
#Comment:
    /**
     * Writes an element to the cache. NOTE: If disk caching is enabled, this will write through to
     * the disk, which may introduce a performance penalty.
     */

#Code:
    public synchronized ValT put(KeyT key, ValT value) {
        if (isDiskCacheEnabled) {
            cacheToDisk(key, value);
        }

        return cache.put(key, value);
    }

#No. 963
#File: E:\bishe\1\AbstractCache.java
#Comment:
    /**
     * Checks if a value is present in the cache. If the disk cached is enabled, this will also
     * check whether the value has been persisted to disk.
     * 
     * @param key
     *            the cache key
     * @return true if the value is cached in memory or on disk, false otherwise
     */

#Code:
    @SuppressWarnings("unchecked")
    public synchronized boolean containsKey(Object key) {
        return cache.containsKey(key) || (isDiskCacheEnabled && getFileForKey((KeyT) key).exists());
    }

#No. 964
#File: E:\bishe\1\AbstractCache.java
#Comment:
    /**
     * Checks if a value is present in the in-memory cache. This method ignores the disk cache.
     * 
     * @param key
     *            the cache key
     * @return true if the value is currently hold in memory, false otherwise
     */

#Code:
    public synchronized boolean containsKeyInMemory(Object key) {
        return cache.containsKey(key);
    }

#No. 965
#File: E:\bishe\1\AbstractCache.java
#Comment:
    /**
     * Checks if the given value is currently hold in memory.
     */

#Code:
    public synchronized boolean containsValue(Object value) {
        return cache.containsValue(value);
    }

#No. 966
#File: E:\bishe\1\AbstractCache.java
#Comment:
    /**
     * 
     * @param rootDir
     *            a folder name to enable caching or null to disable it.
     */

#Code:
    public void setDiskCacheEnabled(String rootDir) {
        if (rootDir != null && rootDir.length() > 0) {
            setRootDir(rootDir);
            this.isDiskCacheEnabled = true;
        } else {
            this.isDiskCacheEnabled = false;
        }
    }

#No. 967
#File: E:\bishe\1\AbstractCacheHandle.java
#Comment:
	/**
	 * 当Key存在时，会替换，当Key不存在时，会新增
	 * 当指定级别缓存器和当前缓存器级别一致时，当前缓存器设置缓存数据
	 * 当前缓存器设置完后，如果当前缓存器下还存在下个级别的缓存器，将数据交由下个级别的缓存器缓存
	 */

#Code:
	public void set(String cacheLevel, Map<String, String> map, int seconds) throws Exception{
		if(cacheLevel == null || this.level.equals(cacheLevel)){
			//set缓存时，如果明确了数据欲缓存的级别，那只有该级别和该级别下的缓存服务器才会缓存
			//例：数据要缓存在L2上，此时L1将不缓存，而L2和后续级别将缓存该数据
			if(this.isActivate()){
				client.set(map, seconds);
			}
			cacheLevel = null;
		}
		this.setNextHandle();
		if(this.nextHandle != null){
			this.nextHandle.set(cacheLevel, map, seconds);
		}
	}

#No. 968
#File: E:\bishe\1\AbstractCacheHandle.java
#Comment:
	/**
	 * 当Key存在时，失败，当Key不存在时，会新增
	 * 当指定级别缓存器和当前缓存器级别一致时，当前缓存器设置缓存数据
	 * 当前缓存器设置完后，如果当前缓存器下还存在下个级别的缓存器，将数据交由下个级别的缓存器缓存
	 */

#Code:
	public void add(String cacheLevel, Map<String, String> map, int seconds) throws Exception{
		if(cacheLevel == null || this.level.equals(cacheLevel)){
			if(this.isActivate()){
				client.add(map, seconds);
			}
			cacheLevel = null;
		}
		this.setNextHandle();
		if(this.nextHandle != null){
			this.nextHandle.add(cacheLevel, map, seconds);
		}
	}

#No. 969
#File: E:\bishe\1\AbstractCacheHandle.java
#Comment:
	/**
	 * 当Key存在时，会替换，当Key不存在时，会失败
	 * 当指定级别缓存器和当前缓存器级别一致时，当前缓存器设置缓存数据
	 * 当前缓存器设置完后，如果当前缓存器下还存在下个级别的缓存器，将数据交由下个级别的缓存器缓存
	 */

#Code:
	public void replace(String cacheLevel, Map<String, String> map, int seconds) throws Exception{
		if(cacheLevel == null || this.level.equals(cacheLevel)){
			if(this.isActivate()){
				client.replace(map, seconds);
			}
			cacheLevel = null;
		}
		this.setNextHandle();
		if(this.nextHandle != null){
			this.nextHandle.replace(cacheLevel, map, seconds);
		}
	}

#No. 970
#File: E:\bishe\1\AbstractCacheHandle.java
#Comment:
	/**
	 * 当前缓存器设置了Key，返回当前缓存器的Key内容，如果当前缓存器未设置Key，交给下一缓存器去获取
	 */

#Code:
	public Set<String> keys(String pattern, String regexp) throws Exception{
		if(this.isActivate()){
			Set<String> set = client.keys(pattern, regexp);
			if(set != null) {
				return set;
			}
		}
		
		this.setNextHandle();
		if (this.nextHandle != null) {
			return this.nextHandle.keys(pattern, regexp);
		} else {
			return null;
		}
	}

#No. 971
#File: E:\bishe\1\AbstractCacheHandle.java
#Comment:
	/**
	 * 设置失效时间
	 * 所有缓存级别只要存在该Key，都会设置失败时间
	 * 考虑到Key的分布可能不会在所有缓存器里都存在，所以只要有一个缓存器设置成功，则返回成功
	 * 
	 */

#Code:
	public Boolean expire(String key, int seconds) throws Exception {
		boolean result = false;
		if(this.isActivate()){
			result = client.expire(key, seconds);
		}
		this.setNextHandle();
		if(this.nextHandle != null){
			if(this.isActivate() && result){
				this.nextHandle.expire(key, seconds);
			} else {
				result = this.nextHandle.expire(key, seconds);
			}
		}
		return result;
	}

#No. 972
#File: E:\bishe\1\AbstractCacheHandle.java
#Comment:
	/**
	 * 当前缓存器如果激活，则根据Key获取Value，获到后直接返回，如果获不到，交由下一缓存器获取
	 */

#Code:
	public String get(String key) throws Exception{
		if(this.isActivate()){
			String value = client.get(key);
			if(value != null) {
				return value;
			}
		}
		this.setNextHandle();
		if (this.nextHandle != null) {
			return this.nextHandle.get(key);
		} else {
			return null;
		}
	}

#No. 973
#File: E:\bishe\1\AbstractCacheHandle.java
#Comment:
	/**
	 * 当前缓存器如果存在Key，返回True，否则交给下一缓存器判断
	 */

#Code:
	public Boolean exists(String key) throws Exception {
		if(this.isActivate()){
			Boolean value = client.exists(key);
			if(value != null && value) {
				return value;
			}
		}
		this.setNextHandle();
		if (this.nextHandle != null) {
			return this.nextHandle.exists(key);
		} else {
			return new Boolean(false);
		}
	}

#No. 974
#File: E:\bishe\1\AbstractCacheManager.java
#Comment:
    /**
     * the current cache policy.
     */

#Code:
    private int _cachePolicy;

    /**
     * in case of eviction policy we evict unused entries in order to ensure space.
     */
    protected int _evictionQuota;

    protected int m_CacheSize;


    /**
     * Evict a quota of entries from cache.
     *
     * @return number of actual evicted
     */
    abstract public int evictBatch(int evictionQuota);

    public void setEvictionQuota(int evictionQuota) {
        _evictionQuota = evictionQuota;
    }

#No. 975
#File: E:\bishe\1\AbstractCacheProvider.java
#Comment:
    /**
     * 避免关联key集合越积越多，按插入的先后顺序计算score便于后续定期删除。<br>
     * Score 即为 实际过期时间的时间戳
     * 
     * @return
     */

#Code:
    protected long calcScoreInRegionKeysSet(long expireSeconds) {
        long currentTime = System.currentTimeMillis() / 1000;
        long score = currentTime + expireSeconds - this.baseScoreInRegionKeysSet;
        return score;
    }

#No. 976
#File: E:\bishe\1\AbstractCachingAuthenticator.java
#Comment:
    /**
     * Clear out all elements from the cache.
     */

#Code:
    protected void clearCache() {
        cache.invalidateAll();
    }

#No. 977
#File: E:\bishe\1\AbstractCachingAuthenticator.java
#Comment:
    /**
     * If the Principal for this Credentials is already cached, return it.  Otherwise call {@link #loadPrincipal} and cache the results.
     */

#Code:
    @Override
    protected final Principal getPrincipal(final Credentials credentials) {
        try {
            Optional<Principal> principalOptional = cache.get(credentials.getApiKey(), new Callable<Optional<Principal>>() {
                public Optional<Principal> call() throws Exception {
                    return Optional.fromNullable(loadPrincipal(credentials));
                }
            });
            return principalOptional.orNull();
        } catch (ExecutionException e) {
            LOG.warn("Exception when loading the cache for credentials with API key " + credentials.getApiKey());
            return null;
        }
    }

#No. 978
#File: E:\bishe\1\AbstractCachingAuthenticator.java
#Comment:
    /**
     * Put this principal directly into cache.  This can avoid lookup on
     * user request and "prepay" the lookup cost.
     */

#Code:
    protected void cachePrincipal(String apiKey, Principal principal) {
        cache.put(apiKey, Optional.fromNullable(principal));
    }

#No. 979
#File: E:\bishe\1\AbstractCalendarView.java
#Comment:
    /**
     * Set the style for a single day. See DayStyleFactory for options.
     *
     * @param dayStyle The style
     * @see com.vdesmet.lib.calendar.factory.DayStyleFactory DayStyleFactory: Check the available values
     */

#Code:
    public void setDayStyle(int dayStyle) {
        if(DayStyleFactory.isValidStyle(dayStyle)) {
            this.mDayStyle = dayStyle;
        } else {
            throw new IllegalArgumentException("Day Style is invalid. Check DayStyleFactory for options");
        }
    }

#No. 980
#File: E:\bishe\1\AbstractCalendarView.java
#Comment:
    /**
     * Set the first day of the week that needs to be shown
     * All days of the week are valid
     *
     * @param day Day of the week. e.g. Calendar.MONDAY
     */

#Code:
    public void setFirstDayOfWeek(final int day) {
        if(day < Calendar.SUNDAY || day > Calendar.SATURDAY) {
            throw new IllegalArgumentException("day must be between " + Calendar.SUNDAY + " and " + Calendar.SATURDAY);
        }

        mFirstDayOfWeek = day;

        if(mFirstValidDay != null) {
            // Fix first day of week in the Calendar
            mFirstValidDay.setFirstDayOfWeek(mFirstDayOfWeek);

            // update calendar
            updateCalendar();
        }
        notifyDataSetChanged();
    }

#No. 981
#File: E:\bishe\1\AbstractCalendarView.java
#Comment:
    /**
     * (Optional) Set the last day of the week that needs to be shown
     * All days of the week are valid
     * If not set, it'll pick the day before the first day of the week
     * Possible implementation: Hide the weekends -> setLastDayOfWeek(Calendar.FRIDAY)
     *
     * @param day Day of the week. e.g. Calendar.SUNDAY
     */

#Code:
    public void setLastDayOfWeek(final int day) {
        if(day < Calendar.SUNDAY || day > Calendar.SATURDAY) {
            throw new IllegalArgumentException("day must be between " + Calendar.SUNDAY + " and " + Calendar.SATURDAY);
        }

        mLastDayOfWeek = day;
        notifyDataSetChanged();
    }

#No. 982
#File: E:\bishe\1\AbstractCalendarView.java
#Comment:
    /**
     * Set a first valid day. All the days before this day will be disabled.
     *
     * @param firstValidDay The first valid day
     */

#Code:
    public void setFirstValidDay(final Calendar firstValidDay) {
        // set all the useless attributes to 0
        firstValidDay.set(Calendar.HOUR_OF_DAY, 0);
        firstValidDay.set(Calendar.MINUTE, 0);
        firstValidDay.set(Calendar.SECOND, 0);
        firstValidDay.set(Calendar.MILLISECOND, 0);
        firstValidDay.setFirstDayOfWeek(mFirstDayOfWeek);

        mCurrentMonth = firstValidDay.get(Calendar.MONTH);

        this.mFirstValidDay = firstValidDay;

        updateCalendar();
        notifyDataSetChanged();
    }

#No. 983
#File: E:\bishe\1\AbstractCalendarView.java
#Comment:
    /**
     * (Optional) Set a custom last valid day. If set, all the days after this day will be disabled.
     * If not set, this will be the last day of the month
     *
     * @param lastValidDay The last valid day
     */

#Code:
    public void setLastValidDay(final Calendar lastValidDay) {
        // set all the useless attributes to 0
        lastValidDay.set(Calendar.HOUR_OF_DAY, 0);
        lastValidDay.set(Calendar.MINUTE, 0);
        lastValidDay.set(Calendar.SECOND, 0);
        lastValidDay.set(Calendar.MILLISECOND, 0);

        this.mLastValidDay = lastValidDay;
        notifyDataSetChanged();
    }

#No. 984
#File: E:\bishe\1\AbstractCalendarView.java
#Comment:
    /**
     * Set a DayAdapter
     * The DayAdapter will be able to change the TextViews of the headers/days
     * and is able to add Category Colors to days
     *
     * @param newAdapter The (new) adapter to be set
     */

#Code:
    public void setDayAdapter(DayAdapter newAdapter) {
        this.mDayAdapter = newAdapter;
    }

#No. 985
#File: E:\bishe\1\AbstractCalendarView.java
#Comment:
    /**
     * Set a custom Typeface for the days and headers(1-31 and Mon-Sun)
     *
     * @param newTypeFace The new Typeface which will be used, or null for default(Roboto Light)
     */

#Code:
    public void setTypeface(final Typeface newTypeFace) {
        if(newTypeFace != null) {
            this.mTypeface = newTypeFace;
        } else {
            // newTypeFace is null, reset to default
            setDefaultTypeface();
        }
    }

#No. 986
#File: E:\bishe\1\AbstractCalendarView.java
#Comment:
    /**
     * Set an onDayClick listener, which will be called when the user clicked on a valid Day
     *
     * @param listener Listener to respond to onClick events
     */

#Code:
    public void setOnDayClickListener(OnDayClickListener listener) {
        this.mOnDayClickListener = listener;
    }

#No. 987
#File: E:\bishe\1\AbstractCalendarView.java
#Comment:
    /**
     * Updates mFirstDayCalendar, so initView() knows on which day he needs to start
     * creating the views.
     */

#Code:
    private void updateCalendar() {
        // throw an exception if there is no calendar available
        if(mFirstValidDay == null) {
            throw new NullPointerException("mFirstValidDay is null. " +
                    "Did you forget to call setFirstValidDay(Calendar) to set the month?");
        }
        // create a new calendar
        final Calendar calendar = Calendar.getInstance();
        calendar.setTimeInMillis(mFirstValidDay.getTimeInMillis());

        // change calendar to first day of month
        calendar.set(Calendar.DAY_OF_MONTH, 1);

        // change day to firstDayOfWeek
        final int calendarDay = calendar.get(Calendar.DAY_OF_WEEK);

        // get the number of days we need to remove from the calendar, to start the calendar at mFirstDayOfWeek;
        final int daysToWithdraw;
        if(mFirstDayOfWeek > calendarDay)
            daysToWithdraw = (calendarDay + DAYS_IN_WEEK) - mFirstDayOfWeek;
        else
            daysToWithdraw = calendarDay - mFirstDayOfWeek;

        // withdraw that number from the calendar
        calendar.add(Calendar.DAY_OF_WEEK, -daysToWithdraw);

        // set all the useless attributes to 0
        calendar.set(Calendar.HOUR_OF_DAY, 0);
        calendar.set(Calendar.MINUTE, 0);
        calendar.set(Calendar.SECOND, 0);
        calendar.set(Calendar.MILLISECOND, 0);

        // set calendar
        this.mCalendarFirstDay = calendar;
    }

#No. 988
#File: E:\bishe\1\AbstractCalendarView.java
#Comment:
    /**
     * Get a human readable name for this day of the week
     *
     * @param dayOfWeek between Calendar.SUNDAY and Calendar.SATURDAY
     * @param resources A resources object which can be retrieved by Context.getResources()
     * @return A name for this day of the week. MON - SUN.
     * @throws IllegalArgumentException Thrown when provided dayOfWeek is invalid
     */

#Code:
    protected String getNameForDay(final int dayOfWeek, final Resources resources) throws IllegalArgumentException {
        switch(dayOfWeek) {
            case Calendar.MONDAY:
                return resources.getString(R.string.lib_header_monday);
            case Calendar.TUESDAY:
                return resources.getString(R.string.lib_header_tuesday);
            case Calendar.WEDNESDAY:
                return resources.getString(R.string.lib_header_wednesday);
            case Calendar.THURSDAY:
                return resources.getString(R.string.lib_header_thursday);
            case Calendar.FRIDAY:
                return resources.getString(R.string.lib_header_friday);
            case Calendar.SATURDAY:
                return resources.getString(R.string.lib_header_saturday);
            case Calendar.SUNDAY:
                return resources.getString(R.string.lib_header_sunday);
            default:
                // unknown day
                throw new IllegalArgumentException("dayOfWeek is not valid. Pick a value between 1 and 7. " +
                        "dayOfWeek: " + dayOfWeek);
        }
    }

#No. 989
#File: E:\bishe\1\AbstractCalendarView.java
#Comment:
    /**
     * Getter methods
     */

#Code:
    public int getFirstDayOfWeek() {
        return mFirstDayOfWeek;
    }

#No. 990
#File: E:\bishe\1\AbstractCalendarView.java
#Comment:
    /**
     * Get the number of days visible in one row.
     * For example, from monday to friday -> 5
     *
     * @return the number of columns in a row
     */

#Code:
    public int getDaysInRow() {
        int firstDayOfWeek = mFirstDayOfWeek;
        int daysInRow = 1;
        while(firstDayOfWeek != mLastDayOfWeek) {
            // Go to the next day in the week
            firstDayOfWeek = firstDayOfWeek % 7;
            firstDayOfWeek++;

            // Add another day
            daysInRow++;
        }

        return daysInRow;
    }

#No. 991
#File: E:\bishe\1\AbstractCalendarView.java
#Comment:
    /**
     * Return the currently selected dayStyle
     * @return the selected day style.
     */

#Code:
    public int getDayStyle() {
        return mDayStyle;
    }

#No. 992
#File: E:\bishe\1\AbstractCalendarView.java
#Comment:
    /**
     * Returns the currently selected Typeface
     * @return the selected typeface
     */

#Code:
    public Typeface getTypeface() {
        return mTypeface;
    }

#No. 993
#File: E:\bishe\1\AbstractCalendarView.java
#Comment:
    /**
     * Retrieve the TextView used for the [timeInMillis] date
     *
     * @param dayInMillis The time in milliseconds
     * @return The TextView representing the entered date
     */

#Code:
    public abstract TextView getTextViewForDate(final long dayInMillis);

}
}

#No. 994
#File: E:\bishe\1\AbstractCallbackHandler.java
#Comment:
  /**
   * Handles an unknown callback. The default implementation simply throws
   * an {@link UnsupportedCallbackException}.
   *
   * @param callback The callback to handle.
   * @throws IOException If an I/O error occurs.
   * @throws UnsupportedCallbackException If the specified callback is not
   *   supported.
   */

#Code:
  protected void handleOther(Callback callback)
    throws IOException, UnsupportedCallbackException
  {
    throw new UnsupportedCallbackException(callback);
  }

#No. 995
#File: E:\bishe\1\AbstractCalulationCollectionMerger.java
#Comment:
    /**
     * Convert the input into an iterable instance.
     * @param input the input object to iterate over.
     * @return an UniversalIterable instance.
     */

#Code:
    private Iterable convertInput(Object input) {
        return new UniversalIterable(input);
    }

#No. 996
#File: E:\bishe\1\AbstractCalulationCollectionMerger.java
#Comment:
    /**
     * Get the actual number from a property. An empty or null extra param means
     * return the same object.
     * 
     * @param value the source object to read from.
     * @param extraParam the name of the property to be read.
     * @return the expected double or 0 if value == null.
     */

#Code:
    protected Double getActualValue(Object value, String extraParam) {

        if (value == null) {
            return 0.0;
        }

        if (StringUtils.isEmpty(extraParam)) {
            return ((Number) value).doubleValue();
        } else {
            return ((Number) modifier.readPropertyValue(extraParam, value)).doubleValue();
        }
    }

#No. 997
#File: E:\bishe\1\AbstractCameraPositionPath.java
#Comment:
	/**
	 * @return The delta of the current and previous position
	 */

#Code:
	private double calculateDelta(Position currentPosition, Position previousPosition)
	{
		Vec4 current = animation.getView().getGlobe().computePointFromPosition(currentPosition);
		Vec4 previous = animation.getView().getGlobe().computePointFromPosition(previousPosition);
		return Math.abs(current.distanceTo3(previous));
	}

#No. 998
#File: E:\bishe\1\AbstractCameraPositionPath.java
#Comment:
	/**
	 * Swap the front and back buffers, giving access to the newly updated data
	 * for drawing
	 */

#Code:
	private void swapBuffers()
	{
		synchronized (pathBufferLock)
		{
			DoubleBuffer tmp = pathVertexFrontBuffer;
			pathVertexFrontBuffer = pathVertexBackBuffer;
			pathVertexBackBuffer = tmp;
			pathVertexFrontBuffer.rewind();

			tmp = pathColourFrontBuffer;
			pathColourFrontBuffer = pathColourBackBuffer;
			pathColourBackBuffer = tmp;
			pathColourFrontBuffer.rewind();
			
			pathReferenceCenterFront = pathReferenceCenterBack;
		}
	}

#No. 999
#File: E:\bishe\1\AbstractCanalInstanceHandle.java
#Comment:
    /**
     * 不指定 position 获取事件.
     * 该方法返回的条件：
     * a. 拿够{@link #messageBatchSize}条记录或者超过timeout时间
     * b. 如果{@link #messageTimeout} = 0，则阻塞至拿到batchSize记录才返回
     * <p/>
     * canal 会记住此 client 最新的position。 <br/>
     * 如果是第一次 fetch，则会从 canal 中保存的最老一条数据开始输出。
     */

#Code:
    @Override
    public Message getWithoutAck() {
        return canalConnector.getWithoutAck(messageBatchSize, messageTimeout, TimeUnit.MILLISECONDS);
    }

#No. 1000
#File: E:\bishe\1\AbstractCanalInstanceHandle.java
#Comment:
    /**
     * 如果batchId == 0, 则下次fetch的时候，可以从最后一个没有 {@link #ack(long)} 的地方开始拿, 即调用
     * {@link CanalConnector#rollback()}
     *
     * @param batchId message id
     */

#Code:
    @Override
    public void rollback(long batchId) {
        if (batchId == 0L) {
            canalConnector.rollback();
        } else {
            canalConnector.rollback(batchId);
        }
    }

#No. 1001
#File: E:\bishe\1\AbstractCanalInstanceHandle.java
#Comment:
    /**
     * 获取Message {@link CanalConnector#getWithoutAck(int, Long, TimeUnit)}的batchSize
     * 默认1000, 如果 <= 0, canal内部取默认1000
     */

#Code:
    public void setMessageBatchSize(int messageBatchSize) {
        this.messageBatchSize = messageBatchSize;
    }

#No. 1002
#File: E:\bishe\1\AbstractCanalInstanceHandle.java
#Comment:
    /**
     * 获取Message {@link CanalConnector#getWithoutAck(int, Long, TimeUnit)}的超时时间
     * time unit is ms, 默认1s
     */

#Code:
    public void setMessageTimeout(Long messageTimeout) {
        this.messageTimeout = messageTimeout;
    }

#No. 1003
#File: E:\bishe\1\AbstractCanalInstanceHandle.java
#Comment:
    /**
     * 轮询获取变更数据的时间间隔, 默认500ms, 如果对于实时性要求较高可以设置小一些
     *
     * @see #fetchInterval()
     */

#Code:
    public void setFetchInterval(long fetchInterval) {
        this.fetchInterval = fetchInterval;
    }

#No. 1004
#File: E:\bishe\1\AbstractCanalSelector.java
#Comment:
    /**
     * 记录一下message对象
     */

#Code:
    protected void dumpMessages(Message message, String startPosition, String endPosition, int total) {
        try {
            MDC.put(ClaveConfig.splitLogFileKey, destination);
            logger.info(SEP + "****************************************************" + SEP);
            logger.info(MessageDumper.dumpMessageInfo(message, startPosition, endPosition, total));
            logger.info("****************************************************" + SEP);
            if (dumpDetail) {// 判断一下是否需要打印详细信息
                dumpEventDatas(message.getDatas());
                logger.info("****************************************************" + SEP);
            }
        } finally {
            MDC.remove(ClaveConfig.splitLogFileKey);
        }
    }

#No. 1005
#File: E:\bishe\1\AbstractCanalSelector.java
#Comment:
    /**
     * 分批输出多个数据
     */

#Code:
    protected void dumpEventDatas(List<EventData> eventDatas) {
        int size = eventDatas.size();
        // 开始输出每条记录
        int index = 0;
        do {
            if (index + logSplitSize >= size) {
                logger.info(MessageDumper.dumpEventDatas(eventDatas.subList(index, size)));
            } else {
                logger.info(MessageDumper.dumpEventDatas(eventDatas.subList(index, index + logSplitSize)));
            }
            index += logSplitSize;
        } while (index < size);
    }

#No. 1006
#File: E:\bishe\1\AbstractCard.java
#Comment:
	/**
	 * @return the data
	 */

#Code:
	public Object getData() {
		return data;
	}

#No. 1007
#File: E:\bishe\1\AbstractCard.java
#Comment:
	/**
	 * @param data
	 *            the data to set
	 */

#Code:
	public void setData(Object data) {
		this.data = data;
	}

#No. 1008
#File: E:\bishe\1\AbstractCardProductAdapter.java
#Comment:
	/**
	 * This implementation returns <code>null</code>.
	 */

#Code:
	@Override
	public SystrayMenuItem getExtensionSystrayMenuItem() {
		return null;
	}

#No. 1009
#File: E:\bishe\1\AbstractCardProductAdapter.java
#Comment:
	/**
	 * This implementation returns an empty list.
	 */

#Code:
	@Override
	public List<Product> detectProducts() {
		return Collections.emptyList();
	}

#No. 1010
#File: E:\bishe\1\AbstractCassandraConfiguration.java
#Comment:
	/**
	 * Return keyspace attributes
	 * 
	 * @return KeyspaceAttributes
	 */

#Code:
	public KeyspaceAttributes getKeyspaceAttributes() {
		return new KeyspaceAttributes();
	}

#No. 1011
#File: E:\bishe\1\AbstractCassandraConfiguration.java
#Comment:
	/**
	 * Creates a {@link Session}. Will create, verify or drop tables in Cassandra on creation/destroy stage.
	 * 
	 * @see #cluster()
	 * @see #Keyspace()
	 * @return
	 * @throws ClassNotFoundException
	 * @throws Exception
	 */

#Code:
	@Bean
	public CassandraSessionFactoryBean session() throws Exception {
		CassandraSessionFactoryBean factory = new CassandraSessionFactoryBean();
		factory.setKeyspace(getKeyspace());
		factory.setCluster(cluster().getObject());
		factory.setConverter(converter());
		factory.setKeyspaceAttributes(getKeyspaceAttributes());
		factory.setBeanClassLoader(beanClassLoader);
		return factory;
	}

#No. 1012
#File: E:\bishe\1\AbstractCassandraConfiguration.java
#Comment:
	/**
	 * Return the base package to scan for mapped {@link Table}s. Will return the package name of the configuration class'
	 * (the concrete class, not this one here) by default. So if you have a {@code com.acme.AppConfig} extending
	 * {@link AbstractCassandraConfiguration} the base package will be considered {@code com.acme} unless the method is
	 * overriden to implement alternate behaviour.
	 * 
	 * @return the base package to scan for mapped {@link Table} classes or {@literal null} to not enable scanning for
	 *         entities.
	 */

#Code:
	protected String getMappingBasePackage() {
		return getClass().getPackage().getName();
	}

#No. 1013
#File: E:\bishe\1\AbstractCassandraConfiguration.java
#Comment:
	/**
	 * Creates a {@link CqlTemplate}.
	 * 
	 * @return CqlOperations
	 */

#Code:
	@Bean
	public CqlTemplateFactoryBean cqlTemplate() throws Exception {
		CqlTemplateFactoryBean factory = new CqlTemplateFactoryBean();
		factory.setKeyspace(getKeyspace());
		factory.setSession(session().getObject());
		return factory;
	}

#No. 1014
#File: E:\bishe\1\AbstractCassandraConfiguration.java
#Comment:
	/**
	 * Creates a {@link CassandraTemplate}.
	 * 
	 * @return CassandraOperations
	 */

#Code:
	@Bean
	public CassandraTemplateFactoryBean template() throws Exception {
		CassandraTemplateFactoryBean factory = new CassandraTemplateFactoryBean();
		factory.setKeyspace(getKeyspace());
		factory.setSession(session().getObject());
		factory.setConverter(converter());
		return factory;
	}

#No. 1015
#File: E:\bishe\1\AbstractCassandraConfiguration.java
#Comment:
	/**
	 * Return the {@link MappingContext} instance to map Entities to properties.
	 * 
	 * @return
	 * @throws ClassNotFoundException
	 * @throws Exception
	 */

#Code:
	@Bean
	public MappingContext<? extends CassandraPersistentEntity<?>, CassandraPersistentProperty> mappingContext() {
		CassandraMappingContext context = new CassandraMappingContext();
		context.setInitialEntitySet(getInitialEntitySet());
		return context;
	}

#No. 1016
#File: E:\bishe\1\AbstractCassandraConfiguration.java
#Comment:
	/**
	 * Return the {@link CassandraConverter} instance to convert Rows to Objects, Objects to BuiltStatements
	 * 
	 * @return
	 * @throws ClassNotFoundException
	 * @throws Exception
	 */

#Code:
	@Bean
	public CassandraConverter converter() {
		MappingCassandraConverter converter = new MappingCassandraConverter(mappingContext());
		converter.setBeanClassLoader(beanClassLoader);
		return converter;
	}

#No. 1017
#File: E:\bishe\1\AbstractCassandraConfiguration.java
#Comment:
	/**
	 * Scans the mapping base package for classes annotated with {@link Table}.
	 * 
	 * @see #getMappingBasePackage()
	 * @return
	 * @throws ClassNotFoundException
	 */

#Code:
	protected Set<Class<?>> getInitialEntitySet() {

		String basePackage = getMappingBasePackage();
		Set<Class<?>> initialEntitySet = new HashSet<Class<?>>();

		if (StringUtils.hasText(basePackage)) {
			ClassPathScanningCandidateComponentProvider componentProvider = new ClassPathScanningCandidateComponentProvider(
					false);
			componentProvider.addIncludeFilter(new AnnotationTypeFilter(Table.class));
			componentProvider.addIncludeFilter(new AnnotationTypeFilter(Persistent.class));

			for (BeanDefinition candidate : componentProvider.findCandidateComponents(basePackage)) {
				initialEntitySet.add(loadClass(candidate.getBeanClassName()));
			}
		}

		return initialEntitySet;
	}

#No. 1018
#File: E:\bishe\1\AbstractCassandraConfiguration.java
#Comment:
	/**
	 * Bean ClassLoader Aware for CassandraTemplate/CassandraAdminTemplate
	 */

#Code:
	@Override
	public void setBeanClassLoader(ClassLoader classLoader) {
		this.beanClassLoader = classLoader;
	}

#No. 1019
#File: E:\bishe\1\AbstractCassandraConfiguration.java
#Comment:
	/**
	 * Service method to load class and transform ClassNotFoundException to IllegalArgumentException
	 * 
	 * @param className
	 * @return
	 */

#Code:

	private Class<?> loadClass(String className) {
		try {
			return ClassUtils.forName(className, this.beanClassLoader);
		} catch (Exception e) {
			throw new IllegalArgumentException("class not found " + className, e);
		}
	}

#No. 1020
#File: E:\bishe\1\AbstractCassandraMutation.java
#Comment:
	/**
	 *
	 *
	 * @param key
	 * @return
	 */

#Code:
	public static byte[] md5(String key) {
		MessageDigest algorithm;
		try {
			algorithm=MessageDigest.getInstance("MD5");
		}
		catch (NoSuchAlgorithmException ex) {
			throw new RuntimeException(ex);
		}

		algorithm.reset();

		try {
			algorithm.update(key.getBytes("UTF-8"));
		}
		catch (UnsupportedEncodingException ex) {
			throw new RuntimeException(ex);
		}

		byte[] messageDigest=algorithm.digest();
		return messageDigest;
	}

#No. 1021
#File: E:\bishe\1\AbstractCassandraMutation.java
#Comment:
	/**
	 *
	 *
	 * @param key
	 * @return
	 */

#Code:
	public static String md5String(String key) {
		byte[] messageDigest=md5(key);
		return toHex(messageDigest);
	}

#No. 1022
#File: E:\bishe\1\AbstractCassandraMutation.java
#Comment:
	/**
	 * Encode a byte array as a hexadecimal string
	 *
	 * @param	bytes
	 * @return
	 */

#Code:
	public static String toHex(byte[] bytes) {
		StringBuilder hexString=new StringBuilder();
		for (int i=0; i<bytes.length; i++) {

			String hex=Integer.toHexString(0xFF & bytes[i]);
			if (hex.length() == 1) {
				hexString.append('0');
			}

			hexString.append(hex);
		}

		return hexString.toString();
	}

#No. 1023
#File: E:\bishe\1\AbstractCassandraQuery.java
#Comment:
	/**
	 * {@link Execution} for collection returning queries.
	 * 
	 * @author Alex Shvid
	 */

#Code:
	class CollectionExecution extends Execution {

		CollectionExecution() {
		}

		@Override
		public Object execute(String query) {
			return readCollection(query);
		}
	}

#No. 1024
#File: E:\bishe\1\AbstractCassandraQuery.java
#Comment:
	/**
	 * {@link Execution} to return a single entity.
	 * 
	 * @author Alex Shvid
	 */

#Code:
	class SingleEntityExecution extends Execution {

		private final boolean countProjection;

		private SingleEntityExecution(boolean countProjection) {
			this.countProjection = countProjection;
		}

		@Override
		Object execute(String query) {

			CassandraEntityMetadata<?> metadata = method.getEntityInformation();
			if (countProjection) {
				return cassandraOperations.getCqlOperations().buildQueryOperation(query).singleResult().firstColumn(Long.class).execute();
			} else {
				return cassandraOperations.buildFindOneOperation(metadata.getJavaType(), query).execute();
			}

		}
	}

#No. 1025
#File: E:\bishe\1\AbstractCatalogRegistryModule.java
#Comment:
    /**
     * Finalizes the content of the registry module, any further attempts for
     * changes will throw exceptions.
     */

#Code:
    protected void finalizeContent() {
        checkFinalizedContent();
        this.types = ImmutableMap.copyOf(this.types);
        this.values = ImmutableSet.copyOf(this.types.values());
    }

#No. 1026
#File: E:\bishe\1\AbstractCategoryItemRenderer.java
#Comment:
    /**
     * Sets the item label generator for a series and sends a
     * {@link RendererChangeEvent} to all registered listeners.
     *
     * @param series  the series index (zero based).
     * @param generator  the generator (<code>null</code> permitted).
     *
     * @see #getSeriesItemLabelGenerator(int)
     */

#Code:
    public void setSeriesItemLabelGenerator(int series,
                                        CategoryItemLabelGenerator generator) {
        this.itemLabelGeneratorList.set(series, generator);
        fireChangeEvent();
    }

#No. 1027
#File: E:\bishe\1\AbstractCategoryItemRenderer.java
#Comment:
    /**
     * Returns the base item label generator.
     *
     * @return The generator (possibly <code>null</code>).
     *
     * @see #setBaseItemLabelGenerator(CategoryItemLabelGenerator)
     */

#Code:
    public CategoryItemLabelGenerator getBaseItemLabelGenerator() {
        return this.baseItemLabelGenerator;
    }

#No. 1028
#File: E:\bishe\1\AbstractCategoryItemRenderer.java
#Comment:
    /**
     * Sets the base item label generator and sends a
     * {@link RendererChangeEvent} to all registered listeners.
     *
     * @param generator  the generator (<code>null</code> permitted).
     *
     * @see #getBaseItemLabelGenerator()
     */

#Code:
    public void setBaseItemLabelGenerator(
            CategoryItemLabelGenerator generator) {
        this.baseItemLabelGenerator = generator;
        fireChangeEvent();
    }

#No. 1029
#File: E:\bishe\1\AbstractCategoryItemRenderer.java
#Comment:
    /**
     * Returns the tool tip generator that should be used for the specified
     * item.  This method looks up the generator using the "three-layer"
     * approach outlined in the general description of this interface.  You
     * can override this method if you want to return a different generator per
     * item.
     *
     * @param row  the row index (zero-based).
     * @param column  the column index (zero-based).
     *
     * @return The generator (possibly <code>null</code>).
     */

#Code:
    public CategoryToolTipGenerator getToolTipGenerator(int row, int column) {

        CategoryToolTipGenerator result = null;
        if (this.toolTipGenerator != null) {
            result = this.toolTipGenerator;
        }
        else {
            result = getSeriesToolTipGenerator(row);
            if (result == null) {
                result = this.baseToolTipGenerator;
            }
        }
        return result;
    }

#No. 1030
#File: E:\bishe\1\AbstractCategoryItemRenderer.java
#Comment:
    /**
     * Returns the tool tip generator that will be used for ALL items in the
     * dataset (the "layer 0" generator).
     *
     * @return A tool tip generator (possibly <code>null</code>).
     *
     * @see #setToolTipGenerator(CategoryToolTipGenerator)
     *
     * @deprecated This method should no longer be used (as of version 1.0.6).
     *     It is sufficient to rely on {@link #getSeriesToolTipGenerator(int)}
     *     and {@link #getBaseToolTipGenerator()}.
     */

#Code:
    public CategoryToolTipGenerator getToolTipGenerator() {
        return this.toolTipGenerator;
    }

#No. 1031
#File: E:\bishe\1\AbstractCategoryItemRenderer.java
#Comment:
    /**
     * Sets the tool tip generator for ALL series and sends a
     * {@link org.jfree.chart.event.RendererChangeEvent} to all registered
     * listeners.
     *
     * @param generator  the generator (<code>null</code> permitted).
     *
     * @see #getToolTipGenerator()
     *
     * @deprecated This method should no longer be used (as of version 1.0.6).
     *     It is sufficient to rely on {@link #setSeriesToolTipGenerator(int,
     *     CategoryToolTipGenerator)} and
     *     {@link #setBaseToolTipGenerator(CategoryToolTipGenerator)}.
     */

#Code:
    public void setToolTipGenerator(CategoryToolTipGenerator generator) {
        this.toolTipGenerator = generator;
        fireChangeEvent();
    }

#No. 1032
#File: E:\bishe\1\AbstractCategoryItemRenderer.java
#Comment:
    /**
     * Returns the tool tip generator for the specified series (a "layer 1"
     * generator).
     *
     * @param series  the series index (zero-based).
     *
     * @return The tool tip generator (possibly <code>null</code>).
     *
     * @see #setSeriesToolTipGenerator(int, CategoryToolTipGenerator)
     */

#Code:
    public CategoryToolTipGenerator getSeriesToolTipGenerator(int series) {
        return (CategoryToolTipGenerator) this.toolTipGeneratorList.get(series);
    }

#No. 1033
#File: E:\bishe\1\AbstractCategoryItemRenderer.java
#Comment:
    /**
     * Sets the tool tip generator for a series and sends a
     * {@link RendererChangeEvent} to all registered listeners.
     *
     * @param series  the series index (zero-based).
     * @param generator  the generator (<code>null</code> permitted).
     *
     * @see #getSeriesToolTipGenerator(int)
     */

#Code:
    public void setSeriesToolTipGenerator(int series,
                                          CategoryToolTipGenerator generator) {
        this.toolTipGeneratorList.set(series, generator);
        fireChangeEvent();
    }

#No. 1034
#File: E:\bishe\1\AbstractCategoryItemRenderer.java
#Comment:
    /**
     * Returns the base tool tip generator (the "layer 2" generator).
     *
     * @return The tool tip generator (possibly <code>null</code>).
     *
     * @see #setBaseToolTipGenerator(CategoryToolTipGenerator)
     */

#Code:
    public CategoryToolTipGenerator getBaseToolTipGenerator() {
        return this.baseToolTipGenerator;
    }

#No. 1035
#File: E:\bishe\1\AbstractCategoryItemRenderer.java
#Comment:
    /**
     * Sets the base tool tip generator and sends a {@link RendererChangeEvent}
     * to all registered listeners.
     *
     * @param generator  the generator (<code>null</code> permitted).
     *
     * @see #getBaseToolTipGenerator()
     */

#Code:
    public void setBaseToolTipGenerator(CategoryToolTipGenerator generator) {
        this.baseToolTipGenerator = generator;
        fireChangeEvent();
    }

#No. 1036
#File: E:\bishe\1\AbstractCategoryItemRenderer.java
#Comment:
    /**
     * Returns the URL generator for a data item.  This method just calls the
     * getSeriesItemURLGenerator method, but you can override this behaviour if
     * you want to.
     *
     * @param row  the row index (zero based).
     * @param column  the column index (zero based).
     *
     * @return The URL generator.
     */

#Code:
    public CategoryURLGenerator getItemURLGenerator(int row, int column) {
        return getSeriesItemURLGenerator(row);
    }

#No. 1037
#File: E:\bishe\1\AbstractCategoryItemRenderer.java
#Comment:
    /**
     * Returns the URL generator for a series.
     *
     * @param series  the series index (zero based).
     *
     * @return The URL generator for the series.
     *
     * @see #setSeriesItemURLGenerator(int, CategoryURLGenerator)
     */

#Code:
    public CategoryURLGenerator getSeriesItemURLGenerator(int series) {

        // return the generator for ALL series, if there is one...
        if (this.itemURLGenerator != null) {
            return this.itemURLGenerator;
        }

        // otherwise look up the generator table
        CategoryURLGenerator generator
            = (CategoryURLGenerator) this.itemURLGeneratorList.get(series);
        if (generator == null) {
            generator = this.baseItemURLGenerator;
        }
        return generator;

    }

#No. 1038
#File: E:\bishe\1\AbstractCategoryItemRenderer.java
#Comment:
    /**
     * Sets the item URL generator for ALL series and sends a
     * {@link RendererChangeEvent} to all registered listeners.
     *
     * @param generator  the generator.
     *
     * @deprecated This method should no longer be used (as of version 1.0.6).
     *     It is sufficient to rely on {@link #setSeriesItemURLGenerator(int,
     *     CategoryURLGenerator)} and
     *     {@link #setBaseItemURLGenerator(CategoryURLGenerator)}.
     */

#Code:
    public void setItemURLGenerator(CategoryURLGenerator generator) {
        this.itemURLGenerator = generator;
        fireChangeEvent();
    }

#No. 1039
#File: E:\bishe\1\AbstractCategoryItemRenderer.java
#Comment:
    /**
     * Sets the URL generator for a series and sends a
     * {@link RendererChangeEvent} to all registered listeners.
     *
     * @param series  the series index (zero based).
     * @param generator  the generator.
     *
     * @see #getSeriesItemURLGenerator(int)
     */

#Code:
    public void setSeriesItemURLGenerator(int series,
                                          CategoryURLGenerator generator) {
        this.itemURLGeneratorList.set(series, generator);
        fireChangeEvent();
    }

#No. 1040
#File: E:\bishe\1\AbstractCategoryItemRenderer.java
#Comment:
    /**
     * Returns the base item URL generator.
     *
     * @return The item URL generator.
     *
     * @see #setBaseItemURLGenerator(CategoryURLGenerator)
     */

#Code:
    public CategoryURLGenerator getBaseItemURLGenerator() {
        return this.baseItemURLGenerator;
    }

#No. 1041
#File: E:\bishe\1\AbstractCategoryItemRenderer.java
#Comment:
    /**
     * Sets the base item URL generator and sends a
     * {@link RendererChangeEvent} to all registered listeners.
     *
     * @param generator  the item URL generator (<code>null</code> permitted).
     *
     * @see #getBaseItemURLGenerator()
     */

#Code:
    public void setBaseItemURLGenerator(CategoryURLGenerator generator) {
        this.baseItemURLGenerator = generator;
        fireChangeEvent();
    }

#No. 1042
#File: E:\bishe\1\AbstractCategoryItemRenderer.java
#Comment:
    /**
     * Returns the number of rows in the dataset.  This value is updated in the
     * {@link AbstractCategoryItemRenderer#initialise} method.
     *
     * @return The row count.
     */

#Code:
    public int getRowCount() {
        return this.rowCount;
    }

#No. 1043
#File: E:\bishe\1\AbstractCategoryItemRenderer.java
#Comment:
    /**
     * Returns the number of columns in the dataset.  This value is updated in
     * the {@link AbstractCategoryItemRenderer#initialise} method.
     *
     * @return The column count.
     */

#Code:
    public int getColumnCount() {
        return this.columnCount;
    }

#No. 1044
#File: E:\bishe\1\AbstractCategoryItemRenderer.java
#Comment:
    /**
     * Creates a new state instance---this method is called from the
     * {@link #initialise(Graphics2D, Rectangle2D, CategoryPlot, int,
     * PlotRenderingInfo)} method.  Subclasses can override this method if
     * they need to use a subclass of {@link CategoryItemRendererState}.
     *
     * @param info  collects plot rendering info (<code>null</code> permitted).
     *
     * @return The new state instance (never <code>null</code>).
     *
     * @since 1.0.5
     */

#Code:
    protected CategoryItemRendererState createState(PlotRenderingInfo info) {
        return new CategoryItemRendererState(info);
    }

#No. 1045
#File: E:\bishe\1\AbstractCategoryItemRenderer.java
#Comment:
    /**
     * Initialises the renderer and returns a state object that will be used
     * for the remainder of the drawing process for a single chart.  The state
     * object allows for the fact that the renderer may be used simultaneously
     * by multiple threads (each thread will work with a separate state object).
     *
     * @param g2  the graphics device.
     * @param dataArea  the data area.
     * @param plot  the plot.
     * @param rendererIndex  the renderer index.
     * @param info  an object for returning information about the structure of
     *              the plot (<code>null</code> permitted).
     *
     * @return The renderer state.
     */

#Code:
    public CategoryItemRendererState initialise(Graphics2D g2,
                                                Rectangle2D dataArea,
                                                CategoryPlot plot,
                                                int rendererIndex,
                                                PlotRenderingInfo info) {

        setPlot(plot);
        CategoryDataset data = plot.getDataset(rendererIndex);
        if (data != null) {
            this.rowCount = data.getRowCount();
            this.columnCount = data.getColumnCount();
        }
        else {
            this.rowCount = 0;
            this.columnCount = 0;
        }
        return createState(info);

    }

#No. 1046
#File: E:\bishe\1\AbstractCategoryItemRenderer.java
#Comment:
    /**
     * Returns the range of values the renderer requires to display all the
     * items from the specified dataset.
     *
     * @param dataset  the dataset (<code>null</code> permitted).
     *
     * @return The range (or <code>null</code> if the dataset is
     *         <code>null</code> or empty).
     */

#Code:
    public Range findRangeBounds(CategoryDataset dataset) {
        return DatasetUtilities.findRangeBounds(dataset);
    }

#No. 1047
#File: E:\bishe\1\AbstractCategoryItemRenderer.java
#Comment:
    /**
     * Returns the Java2D coordinate for the middle of the specified data item.
     *
     * @param rowKey  the row key.
     * @param columnKey  the column key.
     * @param dataset  the dataset.
     * @param axis  the axis.
     * @param area  the data area.
     * @param edge  the edge along which the axis lies.
     *
     * @return The Java2D coordinate for the middle of the item.
     *
     * @since 1.0.11
     */

#Code:
    public double getItemMiddle(Comparable rowKey, Comparable columnKey,
            CategoryDataset dataset, CategoryAxis axis, Rectangle2D area,
            RectangleEdge edge) {
        return axis.getCategoryMiddle(columnKey, dataset.getColumnKeys(), area,
                edge);
    }

#No. 1048
#File: E:\bishe\1\AbstractCategoryItemRenderer.java
#Comment:
    /**
     * Draws a background for the data area.  The default implementation just
     * gets the plot to draw the background, but some renderers will override
     * this behaviour.
     *
     * @param g2  the graphics device.
     * @param plot  the plot.
     * @param dataArea  the data area.
     */

#Code:
    public void drawBackground(Graphics2D g2,
                               CategoryPlot plot,
                               Rectangle2D dataArea) {

        plot.drawBackground(g2, dataArea);

    }

#No. 1049
#File: E:\bishe\1\AbstractCategoryItemRenderer.java
#Comment:
    /**
     * Draws an outline for the data area.  The default implementation just
     * gets the plot to draw the outline, but some renderers will override this
     * behaviour.
     *
     * @param g2  the graphics device.
     * @param plot  the plot.
     * @param dataArea  the data area.
     */

#Code:
    public void drawOutline(Graphics2D g2,
                            CategoryPlot plot,
                            Rectangle2D dataArea) {

        plot.drawOutline(g2, dataArea);

    }

#No. 1050
#File: E:\bishe\1\AbstractCategoryItemRenderer.java
#Comment:
    /**
     * Draws a grid line against the domain axis.
     * <P>
     * Note that this default implementation assumes that the horizontal axis
     * is the domain axis. If this is not the case, you will need to override
     * this method.
     *
     * @param g2  the graphics device.
     * @param plot  the plot.
     * @param dataArea  the area for plotting data (not yet adjusted for any
     *                  3D effect).
     * @param value  the Java2D value at which the grid line should be drawn.
     *
     * @see #drawRangeGridline(Graphics2D, CategoryPlot, ValueAxis,
     *     Rectangle2D, double)
     */

#Code:
    public void drawDomainGridline(Graphics2D g2,
                                   CategoryPlot plot,
                                   Rectangle2D dataArea,
                                   double value) {

        Line2D line = null;
        PlotOrientation orientation = plot.getOrientation();

        if (orientation == PlotOrientation.HORIZONTAL) {
            line = new Line2D.Double(dataArea.getMinX(), value,
                    dataArea.getMaxX(), value);
        }
        else if (orientation == PlotOrientation.VERTICAL) {
            line = new Line2D.Double(value, dataArea.getMinY(), value,
                    dataArea.getMaxY());
        }

        Paint paint = plot.getDomainGridlinePaint();
        if (paint == null) {
            paint = CategoryPlot.DEFAULT_GRIDLINE_PAINT;
        }
        g2.setPaint(paint);

        Stroke stroke = plot.getDomainGridlineStroke();
        if (stroke == null) {
            stroke = CategoryPlot.DEFAULT_GRIDLINE_STROKE;
        }
        g2.setStroke(stroke);

        g2.draw(line);

    }

#No. 1051
#File: E:\bishe\1\AbstractCategoryItemRenderer.java
#Comment:
    /**
     * Draws a grid line against the range axis.
     *
     * @param g2  the graphics device.
     * @param plot  the plot.
     * @param axis  the value axis.
     * @param dataArea  the area for plotting data (not yet adjusted for any
     *                  3D effect).
     * @param value  the value at which the grid line should be drawn.
     *
     * @see #drawDomainGridline(Graphics2D, CategoryPlot, Rectangle2D, double)
     *
     */

#Code:
    public void drawRangeGridline(Graphics2D g2,
                                  CategoryPlot plot,
                                  ValueAxis axis,
                                  Rectangle2D dataArea,
                                  double value) {

        Range range = axis.getRange();
        if (!range.contains(value)) {
            return;
        }

        PlotOrientation orientation = plot.getOrientation();
        double v = axis.valueToJava2D(value, dataArea, plot.getRangeAxisEdge());
        Line2D line = null;
        if (orientation == PlotOrientation.HORIZONTAL) {
            line = new Line2D.Double(v, dataArea.getMinY(), v,
                    dataArea.getMaxY());
        }
        else if (orientation == PlotOrientation.VERTICAL) {
            line = new Line2D.Double(dataArea.getMinX(), v,
                    dataArea.getMaxX(), v);
        }

        Paint paint = plot.getRangeGridlinePaint();
        if (paint == null) {
            paint = CategoryPlot.DEFAULT_GRIDLINE_PAINT;
        }
        g2.setPaint(paint);

        Stroke stroke = plot.getRangeGridlineStroke();
        if (stroke == null) {
            stroke = CategoryPlot.DEFAULT_GRIDLINE_STROKE;
        }
        g2.setStroke(stroke);

        g2.draw(line);

    }

#No. 1052
#File: E:\bishe\1\AbstractCategoryItemRenderer.java
#Comment:
    /**
     * Calculates the (x, y) coordinates for drawing the label for a marker on
     * the range axis.
     *
     * @param g2  the graphics device.
     * @param orientation  the plot orientation.
     * @param dataArea  the data area.
     * @param markerArea  the rectangle surrounding the marker.
     * @param markerOffset  the marker offset.
     * @param labelOffsetType  the label offset type.
     * @param anchor  the label anchor.
     *
     * @return The coordinates for drawing the marker label.
     */

#Code:
    protected Point2D calculateDomainMarkerTextAnchorPoint(Graphics2D g2,
                                      PlotOrientation orientation,
                                      Rectangle2D dataArea,
                                      Rectangle2D markerArea,
                                      RectangleInsets markerOffset,
                                      LengthAdjustmentType labelOffsetType,
                                      RectangleAnchor anchor) {

        Rectangle2D anchorRect = null;
        if (orientation == PlotOrientation.HORIZONTAL) {
            anchorRect = markerOffset.createAdjustedRectangle(markerArea,
                    LengthAdjustmentType.CONTRACT, labelOffsetType);
        }
        else if (orientation == PlotOrientation.VERTICAL) {
            anchorRect = markerOffset.createAdjustedRectangle(markerArea,
                    labelOffsetType, LengthAdjustmentType.CONTRACT);
        }
        return RectangleAnchor.coordinates(anchorRect, anchor);

    }

#No. 1053
#File: E:\bishe\1\AbstractCategoryItemRenderer.java
#Comment:
    /**
     * Calculates the (x, y) coordinates for drawing a marker label.
     *
     * @param g2  the graphics device.
     * @param orientation  the plot orientation.
     * @param dataArea  the data area.
     * @param markerArea  the rectangle surrounding the marker.
     * @param markerOffset  the marker offset.
     * @param labelOffsetType  the label offset type.
     * @param anchor  the label anchor.
     *
     * @return The coordinates for drawing the marker label.
     */

#Code:
    protected Point2D calculateRangeMarkerTextAnchorPoint(Graphics2D g2,
                                      PlotOrientation orientation,
                                      Rectangle2D dataArea,
                                      Rectangle2D markerArea,
                                      RectangleInsets markerOffset,
                                      LengthAdjustmentType labelOffsetType,
                                      RectangleAnchor anchor) {

        Rectangle2D anchorRect = null;
        if (orientation == PlotOrientation.HORIZONTAL) {
            anchorRect = markerOffset.createAdjustedRectangle(markerArea,
                    labelOffsetType, LengthAdjustmentType.CONTRACT);
        }
        else if (orientation == PlotOrientation.VERTICAL) {
            anchorRect = markerOffset.createAdjustedRectangle(markerArea,
                    LengthAdjustmentType.CONTRACT, labelOffsetType);
        }
        return RectangleAnchor.coordinates(anchorRect, anchor);

    }

#No. 1054
#File: E:\bishe\1\AbstractCategoryItemRenderer.java
#Comment:
    /**
     * Returns a hash code for the renderer.
     *
     * @return The hash code.
     */

#Code:
    public int hashCode() {
        int result = super.hashCode();
        return result;
    }

#No. 1055
#File: E:\bishe\1\AbstractCategoryItemRenderer.java
#Comment:
    /**
     * Returns the drawing supplier from the plot.
     *
     * @return The drawing supplier (possibly <code>null</code>).
     */

#Code:
    public DrawingSupplier getDrawingSupplier() {
        DrawingSupplier result = null;
        CategoryPlot cp = getPlot();
        if (cp != null) {
            result = cp.getDrawingSupplier();
        }
        return result;
    }

#No. 1056
#File: E:\bishe\1\AbstractCategoryItemRenderer.java
#Comment:
    /**
     * Considers the current (x, y) coordinate and updates the crosshair point
     * if it meets the criteria (usually means the (x, y) coordinate is the
     * closest to the anchor point so far).
     *
     * @param crosshairState  the crosshair state (<code>null</code> permitted,
     *                        but the method does nothing in that case).
     * @param rowKey  the row key.
     * @param columnKey  the column key.
     * @param value  the data value.
     * @param datasetIndex  the dataset index.
     * @param transX  the x-value translated to Java2D space.
     * @param transY  the y-value translated to Java2D space.
     * @param orientation  the plot orientation (<code>null</code> not
     *                     permitted).
     *
     * @since 1.0.11
     */

#Code:
    protected void updateCrosshairValues(CategoryCrosshairState crosshairState,
            Comparable rowKey, Comparable columnKey, double value,
            int datasetIndex,
            double transX, double transY, PlotOrientation orientation) {

        if (orientation == null) {
            throw new IllegalArgumentException("Null 'orientation' argument.");
        }

        if (crosshairState != null) {
            if (this.plot.isRangeCrosshairLockedOnData()) {
                // both axes
                crosshairState.updateCrosshairPoint(rowKey, columnKey, value,
                        datasetIndex, transX, transY, orientation);
            }
            else {
                crosshairState.updateCrosshairX(rowKey, columnKey,
                        datasetIndex, transX, orientation);
            }
        }
    }

#No. 1057
#File: E:\bishe\1\AbstractCategoryItemRenderer.java
#Comment:
    /**
     * Draws an item label.
     *
     * @param g2  the graphics device.
     * @param orientation  the orientation.
     * @param dataset  the dataset.
     * @param row  the row.
     * @param column  the column.
     * @param x  the x coordinate (in Java2D space).
     * @param y  the y coordinate (in Java2D space).
     * @param negative  indicates a negative value (which affects the item
     *                  label position).
     */

#Code:
    protected void drawItemLabel(Graphics2D g2,
                                 PlotOrientation orientation,
                                 CategoryDataset dataset,
                                 int row, int column,
                                 double x, double y,
                                 boolean negative) {

        CategoryItemLabelGenerator generator
            = getItemLabelGenerator(row, column);
        if (generator != null) {
            Font labelFont = getItemLabelFont(row, column);
            Paint paint = getItemLabelPaint(row, column);
            g2.setFont(labelFont);
            g2.setPaint(paint);
            String label = generator.generateLabel(dataset, row, column);
            ItemLabelPosition position = null;
            if (!negative) {
                position = getPositiveItemLabelPosition(row, column);
            }
            else {
                position = getNegativeItemLabelPosition(row, column);
            }
            Point2D anchorPoint = calculateLabelAnchorPoint(
                    position.getItemLabelAnchor(), x, y, orientation);
            TextUtilities.drawRotatedString(label, g2,
                    (float) anchorPoint.getX(), (float) anchorPoint.getY(),
                    position.getTextAnchor(),
                    position.getAngle(), position.getRotationAnchor());
        }

    }

#No. 1058
#File: E:\bishe\1\AbstractCategoryItemRenderer.java
#Comment:
    /**
     * Returns a domain axis for a plot.
     *
     * @param plot  the plot.
     * @param index  the axis index.
     *
     * @return A domain axis.
     */

#Code:
    protected CategoryAxis getDomainAxis(CategoryPlot plot, int index) {
        CategoryAxis result = plot.getDomainAxis(index);
        if (result == null) {
            result = plot.getDomainAxis();
        }
        return result;
    }

#No. 1059
#File: E:\bishe\1\AbstractCategoryItemRenderer.java
#Comment:
    /**
     * Returns a range axis for a plot.
     *
     * @param plot  the plot.
     * @param index  the axis index.
     *
     * @return A range axis.
     */

#Code:
    protected ValueAxis getRangeAxis(CategoryPlot plot, int index) {
        ValueAxis result = plot.getRangeAxis(index);
        if (result == null) {
            result = plot.getRangeAxis();
        }
        return result;
    }

#No. 1060
#File: E:\bishe\1\AbstractCategoryItemRenderer.java
#Comment:
    /**
     * Returns a (possibly empty) collection of legend items for the series
     * that this renderer is responsible for drawing.
     *
     * @return The legend item collection (never <code>null</code>).
     *
     * @see #getLegendItem(int, int)
     */

#Code:
    public LegendItemCollection getLegendItems() {
        if (this.plot == null) {
            return new LegendItemCollection();
        }
        LegendItemCollection result = new LegendItemCollection();
        int index = this.plot.getIndexOf(this);
        CategoryDataset dataset = this.plot.getDataset(index);
        if (dataset != null) {
            int seriesCount = dataset.getRowCount();
            for (int i = 0; i < seriesCount; i++) {
                if (isSeriesVisibleInLegend(i)) {
                    LegendItem item = getLegendItem(index, i);
                    if (item != null) {
                        result.add(item);
                    }
                }
            }

        }
        return result;
    }

#No. 1061
#File: E:\bishe\1\AbstractCategoryItemRenderer.java
#Comment:
    /**
     * Returns the legend item label generator.
     *
     * @return The label generator (never <code>null</code>).
     *
     * @see #setLegendItemLabelGenerator(CategorySeriesLabelGenerator)
     */

#Code:
    public CategorySeriesLabelGenerator getLegendItemLabelGenerator() {
        return this.legendItemLabelGenerator;
    }

#No. 1062
#File: E:\bishe\1\AbstractCategoryItemRenderer.java
#Comment:
    /**
     * Sets the legend item label generator and sends a
     * {@link RendererChangeEvent} to all registered listeners.
     *
     * @param generator  the generator (<code>null</code> not permitted).
     *
     * @see #getLegendItemLabelGenerator()
     */

#Code:
    public void setLegendItemLabelGenerator(
            CategorySeriesLabelGenerator generator) {
        if (generator == null) {
            throw new IllegalArgumentException("Null 'generator' argument.");
        }
        this.legendItemLabelGenerator = generator;
        fireChangeEvent();
    }

#No. 1063
#File: E:\bishe\1\AbstractCategoryItemRenderer.java
#Comment:
    /**
     * Returns the legend item tool tip generator.
     *
     * @return The tool tip generator (possibly <code>null</code>).
     *
     * @see #setLegendItemToolTipGenerator(CategorySeriesLabelGenerator)
     */

#Code:
    public CategorySeriesLabelGenerator getLegendItemToolTipGenerator() {
        return this.legendItemToolTipGenerator;
    }

#No. 1064
#File: E:\bishe\1\AbstractCategoryItemRenderer.java
#Comment:
    /**
     * Sets the legend item tool tip generator and sends a
     * {@link RendererChangeEvent} to all registered listeners.
     *
     * @param generator  the generator (<code>null</code> permitted).
     *
     * @see #setLegendItemToolTipGenerator(CategorySeriesLabelGenerator)
     */

#Code:
    public void setLegendItemToolTipGenerator(
            CategorySeriesLabelGenerator generator) {
        this.legendItemToolTipGenerator = generator;
        fireChangeEvent();
    }

#No. 1065
#File: E:\bishe\1\AbstractCategoryItemRenderer.java
#Comment:
    /**
     * Returns the legend item URL generator.
     *
     * @return The URL generator (possibly <code>null</code>).
     *
     * @see #setLegendItemURLGenerator(CategorySeriesLabelGenerator)
     */

#Code:
    public CategorySeriesLabelGenerator getLegendItemURLGenerator() {
        return this.legendItemURLGenerator;
    }

#No. 1066
#File: E:\bishe\1\AbstractCategoryItemRenderer.java
#Comment:
    /**
     * Sets the legend item URL generator and sends a
     * {@link RendererChangeEvent} to all registered listeners.
     *
     * @param generator  the generator (<code>null</code> permitted).
     *
     * @see #getLegendItemURLGenerator()
     */

#Code:
    public void setLegendItemURLGenerator(
            CategorySeriesLabelGenerator generator) {
        this.legendItemURLGenerator = generator;
        fireChangeEvent();
    }

#No. 1067
#File: E:\bishe\1\AbstractCategoryItemRenderer.java
#Comment:
    /**
     * Adds an entity with the specified hotspot.
     *
     * @param entities  the entity collection.
     * @param dataset  the dataset.
     * @param row  the row index.
     * @param column  the column index.
     * @param hotspot  the hotspot.
     */

#Code:
    protected void addItemEntity(EntityCollection entities,
                                 CategoryDataset dataset, int row, int column,
                                 Shape hotspot) {

        String tip = null;
        CategoryToolTipGenerator tipster = getToolTipGenerator(row, column);
        if (tipster != null) {
            tip = tipster.generateToolTip(dataset, row, column);
        }
        String url = null;
        CategoryURLGenerator urlster = getItemURLGenerator(row, column);
        if (urlster != null) {
            url = urlster.generateURL(dataset, row, column);
        }
        CategoryItemEntity entity = new CategoryItemEntity(hotspot, tip, url,
                dataset, dataset.getRowKey(row), dataset.getColumnKey(column));
        entities.add(entity);

    }

#No. 1068
#File: E:\bishe\1\AbstractCdiContainer.java
#Comment:
    /**
     * Builds the composite class loader for the given bundle, also including the bundle containing
     * this class and all extension bundles.
     */

#Code:
    protected ClassLoader buildContextClassLoader() {
        List<Bundle> delegateBundles = new ArrayList<>();
        delegateBundles.add(bundle);
        delegateBundles.addAll(additionalBundles);
        delegateBundles.addAll(extensionBundles);
        DelegatingBundle delegatingBundle = new DelegatingBundle(delegateBundles);
        return new BundleClassLoader(delegatingBundle);
    }

#No. 1069
#File: E:\bishe\1\AbstractChannelListener.java
#Comment:
  /**
   * Callback which is called when Faye server publishes new event.
   *
   * @param channel name of the channel that received event.
   * @param message parsed with Gson event data.
   */

#Code:
  public abstract void onMessage(String channel, T message);

  public void onMessage(String channel, JsonObject event) {
    T parseMessage = gson.fromJson(event, getParameterClass());
    onMessage(channel, parseMessage);
  }

#No. 1070
#File: E:\bishe\1\AbstractCharBasedFormatter.java
#Comment:
	/**
     * Parse a text-format message from {@code input} and merge the contents into {@code builder}.
     * Extensions will be recognized if they are registered in {@code extensionRegistry}.
     */

#Code:
    public void merge(Readable input,
    		ExtensionRegistry extensionRegistry,
    		Message.Builder builder) throws IOException {
        // Read the entire input to a String then parse that.

        // If StreamTokenizer were not quite so crippled, or if there were a kind
        // of Reader that could read in chunks that match some particular regex,
        // or if we wanted to write a custom Reader to tokenize our stream, then
        // we would not have to read to one big String. Alas, none of these is
        // the case. Oh well.

		merge(TextUtils.toStringBuilder(input), extensionRegistry, builder);
    }

#No. 1071
#File: E:\bishe\1\AbstractCharList.java
#Comment:
    /**
     * Returns the index of the first occurrence of the specified element.
     * Returns <code>-1</code> if the receiver does not contain this element.
     * 
     * @param element
     *            the element to be searched for.
     * @return the index of the first occurrence of the element in the receiver;
     *         returns <code>-1</code> if the element is not found.
     */

#Code:
    public int indexOf(char element) { // delta
        return indexOfFromTo(element, 0, size - 1);
    }

#No. 1072
#File: E:\bishe\1\AbstractCharList.java
#Comment:
    /**
     * Returns the index of the first occurrence of the specified element.
     * Returns <code>-1</code> if the receiver does not contain this element.
     * Searches between <code>from</code>, inclusive and <code>to</code>,
     * inclusive. Tests for identity.
     * 
     * @param element
     *            element to search for.
     * @param from
     *            the leftmost search position, inclusive.
     * @param to
     *            the rightmost search position, inclusive.
     * @return the index of the first occurrence of the element in the receiver;
     *         returns <code>-1</code> if the element is not found.
     * @exception IndexOutOfBoundsException
     *                index is out of range (
     *                <tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>
     *                ).
     */

#Code:
    public int indexOfFromTo(char element, int from, int to) {
        checkRangeFromTo(from, to, size);

        for (int i = from; i <= to; i++) {
            if (element == getQuick(i))
                return i; // found
        }
        return -1; // not found
    }

#No. 1073
#File: E:\bishe\1\AbstractCharList.java
#Comment:
    /**
     * Returns the index of the last occurrence of the specified element.
     * Returns <code>-1</code> if the receiver does not contain this element.
     * 
     * @param element
     *            the element to be searched for.
     * @return the index of the last occurrence of the element in the receiver;
     *         returns <code>-1</code> if the element is not found.
     */

#Code:
    public int lastIndexOf(char element) {
        return lastIndexOfFromTo(element, 0, size - 1);
    }

#No. 1074
#File: E:\bishe\1\AbstractCharList.java
#Comment:
    /**
     * Returns the index of the last occurrence of the specified element.
     * Returns <code>-1</code> if the receiver does not contain this element.
     * Searches beginning at <code>to</code>, inclusive until <code>from</code>,
     * inclusive. Tests for identity.
     * 
     * @param element
     *            element to search for.
     * @param from
     *            the leftmost search position, inclusive.
     * @param to
     *            the rightmost search position, inclusive.
     * @return the index of the last occurrence of the element in the receiver;
     *         returns <code>-1</code> if the element is not found.
     * @exception IndexOutOfBoundsException
     *                index is out of range (
     *                <tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>
     *                ).
     */

#Code:
    public int lastIndexOfFromTo(char element, int from, int to) {
        checkRangeFromTo(from, to, size());

        for (int i = to; i >= from; i--) {
            if (element == getQuick(i))
                return i; // found
        }
        return -1; // not found
    }

#No. 1075
#File: E:\bishe\1\AbstractCharList.java
#Comment:
    /**
     * Sorts the specified range of the receiver into ascending order.
     * 
     * The sorting algorithm is a modified mergesort (in which the merge is
     * omitted if the highest element in the low sublist is less than the lowest
     * element in the high sublist). This algorithm offers guaranteed n*log(n)
     * performance, and can approach linear performance on nearly sorted lists.
     * 
     * <p>
     * <b>You should never call this method unless you are sure that this
     * particular sorting algorithm is the right one for your data set.</b> It
     * is generally better to call <tt>sort()</tt> or <tt>sortFromTo(...)</tt>
     * instead, because those methods automatically choose the best sorting
     * algorithm.
     * 
     * @param from
     *            the index of the first element (inclusive) to be sorted.
     * @param to
     *            the index of the last element (inclusive) to be sorted.
     * @exception IndexOutOfBoundsException
     *                index is out of range (
     *                <tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>
     *                ).
     */

#Code:

    public void mergeSortFromTo(int from, int to) {
        int mySize = size();
        checkRangeFromTo(from, to, mySize);

        char[] myElements = elements();
        cern.colt.Sorting.mergeSort(myElements, from, to + 1);
        elements(myElements);
        setSizeRaw(mySize);
    }

#No. 1076
#File: E:\bishe\1\AbstractCharList.java
#Comment:
    /**
     * Sorts the receiver according to the order induced by the specified
     * comparator. All elements in the range must be <i>mutually comparable</i>
     * by the specified comparator (that is, <tt>c.compare(e1, e2)</tt> must not
     * throw a <tt>ClassCastException</tt> for any elements <tt>e1</tt> and
     * <tt>e2</tt> in the range).
     * <p>
     * 
     * This sort is guaranteed to be <i>stable</i>: equal elements will not be
     * reordered as a result of the sort.
     * <p>
     * 
     * The sorting algorithm is a modified mergesort (in which the merge is
     * omitted if the highest element in the low sublist is less than the lowest
     * element in the high sublist). This algorithm offers guaranteed n*log(n)
     * performance, and can approach linear performance on nearly sorted lists.
     * 
     * @param from
     *            the index of the first element (inclusive) to be sorted.
     * @param to
     *            the index of the last element (inclusive) to be sorted.
     * @param c
     *            the comparator to determine the order of the receiver.
     * @throws ClassCastException
     *             if the array contains elements that are not <i>mutually
     *             comparable</i> using the specified comparator.
     * @throws IllegalArgumentException
     *             if <tt>fromIndex &gt; toIndex</tt>
     * @throws ArrayIndexOutOfBoundsException
     *             if <tt>fromIndex &lt; 0</tt> or
     *             <tt>toIndex &gt; a.length</tt>
     * @exception IndexOutOfBoundsException
     *                index is out of range (
     *                <tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>
     *                ).
     */

#Code:
    public void mergeSortFromTo(int from, int to, CharComparator c) {
        int mySize = size();
        checkRangeFromTo(from, to, mySize);

        char[] myElements = elements();
        cern.colt.Sorting.mergeSort(myElements, from, to + 1, c);
        elements(myElements);
        setSizeRaw(mySize);
    }

#No. 1077
#File: E:\bishe\1\AbstractCharList.java
#Comment:
    /**
     * Returns a new list of the part of the receiver between <code>from</code>,
     * inclusive, and <code>to</code>, inclusive.
     * 
     * @param from
     *            the index of the first element (inclusive).
     * @param to
     *            the index of the last element (inclusive).
     * @return a new list
     * @exception IndexOutOfBoundsException
     *                index is out of range (
     *                <tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>
     *                ).
     */

#Code:
    public AbstractCharList partFromTo(int from, int to) {
        checkRangeFromTo(from, to, size);

        int length = to - from + 1;
        CharArrayList part = new CharArrayList(length);
        part.addAllOfFromTo(this, from, to);
        return part;
    }

#No. 1078
#File: E:\bishe\1\AbstractCharList.java
#Comment:
    /**
     * Sorts the specified range of the receiver into ascending numerical order.
     * The sorting algorithm is a tuned quicksort, adapted from Jon L. Bentley
     * and M. Douglas McIlroy's "Engineering a Sort Function", Software-Practice
     * and Experience, Vol. 23(11) P. 1249-1265 (November 1993). This algorithm
     * offers n*log(n) performance on many data sets that cause other quicksorts
     * to degrade to quadratic performance.
     * 
     * <p>
     * <b>You should never call this method unless you are sure that this
     * particular sorting algorithm is the right one for your data set.</b> It
     * is generally better to call <tt>sort()</tt> or <tt>sortFromTo(...)</tt>
     * instead, because those methods automatically choose the best sorting
     * algorithm.
     * 
     * @param from
     *            the index of the first element (inclusive) to be sorted.
     * @param to
     *            the index of the last element (inclusive) to be sorted.
     * @exception IndexOutOfBoundsException
     *                index is out of range (
     *                <tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>
     *                ).
     */

#Code:

    public void quickSortFromTo(int from, int to) {
        int mySize = size();
        checkRangeFromTo(from, to, mySize);

        char[] myElements = elements();
        java.util.Arrays.sort(myElements, from, to + 1);
        elements(myElements);
        setSizeRaw(mySize);
    }

#No. 1079
#File: E:\bishe\1\AbstractCharList.java
#Comment:
    /**
     * Sorts the receiver according to the order induced by the specified
     * comparator. All elements in the range must be <i>mutually comparable</i>
     * by the specified comparator (that is, <tt>c.compare(e1, e2)</tt> must not
     * throw a <tt>ClassCastException</tt> for any elements <tt>e1</tt> and
     * <tt>e2</tt> in the range).
     * <p>
     * 
     * The sorting algorithm is a tuned quicksort, adapted from Jon L. Bentley
     * and M. Douglas McIlroy's "Engineering a Sort Function", Software-Practice
     * and Experience, Vol. 23(11) P. 1249-1265 (November 1993). This algorithm
     * offers n*log(n) performance on many data sets that cause other quicksorts
     * to degrade to quadratic performance.
     * 
     * @param from
     *            the index of the first element (inclusive) to be sorted.
     * @param to
     *            the index of the last element (inclusive) to be sorted.
     * @param c
     *            the comparator to determine the order of the receiver.
     * @throws ClassCastException
     *             if the array contains elements that are not <i>mutually
     *             comparable</i> using the specified comparator.
     * @throws IllegalArgumentException
     *             if <tt>fromIndex &gt; toIndex</tt>
     * @throws ArrayIndexOutOfBoundsException
     *             if <tt>fromIndex &lt; 0</tt> or
     *             <tt>toIndex &gt; a.length</tt>
     * @exception IndexOutOfBoundsException
     *                index is out of range (
     *                <tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>
     *                ).
     */

#Code:
    public void quickSortFromTo(int from, int to, CharComparator c) {
        int mySize = size();
        checkRangeFromTo(from, to, mySize);

        char[] myElements = elements();
        cern.colt.Sorting.quickSort(myElements, from, to + 1, c);
        elements(myElements);
        setSizeRaw(mySize);
    }

#No. 1080
#File: E:\bishe\1\AbstractCharList.java
#Comment:
    /**
     * Removes from the receiver all elements that are contained in the
     * specified list. Tests for identity.
     * 
     * @param other
     *            the other list.
     * @return <code>true</code> if the receiver changed as a result of the
     *         call.
     */

#Code:
    public boolean removeAll(AbstractCharList other) {
        if (other.size() == 0)
            return false; // nothing to do
        int limit = other.size() - 1;
        int j = 0;

        for (int i = 0; i < size; i++) {
            if (other.indexOfFromTo(getQuick(i), 0, limit) < 0)
                setQuick(j++, getQuick(i));
        }

        boolean modified = (j != size);
        setSize(j);
        return modified;
    }

#No. 1081
#File: E:\bishe\1\AbstractCharList.java
#Comment:
    /**
     * Removes from the receiver all elements whose index is between
     * <code>from</code>, inclusive and <code>to</code>, inclusive. Shifts any
     * succeeding elements to the left (reduces their index). This call shortens
     * the list by <tt>(to - from + 1)</tt> elements.
     * 
     * @param from
     *            index of first element to be removed.
     * @param to
     *            index of last element to be removed.
     * @exception IndexOutOfBoundsException
     *                index is out of range (
     *                <tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>
     *                ).
     */

#Code:

    public void removeFromTo(int from, int to) {
        checkRangeFromTo(from, to, size);
        int numMoved = size - to - 1;
        if (numMoved > 0) {
            replaceFromToWithFrom(from, from - 1 + numMoved, this, to + 1);
            // fillFromToWith(from+numMoved, size-1, 0.0f); //delta
        }
        int width = to - from + 1;
        if (width > 0)
            setSizeRaw(size - width);
    }

#No. 1082
#File: E:\bishe\1\AbstractCharList.java
#Comment:
    /**
     * Replaces a number of elements in the receiver with the same number of
     * elements of another list. Replaces elements in the receiver, between
     * <code>from</code> (inclusive) and <code>to</code> (inclusive), with
     * elements of <code>other</code>, starting from <code>otherFrom</code>
     * (inclusive).
     * 
     * @param from
     *            the position of the first element to be replaced in the
     *            receiver
     * @param to
     *            the position of the last element to be replaced in the
     *            receiver
     * @param other
     *            list holding elements to be copied into the receiver.
     * @param otherFrom
     *            position of first element within other list to be copied.
     */

#Code:
    public void replaceFromToWithFrom(int from, int to, AbstractCharList other, int otherFrom) {
        int length = to - from + 1;
        if (length > 0) {
            checkRangeFromTo(from, to, size());
            checkRangeFromTo(otherFrom, otherFrom + length - 1, other.size());

            // unambiguous copy (it may hold other==this)
            if (from <= otherFrom) {
                for (; --length >= 0;)
                    setQuick(from++, other.getQuick(otherFrom++));
            } else {
                int otherTo = otherFrom + length - 1;
                for (; --length >= 0;)
                    setQuick(to--, other.getQuick(otherTo--));
            }

        }
    }

#No. 1083
#File: E:\bishe\1\AbstractCharList.java
#Comment:
    /**
     * Replaces the part between <code>from</code> (inclusive) and
     * <code>to</code> (inclusive) with the other list's part between
     * <code>otherFrom</code> and <code>otherTo</code>. Powerful (and tricky)
     * method! Both parts need not be of the same size (part A can both be
     * smaller or larger than part B). Parts may overlap. Receiver and other
     * list may (but most not) be identical. If <code>from &gt; to</code>, then
     * inserts other part before <code>from</code>.
     * 
     * @param from
     *            the first element of the receiver (inclusive)
     * @param to
     *            the last element of the receiver (inclusive)
     * @param other
     *            the other list (may be identical with receiver)
     * @param otherFrom
     *            the first element of the other list (inclusive)
     * @param otherTo
     *            the last element of the other list (inclusive)
     * 
     *            <p>
     *            <b>Examples:</b>
     * 
     *            <pre>
     * a=[0, 1, 2, 3, 4, 5, 6, 7]
     * b=[50, 60, 70, 80, 90]
     * a.R(...)=a.replaceFromToWithFromTo(...)
     * 
     * a.R(3,5,b,0,4)--&gt;[0, 1, 2, 50, 60, 70, 80, 90, 6, 7]
     * a.R(1,6,b,0,4)--&gt;[0, 50, 60, 70, 80, 90, 7]
     * a.R(0,6,b,0,4)--&gt;[50, 60, 70, 80, 90, 7]
     * a.R(3,5,b,1,2)--&gt;[0, 1, 2, 60, 70, 6, 7]
     * a.R(1,6,b,1,2)--&gt;[0, 60, 70, 7]
     * a.R(0,6,b,1,2)--&gt;[60, 70, 7]
     * a.R(5,3,b,0,4)--&gt;[0, 1, 2, 3, 4, 50, 60, 70, 80, 90, 5, 6, 7]
     * a.R(5,0,b,0,4)--&gt;[0, 1, 2, 3, 4, 50, 60, 70, 80, 90, 5, 6, 7]
     * a.R(5,3,b,1,2)--&gt;[0, 1, 2, 3, 4, 60, 70, 5, 6, 7]
     * a.R(5,0,b,1,2)--&gt;[0, 1, 2, 3, 4, 60, 70, 5, 6, 7]
     * 
     * Extreme cases:
     * a.R(5,3,b,0,0)--&gt;[0, 1, 2, 3, 4, 50, 5, 6, 7]
     * a.R(5,3,b,4,4)--&gt;[0, 1, 2, 3, 4, 90, 5, 6, 7]
     * a.R(3,5,a,0,1)--&gt;[0, 1, 2, 0, 1, 6, 7]
     * a.R(3,5,a,3,5)--&gt;[0, 1, 2, 3, 4, 5, 6, 7]
     * a.R(3,5,a,4,4)--&gt;[0, 1, 2, 4, 6, 7]
     * a.R(5,3,a,0,4)--&gt;[0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 5, 6, 7]
     * a.R(0,-1,b,0,4)--&gt;[50, 60, 70, 80, 90, 0, 1, 2, 3, 4, 5, 6, 7]
     * a.R(0,-1,a,0,4)--&gt;[0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 5, 6, 7]
     * a.R(8,0,a,0,4)--&gt;[0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4]
     * </pre>
     */

#Code:
    public void replaceFromToWithFromTo(int from, int to, AbstractCharList other, int otherFrom, int otherTo) {
        if (otherFrom > otherTo) {
            throw new IndexOutOfBoundsException("otherFrom: " + otherFrom + ", otherTo: " + otherTo);
        }

        if (this == other && to - from != otherTo - otherFrom) { // avoid
            // stumbling
            // over my
            // own feet
            replaceFromToWithFromTo(from, to, partFromTo(otherFrom, otherTo), 0, otherTo - otherFrom);
            return;
        }

        int length = otherTo - otherFrom + 1;
        int diff = length;
        int theLast = from - 1;

        if (to >= from) {
            diff -= (to - from + 1);
            theLast = to;
        }

        if (diff > 0) {
            beforeInsertDummies(theLast + 1, diff);
        } else {
            if (diff < 0) {
                removeFromTo(theLast + diff, theLast - 1);
            }
        }

        if (length > 0) {
            replaceFromToWithFrom(from, from + length - 1, other, otherFrom);
        }
    }

#No. 1084
#File: E:\bishe\1\AbstractCharList.java
#Comment:
    /**
     * Replaces the part of the receiver starting at <code>from</code>
     * (inclusive) with all the elements of the specified collection. Does not
     * alter the size of the receiver. Replaces exactly
     * <tt>Math.max(0,Math.min(size()-from, other.size()))</tt> elements.
     * 
     * @param from
     *            the index at which to copy the first element from the
     *            specified collection.
     * @param other
     *            Collection to replace part of the receiver
     * @exception IndexOutOfBoundsException
     *                index is out of range (index &lt; 0 || index &gt;=
     *                size()).
     */

#Code:

    public void replaceFromWith(int from, java.util.Collection other) {
        checkRange(from, size());
        java.util.Iterator e = other.iterator();
        int index = from;
        int limit = Math.min(size() - from, other.size());
        for (int i = 0; i < limit; i++)
            set(index++, ((Character) e.next()).charValue()); // delta
    }

#No. 1085
#File: E:\bishe\1\AbstractCharList.java
#Comment:
    /**
     * Retains (keeps) only the elements in the receiver that are contained in
     * the specified other list. In other words, removes from the receiver all
     * of its elements that are not contained in the specified other list.
     * 
     * @param other
     *            the other list to test against.
     * @return <code>true</code> if the receiver changed as a result of the
     *         call.
     */

#Code:
    public boolean retainAll(AbstractCharList other) {
        if (other.size() == 0) {
            if (size == 0)
                return false;
            setSize(0);
            return true;
        }

        int limit = other.size() - 1;
        int j = 0;
        for (int i = 0; i < size; i++) {
            if (other.indexOfFromTo(getQuick(i), 0, limit) >= 0)
                setQuick(j++, getQuick(i));
        }

        boolean modified = (j != size);
        setSize(j);
        return modified;
    }

#No. 1086
#File: E:\bishe\1\AbstractCharList.java
#Comment:
    /**
     * Reverses the elements of the receiver. Last becomes first, second last
     * becomes second first, and so on.
     */

#Code:

    public void reverse() {
        char tmp;
        int limit = size() / 2;
        int j = size() - 1;

        for (int i = 0; i < limit;) { // swap
            tmp = getQuick(i);
            setQuick(i++, getQuick(j));
            setQuick(j--, tmp);
        }
    }

#No. 1087
#File: E:\bishe\1\AbstractCharList.java
#Comment:
    /**
     * Replaces the element at the specified position in the receiver with the
     * specified element.
     * 
     * @param index
     *            index of element to replace.
     * @param element
     *            element to be stored at the specified position.
     * @throws IndexOutOfBoundsException
     *             if <tt>index &lt; 0 || index &gt;= size()</tt>.
     */

#Code:
    public void set(int index, char element) {
        if (index >= size || index < 0)
            throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size);
        setQuick(index, element);
    }

#No. 1088
#File: E:\bishe\1\AbstractCharList.java
#Comment:
    /**
     * Sets the size of the receiver without modifying it otherwise. This method
     * should not release or allocate new memory but simply set some instance
     * variable like <tt>size</tt>.
     * 
     * If your subclass overrides and delegates size changing methods to some
     * other object, you must make sure that those overriding methods not only
     * update the size of the delegate but also of this class. For example:
     * public DatabaseList extends AbstractCharList { ... public void
     * removeFromTo(int from,int to) { myDatabase.removeFromTo(from,to);
     * this.setSizeRaw(size-(to-from+1)); } }
     */

#Code:
    protected void setSizeRaw(int newSize) {
        size = newSize;
    }

#No. 1089
#File: E:\bishe\1\AbstractCharList.java
#Comment:
    /**
     * Randomly permutes the part of the receiver between <code>from</code>
     * (inclusive) and <code>to</code> (inclusive).
     * 
     * @param from
     *            the index of the first element (inclusive) to be permuted.
     * @param to
     *            the index of the last element (inclusive) to be permuted.
     * @exception IndexOutOfBoundsException
     *                index is out of range (
     *                <tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>
     *                ).
     */

#Code:

    public void shuffleFromTo(int from, int to) {
        checkRangeFromTo(from, to, size());

        cern.jet.random.tdouble.DoubleUniform gen = new cern.jet.random.tdouble.DoubleUniform(
                new cern.jet.random.tdouble.engine.DRand(new java.util.Date()));
        for (int i = from; i < to; i++) {
            int random = gen.nextIntFromTo(i, to);

            // swap(i, random)
            char tmpElement = getQuick(random);
            setQuick(random, getQuick(i));
            setQuick(i, tmpElement);
        }
    }

#No. 1090
#File: E:\bishe\1\AbstractCharList.java
#Comment:
    /**
     * Returns the number of elements contained in the receiver.
     * 
     * @return the number of elements contained in the receiver.
     */

#Code:

    public int size() {
        return size;
    }

#No. 1091
#File: E:\bishe\1\AbstractCharList.java
#Comment:
    /**
     * Returns a list which is a concatenation of <code>times</code> times the
     * receiver.
     * 
     * @param times
     *            the number of times the receiver shall be copied.
     */

#Code:
    public AbstractCharList times(int times) {
        AbstractCharList newList = new CharArrayList(times * size());
        for (int i = times; --i >= 0;) {
            newList.addAllOfFromTo(this, 0, size() - 1);
        }
        return newList;
    }

#No. 1092
#File: E:\bishe\1\AbstractCharList.java
#Comment:
    /**
     * Returns a <code>java.util.ArrayList</code> containing all the elements in
     * the receiver.
     */

#Code:

    public java.util.ArrayList toList() {
        int mySize = size();
        java.util.ArrayList list = new java.util.ArrayList(mySize);
        for (int i = 0; i < mySize; i++)
            list.add(new Character(get(i)));
        return list;
    }

#No. 1093
#File: E:\bishe\1\AbstractCharList.java
#Comment:
    /**
     * Returns a string representation of the receiver, containing the String
     * representation of each element.
     */

#Code:

    public String toString() {
        return cern.colt.Arrays.toString(partFromTo(0, size() - 1).elements());
    }

#No. 1094
#File: E:\bishe\1\AbstractChat.java
#Comment:
    /**
     * @return true if done with this chat
     */

#Code:
    public abstract boolean init(Conversation conversation, SelectionKey key);

    /**
     * @return true if done with this chat
     */
    public abstract boolean process(SelectionKey key);

    public abstract T result();

    protected void removeInterest(SelectionKey key, int op) {
        if (!key.isValid()) {
            return;
        }
        final int interestOps = key.interestOps();
        if ((interestOps & op) != 0) {
            key.interestOps(interestOps & ~op);
        }
    }

#No. 1095
#File: E:\bishe\1\AbstractChatAction.java
#Comment:
	/**
	 * holding the chatbox id
	 */

#Code:
	private String chatBoxId;

	private String spaceKey;
	private String lastHeartBeatServerdate;

	private ChatBoxMap chatBoxMap = new ChatBoxMap();
	private Date newRequestDate = null;

	public AbstractChatAction(ChatManager chatManager, PageManager pageManager) {
		this.chatManager = chatManager;
		this.pageManager = pageManager;

	}

#No. 1096
#File: E:\bishe\1\AbstractChatAction.java
#Comment:
	/**
	 * Add all important messages from given box
	 *
	 * @param chatBox box where we like to add old messages
	 * @param date the date in the past
	 */

#Code:
	protected void addMessagesSince(ChatBox chatBox, Date date) {
		if (chatBox.hasMessageSince(date)) {
			chatBoxMap.getChatBoxById(chatBox.getId()).setLastMessage(chatBox.getLastMessage());
			if (chatBox.isOpen()) {
				chatBoxMap.getChatBoxById(chatBox.getId()).open();
			} else {
				chatBoxMap.getChatBoxById(chatBox.getId()).close();
			}
			ChatMessageList messagesSince = chatBox.getMessagesSince(date);
			Collections.reverse(messagesSince);

			for (int i = 0; i < messagesSince.size(); i++) {
				ChatMessage message = messagesSince.get(i);
				this.setNewRequestDate(message.getSenddate());
				chatBoxMap.getChatBoxById(chatBox.getId()).addMessage(message);
			}
		}
		chatManager.manageHistory(chatBox, AuthenticatedUserThreadLocal.getUser());
	}

#No. 1097
#File: E:\bishe\1\AbstractChatAction.java
#Comment:
	/**
	 * @return the chatBoxMap
	 */

#Code:
	public ChatBoxMap getChatBoxMap() {
		if (chatBoxMap == null) {
			chatBoxMap = new ChatBoxMap();
		}
		return chatBoxMap;
	}

#No. 1098
#File: E:\bishe\1\AbstractChatAction.java
#Comment:
	/**
	 * @return the newRequestDate
	 */

#Code:
	public Date getNewRequestDate() {
		if (this.newRequestDate == null) {
			this.newRequestDate = this.getLastRequestDate();
		}
		return newRequestDate;
	}

#No. 1099
#File: E:\bishe\1\AbstractChatConfigAction.java
#Comment:
	/**
	 * @return the chatManager
	 */

#Code:
	public ChatManager getChatManager() {
		return chatManager;
	}

#No. 1100
#File: E:\bishe\1\AbstractChatConfigAction.java
#Comment:
	/**
	 * @param chatManager the chatManager to set
	 */

#Code:
	public void setChatManager(ChatManager chatManager) {
		this.chatManager = chatManager;
	}

#No. 1101
#File: E:\bishe\1\AbstractCheckedFuture.java
#Comment:
  /**
   * {@inheritDoc}
   *
   * <p>This implementation calls {@link #get()} and maps that method's standard
   * exceptions to instances of type {@code X} using {@link #mapException}.
   *
   * <p>In addition, if {@code get} throws an {@link InterruptedException}, this
   * implementation will set the current thread's interrupt status before
   * calling {@code mapException}.
   *
   * @throws X if {@link #get()} throws an {@link InterruptedException},
   *         {@link CancellationException}, or {@link ExecutionException}
   */

#Code:
  @Override
  public V checkedGet() throws X {
    try {
      return get();
    } catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw mapException(e);
    } catch (CancellationException e) {
      throw mapException(e);
    } catch (ExecutionException e) {
      throw mapException(e);
    }
  }

#No. 1102
#File: E:\bishe\1\AbstractCheckedFuture.java
#Comment:
  /**
   * {@inheritDoc}
   *
   * <p>This implementation calls {@link #get(long, TimeUnit)} and maps that
   * method's standard exceptions (excluding {@link TimeoutException}, which is
   * propagated) to instances of type {@code X} using {@link #mapException}.
   *
   * <p>In addition, if {@code get} throws an {@link InterruptedException}, this
   * implementation will set the current thread's interrupt status before
   * calling {@code mapException}.
   *
   * @throws X if {@link #get()} throws an {@link InterruptedException},
   *         {@link CancellationException}, or {@link ExecutionException}
   * @throws TimeoutException {@inheritDoc}
   */

#Code:
  @Override
  public V checkedGet(long timeout, TimeUnit unit) throws TimeoutException, X {
    try {
      return get(timeout, unit);
    } catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw mapException(e);
    } catch (CancellationException e) {
      throw mapException(e);
    } catch (ExecutionException e) {
      throw mapException(e);
    }
  }

#No. 1103
#File: E:\bishe\1\AbstractChecker.java
#Comment:
	/**
	 * Asserts that a condition is true. If it isn't it throws an
	 * AssertionFailedError with the given message.
	 */

#Code:
	static public void assertTrue(String message, boolean condition) {
		if (!condition)
			fail(message);
	}

#No. 1104
#File: E:\bishe\1\AbstractChecker.java
#Comment:
	/**
	 * Asserts that a condition is true. If it isn't it throws an
	 * AssertionFailedError.
	 */

#Code:
	static public void assertTrue(boolean condition) {
		assertTrue(null, condition);
	}

#No. 1105
#File: E:\bishe\1\AbstractChecker.java
#Comment:
	/**
	 * Asserts that a condition is false. If it isn't it throws an
	 * AssertionFailedError with the given message.
	 */

#Code:
	static public void assertFalse(String message, boolean condition) {
		assertTrue(message, !condition);
	}

#No. 1106
#File: E:\bishe\1\AbstractChecker.java
#Comment:
	/**
	 * Asserts that a condition is false. If it isn't it throws an
	 * AssertionFailedError.
	 */

#Code:
	static public void assertFalse(boolean condition) {
		assertFalse(null, condition);
	}

#No. 1107
#File: E:\bishe\1\AbstractChecker.java
#Comment:
	/**
	 * Fails a test with the given message.
	 */

#Code:
	static public void fail(String message) {
		throw new AssertionFailedError(message);
	}

#No. 1108
#File: E:\bishe\1\AbstractChecker.java
#Comment:
	/**
	 * Fails a test with no message.
	 */

#Code:
	static public void fail() {
		fail(null);
	}

#No. 1109
#File: E:\bishe\1\AbstractChecker.java
#Comment:
	/**
	 * Asserts that two objects are equal. If they are not an
	 * AssertionFailedError is thrown with the given message.
	 */

#Code:
	static public void assertEquals(String message, Object expected,
			Object actual) {
		if (expected == null && actual == null)
			return;
		if (expected != null && expected.equals(actual))
			return;
		failNotEquals(message, expected, actual);
	}

#No. 1110
#File: E:\bishe\1\AbstractChecker.java
#Comment:
	/**
	 * Asserts that two objects are equal. If they are not an
	 * AssertionFailedError is thrown.
	 */

#Code:
	static public void assertEquals(Object expected, Object actual) {
		assertEquals(null, expected, actual);
	}

#No. 1111
#File: E:\bishe\1\AbstractChecker.java
#Comment:
	/**
	 * Asserts that two Strings are equal.
	 */

#Code:
	static public void assertEquals(String message, String expected,
			String actual) {
		if (expected == null && actual == null)
			return;
		if (expected != null && expected.equals(actual))
			return;
		throw new ComparisonFailure(message, expected, actual);
	}

#No. 1112
#File: E:\bishe\1\AbstractChecker.java
#Comment:
	/**
	 * Asserts that two Strings are equal.
	 */

#Code:
	static public void assertEquals(String expected, String actual) {
		assertEquals(null, expected, actual);
	}

#No. 1113
#File: E:\bishe\1\AbstractChecker.java
#Comment:
	/**
	 * Asserts that two doubles are equal concerning a delta. If they are not an
	 * AssertionFailedError is thrown with the given message. If the expected
	 * value is infinity then the delta value is ignored.
	 */

#Code:
	static public void assertEquals(String message, double expected,
			double actual, double delta) {
		// handle infinity specially since subtracting to infinite values gives
		// NaN and the
		// the following test fails
		if (Double.isInfinite(expected)) {
			if (!(expected == actual))
				failNotEquals(message, new Double(expected), new Double(actual));
		} else if (!(Math.abs(expected - actual) <= delta)) // Because
															// comparison with
															// NaN always
															// returns false
			failNotEquals(message, new Double(expected), new Double(actual));
	}

#No. 1114
#File: E:\bishe\1\AbstractChecker.java
#Comment:
	/**
	 * Asserts that two doubles are equal concerning a delta. If the expected
	 * value is infinity then the delta value is ignored.
	 */

#Code:
	static public void assertEquals(double expected, double actual, double delta) {
		assertEquals(null, expected, actual, delta);
	}

#No. 1115
#File: E:\bishe\1\AbstractChecker.java
#Comment:
	/**
	 * Asserts that two floats are equal concerning a delta. If they are not an
	 * AssertionFailedError is thrown with the given message. If the expected
	 * value is infinity then the delta value is ignored.
	 */

#Code:
	static public void assertEquals(String message, float expected,
			float actual, float delta) {
		// handle infinity specially since subtracting to infinite values gives
		// NaN and the
		// the following test fails
		if (Float.isInfinite(expected)) {
			if (!(expected == actual))
				failNotEquals(message, new Float(expected), new Float(actual));
		} else if (!(Math.abs(expected - actual) <= delta))
			failNotEquals(message, new Float(expected), new Float(actual));
	}

#No. 1116
#File: E:\bishe\1\AbstractChecker.java
#Comment:
	/**
	 * Asserts that two floats are equal concerning a delta. If the expected
	 * value is infinity then the delta value is ignored.
	 */

#Code:
	static public void assertEquals(float expected, float actual, float delta) {
		assertEquals(null, expected, actual, delta);
	}

#No. 1117
#File: E:\bishe\1\AbstractChecker.java
#Comment:
	/**
	 * Asserts that two longs are equal. If they are not an AssertionFailedError
	 * is thrown with the given message.
	 */

#Code:
	static public void assertEquals(String message, long expected, long actual) {
		assertEquals(message, new Long(expected), new Long(actual));
	}

#No. 1118
#File: E:\bishe\1\AbstractChecker.java
#Comment:
	/**
	 * Asserts that two longs are equal.
	 */

#Code:
	static public void assertEquals(long expected, long actual) {
		assertEquals(null, expected, actual);
	}

#No. 1119
#File: E:\bishe\1\AbstractChecker.java
#Comment:
	/**
	 * Asserts that two booleans are equal. If they are not an
	 * AssertionFailedError is thrown with the given message.
	 */

#Code:
	static public void assertEquals(String message, boolean expected,
			boolean actual) {
		assertEquals(message, new Boolean(expected), new Boolean(actual));
	}

#No. 1120
#File: E:\bishe\1\AbstractChecker.java
#Comment:
	/**
	 * Asserts that two booleans are equal.
	 */

#Code:
	static public void assertEquals(boolean expected, boolean actual) {
		assertEquals(null, expected, actual);
	}

#No. 1121
#File: E:\bishe\1\AbstractChecker.java
#Comment:
	/**
	 * Asserts that two bytes are equal. If they are not an AssertionFailedError
	 * is thrown with the given message.
	 */

#Code:
	static public void assertEquals(String message, byte expected, byte actual) {
		assertEquals(message, new Byte(expected), new Byte(actual));
	}

#No. 1122
#File: E:\bishe\1\AbstractChecker.java
#Comment:
	/**
	 * Asserts that two bytes are equal.
	 */

#Code:
	static public void assertEquals(byte expected, byte actual) {
		assertEquals(null, expected, actual);
	}

#No. 1123
#File: E:\bishe\1\AbstractChecker.java
#Comment:
	/**
	 * Asserts that two chars are equal. If they are not an AssertionFailedError
	 * is thrown with the given message.
	 */

#Code:
	static public void assertEquals(String message, char expected, char actual) {
		assertEquals(message, new Character(expected), new Character(actual));
	}

#No. 1124
#File: E:\bishe\1\AbstractChecker.java
#Comment:
	/**
	 * Asserts that two chars are equal.
	 */

#Code:
	static public void assertEquals(char expected, char actual) {
		assertEquals(null, expected, actual);
	}

#No. 1125
#File: E:\bishe\1\AbstractChecker.java
#Comment:
	/**
	 * Asserts that two shorts are equal. If they are not an
	 * AssertionFailedError is thrown with the given message.
	 */

#Code:
	static public void assertEquals(String message, short expected, short actual) {
		assertEquals(message, new Short(expected), new Short(actual));
	}

#No. 1126
#File: E:\bishe\1\AbstractChecker.java
#Comment:
	/**
	 * Asserts that two shorts are equal.
	 */

#Code:
	static public void assertEquals(short expected, short actual) {
		assertEquals(null, expected, actual);
	}

#No. 1127
#File: E:\bishe\1\AbstractChecker.java
#Comment:
	/**
	 * Asserts that two ints are equal. If they are not an AssertionFailedError
	 * is thrown with the given message.
	 */

#Code:
	static public void assertEquals(String message, int expected, int actual) {
		assertEquals(message, new Integer(expected), new Integer(actual));
	}

#No. 1128
#File: E:\bishe\1\AbstractChecker.java
#Comment:
	/**
	 * Asserts that two ints are equal.
	 */

#Code:
	static public void assertEquals(int expected, int actual) {
		assertEquals(null, expected, actual);
	}

#No. 1129
#File: E:\bishe\1\AbstractChecker.java
#Comment:
	/**
	 * Asserts that an object isn't null.
	 */

#Code:
	static public void assertNotNull(Object object) {
		assertNotNull(null, object);
	}

#No. 1130
#File: E:\bishe\1\AbstractChecker.java
#Comment:
	/**
	 * Asserts that an object isn't null. If it is an AssertionFailedError is
	 * thrown with the given message.
	 */

#Code:
	static public void assertNotNull(String message, Object object) {
		assertTrue(message, object != null);
	}

#No. 1131
#File: E:\bishe\1\AbstractChecker.java
#Comment:
	/**
	 * Asserts that an object is null.
	 */

#Code:
	static public void assertNull(Object object) {
		assertNull(null, object);
	}

#No. 1132
#File: E:\bishe\1\AbstractChecker.java
#Comment:
	/**
	 * Asserts that an object is null. If it is not an AssertionFailedError is
	 * thrown with the given message.
	 */

#Code:
	static public void assertNull(String message, Object object) {
		assertTrue(message, object == null);
	}

#No. 1133
#File: E:\bishe\1\AbstractChecker.java
#Comment:
	/**
	 * Asserts that two objects refer to the same object. If they are not an
	 * AssertionFailedError is thrown with the given message.
	 */

#Code:
	static public void assertSame(String message, Object expected, Object actual) {
		if (expected == actual)
			return;
		failNotSame(message, expected, actual);
	}

#No. 1134
#File: E:\bishe\1\AbstractChecker.java
#Comment:
	/**
	 * Asserts that two objects refer to the same object. If they are not the
	 * same an AssertionFailedError is thrown.
	 */

#Code:
	static public void assertSame(Object expected, Object actual) {
		assertSame(null, expected, actual);
	}

#No. 1135
#File: E:\bishe\1\AbstractChecker.java
#Comment:
	/**
	 * Asserts that two objects refer to the same object. If they are not an
	 * AssertionFailedError is thrown with the given message.
	 */

#Code:
	static public void assertNotSame(String message, Object expected,
			Object actual) {
		if (expected == actual)
			failSame(message);
	}

#No. 1136
#File: E:\bishe\1\AbstractChecker.java
#Comment:
	/**
	 * Asserts that two objects refer to the same object. If they are not the
	 * same an AssertionFailedError is thrown.
	 */

#Code:
	static public void assertNotSame(Object expected, Object actual) {
		assertNotSame(null, expected, actual);
	}

#No. 1137
#File: E:\bishe\1\AbstractChildrenInventory.java
#Comment:
    /**
     * All the children that are present in this {@link Inventory}.
     */

#Code:
    private final List<AbstractInventory> children;

    public AbstractChildrenInventory(@Nullable Inventory parent, @Nullable Translation name) {
        this(parent, name, new ArrayList<>());
    }

    public AbstractChildrenInventory(@Nullable Inventory parent, @Nullable Translation name, List<AbstractInventory> children) {
        super(parent, name);
        this.children = checkNotNull(children, "children");
    }

    @Override
    AbstractInventory getChild(int index) {
        return index < 0 || index >= this.children.size() ? empty() : this.children.get(index);
    }

#No. 1138
#File: E:\bishe\1\AbstractChildrenInventory.java
#Comment:
    /**
     * Gets the children of the inventory.
     *
     * @return The children
     */

#Code:
    public List<AbstractInventory> getChildren() {
        return Collections.unmodifiableList(this.children);
    }

#No. 1139
#File: E:\bishe\1\AbstractChildrenInventory.java
#Comment:
    /**
     * Registers a child {@link Inventory} for this inventory. {@link Slot}s
     * cannot be added through this method.
     *
     * @param childInventory The child inventory
     */

#Code:
    protected <T extends Inventory> T registerChild(T childInventory) {
        checkNotNull(childInventory, "childInventory");
        final AbstractInventory childInventory1 = (AbstractInventory) childInventory;
        checkArgument(!this.children.contains(childInventory1), "The child is already registered");
        this.children.add(childInventory1);
        return childInventory;
    }

#No. 1140
#File: E:\bishe\1\AbstractChildrenInventory.java
#Comment:
    /**
     * Prioritizes a child {@link Inventory} to have a higher priority
     * for {@link Inventory#poll}, {@link Inventory#offer(ItemStack)},
     * ... functions. The child must be registered
     *
     * @param childInventory The child inventory
     * @param <T> The child inventory type
     * @return The child inventory
     */

#Code:
    protected <T extends Inventory> T prioritizeChild(T childInventory) {
        checkNotNull(childInventory, "inventory");
        final AbstractInventory childInventory1 = (AbstractInventory) childInventory;
        checkArgument(this.children.contains(childInventory1), "The inventory is not registered");
        if (this.children.size() == 1) {
            return childInventory;
        }
        this.children.remove(childInventory1);
        this.children.add(0, childInventory1);
        return childInventory;
    }

#No. 1141
#File: E:\bishe\1\AbstractChorusOutputWriter.java
#Comment:
    /**
     * This is an extension point to change Chorus output
     *
     * The user can provider their own OutputWriter which extends the default and
     * overrides getPrintWriter() to return a writer configured for a different output stream
     *
     * n.b. this method will be called frequently so it is expected that the PrintWriter returned
     * will generally be cached and reused by the implementation, but in some circumstances it is
     * useful to be able to change the PrintWriter during the testing process so the details are
     * left to the implementation
     *
     * @return a PrintWriter to use for all logging
     */

#Code:
    protected PrintWriter getPrintWriter() {
        if ( printWriter == null || printStream != ChorusOut.out) {
            printWriter = new PrintWriter(ChorusOut.out);
            printStream = ChorusOut.out;
        }
        return printWriter;
    }

#No. 1142
#File: E:\bishe\1\AbstractChrono.java
#Comment:
/**
 * Initializes this `AbstractChrono` to zero.
 */

#Code:
public void init() {
      getTime (now);
      m_second = now[0];
      m_microsec = now[1];
   }

#No. 1143
#File: E:\bishe\1\AbstractChrono.java
#Comment:
   /**
    * Returns the CPU time in seconds used by the program since the last
    * call to  #init for this `AbstractChrono`.
    *  @return the number of seconds
    */

#Code:
   public double getSeconds() {
      getTime (now);
      double time = (now[1] - m_microsec)/1000000.0
             + (now[0] - m_second);
      return time;
   }

#No. 1144
#File: E:\bishe\1\AbstractChrono.java
#Comment:
   /**
    * Returns the CPU time in minutes used by the program since the last
    * call to  #init for this `AbstractChrono`.
    *  @return the number of minutes
    */

#Code:
   public double getMinutes() {
      getTime (now);
      double time = (now[1] - m_microsec)/1000000.0
             + (now[0] - m_second);
      return time*1.666666667*0.01;
   }

#No. 1145
#File: E:\bishe\1\AbstractChrono.java
#Comment:
   /**
    * Returns the CPU time in hours used by the program since the last
    * call to  #init for this `AbstractChrono`.
    *  @return the number of hours
    */

#Code:
   public double getHours() {
      getTime (now);
      double time = (now[1] - m_microsec)/1000000.0
             + (now[0] - m_second);
      return time*2.777777778*0.0001;
   }

#No. 1146
#File: E:\bishe\1\AbstractChrono.java
#Comment:
   /**
    * Converts the CPU time used by the program since its last call to
    * #init for this <tt>AbstractChrono</tt> to a  String in the
    * `HH:MM:SS.xx` format.
    *  @return the string representation of the CPU time
    */

#Code:
   public String format() {
      return format (getSeconds());
   }

#No. 1147
#File: E:\bishe\1\AbstractChrono.java
#Comment:
   /**
    * Converts the time `time`, given in seconds, to a  String in the
    * `HH:MM:SS.xx` format.
    *  @return the string representation of the time `time`
    */

#Code:
   public static String format (double time) {
      int second, hour, min, centieme;
      hour = (int)(time/3600.0);
      if (hour > 0) time -= ((double)hour*3600.0);
      min = (int)(time/60.0);
      if (min > 0) time -= ((double)min*60.0);
      second = (int)time;
      centieme = (int)(100.0*(time - (double)second) + 0.5);
      return String.valueOf (hour) + ":" +
                      min + ":" +
                      second + "." +
                      centieme;
   }

#No. 1148
#File: E:\bishe\1\AbstractCipher.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public byte[] encrypt(byte[] data, int offset, int length,
            CodecParameter param)
    {
        if (cipherKey == null)
        {
            throw new CipherException("Fail to encrypt " + algorithm
                    + ". Cause fail to initialize secret key.");
        }
        try
        {
            Cipher cipher = Cipher.getInstance(algorithm);
            cipher.init(Cipher.ENCRYPT_MODE, cipherKey);
            return cipher.doFinal(data, offset, length);
        }
        catch (Exception e)
        {
            throw new CipherException("Fail to encrypt " + algorithm
                    + ". Cause " + e.getMessage(), e);
        }
    }

#No. 1149
#File: E:\bishe\1\AbstractCipher.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public byte[] decrypt(byte[] data, int offset, int length,
            CodecParameter param)
    {
        if (cipherKey == null)
        {
            throw new CipherException("Fail to decrypt " + algorithm
                    + ". Cause fail to initialize secret key.");
        }
        try
        {
            Cipher cipher = Cipher.getInstance(algorithm);
            cipher.init(Cipher.DECRYPT_MODE, cipherKey);
            return cipher.doFinal(data, offset, length);
        }
        catch (Exception e)
        {
            throw new CipherException("Fail to decrypt " + algorithm
                    + ". Cause " + e.getMessage(), e);
        }
    }

#No. 1150
#File: E:\bishe\1\AbstractClassExample.java
#Comment:
/*
 * class SubClass extends AbstractClassExample {
 * 
 * }
 */

#Code:

// This class implements both abstractMethod1 and abstractMethod2
class SubClass2 extends AbstractClassExample {
	void abstractMethod1() {
		System.out.println("Abstract Method1");
	}

	void abstractMethod2() {
		System.out.println("Abstract Method2");
	}
}

#No. 1151
#File: E:\bishe\1\AbstractClassFactory.java
#Comment:
    /**
     * Hook that is called after the class is loaded, before {@link #cleanup()} is called.
     * <p/>
     * This method may be called mutiple times, if the proxy is definined in multiple class loaders
     *
     * @param clazz The newly loaded class
     */

#Code:
    public void afterClassLoad(Class<?> clazz) {

    }

#No. 1152
#File: E:\bishe\1\AbstractClassFactory.java
#Comment:
    /**
     * Returns the {@link Class} object for the generated class, creating it if it does not exist
     *
     * @return the generated class
     */

#Code:
    @SuppressWarnings("unchecked")
    public Class<? extends T> defineClass() {
        if (generatedClass == null) {
            synchronized (this) {
                if (generatedClass == null) {
                    try {
                        // first check that the proxy has not already been created
                        generatedClass = (Class<? extends T>) classLoader.loadClass(this.className);
                    } catch (ClassNotFoundException e) {
                        buildClassDefinition();
                        if (protectionDomain == null) {
                            generatedClass = (Class<? extends T>) classFile.define(classLoader);
                        } else {
                            generatedClass = (Class<? extends T>) classFile.define(classLoader, protectionDomain);
                        }
                        afterClassLoad(generatedClass);
                    }
                    classFile = null;
                }
            }
        }
        return generatedClass;
    }

#No. 1153
#File: E:\bishe\1\AbstractClassFactory.java
#Comment:
    /**
     * Checks if the proxy class is defined in the factories class loader
     *
     * @return true if the proxy class already exists
     */

#Code:
    public boolean isProxyClassDefined() {
        return isProxyClassDefined(classLoader);
    }

#No. 1154
#File: E:\bishe\1\AbstractClassFactory.java
#Comment:
    /**
     * Checks if the proxy class has been defined in the given class loader
     *
     * @param classLoader The class loader to check
     * @return true if the proxy is defined in the class loader
     */

#Code:
    public boolean isProxyClassDefined(ClassLoader classLoader) {
        try {
            // first check that the proxy has not already been created
            classLoader.loadClass(this.className);
            return true;
        } catch (ClassNotFoundException e) {
            return false;
        }
    }

#No. 1155
#File: E:\bishe\1\AbstractClassFactory.java
#Comment:
    /**
     * Generates the class
     */

#Code:
    public void buildClassDefinition() {
        if (!classGenerated) {
            synchronized (this) {
                if (!classGenerated) {
                    generateClass();
                    cleanup();
                    classGenerated = true;
                }
            }
        }
    }

#No. 1156
#File: E:\bishe\1\AbstractClassFactory.java
#Comment:
    /**
     * Creates a new instance of the generated class by invoking the default constructor.
     * <p/>
     * If the generated class has not been defined it will be created.
     *
     * @return the new instance
     * @throws InstantiationException if the new instance could not be created
     * @throws IllegalAccessException if the new constructor is inaccessible for some reason
     */

#Code:
    public T newInstance() throws InstantiationException, IllegalAccessException {
        return defineClass().newInstance();
    }

#No. 1157
#File: E:\bishe\1\AbstractClassFactory.java
#Comment:
    /**
     * Get the class name.
     *
     * @return the class name
     */

#Code:
    public String getClassName() {
        return className;
    }

#No. 1158
#File: E:\bishe\1\AbstractClassFactory.java
#Comment:
    /**
     * Get the superclass name.
     *
     * @return the superclass name
     */

#Code:
    public String getSuperClassName() {
        return superClass.getName();
    }

#No. 1159
#File: E:\bishe\1\AbstractClassFactory.java
#Comment:
    /**
     * Get the superclass.
     *
     * @return the superclass
     */

#Code:
    public Class<T> getSuperClass() {
        return superClass;
    }

#No. 1160
#File: E:\bishe\1\AbstractClassFactory.java
#Comment:
    /**
     * Get the defining class loader.
     *
     * @return the defining class loader
     */

#Code:
    public ClassLoader getClassLoader() {
        return classLoader;
    }

#No. 1161
#File: E:\bishe\1\AbstractClassFactory.java
#Comment:
    /**
     * Get the defined protection domain.
     *
     * @return the protection domain
     */

#Code:
    public ProtectionDomain getProtectionDomain() {
        return protectionDomain;
    }

#No. 1162
#File: E:\bishe\1\AbstractClassFinishRule.java
#Comment:
    /**
     * This method counts the number of test methods. This counter is used to
     * help shut down the browsers when the test is complete.
     */

#Code:
    @VisibleForTesting
    static int countTestMethods(
            @SuppressWarnings("rawtypes") Class testClass) {

        int count = 0;
        for (Method m : testClass.getMethods()) {
            if ((m.getAnnotation(Test.class) != null)
                    && (m.getAnnotation(Ignore.class) == null)) {
                count++;
            }
        }

#No. 1163
#File: E:\bishe\1\AbstractClassMappingValidator.java
#Comment:
    /**
     * Check all the mappings assigned to this validator. If one of the classes
     * is assignable to this object return true.
     * 
     * @return <code>true</code> when supported, <code>false</code> otherwise
     */

#Code:
    @SuppressWarnings("rawtypes")
    public final boolean supports(final Class clazz) {
        final Iterator keyIter = this.mappings.keySet().iterator();
        boolean supports = false;
        while (keyIter.hasNext() && !supports) {
            final Class targetClazz = (Class) keyIter.next();
            supports = ClassUtils.isAssignable(targetClazz, clazz);
        }
        return supports;
    }

#No. 1164
#File: E:\bishe\1\AbstractClassMappingValidator.java
#Comment:
    /**
     * Gets the fieldname from the configured map. 
     * @param target
     * @return
     */

#Code:
    protected final String getFieldName(final Object target) {
        String fieldName = null;
        for (final Entry<Class<?>, String> entry : this.mappings.entrySet()) {
            if (ClassUtils.isAssignable(entry.getKey(), target.getClass())) {
                fieldName = entry.getValue();
                break;
            }
        }

        if (fieldName == null) {
            throw new IllegalStateException("Cannot find fieldname for class " + target.getClass().getName()
                    + ". Class is not compatible with declared types. [" + this.mappings + "]");
        }
        return fieldName;

    }

#No. 1165
#File: E:\bishe\1\AbstractClassResolver.java
#Comment:
    /**
     * {@inheritDoc}  The base implementation uses the class loader returned from {@code getClassLoader()} and
     * loads the class by name.
     */

#Code:
    public Class<?> resolveClass(final Unmarshaller unmarshaller, final String name, final long serialVersionUID) throws IOException, ClassNotFoundException {
        final Class<?> clazz = loadClass(name);
        if (enforceSerialVersionUid && serialVersionUID != 0L) {
            final long uid = registry.lookup(clazz).getEffectiveSerialVersionUID();
            if (uid != serialVersionUID) {
                throw new StreamCorruptedException("serialVersionUID does not match!");
            }
        }
        return clazz;
    }

#No. 1166
#File: E:\bishe\1\AbstractClassResolver.java
#Comment:
    /**
     * Load a class with the given name.  The base implementation uses the classloader returned from {@link #getClassLoader()}.
     *
     * @param name the name of the class
     * @return the class
     * @throws ClassNotFoundException if the class is not found, or if there is no classloader
     */

#Code:
    protected Class<?> loadClass(final String name) throws ClassNotFoundException {
        final Class<?> prim = primitives.get(name);
        return prim != null ? prim : Class.forName(name, false, getClassLoaderChecked());
    }

#No. 1167
#File: E:\bishe\1\AbstractCLI.java
#Comment:
    /**
     * outputs the usage message using <code>usage()</code>
     * and exits with exit status 1
     */

#Code:
    protected void abort() {
        usage();
        System.exit(1);
    }

#No. 1168
#File: E:\bishe\1\AbstractCLI.java
#Comment:
    /**
     * outputs the usage message using <code>usage()</code>
     * and the given <code>errorReason</code> message and finally exits with exit status 1
     */

#Code:
    protected void abort(String errorReason) {
        usage(errorReason);
        System.exit(1);
    }

#No. 1169
#File: E:\bishe\1\AbstractCLI.java
#Comment:
    /**
     * outputs the usage message and the given <code>errorReason</code> message
     */

#Code:
    protected void usage(String errorReason) {
        usage();

        if (errorReason != null) {
            System.out.println("\n---> " + errorReason);
        }
    }

#No. 1170
#File: E:\bishe\1\AbstractClientExecutor.java
#Comment:
    /**
     * Start performance queue in the database and retrieve its ID
     *
     * @return the started queue ID
     * @throws AgentException 
     */

#Code:
    public int retrieveQueueId( int sequence, String hostsList ) throws AgentException {

        int queueId;
        try {
            if( dbAccess == null ) {
                dbAccess = new DbAccessFactory().getNewDbWriteAccessObject();
            }
            queueId = dbAccess.startLoadQueue( queueName, sequence, hostsList,
                                               threadingPattern.getPatternDescription(),
                                               threadingPattern.getThreadCount(), LOCAL_MACHINE,
                                               Calendar.getInstance().getTimeInMillis(),
                                               ActiveDbAppender.getCurrentInstance().getTestCaseId(), true );

            log.rememberLoadQueueState( queueName, queueId, threadingPattern.getPatternDescription(),
                                        threadingPattern.getThreadCount() );
        } catch( DatabaseAccessException e ) {
            if( ActiveDbAppender.getCurrentInstance() == null ) {
                // The log4j DB appender is not attached
                // We assume the user is running a performance test without DB logging
                log.warn( "Unable to register a performance queue with name '" + queueName
                          + "' in the loggging database."
                          + " This means the results of running this queue will not be registered in the log DB."
                          + " Check your DB configuration in order to fix this problem." );

                // Return this invalid value will not cause an error on the Test Executor side
                // We also know there will be no error on agent's side as our DB appender will not be present there
                queueId = -1;
            } else {
                throw new AgentException( "Unable to register a performance queue with name '" + queueName
                                          + "' in the loggging database. This queue will not run at all.",
                                          e );
            }
        }

        return queueId;
    }

#No. 1171
#File: E:\bishe\1\AbstractClientProxyChannel.java
#Comment:
	/**
	 * @param towrap
	 *            The channel to the proxy server
	 **/

#Code:
	public AbstractClientProxyChannel( ByteChannel towrap ) {
		super( towrap );
		try {
			proxyHandshake = ByteBuffer.wrap( buildHandShake().getBytes( "ASCII" ) );
		} catch ( UnsupportedEncodingException e ) {
			throw new RuntimeException( e );
		}
	}

#No. 1172
#File: E:\bishe\1\AbstractCloseableIterable.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public void closeQuietly() {
        try {
            Closeables.close(this, true);
        } catch (IOException e) {
            // IOException should not have been thrown
        }
    }

#No. 1173
#File: E:\bishe\1\AbstractCloseableIterable.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public void close() throws IOException {
        if (!closed) {
            doClose();
            closed = true;
        }
    }

#No. 1174
#File: E:\bishe\1\AbstractCloseableIterable.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public Iterator<T> iterator() {
        if (closed)
            throw new IllegalStateException("Iterable is already closed");

        return retrieveIterator();
    }

#No. 1175
#File: E:\bishe\1\AbstractClusterConfiguration.java
#Comment:
	/**
	 * Return the {@link Cluster} instance to connect to.
	 * 
	 * @return Cluster object
	 */

#Code:
	@Bean
	public CqlClusterFactoryBean cluster() {

		CqlClusterFactoryBean bean = new CqlClusterFactoryBean();
		bean.setAuthProvider(getAuthProvider());
		bean.setCompressionType(getCompressionType());
		bean.setContactPoints(getContactPoints());
		bean.setPort(getPort());
		bean.setMetricsEnabled(isMetricsEnabled());
		bean.setLoadBalancingPolicy(getLoadBalancingPolicy());
		bean.setReconnectionPolicy(getReconnectionPolicy());
		bean.setLocalPoolingOptions(getLocalPoolingOptions());
		bean.setRemotePoolingOptions(getRemotePoolingOptions());
		bean.setRetryPolicy(getRetryPolicy());
		bean.setSocketOptions(getSocketOptions());

		return bean;
	}

#No. 1176
#File: E:\bishe\1\AbstractClusterer.java
#Comment:
    /**
     * @param trainingParameters
     * @param configuration
     * @see AbstractTrainer#AbstractTrainer(AbstractTrainingParameters, Configuration)
     */

#Code:
    protected AbstractClusterer(TP trainingParameters, Configuration configuration) {
        super(trainingParameters, configuration);
    }

#No. 1177
#File: E:\bishe\1\AbstractClusterer.java
#Comment:
    /**
     * @param storageName
     * @param configuration
     * @see AbstractTrainer#AbstractTrainer(String, Configuration)
     */

#Code:
    protected AbstractClusterer(String storageName, Configuration configuration) {
        super(storageName, configuration);
    }

#No. 1178
#File: E:\bishe\1\AbstractClusterer.java
#Comment:
    /**
     * Clears the clusters from their internal caching parameters before storing
     * them. It should be called in the _fit() method of each Clusterer.
     */

#Code:
    protected void clearClusters() {
        MP modelParameters = knowledgeBase.getModelParameters();
        Map<Integer, CL> clusterMap = modelParameters.getClusterMap();
        for(Map.Entry<Integer, CL> e : clusterMap.entrySet()) {
            Integer clusterId = e.getKey();
            CL c = e.getValue();
            c.clear();
            clusterMap.put(clusterId, c);
        }
    }

#No. 1179
#File: E:\bishe\1\AbstractClusterer.java
#Comment:
    /**
     * Getter for the AbstractCluster list.
     * 
     * @return 
     */

#Code:
    public Map<Integer, CL> getClusters() {
        return knowledgeBase.getModelParameters().getClusterMap();
    }

#No. 1180
#File: E:\bishe\1\AbstractCmisTestCase.java
#Comment:
    /**
     * Returns the test repository id.
     */

#Code:
    protected String getTestRepositoryId() {
        if (fTestRepositoryId != null) {
            return fTestRepositoryId;
        }

        fTestRepositoryId = System.getProperty(PROP_REPOSITORY);
        if (fTestRepositoryId != null) {
            LOG.info("Test repository: " + fTestRepositoryId);
            return fTestRepositoryId;
        }

        fTestRepositoryId = getFirstRepositoryId();
        LOG.info("Test repository: " + fTestRepositoryId);

        return fTestRepositoryId;
    }

#No. 1181
#File: E:\bishe\1\AbstractCmisTestCase.java
#Comment:
    /**
     * Returns the test root folder id.
     */

#Code:
    protected String getTestRootFolder() {
        if (fTestFolderId != null) {
            return fTestFolderId;
        }

        fTestFolderId = System.getProperty(PROP_TESTFOLDER);
        if (fTestFolderId != null) {
            LOG.info("Test root folder: " + fTestFolderId);
            return fTestFolderId;
        }

        fTestFolderId = getRootFolderId();
        LOG.info("Test root folder: " + fTestFolderId);

        return fTestFolderId;
    }

#No. 1182
#File: E:\bishe\1\AbstractCmisTestCase.java
#Comment:
    /**
     * Returns if the test is enabled.
     */

#Code:
    protected boolean isEnabled(String name) {
        boolean testsEnabled = Boolean.parseBoolean(System.getProperty(PROP_TESTS_ENABLED, DEFAULT_TESTS_ENABLED));

        if (testsEnabled && getEnabledTests().contains(name)) {
            return true;
        }

        LOG.info("Skipping test '" + name + "'!");

        return false;
    }

#No. 1183
#File: E:\bishe\1\AbstractCmisTestCase.java
#Comment:
    /**
     * Returns the test username.
     */

#Code:
    protected String getUsername() {
        return System.getProperty(PROP_USERNAME, DEFAULT_USERNAME);
    }

#No. 1184
#File: E:\bishe\1\AbstractCmisTestCase.java
#Comment:
    /**
     * Returns the test password.
     */

#Code:
    protected String getPassword() {
        return System.getProperty(PROP_PASSWORD, DEFAULT_PASSWORD);
    }

#No. 1185
#File: E:\bishe\1\AbstractCmisTestCase.java
#Comment:
    /**
     * Returns the default document type.
     */

#Code:
    protected String getDefaultDocumentType() {
        return System.getProperty(PROP_DOCTYPE, DEFAULT_DOCTYPE);
    }

#No. 1186
#File: E:\bishe\1\AbstractCmisTestCase.java
#Comment:
    /**
     * Returns the default folder type.
     */

#Code:
    protected String getDefaultFolderType() {
        return System.getProperty(PROP_FOLDERTYPE, DEFAULT_FOLDERTYPE);
    }

#No. 1187
#File: E:\bishe\1\AbstractCmisTestCase.java
#Comment:
    /**
     * Returns the AtomPub URL.
     */

#Code:
    protected String getAtomPubURL() {
        return System.getProperty(PROP_ATOMPUB_URL, DEFAULT_ATOMPUB_URL);
    }

#No. 1188
#File: E:\bishe\1\AbstractCmisTestCase.java
#Comment:
    /**
     * Returns the object factory.
     */

#Code:
    protected BindingsObjectFactory getObjectFactory() {
        return getBinding().getObjectFactory();
    }

#No. 1189
#File: E:\bishe\1\AbstractCmisTestCase.java
#Comment:
    /**
     * Returns the id of the first repository.
     */

#Code:
    protected String getFirstRepositoryId() {
        List<RepositoryInfo> repositories = getBinding().getRepositoryService().getRepositoryInfos(null);

        assertNotNull(repositories);
        assertFalse(repositories.isEmpty());
        assertNotNull(repositories.get(0).getId());

        return repositories.get(0).getId();
    }

#No. 1190
#File: E:\bishe\1\AbstractCmisTestCase.java
#Comment:
    /**
     * Returns the info object of the test repository.
     */

#Code:
    protected RepositoryInfo getRepositoryInfo() {
        RepositoryInfo repositoryInfo = getBinding().getRepositoryService().getRepositoryInfo(getTestRepositoryId(),
                null);

        assertNotNull(repositoryInfo);
        assertNotNull(repositoryInfo.getId());
        assertEquals(getTestRepositoryId(), repositoryInfo.getId());

        return repositoryInfo;
    }

#No. 1191
#File: E:\bishe\1\AbstractCmisTestCase.java
#Comment:
    /**
     * Returns the root folder of the test repository.
     */

#Code:
    protected String getRootFolderId() {
        RepositoryInfo repository = getRepositoryInfo();

        assertNotNull(repository.getRootFolderId());

        return repository.getRootFolderId();
    }

#No. 1192
#File: E:\bishe\1\AbstractCmisTestCase.java
#Comment:
    /**
     * Returns if the test repository supports reading ACLs.
     */

#Code:
    protected boolean supportsDiscoverACLs() {
        RepositoryInfo repository = getRepositoryInfo();

        assertNotNull(repository.getCapabilities());

        return repository.getCapabilities().getAclCapability() != CapabilityAcl.NONE;
    }

#No. 1193
#File: E:\bishe\1\AbstractCmisTestCase.java
#Comment:
    /**
     * Returns if the test repository supports setting ACLs.
     */

#Code:
    protected boolean supportsManageACLs() {
        RepositoryInfo repository = getRepositoryInfo();

        assertNotNull(repository.getCapabilities());

        return repository.getCapabilities().getAclCapability() == CapabilityAcl.MANAGE;
    }

#No. 1194
#File: E:\bishe\1\AbstractCmisTestCase.java
#Comment:
    /**
     * Returns if the test repository supports renditions.
     */

#Code:
    protected boolean supportsRenditions() {
        RepositoryInfo repository = getRepositoryInfo();

        assertNotNull(repository.getCapabilities());

        if (repository.getCapabilities().getRenditionsCapability() == null) {
            return false;
        }

        return repository.getCapabilities().getRenditionsCapability() != CapabilityRenditions.NONE;
    }

#No. 1195
#File: E:\bishe\1\AbstractCmisTestCase.java
#Comment:
    /**
     * Returns if the test repository supports descendants.
     */

#Code:
    protected boolean supportsDescendants() {
        RepositoryInfo repository = getRepositoryInfo();

        assertNotNull(repository.getCapabilities());

        if (repository.getCapabilities().isGetDescendantsSupported() == null) {
            return false;
        }

        return repository.getCapabilities().isGetDescendantsSupported();
    }

#No. 1196
#File: E:\bishe\1\AbstractCmisTestCase.java
#Comment:
    /**
     * Returns if the test repository supports descendants.
     */

#Code:
    protected boolean supportsFolderTree() {
        RepositoryInfo repository = getRepositoryInfo();

        assertNotNull(repository.getCapabilities());

        if (repository.getCapabilities().isGetFolderTreeSupported() == null) {
            return false;
        }

        return repository.getCapabilities().isGetFolderTreeSupported();
    }

#No. 1197
#File: E:\bishe\1\AbstractCmisTestCase.java
#Comment:
    /**
     * Returns if the test repository supports content changes.
     */

#Code:
    protected boolean supportsContentChanges() {
        RepositoryInfo repository = getRepositoryInfo();

        assertNotNull(repository.getCapabilities());

        if (repository.getCapabilities().getChangesCapability() == null) {
            return false;
        }

        return repository.getCapabilities().getChangesCapability() != CapabilityChanges.NONE;
    }

#No. 1198
#File: E:\bishe\1\AbstractCmisTestCase.java
#Comment:
    /**
     * Returns if the test repository supports query.
     */

#Code:
    protected boolean supportsQuery() {
        RepositoryInfo repository = getRepositoryInfo();

        assertNotNull(repository.getCapabilities());

        if (repository.getCapabilities().getQueryCapability() == null) {
            return false;
        }

        return repository.getCapabilities().getQueryCapability() != CapabilityQuery.NONE;
    }

#No. 1199
#File: E:\bishe\1\AbstractCmisTestCase.java
#Comment:
    /**
     * Returns if the test repository supports relationships.
     */

#Code:
    protected boolean supportsRelationships() {
        TypeDefinition relType = null;

        try {
            relType = getBinding().getRepositoryService().getTypeDefinition(getTestRepositoryId(), "cmis:relationship",
                    null);
        } catch (CmisObjectNotFoundException e) {
            return false;
        }

        return relType != null;
    }

#No. 1200
#File: E:\bishe\1\AbstractCmisTestCase.java
#Comment:
    /**
     * Returns if the test repository supports policies.
     */

#Code:
    protected boolean supportsPolicies() {
        TypeDefinition relType = null;

        try {
            relType = getBinding().getRepositoryService().getTypeDefinition(getTestRepositoryId(), "cmis:policy", null);
        } catch (CmisObjectNotFoundException e) {
            return false;
        }

        return relType != null;
    }

#No. 1201
#File: E:\bishe\1\AbstractCmisTestCase.java
#Comment:
    /**
     * Returns the AclPropagation from the ACL capabilities.
     */

#Code:
    protected AclPropagation getAclPropagation() {
        RepositoryInfo repository = getRepositoryInfo();

        assertNotNull(repository.getCapabilities());

        if (repository.getAclCapabilities().getAclPropagation() == null) {
            return AclPropagation.REPOSITORYDETERMINED;
        }

        return repository.getAclCapabilities().getAclPropagation();
    }

#No. 1202
#File: E:\bishe\1\AbstractCmisTestCase.java
#Comment:
    /**
     * Prints a warning.
     */

#Code:
    protected void warning(String message) {
        Log.i(TAG, "**** " + message);
    }

#No. 1203
#File: E:\bishe\1\AbstractCmisTestCase.java
#Comment:
    /**
     * Creates a ContentStreamData object from a byte array.
     */

#Code:
    protected ContentStream createContentStreamData(String mimeType, byte[] content) {
        assertNotNull(content);

        return getObjectFactory().createContentStream("test", BigInteger.valueOf(content.length), mimeType,
                new ByteArrayInputStream(content));
    }

#No. 1204
#File: E:\bishe\1\AbstractCmisTestCase.java
#Comment:
    /**
     * Extracts the path from a folder object.
     */

#Code:
    protected String getPath(ObjectData folderObject) {
        assertNotNull(folderObject);
        assertNotNull(folderObject.getProperties());
        assertNotNull(folderObject.getProperties().getProperties());
        assertTrue(folderObject.getProperties().getProperties().get(PropertyIds.PATH) instanceof PropertyString);

        PropertyString pathProperty = (PropertyString) folderObject.getProperties().getProperties().get(
                PropertyIds.PATH);

        assertNotNull(pathProperty.getValues());
        assertEquals(1, pathProperty.getValues().size());
        assertNotNull(pathProperty.getValues().get(0));

        return pathProperty.getValues().get(0);
    }

#No. 1205
#File: E:\bishe\1\AbstractCmisTestCase.java
#Comment:
    /**
     * Retrieves an object.
     */

#Code:
    protected ObjectData getObject(String objectId, String filter, Boolean includeAllowableActions,
            IncludeRelationships includeRelationships, String renditionFilter, Boolean includePolicyIds,
            Boolean includeACL, ExtensionsData extension) {
        ObjectData object = getBinding().getObjectService()
                .getObject(getTestRepositoryId(), objectId, filter, includeAllowableActions, includeRelationships,
                        renditionFilter, includePolicyIds, includeACL, extension);

        assertNotNull(object);

        return object;
    }

#No. 1206
#File: E:\bishe\1\AbstractCmisTestCase.java
#Comment:
    /**
     * Retrieves a full blown object.
     */

#Code:
    protected ObjectData getObject(String objectId) {
        ObjectData object = getObject(objectId, "*", Boolean.TRUE, IncludeRelationships.BOTH, null, Boolean.TRUE,
                Boolean.TRUE, null);

        assertBasicProperties(object.getProperties());

        return object;
    }

#No. 1207
#File: E:\bishe\1\AbstractCmisTestCase.java
#Comment:
    /**
     * Retrieves an object by path.
     */

#Code:
    protected ObjectData getObjectByPath(String path, String filter, Boolean includeAllowableActions,
            IncludeRelationships includeRelationships, String renditionFilter, Boolean includePolicyIds,
            Boolean includeACL, ExtensionsData extension) {
        ObjectData object = getBinding().getObjectService()
                .getObjectByPath(getTestRepositoryId(), path, filter, includeAllowableActions, includeRelationships,
                        renditionFilter, includePolicyIds, includeACL, extension);

        assertNotNull(object);

        return object;
    }

#No. 1208
#File: E:\bishe\1\AbstractCmisTestCase.java
#Comment:
    /**
     * Retrieves a full blown object by path.
     */

#Code:
    protected ObjectData getObjectByPath(String path) {
        ObjectData object = getObjectByPath(path, "*", Boolean.TRUE, IncludeRelationships.BOTH, null, Boolean.TRUE,
                Boolean.TRUE, null);

        assertBasicProperties(object.getProperties());

        return object;
    }

#No. 1209
#File: E:\bishe\1\AbstractCmisTestCase.java
#Comment:
    /**
     * Returns <code>true</code> if the object with the given id exists,
     * <code>false</code> otherwise.
     */

#Code:
    protected boolean existsObject(String objectId) {
        try {
            ObjectData object = getObject(objectId, PropertyIds.OBJECT_ID, Boolean.FALSE, IncludeRelationships.NONE,
                    null, Boolean.FALSE, Boolean.FALSE, null);

            assertNotNull(object);
            assertNotNull(object.getId());
        } catch (CmisObjectNotFoundException e) {
            return false;
        }

        return true;
    }

#No. 1210
#File: E:\bishe\1\AbstractCmisTestCase.java
#Comment:
    /**
     * Returns the child of a folder.
     */

#Code:
    protected ObjectInFolderData getChild(String folderId, String objectId) {
        boolean hasMore = true;

        while (hasMore) {
            ObjectInFolderList children = getBinding().getNavigationService().getChildren(getTestRepositoryId(),
                    folderId, "*", null, Boolean.TRUE, IncludeRelationships.BOTH, null, Boolean.TRUE, null, null, null);

            assertNotNull(children);
            assertTrue(children.getObjects().size() > 0);

            hasMore = (children.hasMoreItems() == null ? false : children.hasMoreItems().booleanValue());

            for (ObjectInFolderData object : children.getObjects()) {
                assertNotNull(object);
                assertNotNull(object.getPathSegment());
                assertNotNull(object.getObject());
                assertNotNull(object.getObject().getId());

                assertBasicProperties(object.getObject().getProperties());

                if (object.getObject().getId().equals(objectId)) {
                    return object;
                }
            }
        }

        fail("Child not found!");

        return null;
    }

#No. 1211
#File: E:\bishe\1\AbstractCmisTestCase.java
#Comment:
    /**
     * Gets the version series id of an object.
     */

#Code:
    protected String getVersionSeriesId(ObjectData object) {
        PropertyData<?> versionSeriesId = object.getProperties().getProperties().get(PropertyIds.VERSION_SERIES_ID);
        assertNotNull(versionSeriesId);
        assertTrue(versionSeriesId instanceof PropertyId);

        return ((PropertyId) versionSeriesId).getFirstValue();
    }

#No. 1212
#File: E:\bishe\1\AbstractCmisTestCase.java
#Comment:
    /**
     * Gets the version series id of an object.
     */

#Code:
    protected String getVersionSeriesId(String docId) {
        return getVersionSeriesId(getObject(docId));
    }

#No. 1213
#File: E:\bishe\1\AbstractCmisTestCase.java
#Comment:
    /**
     * Creates a folder.
     */

#Code:
    protected String createFolder(Properties properties, String folderId, List<String> policies, Acl addACEs,
            Acl removeACEs) {
        String objectId = getBinding().getObjectService().createFolder(getTestRepositoryId(), properties, folderId,
                policies, addACEs, removeACEs, null);
        assertNotNull(objectId);
        assertTrue(existsObject(objectId));

        ObjectInFolderData folderChild = getChild(folderId, objectId);

        // check canGetProperties
        assertAllowableAction(folderChild.getObject().getAllowableActions(), Action.CAN_GET_PROPERTIES, true);

        // check name
        PropertyData<?> nameProp = properties.getProperties().get(PropertyIds.NAME);
        if (nameProp != null) {
            assertPropertyValue(folderChild.getObject().getProperties(), PropertyIds.NAME, PropertyString.class,
                    nameProp.getFirstValue());
        }

        // check object type
        PropertyData<?> typeProp = properties.getProperties().get(PropertyIds.OBJECT_TYPE_ID);
        assertNotNull(typeProp);
        assertPropertyValue(folderChild.getObject().getProperties(), PropertyIds.OBJECT_TYPE_ID, PropertyId.class,
                typeProp.getFirstValue());

        // check parent
        ObjectData parent = getBinding().getNavigationService().getFolderParent(getTestRepositoryId(), objectId, null,
                null);
        assertNotNull(parent);
        assertNotNull(parent.getProperties());
        assertNotNull(parent.getProperties().getProperties());
        assertNotNull(parent.getProperties().getProperties().get(PropertyIds.OBJECT_ID));
        assertEquals(folderId, parent.getProperties().getProperties().get(PropertyIds.OBJECT_ID).getFirstValue());

        return objectId;
    }

#No. 1214
#File: E:\bishe\1\AbstractCmisTestCase.java
#Comment:
    /**
     * Creates a folder with the default type.
     */

#Code:
    protected String createDefaultFolder(String folderId, String name) {
        List<PropertyData<?>> propList = new ArrayList<PropertyData<?>>();
        propList.add(getObjectFactory().createPropertyStringData(PropertyIds.NAME, name));
        propList.add(getObjectFactory().createPropertyIdData(PropertyIds.OBJECT_TYPE_ID, getDefaultFolderType()));

        Properties properties = getObjectFactory().createPropertiesData(propList);

        return createFolder(properties, folderId, null, null, null);
    }

#No. 1215
#File: E:\bishe\1\AbstractCmisTestCase.java
#Comment:
    /**
     * Creates a document with the default type.
     */

#Code:
    protected String createDefaultDocument(String folderId, String name, String contentType, byte[] content) {
        VersioningState vs = (isVersionable(getDefaultDocumentType()) ? VersioningState.MAJOR : VersioningState.NONE);

        List<PropertyData<?>> propList = new ArrayList<PropertyData<?>>();
        propList.add(getObjectFactory().createPropertyStringData(PropertyIds.NAME, name));
        propList.add(getObjectFactory().createPropertyIdData(PropertyIds.OBJECT_TYPE_ID, getDefaultDocumentType()));

        Properties properties = getObjectFactory().createPropertiesData(propList);

        ContentStream contentStream = createContentStreamData(contentType, content);

        return createDocument(properties, folderId, contentStream, vs, null, null, null);
    }

#No. 1216
#File: E:\bishe\1\AbstractCmisTestCase.java
#Comment:
    /**
     * Creates a document from source.
     */

#Code:
    protected String createDocumentFromSource(String sourceId, Properties properties, String folderId,
            VersioningState versioningState, List<String> policies, Acl addACEs, Acl removeACEs) {
        String objectId = getBinding().getObjectService().createDocumentFromSource(getTestRepositoryId(), sourceId,
                properties, folderId, versioningState, policies, addACEs, removeACEs, null);
        assertNotNull(objectId);
        assertTrue(existsObject(objectId));

        if (folderId != null) {
            ObjectInFolderData folderChild = getChild(folderId, objectId);

            // check name
            PropertyData<?> nameProp = properties.getProperties().get(PropertyIds.NAME);
            if (nameProp != null) {
                assertPropertyValue(folderChild.getObject().getProperties(), PropertyIds.NAME, PropertyString.class,
                        nameProp.getValues().get(0));
            }

            // check parent
            List<ObjectParentData> parents = getBinding().getNavigationService().getObjectParents(
                    getTestRepositoryId(), objectId, null, Boolean.TRUE, IncludeRelationships.BOTH, null, Boolean.TRUE,
                    null);
            assertNotNull(parents);
            assertEquals(1, parents.size());

            ObjectParentData parent = parents.get(0);
            assertNotNull(parent);
            assertNotNull(parent.getRelativePathSegment());
            assertNotNull(parent.getObject());
            assertNotNull(parent.getObject().getProperties().getProperties());
            assertNotNull(parent.getObject().getProperties().getProperties().get(PropertyIds.OBJECT_ID));
            assertEquals(folderId, parent.getObject().getProperties().getProperties().get(PropertyIds.OBJECT_ID)
                    .getFirstValue());
        }

        return objectId;
    }

#No. 1217
#File: E:\bishe\1\AbstractCmisTestCase.java
#Comment:
    /**
     * Deletes an object.
     */

#Code:
    protected void delete(String objectId, boolean allVersions) {
        getBinding().getObjectService().deleteObject(getTestRepositoryId(), objectId, allVersions, null);
        assertFalse(existsObject(objectId));
    }

#No. 1218
#File: E:\bishe\1\AbstractCmisTestCase.java
#Comment:
    /**
     * Deletes a tree.
     */

#Code:
    protected void deleteTree(String folderId) {
        getBinding().getObjectService().deleteTree(getTestRepositoryId(), folderId, Boolean.TRUE, UnfileObject.DELETE,
                Boolean.TRUE, null);
        assertFalse(existsObject(folderId));
    }

#No. 1219
#File: E:\bishe\1\AbstractCmisTestCase.java
#Comment:
    /**
     * Gets a content stream.
     */

#Code:
    protected ContentStream getContent(String objectId, String streamId) {
        ContentStream contentStream = getBinding().getObjectService().getContentStream(getTestRepositoryId(), objectId,
                streamId, null, null, null);
        assertNotNull(contentStream);
        assertNotNull(contentStream.getMimeType());
        assertNotNull(contentStream.getStream());

        return contentStream;
    }

#No. 1220
#File: E:\bishe\1\AbstractCmisTestCase.java
#Comment:
    /**
     * Reads the content from a content stream into a byte array.
     */

#Code:
    protected byte[] readContent(ContentStream contentStream) throws Exception {
        assertNotNull(contentStream);
        assertNotNull(contentStream.getStream());

        InputStream stream = contentStream.getStream();
        ByteArrayOutputStream baos = new ByteArrayOutputStream();

        byte[] buffer = new byte[4096];
        int b;
        while ((b = stream.read(buffer)) > -1) {
            baos.write(buffer, 0, b);
        }

        return baos.toByteArray();
    }

#No. 1221
#File: E:\bishe\1\AbstractCmisTestCase.java
#Comment:
    /**
     * Returns a type definition.
     */

#Code:
    protected TypeDefinition getTypeDefinition(String typeName) {
        TypeDefinition typeDef = getBinding().getRepositoryService().getTypeDefinition(getTestRepositoryId(), typeName,
                null);

        assertNotNull(typeDef);
        assertNotNull(typeDef.getId());

        return typeDef;
    }

#No. 1222
#File: E:\bishe\1\AbstractCmisTestCase.java
#Comment:
    /**
     * Returns if the type is versionable.
     */

#Code:
    protected boolean isVersionable(String typeName) {
        TypeDefinition type = getTypeDefinition(typeName);

        assertTrue(type instanceof DocumentTypeDefinition);

        Boolean isVersionable = ((DocumentTypeDefinition) type).isVersionable();
        assertNotNull(isVersionable);

        return isVersionable;
    }

#No. 1223
#File: E:\bishe\1\AbstractCodecPlayInOutCustomPayload.java
#Comment:
    /**
     * Decodes the byte buffer into a set of channels.
     *
     * @param buffer the byte buffer
     * @return the channels
     */

#Code:
    private static Set<String> decodeChannels(ByteBuffer buffer) {
        final byte[] bytes = new byte[buffer.available()];
        buffer.readBytes(bytes);
        return Sets.newHashSet(Splitter.on('\u0000').split(new String(bytes, StandardCharsets.UTF_8)));
    }

#No. 1224
#File: E:\bishe\1\AbstractCodecPlayInOutCustomPayload.java
#Comment:
    /**
     * Encodes the set of channels into a byte buffer.
     *
     * @param channels the channels
     * @return the byte buffer
     */

#Code:
    private static ByteBuffer encodeChannels(Set<String> channels) {
        return ByteBufferAllocator.unpooled().wrappedBuffer(Joiner.on('\u0000').join(channels).getBytes(StandardCharsets.UTF_8));
    }

#No. 1225
#File: E:\bishe\1\AbstractCodeRunner.java
#Comment:
/**
 * Abstract superclass of {@link CodeRunner} implementations.
 * 
 * @author Curtis Rueden
 */

#Code:
public abstract class AbstractCodeRunner extends
	AbstractHandlerPlugin<Object> implements CodeRunner
{

	// -- Internal methods --

	protected <T> T waitFor(final Future<T> future)
		throws InvocationTargetException
	{
		try {
			return future.get();
		}
		catch (final InterruptedException exc) {
			throw new InvocationTargetException(exc);
		}
		catch (final ExecutionException exc) {
			throw new InvocationTargetException(exc);
		}
	}

}

#No. 1226
#File: E:\bishe\1\AbstractCollectHistory.java
#Comment:
    /**
     * Get the compression used for append files.
     *
     * @return The compression used for append files.
     */

#Code:
    public Compression getAppendCompression() {
        return historical_.getAppendCompression();
    }

#No. 1227
#File: E:\bishe\1\AbstractCollectHistory.java
#Comment:
    /**
     * Set the compression used for append files.
     *
     * @param compression The compression used for append files.
     */

#Code:
    public void setAppendCompression(@NonNull Compression compression) {
        historical_.setAppendCompression(compression);
    }

    /**
     * Get the compression used for optimized files.
     *
     * @return The compression used for optimized files.
     */
    public Compression getOptimizedCompression() {
        return historical_.getOptimizedCompression();
    }

#No. 1228
#File: E:\bishe\1\AbstractCollectHistory.java
#Comment:
    /**
     * Set the compression used for optimized files.
     *
     * @param compression The compression used for optimized files.
     */

#Code:
    public void setOptimizedCompression(@NonNull Compression compression) {
        historical_.setOptimizedCompression(compression);
    }
}
}

#No. 1229
#File: E:\bishe\1\AbstractCollection.java
#Comment:
    /**
     * {@inheritDoc}
     *
     * <p>This implementation returns an array containing all the elements
     * returned by this collection's iterator in the same order, stored in
     * consecutive elements of the array, starting with index {@code 0}.
     * If the number of elements returned by the iterator is too large to
     * fit into the specified array, then the elements are returned in a
     * newly allocated array with length equal to the number of elements
     * returned by the iterator, even if the size of this collection
     * changes during iteration, as might happen if the collection permits
     * concurrent modification during iteration.  The {@code size} method is
     * called only as an optimization hint; the correct result is returned
     * even if the iterator returns a different number of elements.
     *
     * <p>This method is equivalent to:
     *
     *  <pre> {@code
     * List<E> list = new ArrayList<E>(size());
     * for (E e : this)
     *     list.add(e);
     * return list.toArray(a);
     * }</pre>
     *
     * @throws ArrayStoreException  {@inheritDoc}
     * @throws NullPointerException {@inheritDoc}
     */

#Code:
    public <T> T[] toArray(T[] a) {
        // Estimate size of array; be prepared to see more or fewer elements
        int size = size();
        T[] r = a.length >= size ? a :
                  (T[])java.lang.reflect.Array
                  .newInstance(a.getClass().getComponentType(), size);
        Iterator<E> it = iterator();

        for (int i = 0; i < r.length; i++) {
            if (! it.hasNext()) { // fewer elements than expected
                if (a == r) {
                    r[i] = null; // null-terminate
                } else if (a.length < i) {
                    return Arrays.copyOf(r, i);
                } else {
                    System.arraycopy(r, 0, a, 0, i);
                    if (a.length > i) {
                        a[i] = null;
                    }
                }
                return a;
            }
            r[i] = (T)it.next();
        }
        // more elements than expected
        return it.hasNext() ? finishToArray(r, it) : r;
    }

#No. 1230
#File: E:\bishe\1\AbstractCollection.java
#Comment:
    /**
     * The maximum size of array to allocate.
     * Some VMs reserve some header words in an array.
     * Attempts to allocate larger arrays may result in
     * OutOfMemoryError: Requested array size exceeds VM limit
     */

#Code:
    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;

    /**
     * Reallocates the array being used within toArray when the iterator
     * returned more elements than expected, and finishes filling it from
     * the iterator.
     *
     * @param r the array, replete with previously stored elements
     * @param it the in-progress iterator over this collection
     * @return array containing the elements in the given array, plus any
     *         further elements returned by the iterator, trimmed to size
     */
    private static <T> T[] finishToArray(T[] r, Iterator<?> it) {
        int i = r.length;
        while (it.hasNext()) {
            int cap = r.length;
            if (i == cap) {
                int newCap = cap + (cap >> 1) + 1;
                // overflow-conscious code
                if (newCap - MAX_ARRAY_SIZE > 0)
                    newCap = hugeCapacity(cap + 1);
                r = Arrays.copyOf(r, newCap);
            }
            r[i++] = (T)it.next();
        }
        // trim if overallocated
        return (i == r.length) ? r : Arrays.copyOf(r, i);
    }

#No. 1231
#File: E:\bishe\1\AbstractCollection.java
#Comment:
    /**
     * {@inheritDoc}
     *
     * <p>This implementation always throws an
     * <tt>UnsupportedOperationException</tt>.
     *
     * @throws UnsupportedOperationException {@inheritDoc}
     * @throws ClassCastException            {@inheritDoc}
     * @throws NullPointerException          {@inheritDoc}
     * @throws IllegalArgumentException      {@inheritDoc}
     * @throws IllegalStateException         {@inheritDoc}
     */

#Code:
    public boolean add(E e) {
        throw new UnsupportedOperationException();
    }

#No. 1232
#File: E:\bishe\1\AbstractCollection.java
#Comment:
    /**
     * {@inheritDoc}
     *
     * <p>This implementation iterates over the collection looking for the
     * specified element.  If it finds the element, it removes the element
     * from the collection using the iterator's remove method.
     *
     * <p>Note that this implementation throws an
     * <tt>UnsupportedOperationException</tt> if the iterator returned by this
     * collection's iterator method does not implement the <tt>remove</tt>
     * method and this collection contains the specified object.
     *
     * @throws UnsupportedOperationException {@inheritDoc}
     * @throws ClassCastException            {@inheritDoc}
     * @throws NullPointerException          {@inheritDoc}
     */

#Code:
    public boolean remove(Object o) {
        Iterator<E> it = iterator();
        if (o==null) {
            while (it.hasNext()) {
                if (it.next()==null) {
                    it.remove();
                    return true;
                }
            }
        } else {
            while (it.hasNext()) {
                if (o.equals(it.next())) {
                    it.remove();
                    return true;
                }
            }
        }
        return false;
    }

#No. 1233
#File: E:\bishe\1\AbstractCollection.java
#Comment:
    /**
     * {@inheritDoc}
     *
     * <p>This implementation iterates over the specified collection,
     * checking each element returned by the iterator in turn to see
     * if it's contained in this collection.  If all elements are so
     * contained <tt>true</tt> is returned, otherwise <tt>false</tt>.
     *
     * @throws ClassCastException            {@inheritDoc}
     * @throws NullPointerException          {@inheritDoc}
     * @see #contains(Object)
     */

#Code:
    public boolean containsAll(Collection<?> c) {
        for (Object e : c)
            if (!contains(e))
                return false;
        return true;
    }

#No. 1234
#File: E:\bishe\1\AbstractCollection.java
#Comment:
    /**
     * {@inheritDoc}
     *
     * <p>This implementation iterates over the specified collection, and adds
     * each object returned by the iterator to this collection, in turn.
     *
     * <p>Note that this implementation will throw an
     * <tt>UnsupportedOperationException</tt> unless <tt>add</tt> is
     * overridden (assuming the specified collection is non-empty).
     *
     * @throws UnsupportedOperationException {@inheritDoc}
     * @throws ClassCastException            {@inheritDoc}
     * @throws NullPointerException          {@inheritDoc}
     * @throws IllegalArgumentException      {@inheritDoc}
     * @throws IllegalStateException         {@inheritDoc}
     *
     * @see #add(Object)
     */

#Code:
    public boolean addAll(Collection<? extends E> c) {
        boolean modified = false;
        for (E e : c)
            if (add(e))
                modified = true;
        return modified;
    }

#No. 1235
#File: E:\bishe\1\AbstractCollection.java
#Comment:
    /**
     * {@inheritDoc}
     *
     * <p>This implementation iterates over this collection, checking each
     * element returned by the iterator in turn to see if it's contained
     * in the specified collection.  If it's so contained, it's removed from
     * this collection with the iterator's <tt>remove</tt> method.
     *
     * <p>Note that this implementation will throw an
     * <tt>UnsupportedOperationException</tt> if the iterator returned by the
     * <tt>iterator</tt> method does not implement the <tt>remove</tt> method
     * and this collection contains one or more elements in common with the
     * specified collection.
     *
     * @throws UnsupportedOperationException {@inheritDoc}
     * @throws ClassCastException            {@inheritDoc}
     * @throws NullPointerException          {@inheritDoc}
     *
     * @see #remove(Object)
     * @see #contains(Object)
     */

#Code:
    public boolean removeAll(Collection<?> c) {
        boolean modified = false;
        Iterator<?> it = iterator();
        while (it.hasNext()) {
            if (c.contains(it.next())) {
                it.remove();
                modified = true;
            }
        }
        return modified;
    }

#No. 1236
#File: E:\bishe\1\AbstractCollection.java
#Comment:
    /**
     * {@inheritDoc}
     *
     * <p>This implementation iterates over this collection, checking each
     * element returned by the iterator in turn to see if it's contained
     * in the specified collection.  If it's not so contained, it's removed
     * from this collection with the iterator's <tt>remove</tt> method.
     *
     * <p>Note that this implementation will throw an
     * <tt>UnsupportedOperationException</tt> if the iterator returned by the
     * <tt>iterator</tt> method does not implement the <tt>remove</tt> method
     * and this collection contains one or more elements not present in the
     * specified collection.
     *
     * @throws UnsupportedOperationException {@inheritDoc}
     * @throws ClassCastException            {@inheritDoc}
     * @throws NullPointerException          {@inheritDoc}
     *
     * @see #remove(Object)
     * @see #contains(Object)
     */

#Code:
    public boolean retainAll(Collection<?> c) {
        boolean modified = false;
        Iterator<E> it = iterator();
        while (it.hasNext()) {
            if (!c.contains(it.next())) {
                it.remove();
                modified = true;
            }
        }
        return modified;
    }

#No. 1237
#File: E:\bishe\1\AbstractCollection.java
#Comment:
    /**
     * {@inheritDoc}
     *
     * <p>This implementation iterates over this collection, removing each
     * element using the <tt>Iterator.remove</tt> operation.  Most
     * implementations will probably choose to override this method for
     * efficiency.
     *
     * <p>Note that this implementation will throw an
     * <tt>UnsupportedOperationException</tt> if the iterator returned by this
     * collection's <tt>iterator</tt> method does not implement the
     * <tt>remove</tt> method and this collection is non-empty.
     *
     * @throws UnsupportedOperationException {@inheritDoc}
     */

#Code:
    public void clear() {
        Iterator<E> it = iterator();
        while (it.hasNext()) {
            it.next();
            it.remove();
        }
    }

#No. 1238
#File: E:\bishe\1\AbstractCollection.java
#Comment:
    /**
     * Returns a string representation of this collection.  The string
     * representation consists of a list of the collection's elements in the
     * order they are returned by its iterator, enclosed in square brackets
     * (<tt>"[]"</tt>).  Adjacent elements are separated by the characters
     * <tt>", "</tt> (comma and space).  Elements are converted to strings as
     * by {@link String#valueOf(Object)}.
     *
     * @return a string representation of this collection
     */

#Code:
    public String toString() {
        Iterator<E> it = iterator();
        if (! it.hasNext())
            return "[]";

        StringBuilder sb = new StringBuilder();
        sb.append('[');
        for (;;) {
            E e = it.next();
            sb.append(e == this ? "(this Collection)" : e);
            if (! it.hasNext())
                return sb.append(']').toString();
            sb.append(',').append(' ');
        }
    }

#No. 1239
#File: E:\bishe\1\AbstractCollectionResultSet.java
#Comment:
	/**
	 * Always called after a positioning change.
	 */

#Code:
	protected void fixupPosition() throws SQLException {
		if (position < -1) {
			position = -1;
		}
		if (position > data.size()) {
			position = data.size();
		}
	}

#No. 1240
#File: E:\bishe\1\AbstractCollectionTest.java
#Comment:
    /**
     * This method compares two collections for equality. Override for ASet, where map() and flatMap() return generic ACollections rather than ASet instances
     */

#Code:
    protected <T> void assertEqualColl (ACollection<T> expected, ACollection<T> coll) {
        assertEquals (expected, coll);
    }

#No. 1241
#File: E:\bishe\1\AbstractCommandExecutor.java
#Comment:
	/**
	 * Gets the subcommand based on args
	 *
	 * @param args arguments
	 * @return subcommand
	 */

#Code:
	protected CommandWrapper getSubCommand(String[] args) {
		int subCommandArg = 0;

		if(args.length >= 2
				&& getCommandsMap().get(args[1]) != null
				&& getCommandsMap().get(args[1]).isReversed()) {
			subCommandArg = 1;
		}

		return getCommandsMap().get(args[subCommandArg]);
	}

#No. 1242
#File: E:\bishe\1\AbstractCommandExecutor.java
#Comment:
	/**
	 * Dumps arguments to the console
	 * For debug purposes
	 *
	 * @param args arguments
	 */

#Code:
	protected final void dumpArgs(String[] args) {
		int index = 0;
		LoggerUtils.debug("Command arguments dump. (" + args.length + " items)");
		for(String arg : args) {
			LoggerUtils.debug(index + ": " + arg);
			index++;
		}
	}

#No. 1243
#File: E:\bishe\1\AbstractCommandLineParser.java
#Comment:
	/**
	 * Parses the command line and sets appropriate configuration options.
	 * @param args array with command line arguments
	 * @throws CommandLineException if help was requested or the command line
	 *     could not be parsed
	 */

#Code:
	public void parseCommandLine(final String[] args)
			throws CommandLineException {
		final Iterator<String> i = ArraysEx.iterator("", args);
		String arg;
		boolean fSpec = false;
		while (i.hasNext()) {
			arg = i.next();
			
			// Check for option termination symbol
			if (arg.equals("--")) {
				// All following options are files
				fSpec = true;
				continue;
			}
			
			if (!fSpec)
				if (arg.startsWith("--"))
					handleLongOption(arg, i);
				else if (arg.startsWith("-"))
					handleShortOption(arg, i);
				else
					// At this point anything must be a file/directory spec
					// since the handle method advance i for every
					// additional argument
					fSpec = true;
			
			if (fSpec)
				handleFileListSpec(arg);
		}
	}

#No. 1244
#File: E:\bishe\1\AbstractCommandLineParser.java
#Comment:
	/**
	 * Handles a single long command line option. A long command line option
	 * begins with `--'.
	 * @param arg the command line argument
	 * @param i the iterator for the current command line
	 * @throws CommandLineException if an unrecognized option was encountered
	 */

#Code:
	public void handleLongOption(String arg, Iterator<String> i)
			throws CommandLineException {
		// TODO: Implement do-nothing behavior in an adapter class
		/* Do nothing */
	}

#No. 1245
#File: E:\bishe\1\AbstractCommandLineParser.java
#Comment:
	/**
	 * Handles single short command line options. A short command line option
	 * begins with `-'.
	 * @param arg the command line argument
	 * @param i the iterator for the current command line
	 * @throws CommandLineException if an invalid option was encountered
	 */

#Code:
	public void handleShortOption(String arg, Iterator<String> i)
			throws CommandLineException {
		// TODO: Implement do-nothing behavior in an adapter class
		/* Do nothing */
	}

#No. 1246
#File: E:\bishe\1\AbstractCommandLineParser.java
#Comment:
	/**
	 * Handles a single file command line argument.
	 * @param arg the command line argument
	 * @throws CommandLineException if there was an I/O error
	 */

#Code:
	public void handleFileListSpec(String arg) throws CommandLineException {
		// TODO: Implement do-nothing behavior in an adapter class
		/* Do nothing */
	}

#No. 1247
#File: E:\bishe\1\AbstractCommandLineParser.java
#Comment:
	/**
	 * Throws a {@code CommandLineException} with an optional detail message.
	 * @param message an optional detail message
	 * @throws CommandLineException always thrown
	 */

#Code:
	public void printCommandLineHelp(String message)
			throws CommandLineException {
		// TODO: Implement do-nothing behavior in an adapter class
		/* Do nothing by default */
	}

#No. 1248
#File: E:\bishe\1\AbstractCommandLineParser.java
#Comment:
	/**
	 * Throws a {@code CommandLineException} with the specified detail message.
	 * @param message the message
	 * @throws CommandLineException always thrown
	 */

#Code:
	public void printCommandLineError(String message)
			throws CommandLineException {
		throw new CommandLineException(message, null);
	}

#No. 1249
#File: E:\bishe\1\AbstractCommandService.java
#Comment:
    /**
     * 向指定group添加指令
     *
     * @param group
     * @param command
     * @return
     */

#Code:
    @Override
    public boolean addCommand(String group, RpcCommand.ClientCommand command) {
        LoggerUtil.info(String.format("add command: group=%s, command=%s: ", group, JSON.toJSONString(command)));
        RpcCommand remoteCommand = RpcCommandUtil.stringToCommand(getCommands(group));
        if (remoteCommand == null) {
            remoteCommand = new RpcCommand();
        }
        List<RpcCommand.ClientCommand> clientCommandList = remoteCommand.getClientCommandList();
        if (clientCommandList == null) {
            clientCommandList = new ArrayList<RpcCommand.ClientCommand>();
        }

        // 该方法只在流量切换界面被调用，此时指令序号默认是0
        int index = getRpcCommandMaxIndex(remoteCommand);
        command.setIndex(index + 1);
        clientCommandList.add(command);
        remoteCommand.setClientCommandList(clientCommandList);

        return setCommand(group, remoteCommand);
    }

#No. 1250
#File: E:\bishe\1\AbstractCommandService.java
#Comment:
    /**
     * 更新指定group的某条指令
     *
     * @param command
     * @param group
     * @return
     */

#Code:
    @Override
    public boolean updateCommand(String group, RpcCommand.ClientCommand command) {
        LoggerUtil.info(String.format("update command: group=%s, command=%s: ", group, JSON.toJSONString(command)));
        RpcCommand remoteCommand = RpcCommandUtil.stringToCommand(getCommands(group));
        if (remoteCommand == null) {
            LoggerUtil.info("update failed, command not found");
            return false;
        }
        List<RpcCommand.ClientCommand> clientCommandList = remoteCommand.getClientCommandList();
        if (clientCommandList == null) {
            LoggerUtil.info("update failed, command not found");
            return false;
        }
        boolean found = false;
        for (RpcCommand.ClientCommand cmd : clientCommandList) {
            if (cmd.getIndex().equals(command.getIndex())) {
                clientCommandList.remove(cmd);
                clientCommandList.add(command);
                found = true;
                break;
            }
        }
        if (!found) {
            LoggerUtil.info("update failed, command not found");
            return false;
        }
        remoteCommand.setClientCommandList(clientCommandList);
        return setCommand(group, remoteCommand);
    }

#No. 1251
#File: E:\bishe\1\AbstractCommandService.java
#Comment:
    /**
     * 删除指定group的某条指令
     *
     * @param group
     * @param index
     * @return
     */

#Code:
    @Override
    public boolean deleteCommand(String group, int index) {
        LoggerUtil.info(String.format("delete command: group=%s, index=%d: ", group, index));
        RpcCommand remoteCommand = RpcCommandUtil.stringToCommand(getCommands(group));
        if (remoteCommand == null) {
            LoggerUtil.info("delete failed, command not found");
            return false;
        }
        List<RpcCommand.ClientCommand> clientCommandList = remoteCommand.getClientCommandList();
        if (clientCommandList == null) {
            LoggerUtil.info("delete failed, command not found");
            return false;
        }
        boolean found = false;
        for (RpcCommand.ClientCommand cmd : clientCommandList) {
            if (cmd.getIndex() == index) {
                clientCommandList.remove(cmd);
                found = true;
                break;
            }
        }
        if (!found) {
            LoggerUtil.info("delete failed, command not found");
            return false;
        }
        remoteCommand.setClientCommandList(clientCommandList);

        return setCommand(group, remoteCommand);
    }

#No. 1252
#File: E:\bishe\1\AbstractCommandService.java
#Comment:
    /**
     * 获取指令集中最大的指令序号
     *
     * @param rpcCommand
     * @return
     */

#Code:
    @Override
    public int getRpcCommandMaxIndex(RpcCommand rpcCommand) {
        return 0;
    }

#No. 1253
#File: E:\bishe\1\AbstractCommandService.java
#Comment:
    /**
     * 预览指令
     *
     * @param group
     * @param clientCommand
     * @param previewIP
     * @return
     */

#Code:
    @Override
    public List<JSONObject> previewCommand(String group, RpcCommand.ClientCommand clientCommand, String previewIP) {
        return null;
    }

#No. 1254
#File: E:\bishe\1\AbstractCommandService.java
#Comment:
    /**
     * 根据group和clientCommand生成指令
     *
     * @param group
     * @param clientCommand
     * @return
     */

#Code:
    @Override
    public RpcCommand buildCommand(String group, RpcCommand.ClientCommand clientCommand) {
        RpcCommand rpcCommand = new RpcCommand();
        List<RpcCommand.ClientCommand> commandList = new ArrayList<RpcCommand.ClientCommand>();
        commandList.add(clientCommand);
        rpcCommand.setClientCommandList(commandList);
        return rpcCommand;
    }

#No. 1255
#File: E:\bishe\1\AbstractCommandService.java
#Comment:
    /**
     * 获取指令操作记录
     *
     * @return
     */

#Code:
    @Override
    public List<OperationRecord> getAllRecord() {
        List<OperationRecord> records;
        if (recordMapper != null) {
            records = recordMapper.selectAll();
        } else {
            return null;
        }
        return records;
    }

#No. 1256
#File: E:\bishe\1\AbstractCommentPanel.java
#Comment:
	/**
	 * <p>Constructor for AbstractCommentPanel.</p>
	 *
	 * @param operatorGraph a {@link lupos.gui.operatorgraph.OperatorGraph} object.
	 */

#Code:
	public AbstractCommentPanel(final OperatorGraph operatorGraph) {
		super();

		this.operatorGraph = operatorGraph;

		this.setFont(this.operatorGraph.getFONT());

		this.addMouseListener(this);
		this.addMouseMotionListener(this);
	}

#No. 1257
#File: E:\bishe\1\AbstractCommentPanel.java
#Comment:
	/**
	 * <p>updateSize.</p>
	 */

#Code:
	protected void updateSize() {
		if (this.getPreferredSize() != this.getSize())
			this.setSize(this.getPreferredSize());
	}

#No. 1258
#File: E:\bishe\1\AbstractCommentPanel.java
#Comment:
	/**
	 * <p>updateFont.</p>
	 *
	 * @param component a {@link java.awt.Container} object.
	 * @param newFont a {@link java.awt.Font} object.
	 */

#Code:
	protected void updateFont(final Container component, final Font newFont) {
		for (int i = 0; i < component.getComponentCount(); i += 1) {
			final Component child = component.getComponent(i);

			child.setFont(newFont);

			if (child instanceof Container) {
				this.updateFont((Container) child, newFont);
			}
		}
	}

#No. 1259
#File: E:\bishe\1\AbstractCommentPanel.java
#Comment:
	/**
	 * <p>finalizeComponent.</p>
	 */

#Code:
	protected void finalizeComponent() {
		this.determinePosition(); // determine the position

		this.operatorGraph.addComment(this); // add this panel to the operator
		// graph
	}

#No. 1260
#File: E:\bishe\1\AbstractCommentPanel.java
#Comment:
	/**
	 * Method to find the GraphWrapper to a given BasicOperator in the children
	 * of the given root GraphWrapper. If the GraphWrapper to the given
	 * BasicOperator was not found, the method returns null;
	 * 
	 * @param rootGW
	 *            GraphWrapper to start the search in
	 * @param basicOp
	 *            The given BasicOperator, where the GraphWrapper is searched
	 *            for
	 * 
	 * @return the GraphWrapper to the BasicOperator or null if there is none
	 */

#Code:
	private GraphWrapper findChildGW(final GraphWrapper graphWrapper,
			final BasicOperator basicOp, final HashSet<GraphWrapper> visited) {
		if (visited.contains(graphWrapper)) {
			return null;
		}

		visited.add(graphWrapper);

		// check the root GraphWrapper...
		if (basicOp.equals(graphWrapper.getElement())) {
			return graphWrapper;
		}

		// walk through succeeding elements of this root GraphWrapper...
		for (final GraphWrapperIDTuple gwIDT : graphWrapper
				.getSucceedingElements()) {
			final GraphWrapper gw = gwIDT.getOperator(); // get the GraphWrapper

			final GraphWrapper found = this.findChildGW(gw, basicOp, visited);

			if (found != null) {
				return found;
			}
		}

		return null;
	}

#No. 1261
#File: E:\bishe\1\AbstractCommentPanel.java
#Comment:
	/**
	 * This method finds the GraphWrapper for a BasicOperator
	 *
	 * @param basicOperator
	 *            The BasicOperator for which the corresponding GraphWrapper
	 *            object should be found
	 * @return the found GraphWrapper or null in the case that the GraphWrapper
	 *         has not been found
	 */

#Code:
	protected GraphWrapper findGraphWrapper(final BasicOperator basicOperator) {
		// get the root elements of the OperatorGraph...
		final LinkedList<GraphWrapper> rootList = this.operatorGraph
				.getRootList(false);

		// finding the GraphWrapper to the "from"-operator...
		final HashSet<GraphWrapper> visited = new HashSet<GraphWrapper>();
		GraphWrapper graphWrapper = null;

		// walk through root GraphWrappers of the OperatorGraph...
		for (final GraphWrapper rootGW : rootList) {
			graphWrapper = this.findChildGW(rootGW, basicOperator, visited);

			if (graphWrapper != null) {
				return graphWrapper;
			}
		}

		return null;
	}

#No. 1262
#File: E:\bishe\1\AbstractCommentPanel.java
#Comment:
	/**
	 * This function is called, when the operator graph was zoomed.
	 */

#Code:
	public abstract void determinePosition();
}
}

#No. 1263
#File: E:\bishe\1\AbstractCommitWarningGenerator.java
#Comment:
    /**
     * Get CommitApi for commit.
     * @param commit Commit to interact with.
     * @return a CommitApi for the Commit.
     */

#Code:
    protected CommitApi getGitCommit(Commit commit) {
        try {
            return getRepository(commit)
                .getCommit(commit.getCommitId());
        }
        catch (NotFoundException e) {
            log.warn(
                String.format(
                    "Failed to retrieve commit %s in git server, failed with %s",
                    commit,
                    e.getMessage()
                ),
                e
            );
            throw e;
        }
    }

#No. 1264
#File: E:\bishe\1\AbstractCommitWarningGenerator.java
#Comment:
    /**
     * Get the RepositoryApi for the repository of a Commit.
     * @param commit Commit to get the RepositoryApi for.
     * @return The RepositoryApi.
     */

#Code:
    protected RepositoryApi getRepository(Commit commit) {
        try {
            return repositoriesApi
               .getRepository(commit.getRepository().getRepositoryName());
        }
        catch (NotFoundException e) {
            log.warn(
                String.format(
                    "Failed to retrieve repository %s in git server, failed with %s",
                    commit.getRepository(),
                    e.getMessage()
                ),
                e
            );
            throw e;
        }
    }

#No. 1265
#File: E:\bishe\1\AbstractCommonMessageDrivenSessionBeanMetaData.java
#Comment:
    /**
     * The timeout method
     */

#Code:
    private NamedMethodMetaData timeoutMethod;

    /**
     * The transaction type
     */
    private TransactionManagementType transactionType;

    /**
     * The around invokes
     */
    private AroundInvokesMetaData aroundInvokes;

    // EJB 3.1

    /**
     * Represents metadata for {@link javax.ejb.Schedule}
     */
    private List<TimerMetaData> timers;

    private AroundTimeoutsMetaData aroundTimeouts;

    private void assertUnknownOrMessageDrivenOrSessionBean() {
        final EjbType ejbType = getEjbType();
        if (ejbType != null) {
            switch (ejbType) {
                case MESSAGE_DRIVEN:
                case SESSION:
                    break;
                default:
                    throw new IllegalStateException("Bean " + this + " is not an unknown, message-driven or session bean, but " + getEjbType());
            }
        }
    }

#No. 1266
#File: E:\bishe\1\AbstractCommonMessageDrivenSessionBeanMetaData.java
#Comment:
    /**
     * Get the aroundInvokes.
     *
     * @return the aroundInvokes.
     */

#Code:
    public AroundInvokesMetaData getAroundInvokes() {
        assertUnknownOrMessageDrivenOrSessionBean();
        return aroundInvokes;
    }

#No. 1267
#File: E:\bishe\1\AbstractCommonMessageDrivenSessionBeanMetaData.java
#Comment:
    /**
     * Set the aroundInvokes.
     *
     * @param aroundInvokes the aroundInvokes.
     * @throws IllegalArgumentException for a null aroundInvokes
     */

#Code:
    public void setAroundInvokes(AroundInvokesMetaData aroundInvokes) {
        assertUnknownOrMessageDrivenOrSessionBean();
        if (aroundInvokes == null)
            throw new IllegalArgumentException("Null aroundInvokes");
        this.aroundInvokes = aroundInvokes;
    }

#No. 1268
#File: E:\bishe\1\AbstractCommonMessageDrivenSessionBeanMetaData.java
#Comment:
    /**
     * Get the timeoutMethod.
     *
     * @return the timeoutMethod.
     */

#Code:
    public NamedMethodMetaData getTimeoutMethod() {
        assertUnknownOrMessageDrivenOrSessionBean();
        return timeoutMethod;
    }

#No. 1269
#File: E:\bishe\1\AbstractCommonMessageDrivenSessionBeanMetaData.java
#Comment:
    /**
     * Set the timeoutMethod.
     *
     * @param timeoutMethod the timeoutMethod.
     * @throws IllegalArgumentException for a null timeoutMethod
     */

#Code:
    public void setTimeoutMethod(NamedMethodMetaData timeoutMethod) {
        assertUnknownOrMessageDrivenOrSessionBean();
        if (timeoutMethod == null)
            throw new IllegalArgumentException("Null timeoutMethod");
        this.timeoutMethod = timeoutMethod;
    }

#No. 1270
#File: E:\bishe\1\AbstractCommonMessageDrivenSessionBeanMetaData.java
#Comment:
    /**
     * Set the transactionType.
     *
     * @param transactionType the transactionType.
     * @throws IllegalArgumentException for a null transactionType
     */

#Code:
    public void setTransactionType(TransactionManagementType transactionType) {
        assertUnknownOrMessageDrivenOrSessionBean();
        if (transactionType == null)
            throw new IllegalArgumentException("Null transactionType");
        this.transactionType = transactionType;
    }

#No. 1271
#File: E:\bishe\1\AbstractCommonMessageDrivenSessionBeanMetaData.java
#Comment:
    /**
     * Returns the {@link TimerMetaData} associated with this bean
     */

#Code:
    public List<TimerMetaData> getTimers() {
        assertUnknownOrMessageDrivenOrSessionBean();
        return this.timers;
    }

#No. 1272
#File: E:\bishe\1\AbstractCommonMessageDrivenSessionBeanMetaData.java
#Comment:
    /**
     * Sets the {@link TimerMetaData} for this bean
     */

#Code:
    public void setTimers(List<TimerMetaData> timers) {
        assertUnknownOrMessageDriven31OrSessionBean31();
        this.timers = timers;
    }

#No. 1273
#File: E:\bishe\1\AbstractCommonPowerMockRunner.java
#Comment:
        /*
           * For extra safety clear the MockitoRepository on each new
           * instantiation of the runner. This is good in cases where a previous
           * test has used e.g. PowerMock#createMock(..) to create a mock without
           * using this runner. That means that there's some state left in the
           * MockRepository that hasn't been cleared. Currently clearing the
           * MockRepository from any classloader will clear the previous state but
           * it's not certain that this is always the case.
           */

#Code:
        MockRepository.clear();
    }

    @Override
    public Description getDescription() {
        return suiteChunker.getDescription();
    }

#No. 1274
#File: E:\bishe\1\AbstractCommonTestSuiteChunkerImpl.java
#Comment:
    /*
    * Maps between a specific class and a map of test methods loaded by a
    * specific mock class loader.
    */

#Code:
    private final List<TestCaseEntry> internalSuites = new LinkedList<TestCaseEntry>();
    private final TestClassesExtractor prepareForTestExtractor = new PrepareForTestExtractorImpl();
    private final TestClassesExtractor suppressionExtractor = new StaticConstructorSuppressExtractorImpl();
    /*
     * Maps the list of test indexes that is assigned to a specific test suite
     * index.
     */
    protected final LinkedHashMap<Integer, List<Integer>> testAtDelegateMapper = new LinkedHashMap<Integer, List<Integer>>();
    protected final Class<?>[] testClasses;
    private final IgnorePackagesExtractor ignorePackagesExtractor = new PowerMockIgnorePackagesExtractorImpl();
    private final ArrayMerger arrayMerger = new ArrayMergerImpl();
    private int currentTestIndex = NOT_INITIALIZED;


    protected AbstractCommonTestSuiteChunkerImpl(Class<?> testClass) throws Exception {
        this(new Class[]{testClass});
    }

#No. 1275
#File: E:\bishe\1\AbstractCommonTestSuiteChunkerImpl.java
#Comment:
            /*
             * If we don't have any test that should be executed by the default
             * class loader remove it to avoid duplicate test print outs.
             */

#Code:
            internalSuites.get(0).getTestChunks().remove(0);
        }
        //else{ /*Delegation-runner maybe doesn't use test-method annotations!*/ }
    }

#No. 1276
#File: E:\bishe\1\AbstractCommonTestSuiteChunkerImpl.java
#Comment:
                /*
                 * Add this test index to the main junit runner
                 * delegator.
                 */

#Code:
                List<Integer> testList = testAtDelegateMapper.get(currentDelegateIndex);
                if (testList == null) {
                    testList = new LinkedList<Integer>();
                    testAtDelegateMapper.put(currentDelegateIndex, testList);
                }

#No. 1277
#File: E:\bishe\1\AbstractCommTest.java
#Comment:
    /**
     * Best effort to terminate a misbehaving thread
     * @deprecated
     */

#Code:
    private void terminateThread( Thread thread )
    {
        int retries = 0;
        while (thread.isAlive() && retries++ < 5)
        {
            try
            {
                thread.join(5*1000);
            }
            catch (InterruptedException e)
            {
                System.out.println("Wait was interrupted.");
            }
            thread.interrupt();
        }
        if (thread.isAlive())
        {
            System.err.println("Cannot properly terminate thread : "+thread);
            StackTraceElement[] stack = thread.getStackTrace();
            if (stack != null)
                for(int n=0;n<stack.length;n++)
                    System.err.println(" "+stack[n]);
            thread.stop();
        }
    }

#No. 1278
#File: E:\bishe\1\AbstractComparatorTest.java
#Comment:
  /**
   * @return first saved result
   */

#Code:
  protected byte[] getActual() {
    return artifactDaoMock.getFirstSavedArtifactData();
  }

#No. 1279
#File: E:\bishe\1\AbstractCompareAction.java
#Comment:
    /**
     * can be overridden as keys can be different (date have different keys/labels)
     *
     * @return {@link SelectParameter}
     */

#Code:
    protected SelectParameter getCompareModeSelectParameter() {

        //@formatter:off
        return SelectParameter.Builder.builder() //
                           .name(CompareAction.COMPARE_MODE) //
                           .item(EQ, EQ) //
                           .item(NE, NE) //
                           .item(GT, GT) //
                           .item(GE, GE) //
                           .item(LT, LT) //
                           .item(LE, LE) //
                           .defaultValue(EQ) //
                           .build();
        //@formatter:on

    }

#No. 1280
#File: E:\bishe\1\AbstractCompareAction.java
#Comment:
    /**
     *
     * @return {@link Parameter} the default value (can be a different type/value)
     */

#Code:
    protected Parameter getDefaultConstantValue() {
        // olamy no idea why this 2 but was here before so just keep backward compat :-)
        return new Parameter(CONSTANT_VALUE, ParameterType.STRING, "2");
    }

#No. 1281
#File: E:\bishe\1\AbstractCompareAction.java
#Comment:
    /**
     * @see ColumnAction#applyOnColumn(DataSetRow, ActionContext)
     */

#Code:
    @Override
    public void applyOnColumn(DataSetRow row, ActionContext context) {
        final String columnId = context.getColumnId();
        final Map<String, String> parameters = context.getParameters();
        final String compareMode = getCompareMode(parameters);

        // create new column and append it after current column
        final String newColumnId = context.column("result");

        ComparisonRequest comparisonRequest = new ComparisonRequest() //
                .setMode(compareMode) //
                .setColumnMetadata1(context.getRowMetadata().getById(columnId)) //
                .setValue1(row.get(columnId)) //
                // this can be null when comparing with a constant
                .setColumnMetadata2(getColumnMetadataToCompareWith(parameters, context)) //
                .setValue2(getValueToCompareWith(parameters, context, row));
        row.set(newColumnId, toStringCompareResult(comparisonRequest));
    }

#No. 1282
#File: E:\bishe\1\AbstractCompareAction.java
#Comment:
    /**
     * can be overridden as keys can be different (date have different keys/labels)
     *
     * @param parameters
     * @return
     */

#Code:
    protected String getCompareMode(Map<String, String> parameters) {
        return parameters.get(CompareAction.COMPARE_MODE);
    }

#No. 1283
#File: E:\bishe\1\AbstractCompareAction.java
#Comment:
    /**
     *
     * @param comparisonRequest
     * @return transforming boolean to <code>true</code> or <code>false</code> as String in case of #doCompare returning
     * #ERROR_COMPARE_RESULT the label #ERROR_COMPARE_RESULT_LABEL is returned
     */

#Code:
    public String toStringCompareResult(ComparisonRequest comparisonRequest) {
        boolean booleanResult;
        try {

            final int result = doCompare(comparisonRequest);

            if (result == ERROR_COMPARE_RESULT) {
                return ERROR_COMPARE_RESULT_LABEL;
            }

            booleanResult = compareResultToBoolean(result, comparisonRequest.mode);

        } catch (NumberFormatException e) {
            LOGGER.debug("Unable to compare values '{}' ", comparisonRequest, e);
            return ERROR_COMPARE_RESULT_LABEL;
        }

        return BooleanUtils.toString(booleanResult, Boolean.TRUE.toString(), Boolean.FALSE.toString());
    }

#No. 1284
#File: E:\bishe\1\AbstractComposedTabMapper.java
#Comment:
/**
 * Abstract composed mapper. Does the mapping by means of component mappers.
 * <p/>
 * Mar 10, 2008
 *
 * @author brandizi
 * @param <TBM>
 */

#Code:
public abstract class AbstractComposedTabMapper<TBM extends AbstractTabMapper> extends AbstractTabMapper
        implements ComposedTabMapper<TBM> {
    protected static final Logger log = Logger.getLogger(AbstractComposedTabMapper.class);

    public AbstractComposedTabMapper(BIIObjectStore store) {
        super(store);
    }

    /**
     * @see org.isatools.tablib.mapping.ComposedTabMapper#getTabMappers()
     */
    public abstract List<TBM> getTabMappers();


    /**
     * Goes through all the composing mappers and invoke their map() method
     */
    public BIIObjectStore map() {
        List<TBM> tabMappers = getTabMappers();
        if (tabMappers == null || tabMappers.size() == 0) {
            log.trace("WARNING, Tab Mapper without any composing mapper");
            return getStore();
        }

        for (AbstractTabMapper mapper : tabMappers) {
            mapper.map();
        }

        return getStore();
    }


}

#No. 1285
#File: E:\bishe\1\AbstractCompositeExpression.java
#Comment:
    /**
     * Can we factor commonComposite out of all subexpressions?
     */

#Code:
    private boolean canFactorOut(Iterable<Expression<T>> subexpressions, Expression<T> commonComposite) {
        for (Expression<T> current : subexpressions) {
            if (!current.equals(commonComposite)) {
                if (!current.isComposite()) {
                    return false;
                }
                AbstractCompositeExpression<T> composite = (AbstractCompositeExpression<T>) current;
                if (!composite.components.contains(commonComposite)) {
                    return false;
                }
            }
        }
        return true;
    }

#No. 1286
#File: E:\bishe\1\AbstractCompoundTag.java
#Comment:
	/**
	 * <p>
	 * Use {@link #put(NBTTag)} instead.
	 * </p>
	 */

#Code:
	@Override
	public final NBTTag put(final String key, final NBTTag value) throws UnsupportedOperationException {
		throw new UnsupportedOperationException();
	}

#No. 1287
#File: E:\bishe\1\AbstractConciergeTestCase.java
#Comment:
	/**
	 * This property allows to wait some time when framework has been shutdown.
	 */

#Code:
	private final static String PROPERTY_WAIT_AFTER_FRAMEWORK_SHUTDOWN = "org.eclipse.concierge.tests.waitAfterFrameworkShutdown";

	protected Framework framework = null;
	protected BundleContext bundleContext = null;
	protected LocalBundleStorage localBundleStorage = LocalBundleStorage
			.getInstance();

	/** Start framework with default settings, which cleans storage first. */
	public void startFramework() throws Exception {
		final Map<String, String> launchArgs = new HashMap<String, String>();
		// start OSGi framework in clean mode as default
		startFrameworkClean(launchArgs);
	}

#No. 1288
#File: E:\bishe\1\AbstractConciergeTestCase.java
#Comment:
	/**
	 * stop the framework, but wait until it will be stopped by someone. Use
	 * this if framework started, but will be closed interactively.
	 */

#Code:
	public void stopFrameworkWaitForStop() throws Exception {
		if (this.framework != null) {
			this.framework.waitForStop(0);
		}
	}

#No. 1289
#File: E:\bishe\1\AbstractConciergeTestCase.java
#Comment:
	/**
	 * Gets a framework property by casting into implementation.
	 */

#Code:
	protected String getFrameworkProperty(String propertyName) {
		try {
			final Concierge c = (Concierge) this.framework;
			final Field f = c.getClass().getDeclaredField("properties");
			f.setAccessible(true);
			Object o = f.get(c);
			Properties p = (Properties) o;
			String s = (String) p.get(propertyName);
			return s;
		} catch (NoSuchFieldException e) {
			e.printStackTrace();
		} catch (SecurityException e) {
			e.printStackTrace();
		} catch (IllegalArgumentException e) {
			e.printStackTrace();
		} catch (IllegalAccessException e) {
			e.printStackTrace();
		}
		return null;
	}

#No. 1290
#File: E:\bishe\1\AbstractConciergeTestCase.java
#Comment:
	/**
	 * Override when a test case should use shell and wait for manual exit of
	 * framework.
	 */

#Code:
	protected boolean stayInShell() {
		return false;
	}

#No. 1291
#File: E:\bishe\1\AbstractConciergeTestCase.java
#Comment:
	/**
	 * Install a bundle for given name.
	 */

#Code:
	protected Bundle installBundle(final String bundleName)
			throws BundleException {
		final String url = this.localBundleStorage.getUrlForBundle(bundleName);
		final Bundle bundle = bundleContext.installBundle(url);
		return bundle;
	}

#No. 1292
#File: E:\bishe\1\AbstractConciergeTestCase.java
#Comment:
	/**
	 * Install a bundle for given name. Will check whether bundle can be
	 * resolved.
	 */

#Code:
	protected Bundle installAndStartBundle(final String bundleName)
			throws BundleException {
		final String url = this.localBundleStorage.getUrlForBundle(bundleName);
		// System.err.println("installAndStartBundle: " + bundleName);

		final Bundle bundle = bundleContext.installBundle(url);

		if (!isFragmentBundle(bundle)) {
			bundle.start();
		}
		return bundle;
	}

#No. 1293
#File: E:\bishe\1\AbstractConciergeTestCase.java
#Comment:
	/**
	 * Enforce to call resolve bundle in Concierge framework for the specified
	 * bundle.
	 */

#Code:
	protected void enforceResolveBundle(final Bundle bundle) {
		// initiate resolver
		framework.adapt(FrameworkWiring.class)
				.resolveBundles(Collections.singleton(bundle));
	}

#No. 1294
#File: E:\bishe\1\AbstractConciergeTestCase.java
#Comment:
	/**
	 * This method will install a "pseudo" bundle into the framework.
	 */

#Code:
	protected Bundle installBundle(SyntheticBundleBuilder builder)
			throws BundleException {
		Bundle b = this.installBundle(builder.getBundleSymbolicName(),
				builder.asInputStream());
		return b;
	}

#No. 1295
#File: E:\bishe\1\AbstractConfig.java
#Comment:
    /**
     * blank if null
     */

#Code:
    protected String bin(String value) {
        return value == null ? "" : value;
    }

#No. 1296
#File: E:\bishe\1\AbstractConfigKey.java
#Comment:
    /**
     * Utility method that checks if the given configuration key is managed by the configuration provided and throw an
     * {@link IllegalStateException} if this is not the case.
     *
     * @param config
     *            the {@link MetaConfiguration} to check
     * @throws IllegalStateException
     *             if the provided configuration does not contain this key
     */

#Code:
    protected final void checkConfigForKey(@Nonnull final MetaConfiguration config) throws IllegalStateException {
        if (!config.getConfigKeys().contains(this)) {
            throw new IllegalStateException(String.format("Configuration does not include key; config='%s', key='%s'",
                    config, this));
        }

#No. 1297
#File: E:\bishe\1\AbstractConfigKey.java
#Comment:
    /**
     * Checks if the given value is {@code null} and/or required.
     *
     * @param value
     *            the value to check
     * @return <ul>
     *         <li>a {@link ValidationError} with {@link ValidationError.ErrorType#NONE} if value is neither
     *         {@code null} nor required</li>
     *         <li>a {@link ValidationError} with {@link ValidationError.ErrorType#VALUE_NULL} if value is {@code null}
     *         but not required</li>
     *         <li>a specific {@link ValidationError} with {@link ValidationError.ErrorType#VALUE_REQUIRED} if value is
     *         both {@code null} and required</li>
     *         </ul>
     */

#Code:
    protected final ValidationError checkForNullAndRequired(final Object value) {
        ValidationError result = ValidationError.NO_ERROR;
        if (value == null) {
            result = new ValidationError(ErrorType.VALUE_NULL, null, this, value, "value is null");
            if (isRequired()) {
                result = new ValidationError(ErrorType.VALUE_REQUIRED, null, this, value, "is required and not set");
            }
        }
        return result;
    }

#No. 1298
#File: E:\bishe\1\AbstractConfigKey.java
#Comment:
    /**
     * Checks if the given {@link Object} is of the exact {@link Class} provided as second argument.
     *
     * As member classes pass this test, enums constants pass.
     *
     * @param value
     *            the Object to check
     * @param clazz
     * @return a {@link ValidationError} with {@link ValidationError.ErrorType#VALUE_INVALID} if the provided value is
     *         not of the exact same type, {@link ValidationError.NO_ERROR} otherwise
     * @throws NullPointerException
     *             if either argument is <code>null</code>
     */

#Code:
    protected final ValidationError checkSameClass(final Object value, final Class<?> clazz)
            throws NullPointerException {
        try {
            clazz.cast(value);
        }
        catch (final ClassCastException ce) {
            return new ValidationError(ErrorType.VALUE_INVALID, null, this, value, ce.getMessage());
        }

        final Class<?> valueClass = value.getClass();

        // checks if clazz is the same or a superclass of value's class
        if (valueClass.isAssignableFrom(clazz)) {
            return ValidationError.NO_ERROR;
        }

        // treats the special case where an enum constant appears as member instance of the enclosing enum class
        if (valueClass.getEnclosingClass() == clazz) {
            return ValidationError.NO_ERROR;
        }

        return new ValidationError(ErrorType.VALUE_INVALID, null, this, value, "is a subclass of "
                + clazz.getCanonicalName());

    }

#No. 1299
#File: E:\bishe\1\AbstractConfigKey.java
#Comment:
    /**
     * Return the {@link String} representation of this object, i.e. it's {@link Class#getCanonicalName() canonical
     * name}.
     *
     * Classes extending {@link AbstractConfigKey} are expected to be singletons, so this method is just for prettily
     * printing the class name.
     */

#Code:
    @Override
    public final String toString() {
        return getClass().getCanonicalName();
    }

#No. 1300
#File: E:\bishe\1\AbstractConfigObject.java
#Comment:
    /**
     * This looks up the key with no transformation or type conversion of any
     * kind, and returns null if the key is not present. The object must be
     * resolved along the nodes needed to get the key or
     * ConfigException.NotResolved will be thrown.
     *
     * @param key
     * @return the unmodified raw value or null
     */

#Code:
    protected final AbstractConfigValue peekAssumingResolved(String key, Path originalPath) {
        try {
            return attemptPeekWithPartialResolve(key);
        } catch (ConfigException.NotResolved e) {
            throw ConfigImpl.improveNotResolved(originalPath, e);
        }
    }

#No. 1301
#File: E:\bishe\1\AbstractConfigObject.java
#Comment:
    /**
     * Look up the key on an only-partially-resolved object, with no
     * transformation or type conversion of any kind; if 'this' is not resolved
     * then try to look up the key anyway if possible.
     *
     * @param key
     *            key to look up
     * @return the value of the key, or null if known not to exist
     * @throws ConfigException.NotResolved
     *             if can't figure out key's value (or existence) without more
     *             resolving
     */

#Code:
    abstract AbstractConfigValue attemptPeekWithPartialResolve(String key);

    /**
     * Looks up the path with no transformation or type conversion. Returns null
     * if the path is not found; throws ConfigException.NotResolved if we need
     * to go through an unresolved node to look up the path.
     */
    protected AbstractConfigValue peekPath(Path path) {
        return peekPath(this, path);
    }

#No. 1302
#File: E:\bishe\1\AbstractConfigProvider.java
#Comment:
    /**
     * This method takes a <code>Message</code> class and determines what <code>Message.Builder</code> needs to be instantiated.
     * After that there is a chained call to convertMessage(builder, contentType, data) is done to populate the builder with the data.
     * The returned builder object is not finalized, and can be further appended, if need be to override the values or augment them. 
     * @param returnType
     * @param contentType
     * @param data
     * @return
     * @throws Exception
     * @see ws.antonov.config.provider.AbstractConfigProvider#convertMessage(com.google.protobuf.Message.Builder, ws.antonov.config.provider.AbstractConfigProvider.ContentType, java.io.InputStream)
     */

#Code:
    protected Message.Builder convertMessage(Class<? extends Message> returnType,
                                             ContentType contentType, InputStream data) throws Exception {
        Message.Builder builder;
        Method m = newBuilderMethodCache.get(returnType);
        if (m == null) {
            m = returnType.getMethod("newBuilder");
            newBuilderMethodCache.put(returnType, m);
        }
        builder = (Message.Builder) m.invoke(returnType);
        return convertMessage(builder, contentType, data);
    }

#No. 1303
#File: E:\bishe\1\AbstractConfiguration.java
#Comment:
	/**
	 * Returns a new {@link Connector} to be used by Jetty to response to HTTP
	 * reqests. Override this method to return a specifically-configured
	 * {@link Connector}. By default, a stock {@link SocketConnector} is
	 * returned. (If you're not running Linux 2.6.27+ on a 64-bit system, you
	 * may want to override this to return a SelectChannelConnector.)
	 * 
	 * @return a {@link SocketConnector}
	 */

#Code:
	public Connector getConnector() {
		return new SocketConnector();
	}

#No. 1304
#File: E:\bishe\1\AbstractConfiguration.java
#Comment:
	/**
	 * Returns a list of Hibernate entity packages.
	 */

#Code:
	public final List<String> getEntityPackages() {
		return ImmutableList.copyOf(entityPackages);
	}

#No. 1305
#File: E:\bishe\1\AbstractConfiguration.java
#Comment:
	/**
	 * Returns a list of Guice modules.
	 */

#Code:
	public final List<Module> getModules() {
		return ImmutableList.copyOf(modules);
	}

#No. 1306
#File: E:\bishe\1\AbstractConfiguration.java
#Comment:
	/**
	 * Returns a list of Jersey resource/provider packages.
	 */

#Code:
	public final List<String> getResourcePackages() {
		return ImmutableList.copyOf(resourcePackages);
	}

#No. 1307
#File: E:\bishe\1\AbstractConfiguration.java
#Comment:
	/**
	 * Returns an ordered map of servlet filter holders and their URL patterns.
	 */

#Code:
	public final Map<FilterHolder, String> getServletFilters() {
		return ImmutableMap.copyOf(servletFilters);
	}

#No. 1308
#File: E:\bishe\1\AbstractConfiguration.java
#Comment:
	/**
	 * Returns the Guice stage.
	 */

#Code:
	public final Stage getStage() {
		return stage;
	}

#No. 1309
#File: E:\bishe\1\AbstractConfiguration.java
#Comment:
	/**
	 * Sets the {@link Stage} that Guice uses when binding classes.
	 * 
	 * @param stage Guice's stage
	 */

#Code:
	protected void setStage(Stage stage) {
		this.stage = checkNotNull(stage);
	}

#No. 1310
#File: E:\bishe\1\AbstractConfiguration.java
#Comment:
	/**
	 * Returns the application binary's names.
	 * 
	 * @return the application binary's name
	 */

#Code:
	public abstract String getExecutableName();
	
	/**
	 * Configures the Jetty {@link Server} before it is started. Override this
	 * to customize the server behavior.
	 * 
	 * @param server
	 */
	protected void configureServer(Server server) {
		// no customizations needed
	}

#No. 1311
#File: E:\bishe\1\AbstractConfiguration.java
#Comment:
	/**
	 * Configures the Jetty {@link Context} before it is started. Override this
	 * to customize the context behavior.
	 * 
	 * @param context
	 */

#Code:
	protected void configureContext(ServletContextHandler context) {
		// no customizations needed
	}

#No. 1312
#File: E:\bishe\1\AbstractConfigurationBlockPreferencePage.java
#Comment:
    /**
     * Creates a new preference page.
     */

#Code:
    public AbstractConfigurationBlockPreferencePage() {
        setDescription();
        setPreferenceStore();
        fOverlayStore = new OverlayPreferenceStore(getPreferenceStore(), new OverlayPreferenceStore.OverlayKey[] {});
        fConfigurationBlock = createConfigurationBlock(fOverlayStore);
    }

#No. 1313
#File: E:\bishe\1\AbstractConfigurationBlockPreferencePage.java
#Comment:
    /*
     * @see PreferencePage#createControl(Composite)
     */

#Code:
    @Override
    public void createControl(Composite parent) {
        super.createControl(parent);
        PlatformUI.getWorkbench().getHelpSystem().setHelp(getControl(), getHelpId());
    }

#No. 1314
#File: E:\bishe\1\AbstractConfigurationBlockPreferencePage.java
#Comment:
    /*
     * @see PreferencePage#createContents(Composite)
     */

#Code:
    @Override
    protected Control createContents(Composite parent) {

        fOverlayStore.load();
        fOverlayStore.start();

        Control content = fConfigurationBlock.createControl(parent);

        initialize();

        Dialog.applyDialogFont(content);
        return content;
    }

#No. 1315
#File: E:\bishe\1\AbstractConfigurationBlockPreferencePage.java
#Comment:
    /*
     * @see PreferencePage#performOk()
     */

#Code:
    @Override
    public boolean performOk() {

        fConfigurationBlock.performOk();

        fOverlayStore.propagate();

        // TODO etxract to plugin class

        try {
            InstanceScope.INSTANCE.getNode(YangEditorPlugin.PLUGIN_ID).flush();
        } catch (BackingStoreException e) {
            YangEditorPlugin.log(e);
        }

        return true;
    }

#No. 1316
#File: E:\bishe\1\AbstractConfigurationBlockPreferencePage.java
#Comment:
    /*
     * @see PreferencePage#performDefaults()
     */

#Code:
    @Override
    public void performDefaults() {

        fOverlayStore.loadDefaults();
        fConfigurationBlock.performDefaults();

        super.performDefaults();
    }

#No. 1317
#File: E:\bishe\1\AbstractConfigurationBlockPreferencePage.java
#Comment:
    /*
     * @see DialogPage#dispose()
     */

#Code:
    @Override
    public void dispose() {

        fConfigurationBlock.dispose();

        if (fOverlayStore != null) {
            fOverlayStore.stop();
            fOverlayStore = null;
        }

        super.dispose();
    }

#No. 1318
#File: E:\bishe\1\AbstractConfigurationLoader.java
#Comment:
	/**
	 * Reads the values from the properties file and loads services behind the values, if necessary.
	 */

#Code:
	@Override
	public void readValues() {
		loadProperties();
		final Set<Object> keys = properties.keySet();

		for (final Object object : keys) {
			final String key = (String) object;
			final String value = properties.getProperty(key);
			final ContextProperties contextProps = ContextProperties.get(key);
			if (contextProps != null) {
				try {
					final Field propertyField = ContextProperties.class.getDeclaredField(contextProps.name());
					final boolean isPrintable = propertyField.getAnnotation(RuntimeMeta.class).printable();
					if (isPrintable) {
						final Scope type = propertyField.getAnnotation(RuntimeMeta.class).type();
						final String typeValue = type != null ? type.getValue() : "";
						log.info(typeValue + ": " + contextProps + "=" + value);
					}
					ContextCache.instance.put(contextProps, value);
				} catch (final NoSuchFieldException | SecurityException e) {
					log.error(e.getMessage());
				}
				readSpecials(contextProps, value);
			}
		}

		finalWork();
		if (latch != null) {
			latch.countDown();
		}
	}

#No. 1319
#File: E:\bishe\1\AbstractConfluenceMojo.java
#Comment:
    /**
     *
     * @return
     */

#Code:
    public String getEncoding() {
        return encoding;
    }

#No. 1320
#File: E:\bishe\1\AbstractConfluenceMojo.java
#Comment:
    /**
     *
     * @param encoding
     */

#Code:
    public void setEncoding(String encoding) {
        this.encoding = encoding;
    }

#No. 1321
#File: E:\bishe\1\AbstractConfluenceMojo.java
#Comment:
    /**
     *
     * @return
     */

#Code:
    protected final Charset getCharset() {

        if( encoding == null ) {
            getLog().warn("encoding is null! default charset will be used");
            return Charset.defaultCharset();
        }

        try {
            Charset result = Charset.forName(encoding);
            return result;

        } catch (UnsupportedCharsetException e) {
            getLog().warn( String.format("encoding [%s] is not valid! default charset will be used", encoding));
            return Charset.defaultCharset();

        }
    }

#No. 1322
#File: E:\bishe\1\AbstractConfluenceMojo.java
#Comment:
    /**
     *
     * @return
     */

#Code:
    protected final String getTitle() {
        return title;
    }

#No. 1323
#File: E:\bishe\1\AbstractConfluenceMojo.java
#Comment:
    /**
     *
     * @param title
     */

#Code:
    public void setTitle(String title) {
        this.title = title;
    }

#No. 1324
#File: E:\bishe\1\AbstractConfluenceMojo.java
#Comment:
    /**
     *
     * @return
     */

#Code:
    public String getFileExt() {
        return (wikiFilesExt.charAt(0)=='.' ) ? wikiFilesExt : ".".concat(wikiFilesExt);
    }

#No. 1325
#File: E:\bishe\1\AbstractConfluenceMojo.java
#Comment:
    /**
     * initialize properties shared with template
     */

#Code:
    protected void initTemplateProperties() {

        processProperties();

        getProperties().put("pageTitle", getTitle());
        getProperties().put("artifactId", project.getArtifactId());
        getProperties().put("version", project.getVersion());
        getProperties().put("groupId", project.getGroupId());
        getProperties().put("name", project.getName());
        getProperties().put("description", project.getDescription());

        final java.util.Properties projectProps = project.getProperties();

        if( projectProps!=null ) {

            for(Map.Entry<Object,Object> e : projectProps.entrySet()){
                getProperties().put( String.valueOf(e.getKey()), String.valueOf(e.getValue()) );
            }
        }

    }

#No. 1326
#File: E:\bishe\1\AbstractConfluenceMojo.java
#Comment:
    /**
     * Issue 46
     *
     **/

#Code:
    private void processProperties() {

        for( Map.Entry<String,String> e : this.getProperties().entrySet() ) {

            try {

                String v = e.getValue();
                if( v == null ) {
                    getLog().warn( String.format("property [%s] has null value!", e.getKey()));
                    continue;
                }
                final java.net.URI uri = new java.net.URI( v );

                if( uri.getScheme() == null ) {
                    continue;
                }

                getProperties().put( e.getKey(), processUri( uri, getCharset() ));

            } catch (ProcessUriException ex) {
                getLog().warn( String.format("error processing value of property [%s]\n%s", e.getKey(), ex.getMessage()));
                if( ex.getCause() != null )
                    getLog().debug( ex.getCause() );

            } catch (URISyntaxException ex) {

                // DO Nothing
                getLog().debug( String.format("property [%s] is not a valid uri", e.getKey()));
            }

        }
    }

#No. 1327
#File: E:\bishe\1\AbstractConfluenceMojo.java
#Comment:
    /**
     *
     * @param uri
     * @return
     * @throws org.bsc.maven.reporting.AbstractConfluenceMojo.ProcessUriException
     */

#Code:
    private String processUri( java.net.URI uri, final Charset charset ) throws ProcessUriException {

        try {
            return  Site.processUri(uri, this.getTitle(), new Func2<InputStream, Representation, String>() {
                @Override
                public String call(InputStream is, Representation r) {
                    try {
                        return AbstractConfluenceMojo.this.toString( is, charset );
                    } catch (IOException ex) {
                        throw new RuntimeException(ex);
                    }
                }
            }) ;

        } catch (Exception ex) {
            throw new ProcessUriException("error reading content!", ex);
        }
    }

#No. 1328
#File: E:\bishe\1\AbstractConfluenceMojo.java
#Comment:
    /**
     *
     * @param reader
     * @return
     * @throws IOException
     */

#Code:
    private String toString(java.io.InputStream stream, Charset charset) throws IOException {
        if (stream == null) {
            throw new IllegalArgumentException("stream");
        }

        try( final java.io.Reader r = new java.io.InputStreamReader(stream, charset) ) {

            final StringBuilder contents = new StringBuilder(4096);

            int c;
            while ((c = r.read()) != -1) {
                contents.append((char) c);
            }

            return contents.toString();

        }
    }

#No. 1329
#File: E:\bishe\1\AbstractConnection.java
#Comment:
    /**
     * 分配缓存
     */

#Code:
    public ByteBuffer allocate() {
        return processor.getBufferPool().allocate();
    }

#No. 1330
#File: E:\bishe\1\AbstractConnection.java
#Comment:
    /**
     * 回收缓存
     */

#Code:
    public void recycle(ByteBuffer buffer) {
        processor.getBufferPool().recycle(buffer);
    }

#No. 1331
#File: E:\bishe\1\AbstractConnection.java
#Comment:
    /**
     * 打开读事件
     */

#Code:
    public void enableRead() {
        final Lock lock = this.keyLock;
        lock.lock();
        try {
            SelectionKey key = this.processKey;
            key.interestOps(key.interestOps() | SelectionKey.OP_READ);
        } finally {
            lock.unlock();
        }
        processKey.selector().wakeup();
    }

#No. 1332
#File: E:\bishe\1\AbstractConnection.java
#Comment:
    /**
     * 关闭读事件
     */

#Code:
    public void disableRead() {
        final Lock lock = this.keyLock;
        lock.lock();
        try {
            SelectionKey key = this.processKey;
            key.interestOps(key.interestOps() & OP_NOT_READ);
        } finally {
            lock.unlock();
        }
    }

#No. 1333
#File: E:\bishe\1\AbstractConnection.java
#Comment:
    /**
     * 检查WriteBuffer容量，不够则写出当前缓存块并申请新的缓存块。
     */

#Code:
    public ByteBuffer checkWriteBuffer(ByteBuffer buffer, int capacity) {
        if (capacity > buffer.remaining()) {
            write(buffer);
            return processor.getBufferPool().allocate();
        } else {
            return buffer;
        }
    }

#No. 1334
#File: E:\bishe\1\AbstractConnection.java
#Comment:
    /**
     * 把数据写到给定的缓存中，如果满了则提交当前缓存并申请新的缓存。
     */

#Code:
    public ByteBuffer writeToBuffer(byte[] src, ByteBuffer buffer) {
        int offset = 0;
        int length = src.length;
        int remaining = buffer.remaining();
        while (length > 0) {
            if (remaining >= length) {
                buffer.put(src, offset, length);
                break;
            } else {
                buffer.put(src, offset, remaining);
                write(buffer);
                buffer = processor.getBufferPool().allocate();
                offset += remaining;
                length -= remaining;
                remaining = buffer.remaining();
                continue;
            }
        }
        return buffer;
    }

#No. 1335
#File: E:\bishe\1\AbstractConnection.java
#Comment:
    /**
     * 清理遗留资源
     */

#Code:
    protected void cleanup() {
        BufferPool pool = processor.getBufferPool();
        ByteBuffer buffer = null;

        // 回收接收缓存
        buffer = this.readBuffer;
        if (buffer != null) {
            this.readBuffer = null;
            pool.recycle(buffer);
        }

        // 回收发送缓存
        while ((buffer = writeQueue.poll()) != null) {
            pool.recycle(buffer);
        }
    }

#No. 1336
#File: E:\bishe\1\AbstractConnection.java
#Comment:
    /**
     * 获取数据包长度，默认是MySQL数据包，其他数据包重载此方法。
     */

#Code:
    protected int getPacketLength(ByteBuffer buffer, int offset) {
        if (buffer.position() < offset + packetHeaderSize) {
            return -1;
        } else {
            int length = buffer.get(offset) & 0xff;
            length |= (buffer.get(++offset) & 0xff) << 8;
            length |= (buffer.get(++offset) & 0xff) << 16;
            return length + packetHeaderSize;
        }
    }

#No. 1337
#File: E:\bishe\1\AbstractConnection.java
#Comment:
    /**
     * 检查ReadBuffer容量，不够则扩展当前缓存，直到最大值。
     */

#Code:
    private ByteBuffer checkReadBuffer(ByteBuffer buffer, int offset, int position) {
        // 当偏移量为0时需要扩容，否则移动数据至偏移量为0的位置。
        if (offset == 0) {
            if (buffer.capacity() >= maxPacketSize) {
                throw new IllegalArgumentException("Packet size over the limit.");
            }
            int size = buffer.capacity() << 1;
            size = (size > maxPacketSize) ? maxPacketSize : size;
            ByteBuffer newBuffer = ByteBuffer.allocate(size);
            buffer.position(offset);
            newBuffer.put(buffer);
            readBuffer = newBuffer;
            // 回收扩容前的缓存块
            processor.getBufferPool().recycle(buffer);
            return newBuffer;
        } else {
            buffer.position(offset);
            buffer.compact();
            readBufferOffset = 0;
            return buffer;
        }
    }

#No. 1338
#File: E:\bishe\1\AbstractConnection.java
#Comment:
    /**
     * 打开写事件
     */

#Code:
    private void enableWrite() {
        final Lock lock = this.keyLock;
        lock.lock();
        try {
            SelectionKey key = this.processKey;
            key.interestOps(key.interestOps() | SelectionKey.OP_WRITE);
        } finally {
            lock.unlock();
        }
        processKey.selector().wakeup();
    }

#No. 1339
#File: E:\bishe\1\AbstractConnection.java
#Comment:
    /**
     * 关闭写事件
     */

#Code:
    private void disableWrite() {
        final Lock lock = this.keyLock;
        lock.lock();
        try {
            SelectionKey key = this.processKey;
            key.interestOps(key.interestOps() & OP_NOT_WRITE);
        } finally {
            lock.unlock();
        }
    }

#No. 1340
#File: E:\bishe\1\AbstractConnectionBean.java
#Comment:
    /**
     * Return an array that gives the column index in the cursor for each field defined
     * @param cursor Database cursor over some columns, possibly including this table
     * @return array of column indices; -1 if the column with that id is not in cursor
     */

#Code:
    public int[] Gen_columnIndices(android.database.Cursor cursor) {
        int[] result=new int[GEN_COUNT];
        result[0] = cursor.getColumnIndex(GEN_FIELD__ID);
        // Make compatible with database generated by older version of plugin with uppercase column name
        if (result[0] == -1) {
            result[0] = cursor.getColumnIndex("_ID");
        }
        result[1] = cursor.getColumnIndex(GEN_FIELD_NICKNAME);
        result[2] = cursor.getColumnIndex(GEN_FIELD_ADDRESS);
        result[3] = cursor.getColumnIndex(GEN_FIELD_PORT);
        result[4] = cursor.getColumnIndex(GEN_FIELD_PASSWORD);
        result[5] = cursor.getColumnIndex(GEN_FIELD_COLORMODEL);
        result[6] = cursor.getColumnIndex(GEN_FIELD_FORCEFULL);
        result[7] = cursor.getColumnIndex(GEN_FIELD_REPEATERID);
        result[8] = cursor.getColumnIndex(GEN_FIELD_INPUTMODE);
        result[9] = cursor.getColumnIndex(GEN_FIELD_SCALEMODE);
        result[10] = cursor.getColumnIndex(GEN_FIELD_USELOCALCURSOR);
        result[11] = cursor.getColumnIndex(GEN_FIELD_KEEPPASSWORD);
        result[12] = cursor.getColumnIndex(GEN_FIELD_FOLLOWMOUSE);
        result[13] = cursor.getColumnIndex(GEN_FIELD_USEREPEATER);
        result[14] = cursor.getColumnIndex(GEN_FIELD_METALISTID);
        result[15] = cursor.getColumnIndex(GEN_FIELD_LAST_META_KEY_ID);
        result[16] = cursor.getColumnIndex(GEN_FIELD_FOLLOWPAN);
        result[17] = cursor.getColumnIndex(GEN_FIELD_USERNAME);
        result[18] = cursor.getColumnIndex(GEN_FIELD_SECURECONNECTIONTYPE);
        result[19] = cursor.getColumnIndex(GEN_FIELD_SHOWZOOMBUTTONS);
        result[20] = cursor.getColumnIndex(GEN_FIELD_DOUBLE_TAP_ACTION);
        return result;
    }

#No. 1341
#File: E:\bishe\1\AbstractConnectionBean.java
#Comment:
    /**
     * Populate one instance from a ContentValues 
     */

#Code:
    public void Gen_populate(android.content.ContentValues values) {
        gen__Id = values.getAsLong(GEN_FIELD__ID);
        gen_nickname = values.getAsString(GEN_FIELD_NICKNAME);
        gen_address = values.getAsString(GEN_FIELD_ADDRESS);
        gen_port = (int)values.getAsInteger(GEN_FIELD_PORT);
        gen_password = values.getAsString(GEN_FIELD_PASSWORD);
        gen_colorModel = values.getAsString(GEN_FIELD_COLORMODEL);
        gen_forceFull = values.getAsLong(GEN_FIELD_FORCEFULL);
        gen_repeaterId = values.getAsString(GEN_FIELD_REPEATERID);
        gen_inputMode = values.getAsString(GEN_FIELD_INPUTMODE);
        gen_SCALEMODE = values.getAsString(GEN_FIELD_SCALEMODE);
        gen_useLocalCursor = (values.getAsInteger(GEN_FIELD_USELOCALCURSOR) != 0);
        gen_keepPassword = (values.getAsInteger(GEN_FIELD_KEEPPASSWORD) != 0);
        gen_followMouse = (values.getAsInteger(GEN_FIELD_FOLLOWMOUSE) != 0);
        gen_useRepeater = (values.getAsInteger(GEN_FIELD_USEREPEATER) != 0);
        gen_metaListId = values.getAsLong(GEN_FIELD_METALISTID);
        gen_LAST_META_KEY_ID = values.getAsLong(GEN_FIELD_LAST_META_KEY_ID);
        gen_followPan = (values.getAsInteger(GEN_FIELD_FOLLOWPAN) != 0);
        gen_userName = values.getAsString(GEN_FIELD_USERNAME);
        gen_secureConnectionType = values.getAsString(GEN_FIELD_SECURECONNECTIONTYPE);
        gen_showZoomButtons = (values.getAsInteger(GEN_FIELD_SHOWZOOMBUTTONS) != 0);
        gen_DOUBLE_TAP_ACTION = values.getAsString(GEN_FIELD_DOUBLE_TAP_ACTION);
    }

#No. 1342
#File: E:\bishe\1\AbstractConnectionProvider.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public String getUsernameLabel() {
        return "Username";
    }

#No. 1343
#File: E:\bishe\1\AbstractConnectionProvider.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public String getPasswordLabel() {
        return "Password";
    }

#No. 1344
#File: E:\bishe\1\AbstractConnPool.java
#Comment:
    /**
     * Closes idle connections.
     *
     * @param idletime  the time the connections should have been idle
     *                  in order to be closed now
     * @param tunit     the unit for the <code>idletime</code>
     */

#Code:
    public void closeIdleConnections(long idletime, TimeUnit tunit) {

        // idletime can be 0 or negative, no problem there
        if (tunit == null) {
            throw new IllegalArgumentException("Time unit must not be null.");
        }

        poolLock.lock();
        try {
            idleConnHandler.closeIdleConnections(tunit.toMillis(idletime));
        } finally {
            poolLock.unlock();
        }
    }

#No. 1345
#File: E:\bishe\1\AbstractConnPool.java
#Comment:
    /**
     * Deletes all entries for closed connections.
     */

#Code:
    public abstract void deleteClosedConnections();

    /**
     * Shuts down this pool and all associated resources.
     * Overriding methods MUST call the implementation here!
     */
    public void shutdown() {

        poolLock.lock();
        try {

            if (isShutDown)
                return;

            // close all connections that are issued to an application
            Iterator<BasicPoolEntry> iter = leasedConnections.iterator();
            while (iter.hasNext()) {
                BasicPoolEntry entry = iter.next();
                iter.remove();
                closeConnection(entry.getConnection());
            }
            idleConnHandler.removeAll();

            isShutDown = true;

        } finally {
            poolLock.unlock();
        }
    }

#No. 1346
#File: E:\bishe\1\AbstractConnPool.java
#Comment:
    /**
     * Closes a connection from this pool.
     *
     * @param conn      the connection to close, or <code>null</code>
     */

#Code:
    protected void closeConnection(final OperatedClientConnection conn) {
        if (conn != null) {
            try {
                conn.close();
            } catch (IOException ex) {
                log.debug("I/O error closing connection", ex);
            }
        }
    }

#No. 1347
#File: E:\bishe\1\AbstractConsensusStateMachine.java
#Comment:
  /**
   * Writes current state of the state machine to internalDb.
   * 
   * @param consensusIndex
   *          The {@link Commit#index()} of the commit that was commited last.
   * @param entries
   *          The entries to store (= the state of the state machine).
   */

#Code:
  protected void writeCurrentStateToInternalDb(long consensusIndex, Collection<T> entries) {
    List<T> entryList;
    if (entries instanceof List)
      entryList = (List<T>) entries;
    else
      entryList = new ArrayList<>(entries);

    try {
      internalDbFileWriter.write(consensusIndex, entryList);
    } catch (WriteException e1) {
      logger.error("Could not write {} internaldb file!", internalDbDataType, e1);
      // this is an error, but we try to continue anyway. When the file is missing, the node might not be able to
      // recover correctly, but for now we can keep working. The admin might want to copy a internaldb file from a
      // different node.
    }
  }

#No. 1348
#File: E:\bishe\1\AbstractConsoleRunnerWithHistory.java
#Comment:
//  /**
//   * Launch process, setup history, actions etc.
//   *
//   * @throws com.intellij.execution.ExecutionException
//   */

#Code:
//  public void initAndRun() throws ExecutionException {
//    // Create Server process
//    myProcessHandler = createProcess();
//    ProcessTerminatedListener.attach(myProcessHandler);
//
//    UIUtil.invokeLaterIfNeeded(new Runnable() {
//      @Override
//      public void run() {
//        initConsoleUI();
//      }
//    });
//  }

#No. 1349
#File: E:\bishe\1\AbstractConstraintModel.java
#Comment:
/**
 * JAVADOC
 */

#Code:
public abstract class AbstractConstraintModel
    implements ConstraintDescriptor, Visitable<ConstraintDescriptor>
{
    protected final Annotation annotation;

    public AbstractConstraintModel( Annotation annotation )
    {
        this.annotation = annotation;
    }

    public Annotation annotation()
    {
        return annotation;
    }

    public abstract ConstraintInstance<?, ?> newInstance();

    @Override
    public <ThrowableType extends Throwable> boolean accept( Visitor<? super ConstraintDescriptor, ThrowableType> modelVisitor ) throws ThrowableType
    {
        return modelVisitor.visit( this );
    }
}
#No. 1350
#File: E:\bishe\1\AbstractConstructorExpectationSetup.java
#Comment:
        /*
        * Check if this type has been mocked before
        */

#Code:
        NewInvocationControl<OngoingStubbing<T>> newInvocationControl =
                (NewInvocationControl<OngoingStubbing<T>>) MockRepository.getNewInstanceControl(unmockedType);
        if (newInvocationControl == null) {
            InvocationSubstitute<T> mock = getMockCreator().createMock(InvocationSubstitute.class, false, false, null, null, (Method[]) null);
            newInvocationControl = createNewInvocationControl(mock);
            MockRepository.putNewInstanceControl(type, newInvocationControl);
            MockRepository.addObjectsToAutomaticallyReplayAndVerify(WhiteboxImpl.getOriginalUnmockedType(type));
        }

#No. 1351
#File: E:\bishe\1\AbstractConsumerTest.java
#Comment:
  /**
   * Create a map with a 'String' to 'Class<?>' mapping based on given parameters.
   * Therefore parameters MUST be a set of such pairs.
   * As example an correct method call would be:
   * <p>
   * <code>
   * createTypeMappings("someKey", Integer.class, "anotherKey", Long.class);
   * </code>
   * </p>
   * 
   * @param firstKeyThenMappingClass
   * @return
   */

#Code:
  protected Map<String, Object> createTypeMappings(final Object... firstKeyThenMappingClass) {
    Map<String, Object> typeMappings = new HashMap<String, Object>();
    if (firstKeyThenMappingClass.length % 2 != 0) {
      throw new IllegalArgumentException("Got odd number of parameters. Please read javadoc.");
    }
    for (int i = 0; i < firstKeyThenMappingClass.length; i += 2) {
      String key = (String) firstKeyThenMappingClass[i];
      Class<?> mappingClass = (Class<?>) firstKeyThenMappingClass[i + 1];
      typeMappings.put(key, mappingClass);
    }
    return typeMappings;
  }

#No. 1352
#File: E:\bishe\1\AbstractConsumerTest.java
#Comment:
  /**
   * 
   * @param content
   * @param replaceWhitespaces if <code>true</code> all XML not necessary whitespaces between tags are
   * @return
   * @throws UnsupportedEncodingException
   */

#Code:
  protected InputStream createContentAsStream(final String content, final boolean replaceWhitespaces)
      throws UnsupportedEncodingException {
    String contentForStream = content;
    if (replaceWhitespaces) {
      contentForStream = content.replaceAll(">\\s.<", "><");
    }

    return new ByteArrayInputStream(contentForStream.getBytes("UTF-8"));
  }

#No. 1353
#File: E:\bishe\1\AbstractContainerCommunicator.java
#Comment:
    /**
     * 当 实现是 TGContainerCommunicator 时，返回的 Map: key=taskId, value=Communication
     * 当 实现是 JobContainerCommunicator 时，返回的 Map: key=taskGroupId, value=Communication
     */

#Code:
    public abstract Map<Integer, Communication> getCommunicationMap();

    public void resetCommunication(Integer id){
        Map<Integer, Communication> map = getCommunicationMap();
        map.put(id, new Communication());
    }

#No. 1354
#File: E:\bishe\1\AbstractContent.java
#Comment:
	//********************************************************************
	//               Clone method
	//********************************************************************
	public Object clone(){
		AbstractContent cPageContent = null;
		try {
			cPageContent = (AbstractContent) super.clone();
		} catch (CloneNotSupportedException e) {
			log.error("Clone "+this.getClass().getName()+" object failed " , e);
		}
		return cPageContent;
	}
	//********************************************************************
	//               Set / Get
	//********************************************************************
	
	/**
	 * @param object
	 */

#Code:
	public abstract void setUid(Integer uid);

	public int getType() {
		return type;
	}

#No. 1355
#File: E:\bishe\1\AbstractContentHandlerServlet.java
#Comment:
	/**
	 * Generic processor of HTTP request when not using JSON control procotol.
	 * 
	 * @param asyncCtx
	 *            Asynchronous context
	 * @param contentId
	 *            Content unique identifier
	 * @param resp
	 *            HTTP response
	 * @throws ServletException
	 *             Exception in Servlet
	 * @throws IOException
	 *             Input/Ouput Exception
	 */

#Code:
	private void doRequest4SimpleHttpProtocol(AsyncContext asyncCtx,
			String contentId, HttpServletResponse resp)
			throws ServletException, IOException {
		try {
			AbstractContentSession contentRequest = createContentSession(
					asyncCtx, contentId);

			Future<?> future = executor.getExecutor()
					.submit(createAsyncRequestProcessor(contentRequest, null,
							asyncCtx));
			// Store future and request for using it in case of error
			asyncCtx.getRequest().setAttribute(
					ContentAsyncListener.FUTURE_REQUEST_PROCESSOR_ATT_NAME,
					future);
			asyncCtx.getRequest().setAttribute(
					ContentAsyncListener.CONTENT_REQUEST_ATT_NAME,
					contentRequest);
		} catch (KurentoMediaFrameworkException ke) {
			getLogger().error(ke.getMessage(), ke);
			ServletUtils.sendHttpError(
					(HttpServletRequest) asyncCtx.getRequest(), resp,
					ExceptionUtils.getHttpErrorCode(ke.getCode()),
					ke.getMessage());
		}
	}

#No. 1356
#File: E:\bishe\1\AbstractContentNegotiationTest.java
#Comment:
    /**
     * Set header with name to given value without any sort of checking or validation of value.
     * @param name
     * @param value
     * @return FitTestBuilder
     */

#Code:
    public FitTestBuilder header(final String name, final String value) {
      test.request.headers.put(name, value);
      return this;
    }

#No. 1357
#File: E:\bishe\1\AbstractContentNegotiationTest.java
#Comment:
    /**
     * Set the accept header if value is not <code>NULL</code> and has a <code>length > 0</code>
     * @param value
     * @return FitTestBuilder
     */

#Code:
    public FitTestBuilder acceptHeader(final String value) {
      if (value != null && value.length() > 0) {
        return header(HttpHeaders.ACCEPT, value);
      }
      return this;
    }

#No. 1358
#File: E:\bishe\1\AbstractContentNegotiationTest.java
#Comment:
    /**
     * Set the accept header if value is not <code>NULL</code> and has a <code>length > 0</code>
     * @param value
     * @return FitTestBuilder
     */

#Code:
    public FitTestBuilder contentTypeHeader(final String value) {
      if (value != null && value.length() > 0) {
        return header(HttpHeaders.CONTENT_TYPE, value);
      }
      return this;
    }

#No. 1359
#File: E:\bishe\1\AbstractContentPanel.java
#Comment:
	/**
	 * Call this method when your tool is ready to display its overlay. 
	 * After this call the main context will remove the main image
	 * and will replace it with the content of this panel
	 */

#Code:
	protected void contentReady() {
		if ( mContentReadyListener != null && isActive() ) mContentReadyListener.onReady( this );
	}

#No. 1360
#File: E:\bishe\1\AbstractContentProvider.java
#Comment:
	/**
	 * Ajout automatique de la <b>valeur de l'ID</b> dans la requete vers
	 * SQLite.
	 * 
	 * @param uri
	 *            URL de l'item
	 * @param whereArgs
	 *            Arguments de recherche actuels
	 * @return Arguments de recherche avec l'ID
	 */

#Code:
	protected String[] appendIdValueToWhere(Uri uri, String[] whereArgs) {
		List<String> whereParams = new ArrayList<String>();
		if (whereArgs != null) {
			whereParams = Arrays.asList(whereArgs);
		}
		whereParams.add(uri.getLastPathSegment());
		whereArgs = whereParams.toArray(new String[] {});
		return whereArgs;
	}

#No. 1361
#File: E:\bishe\1\AbstractContentProvider.java
#Comment:
	/**
	 * Ajout automatique du <b>champ _ID</b> dans la requete vers SQLite.
	 * 
	 * @param where
	 *            Requete de recherche actuelle
	 * @return Requete de recherche avec l'ID
	 */

#Code:
	protected String appendIdClauseToWhere(String where) {
		if (where == null) {
			where = "_ID = ?";
		} else {
			where = where + " AND _ID = ?";
		}
		return where;
	}

#No. 1362
#File: E:\bishe\1\AbstractContentSession.java
#Comment:
	/**
	 * Terminates this object, completing initialAsyncCtx if necessary and
	 * sending an answer to the initial request if necessary.
	 * 
	 * @param code
	 *            termination code
	 * @param description
	 *            termination description
	 */

#Code:

	@Override
	public void terminate(int code, String description) {
		internalTerminateWithoutError(null, code, description, null);
	}

#No. 1363
#File: E:\bishe\1\AbstractContentSession.java
#Comment:
			/*
			 * Whenever a thread wants to change the session state, if that
			 * state is already terminated, that means that another thread
			 * terminated the session. However, the thread calling this method
			 * may have created media elements or other resources. For this
			 * reason, we need to call destroy to guarantee that those resources
			 * are collected.
			 */

#Code:
			if (initial == STATE.TERMINATED) {
				internalTerminateWithError(
						null,
						1,
						"Spureous state change attemp while being already termianted",
						null); // TODO: error code
			}

#No. 1364
#File: E:\bishe\1\AbstractContentTransformerWorker.java
#Comment:
/**
 * Abstract transform node worker which uses a content reference handler to convert the 
 * content reference into a usable File object for the actual implementation.
 * 
 * @author Ray Gauss II
 */

#Code:
public abstract class AbstractContentTransformerWorker 
        extends AbstractContentWorker implements ContentTransformerWorker
{
    protected ContentReferenceHandler targetContentReferenceHandler;
    
    public void setTargetContentReferenceHandler(ContentReferenceHandler targetContentReferenceHandler)
    {
        this.targetContentReferenceHandler = targetContentReferenceHandler;
    }

    public void initialize()
    {
        super.initialize();
    }
    
    protected String getExtension(ContentReference contentReference)
    {
        return FileMediaType.SERVICE.getExtension(contentReference.getMediaType());
    }

    @Override
    public String toString()
    {
        StringBuilder builder = new StringBuilder(this.getClass().getSimpleName() + "[");
        builder.append("sourceContentReferenceHandler: " + sourceContentReferenceHandler.toString());
        builder.append(", ");
        builder.append("targetContentReferenceHandler: " + targetContentReferenceHandler.toString());
        builder.append("]");
        return builder.toString();
    }

}

#No. 1365
#File: E:\bishe\1\AbstractContentValues.java
#Comment:
    /**
     * Returns the {@code uri} argument to pass to the {@code ContentResolver} methods.
     *
     * @return Uri to pass to ContentResolver.
     */

#Code:
    public abstract Uri uri();

    /**
     * Returns the {@code ContentValues} wrapped by this object.
     *
     * @return ContentValues.
     */
    public ContentValues values() {
        return mContentValues;
    }

#No. 1366
#File: E:\bishe\1\AbstractContentValues.java
#Comment:
    /**
     * Inserts a row into a table using the values stored by this object.
     *
     * @param contentResolver The content resolver to use.
     * @return Uri of this new row.
     */

#Code:
    public Uri insert(ContentResolver contentResolver) {
        return contentResolver.insert(uri(), values());
    }

#No. 1367
#File: E:\bishe\1\AbstractContentValues.java
#Comment:
    /**
     * Inserts a row into a table using the values stored by this object.
     *
     * @param context The context to use.
     * @return Uri of this new row.
     */

#Code:
    public Uri insert(Context context) {
        return context.getContentResolver().insert(uri(), values());
    }

#No. 1368
#File: E:\bishe\1\AbstractContextEncodedNgramLanguageModel.java
#Comment:
/**
 * 
 * Default implementation of all ContextEncodedNgramLanguageModel functionality
 * except {@link #getLogProb(long, int, int, LmContextInfo)},
 * {@link #getOffsetForNgram(int[], int, int), and {
 * @link #getNgramForOffset(long, int, int)}.
 * 
 * 
 * @author adampauls
 * 
 * @param <W>
 */

#Code:
public abstract class AbstractContextEncodedNgramLanguageModel<W> extends AbstractNgramLanguageModel<W> implements ContextEncodedNgramLanguageModel<W>,
	Serializable
{

	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;

	public AbstractContextEncodedNgramLanguageModel(final int lmOrder, final WordIndexer<W> wordIndexer, final float oovWordLogProb) {
		super(lmOrder, wordIndexer, oovWordLogProb);
	}

	@Override
	public float scoreSentence(final List<W> sentence) {
		return ContextEncodedNgramLanguageModel.DefaultImplementations.scoreSentence(sentence, this);
	}

	@Override
	public float getLogProb(final List<W> phrase) {
		return ContextEncodedNgramLanguageModel.DefaultImplementations.getLogProb(phrase, this);
	}

	@Override
	public abstract float getLogProb(long contextOffset, int contextOrder, int word, @OutputParameter LmContextInfo outputContext);

	@Override
	public abstract LmContextInfo getOffsetForNgram(int[] ngram, int startPos, int endPos);

	@Override
	public abstract int[] getNgramForOffset(long contextOffset, int contextOrder, int word);

}

#No. 1369
#File: E:\bishe\1\AbstractContextMojo.java
#Comment:
    /**
     * The root spring config location.
     */

#Code:
    @Parameter(required = true,property = "maven-lint.config.location",defaultValue = "config/maven_lint.xml")
    private String configLocation;

    private final GenericApplicationContext applicationContext = new GenericApplicationContext();

    protected void initializeConfig() throws DependencyResolutionRequiredException, IOException {

        List<String> testClasspathElements = project.getTestClasspathElements();
        URL[] testUrls = new URL[testClasspathElements.size()];
        for (int i = 0; i < testClasspathElements.size(); i++) {
            String element = testClasspathElements.get(i);
            testUrls[i] = new File(element).toURI().toURL();
        }

        URLClassLoader classLoader = new URLClassLoader(testUrls, Thread.currentThread().getContextClassLoader());
        ClassPathResource classPathResource = new ClassPathResource(configLocation, classLoader);

        XmlBeanDefinitionReader xmlBeanDefinitionReader = new XmlBeanDefinitionReader(applicationContext);
        xmlBeanDefinitionReader.loadBeanDefinitions(classPathResource);

        applicationContext.getBeanFactory().registerSingleton("log", getLog());
        applicationContext.refresh();
    }

#No. 1370
#File: E:\bishe\1\AbstractControlConnector.java
#Comment:
	/**
	 * Deferred state change where layers have been created and added
	 * 
	 * @param stateChangeEvent
	 */

#Code:
	protected void doStateChange(StateChangeEvent stateChangeEvent) {

	}

#No. 1371
#File: E:\bishe\1\AbstractControllableView.java
#Comment:
/**
 * This is an abstract base class for {@link ControllableView} implementations.
 * 
 * @author Petter Holmström
 * @since 1.0
 * 
 * @param <V>
 *            the type of the View.
 * @param <P>
 *            the type of the Presenter.
 */

#Code:
@Deprecated
public abstract class AbstractControllableView<V extends ControllableView, P extends ControllablePresenter<V>>
		extends AbstractView<V, P> implements ControllableView {

	private static final long serialVersionUID = 6769129811745901667L;

	private ViewController viewController;

	/**
	 * Creates a new <code>AbstractControllableView</code>, but does NOT
	 * initialize it. It has to be initialized later by calling {@link #init()}.
	 * This constructor is useful if any resources need to be injected into the
	 * view before it is initialized.
	 */
	public AbstractControllableView() {
		super();
	}

	/**
	 * Creates a new <code>AbstractControllableView</code> and optionally
	 * initializes it by calling {@link #init()}.
	 * 
	 * @param initialize
	 *            true to initialize the view directly, false to manually
	 *            initialize it later.
	 */
	public AbstractControllableView(boolean initialize) {
		super(initialize);
	}

	@Override
	public ViewController getViewController() {
		return viewController;
	}

	/**
	 * {@inheritDoc}
	 * <p>
	 * This implementation updates the {@link #getViewController()
	 * viewController} property, then delegates to

#No. 1372
#File: E:\bishe\1\AbstractControllableView.java
#Comment:
	/**
	 * This method is called by
	 * {@link #showView(ViewController, Map, ControllableView, Direction)} after
	 * the view controller has been set. This implementation does nothing,
	 * subclasses may override.
	 * 
	 * @see #getViewController().
	 */

#Code:
	protected void doShowView(Map<String, Object> userData,
			ControllableView oldView, Direction direction) {
	}

#No. 1373
#File: E:\bishe\1\AbstractControllableView.java
#Comment:
	/**
	 * {@inheritDoc}
	 * <p>
	 * This implementation delegates to
	 * {@link #doHideView(ControllableView, Direction)}. If the returned
	 * {@link ControllableView.HideOperation} allows the operation, the
	 * {@link #getViewController() viewController} property is reset to
	 * <code>null</code>.
	 */

#Code:
	@Override
	public final HideOperation hideView(ViewController viewController,
			ControllableView newView, Direction direction) {
		if (getViewController() == null
				|| getViewController() != viewController) {
			throw new IllegalStateException(
					"View is already controlled by another controller "
							+ "or is not controlled at all");
		}
		HideOperation operation = doHideView(newView, direction);
		if (direction == Direction.BACKWARD && operation == HideOperation.ALLOW_WITHOUT_FORWARD_NAVIGATION) {
			this.viewController = null;
		}
		return operation;
	}

#No. 1374
#File: E:\bishe\1\AbstractControllableView.java
#Comment:
	/**
	 * This method is called by
	 * {@link #hideView(ViewController, ControllableView, Direction)} before the
	 * view controller has been reset. This implementation always returns
	 * <code>ALLOW_WITHOUT_FORWARD_NAVIGATION</code>, subclasses may override.
	 * 
	 * @see #getViewController()
	 */

#Code:
	protected HideOperation doHideView(ControllableView newView,
			Direction direction) {
		return HideOperation.ALLOW_WITHOUT_FORWARD_NAVIGATION;
	}

#No. 1375
#File: E:\bishe\1\AbstractControlPropertyListenerHandleTest.java
#Comment:
	/**
	 * Creates the tested {@link ControlPropertyListenerHandle}. It will operate on {@link #properties}, listen to
	 * {@link #LISTENED_KEY} and values of type {@link String}. The created listener is initially
	 * {@link CreateListenerHandle#DETACHED detached}.
	 *
	 * @param valueProcessor
	 *            the {@link Consumer} for the key's string values
	 * @return the created {@link ControlPropertyListenerHandle}
	 */

#Code:
	private ControlPropertyListenerHandle createDetachedDefaultListener(Consumer<? super String> valueProcessor) {
		return createListener(properties, LISTENED_KEY, String.class, valueProcessor, CreateListenerHandle.DETACHED);
	}

#No. 1376
#File: E:\bishe\1\AbstractControlPropertyListenerHandleTest.java
#Comment:
	/**
	 * Creates the tested {@link ControlPropertyListenerHandle}. It will operate on {@link #properties}, listen to
	 * {@link #LISTENED_KEY} and values of type {@link String}. The created listener is initially
	 * {@link CreateListenerHandle#ATTACHED attached}.
	 *
	 * @param valueProcessor
	 *            the {@link Consumer} for the key's string values
	 * @return the created {@link ControlPropertyListenerHandle}
	 */

#Code:
	private ControlPropertyListenerHandle createAttachedDefaultListener(Consumer<? super String> valueProcessor) {
		return createListener(properties, LISTENED_KEY, String.class, valueProcessor, CreateListenerHandle.ATTACHED);
	}

#No. 1377
#File: E:\bishe\1\AbstractControlPropertyListenerHandleTest.java
#Comment:
	/**
	 * Tests whether the listener correctly processes a value for the correct key if the listener is initially attached.
	 */

#Code:
	@Test
	public void testSettingListenedKeyOnceWhenInitiallyAttached() {
		// setup
		createAttachedDefaultListener(valueProcessor);

		// put a value
		String addedValue = "This value is put into the map.";
		properties.put(LISTENED_KEY, addedValue);

		// check
		verify(valueProcessor, times(1)).accept(addedValue);
		verifyNoMoreInteractions(valueProcessor);
	}

#No. 1378
#File: E:\bishe\1\AbstractControlPropertyListenerHandleTest.java
#Comment:
	/**
	 * Tests whether the listener correctly processes a value for the correct key.
	 */

#Code:
	@Test
	public void testSettingListenedKeyOnceWhenAttachedAfterConstruction() {
		// setup
		ControlPropertyListenerHandle listenerHandle = createDetachedDefaultListener(valueProcessor);
		listenerHandle.attach();

		// put a value
		String addedValue = "This value is put into the map.";
		properties.put(LISTENED_KEY, addedValue);

		// check
		verify(valueProcessor, times(1)).accept(addedValue);
		verifyNoMoreInteractions(valueProcessor);
	}

#No. 1379
#File: E:\bishe\1\AbstractControlPropertyListenerHandleTest.java
#Comment:
	/**
	 * Tests whether the listener correctly processes setting the same value multiple times for the correct key.
	 */

#Code:
	@Test
	public void testSettingListenedKeyRepeatedly() {
		// setup
		createAttachedDefaultListener(valueProcessor);

		// put the same value over and over
		String addedValue = "This value is put into the map.";
		for (int i = 0; i < 10; i++)
			properties.put(LISTENED_KEY, addedValue);

		// check
		verify(valueProcessor, times(10)).accept(addedValue);
		verifyNoMoreInteractions(valueProcessor);
	}

#No. 1380
#File: E:\bishe\1\AbstractControlPropertyListenerHandleTest.java
#Comment:
	/**
	 * Tests whether the listener correctly processes setting multiple random values.
	 */

#Code:
	@Test
	public void testSettingListenedKeyRandomly() {
		// setup
		Property<String> listenedValue = new SimpleStringProperty();
		createAttachedDefaultListener(listenedValue::setValue);

		// put and check some random values
		Random random = new Random();
		for (int i = 0; i < 10; i++) {
			// create a random string
			byte[] bytes = new byte[256];
			random.nextBytes(bytes);
			String addedValue = new String(bytes);
			// put and check
			properties.put(LISTENED_KEY, addedValue);
			assertSame(addedValue, listenedValue.getValue());
		}
	}

#No. 1381
#File: E:\bishe\1\AbstractControlPropertyListenerHandleTest.java
#Comment:
	/**
	 * Tests whether the listener ignores values of the wrong type.
	 */

#Code:
	@Test
	public void testSettingListenedKeyOfWrongType() {
		Consumer<Integer> valueProcessorWhichFailsTestWhenCalled = any -> fail();
		// setup
		createListener(properties, LISTENED_KEY, Integer.class,
				valueProcessorWhichFailsTestWhenCalled, CreateListenerHandle.ATTACHED);

		// put a value of the wrong type
		properties.put(LISTENED_KEY, "some non integer");
	}

#No. 1382
#File: E:\bishe\1\AbstractControlPropertyListenerHandleTest.java
#Comment:
	/**
	 * Tests whether the listener ignores values for other keys.
	 */

#Code:
	@Test
	public void testSettingIgnoredKey() {
		// setup
		ControlPropertyListenerHandle listenerHandle =
				createDetachedDefaultListener(valueProcessorWhichFailsTestWhenCalled);
		listenerHandle.attach();

		// put a value for a key to which the listener does not listen
		properties.put(IGNORED_KEY, "some value");
	}

#No. 1383
#File: E:\bishe\1\AbstractControlPropertyListenerHandleTest.java
#Comment:
	/**
	 * Tests whether the listener correctly processes a value which already existed in the map before it was attached.
	 */

#Code:
	@Test
	public void testProcessingPresentValueOnAttach() {
		// setup
		ControlPropertyListenerHandle listenerHandle = createDetachedDefaultListener(valueProcessor);
		String existingValue = "some existing value";
		properties.put(LISTENED_KEY, existingValue);

		// this should trigger processing the value
		listenerHandle.attach();

		verify(valueProcessor, times(1)).accept(existingValue);
		verifyNoMoreInteractions(valueProcessor);
	}

#No. 1384
#File: E:\bishe\1\AbstractControlPropertyListenerHandleTest.java
#Comment:
	/**
	 * Tests whether the listener ignores values after it was detached.
	 */

#Code:
	@Test
	public void testDetachWhenInitiallyAttached() {
		// setup
		ControlPropertyListenerHandle listenerHandle =
				createAttachedDefaultListener(valueProcessorWhichFailsTestWhenCalled);
		listenerHandle.detach();

		// put a value of the correct type for the listened key
		properties.put(LISTENED_KEY, "some value");
	}

#No. 1385
#File: E:\bishe\1\AbstractControlPropertyListenerHandleTest.java
#Comment:
	/**
	 * Tests whether the listener ignores values after it was detached.
	 */

#Code:
	@Test
	public void testDetachAfterAttach() {
		// setup
		ControlPropertyListenerHandle listenerHandle =
				createDetachedDefaultListener(valueProcessorWhichFailsTestWhenCalled);
		listenerHandle.attach();
		listenerHandle.detach();

		// put a value of the correct type for the listened key
		properties.put(LISTENED_KEY, "some value");
	}

#No. 1386
#File: E:\bishe\1\AbstractControlPropertyListenerHandleTest.java
#Comment:
	/**
	 * Tests whether the listener ignores values after it was detached repeatedly.
	 */

#Code:
	@Test
	public void testMultipleDetach() {
		// setup
		ControlPropertyListenerHandle listenerHandle =
				createDetachedDefaultListener(valueProcessorWhichFailsTestWhenCalled);
		listenerHandle.attach();
		listenerHandle.detach();
		listenerHandle.detach();
		listenerHandle.detach();

		// put a value of the correct type for the listened key
		properties.put(LISTENED_KEY, "some value");
	}

#No. 1387
#File: E:\bishe\1\AbstractControlPropertyListenerHandleTest.java
#Comment:
	/**
	 * Tests whether the listener processes values after it was detached and then reattached.
	 */

#Code:
	@Test
	public void testReattach() {
		// setup
		ControlPropertyListenerHandle listenerHandle = createDetachedDefaultListener(valueProcessor);
		listenerHandle.attach();
		listenerHandle.detach();
		listenerHandle.attach();

		// put a value of the correct type for the listened key
		String addedValue = "This value is put into the map.";
		properties.put(LISTENED_KEY, addedValue);

		// check
		verify(valueProcessor, times(1)).accept(addedValue);
		verifyNoMoreInteractions(valueProcessor);
	}

#No. 1388
#File: E:\bishe\1\AbstractControlPropertyListenerHandleTest.java
#Comment:
	/**
	 * Tests whether the listener is only called once even when attached is called repeatedly.
	 */

#Code:
	@Test
	public void testMultipleAttach() {
		ControlPropertyListenerHandle listenerHandle = createDetachedDefaultListener(valueProcessor);
		listenerHandle.attach();
		listenerHandle.attach();
		listenerHandle.attach();

		// put a value of the correct type for the listened key
		String addedValue = "Some value...";
		properties.put(LISTENED_KEY, addedValue);

		// check
		verify(valueProcessor, times(1)).accept(addedValue);
		verifyNoMoreInteractions(valueProcessor);
	}

#No. 1389
#File: E:\bishe\1\AbstractCoreZipLibrary.java
#Comment:
	/**
	 * Returns the file path; extracts the file on demand
	 * @param zipFile
	 * @param entry
	 * @param zipLastModified
	 * @return
	 */

#Code:
	protected String getJsFilePath(ZipFile zipFile, ZipEntry entry, long zipLastModified) throws IOException {
		final IPath path = ExtJSCore.getDefault().getStateLocation().append(".jscore").append(this.getName()).append(entry.getName());
		final File file = path.toFile();
		if (!file.getParentFile().exists()) {
			if (!file.getParentFile().mkdirs()) {
				throw new IOException("Unable to create dir " + file.getParent());
			}
		}
		
		final long lastModified = entry.getTime() < 0 ? zipLastModified : entry.getTime();
		
		if (file.exists() && file.lastModified() < lastModified) {
			file.delete();
		}
		if (!file.exists()) {
			// extract file
			final byte[] buf = new byte[1024*32];
			final InputStream is = zipFile.getInputStream(entry);
			final FileOutputStream fos = new FileOutputStream(file);
			try {
				int bytesRead = 0;
				while ((bytesRead = is.read(buf)) > 0) {
					fos.write(buf, 0, bytesRead);
				}
				fos.flush();
			}
			catch (IOException ex) {
				throw ex;
			}
			finally {
				if (fos != null) {
					fos.close();
				}
				if (is != null) {
					is.close();
				}
			}
		}
		return file.getAbsolutePath();
	}

#No. 1390
#File: E:\bishe\1\AbstractCosmoAccountActivator.java
#Comment:
/**
     * Given an activation token, look up and return a user.
     *
     * @param activationToken
     * @throws DataRetrievalFailureException if the token does
     * not correspond to any users
     */

#Code:
    public User getUserFromToken(String activationToken){
        return this.userDao.getUserByActivationId(activationToken);
    }

#No. 1391
#File: E:\bishe\1\AbstractCosmoAccountActivator.java
#Comment:
    /**
     * Determines whether or not activation is required.
     */

#Code:
    public boolean isRequired() {
        return required;
    }

#No. 1392
#File: E:\bishe\1\AbstractCPUMetricTest.java
#Comment:
    /**
     * Test of getMetric method, of class AbstractCPUMetric.
     */

#Code:
    public void testGetMetric() {
        System.out.println("getMetric");
        SigarProxy sigar = null;
        MetricParamsSigar metricParams = MetricParamsSigar.createFromString("", sigar);
        AbstractCPUMetric result = AbstractCPUMetric.getMetric(sigar, metricParams);
        assertNotNull(result);
    }

#No. 1393
#File: E:\bishe\1\AbstractCqlConfiguration.java
#Comment:
	/**
	 * Return keyspace attributes
	 * 
	 * @return KeyspaceAttributes
	 */

#Code:
	public KeyspaceAttributes getKeyspaceAttributes() {
		return new KeyspaceAttributes();
	}

#No. 1394
#File: E:\bishe\1\AbstractCqlConfiguration.java
#Comment:
	/**
	 * Creates a {@link Session} to be used by the {@link CqlTemplate}. Will use the {@link Cluster} instance configured
	 * in {@link #cluster()}.
	 * 
	 * @see #cluster()
	 * @see #Keyspace()
	 * @return Session
	 */

#Code:
	@Bean
	public CqlSessionFactoryBean session() throws Exception {
		CqlSessionFactoryBean factory = new CqlSessionFactoryBean();
		factory.setKeyspace(getKeyspace());
		factory.setCluster(cluster().getObject());
		factory.setKeyspaceAttributes(getKeyspaceAttributes());
		return factory;
	}

#No. 1395
#File: E:\bishe\1\AbstractCqlConfiguration.java
#Comment:
	/**
	 * Creates a {@link CqlTemplate}.
	 * 
	 * @return CqlOperations
	 */

#Code:
	@Bean
	public CqlTemplateFactoryBean template() throws Exception {
		CqlTemplateFactoryBean factory = new CqlTemplateFactoryBean();
		factory.setKeyspace(getKeyspace());
		factory.setSession(session().getObject());
		return factory;
	}

#No. 1396
#File: E:\bishe\1\AbstractCreateStatement.java
#Comment:
    /**
     * Add the 'IF NOT EXISTS' condition to this CREATE statement.
     *
     * @return this CREATE statement.
     */

#Code:
    public T ifNotExists() {
        this.ifNotExists = true;
        return self;
    }

#No. 1397
#File: E:\bishe\1\AbstractCreateStatement.java
#Comment:
    /**
     * Add a column definition to this CREATE statement.
     *
     * <p>
     * To add a list column:
     * <pre class="code"><code class="java">
     *     addColumn("myList",DataType.list(DataType.text()))
     * </code></pre>
     *
     * To add a set column:
     * <pre class="code"><code class="java">
     *     addColumn("mySet",DataType.set(DataType.text()))
     * </code></pre>
     *
     * To add a map column:
     * <pre class="code"><code class="java">
     *     addColumn("myMap",DataType.map(DataType.cint(),DataType.text()))
     * </code></pre>
     *
     * @param columnName the name of the column to be added.
     * @param dataType the data type of the column to be added.
     * @return this CREATE statement.
     */

#Code:
    public T addColumn(String columnName, DataType dataType) {
        validateNotEmpty(columnName, "Column name");
        validateNotNull(dataType, "Column type");
        validateNotKeyWord(columnName, String.format("The column name '%s' is not allowed because it is a reserved keyword", columnName));
        simpleColumns.put(columnName, new NativeColumnType(dataType));
        return self;
    }

#No. 1398
#File: E:\bishe\1\AbstractCreateStatement.java
#Comment:
    /**
     * Add a column definition to this CREATE statement, when the type contains a UDT.
     *
     * @param columnName the name of the column to be added.
     * @param udtType the UDT type of the column to be added. Use {@link SchemaBuilder#frozen(String)} or {@link SchemaBuilder#udtLiteral(String)}.
     * @return this CREATE statement.
     */

#Code:
    public T addUDTColumn(String columnName, UDTType udtType) {
        validateNotEmpty(columnName, "Column name");
        validateNotNull(udtType, "Column type");
        validateNotKeyWord(columnName, String.format("The column name '%s' is not allowed because it is a reserved keyword", columnName));
        simpleColumns.put(columnName, udtType);
        return self;
    }

#No. 1399
#File: E:\bishe\1\AbstractCreateStatement.java
#Comment:
    /**
     * Shorthand to add a column definition to this CREATE statement, when the type is a list of UDT.
     *
     * @param columnName the name of the column to be added
     * @param udtType the udt type of the column to be added. Use {@link SchemaBuilder#frozen(String)}.
     * @return this CREATE statement.
     */

#Code:
    public T addUDTListColumn(String columnName, UDTType udtType) {
        validateNotEmpty(columnName, "Column name");
        validateNotNull(udtType, "Column element type");
        validateNotKeyWord(columnName, String.format("The column name '%s' is not allowed because it is a reserved keyword", columnName));
        simpleColumns.put(columnName, UDTType.list(udtType));
        return self;
    }

#No. 1400
#File: E:\bishe\1\AbstractCreateStatement.java
#Comment:
    /**
     * Shorthand to add a column definition to this CREATE statement, when the type is a set of UDT.
     *
     * @param columnName the name of the column to be added
     * @param udtType the udt type of the column to be added. Use {@link SchemaBuilder#frozen(String)}.
     * @return this CREATE statement.
     */

#Code:
    public T addUDTSetColumn(String columnName, UDTType udtType) {
        validateNotEmpty(columnName, "Column name");
        validateNotNull(udtType, "Column element type");
        validateNotKeyWord(columnName, String.format("The column name '%s' is not allowed because it is a reserved keyword", columnName));
        simpleColumns.put(columnName, UDTType.set(udtType));
        return self;
    }

#No. 1401
#File: E:\bishe\1\AbstractCreateStatement.java
#Comment:
    /**
     * Shorthand to add a column definition to this CREATE statement, when the type is a map with a UDT value type.
     * <p>
     * Example:
     * <pre>
     *     addUDTMapColumn("addresses", DataType.text(), frozen("address"));
     * </pre>
     *
     * @param columnName the name of the column to be added.
     * @param keyType the key type of the column to be added.
     * @param valueUdtType the value UDT type of the column to be added. Use {@link SchemaBuilder#frozen(String)}.
     * @return this CREATE statement.
     */

#Code:
    public T addUDTMapColumn(String columnName, DataType keyType, UDTType valueUdtType) {
        validateNotEmpty(columnName, "Column name");
        validateNotNull(keyType, "Map key type");
        validateNotNull(valueUdtType, "Map value UDT type");
        validateNotKeyWord(columnName, String.format("The column name '%s' is not allowed because it is a reserved keyword", columnName));
        simpleColumns.put(columnName, UDTType.mapWithUDTValue(keyType, valueUdtType));
        return self;
    }

#No. 1402
#File: E:\bishe\1\AbstractCreateStatement.java
#Comment:
    /**
     * Shorthand to add a column definition to this CREATE statement, when the type is a map with a UDT key type.
     * <p>
     * Example:
     * <pre>
     *     addUDTMapColumn("roles", frozen("user"), DataType.text());
     * </pre>
     *
     * @param columnName the name of the column to be added.
     * @param udtKeyType the key UDT type of the column to be added. Use {@link SchemaBuilder#frozen(String)}.
     * @param valueType the value raw type of the column to be added.
     * @return this CREATE statement.
     */

#Code:
    public T addUDTMapColumn(String columnName, UDTType udtKeyType, DataType valueType) {
        validateNotEmpty(columnName, "Column name");
        validateNotNull(udtKeyType, "Map key UDT type");
        validateNotNull(valueType, "Map value type");
        validateNotKeyWord(columnName, String.format("The column name '%s' is not allowed because it is a reserved keyword", columnName));
        simpleColumns.put(columnName, UDTType.mapWithUDTKey(udtKeyType, valueType));
        return self;
    }

#No. 1403
#File: E:\bishe\1\AbstractCreateStatement.java
#Comment:
    /**
     * Shorthand to add a column definition to this CREATE statement, when the type is a map with UDT key and value types.
     * <p>
     * Example:
     * <pre>
     *     addUDTMapColumn("users", frozen("user"), frozen("address"));
     * </pre>
     *
     * @param columnName the name of the column to be added.
     * @param udtKeyType the key UDT type of the column to be added. Use {@link SchemaBuilder#frozen(String)}.
     * @param udtValueType the value UDT type of the column to be added. Use {@link SchemaBuilder#frozen(String)}.
     * @return this CREATE statement.
     *
     */

#Code:
    public T addUDTMapColumn(String columnName, UDTType udtKeyType, UDTType udtValueType) {
        validateNotEmpty(columnName, "Column name");
        validateNotNull(udtKeyType, "Map key UDT type");
        validateNotNull(udtValueType, "Map value UDT type");
        validateNotKeyWord(columnName, String.format("The column name '%s' is not allowed because it is a reserved keyword", columnName));
        simpleColumns.put(columnName, UDTType.mapWithUDTKeyAndValue(udtKeyType, udtValueType));
        return self;
    }

#No. 1404
#File: E:\bishe\1\AbstractCreative.java
#Comment:
    /**
     *
     */

#Code:
    protected static final long serialVersionUID = -4025356052316263961L;

    public AbstractCreative() {
        // ignore
    }

#No. 1405
#File: E:\bishe\1\AbstractCredentialCollector.java
#Comment:
  /**
   * 
   */

#Code:
  public AbstractCredentialCollector() {
    super();
  }

#No. 1406
#File: E:\bishe\1\AbstractCSSClassNameOrIdTraverser.java
#Comment:
	/**
	 * s
	 * 
	 */

#Code:
	protected short preNode(ICSSNode node) {
		short ret;
		if (node instanceof ICSSStyleRule) {
			traverseRule((ICSSStyleRule) node);
			ret = TRAV_PRUNE;
		} else if (node instanceof ICSSStyleSheet
				|| node instanceof ICSSMediaRule
				|| node instanceof ICSSImportRule) {
			ret = TRAV_CONT;
		} else {
			ret = TRAV_PRUNE;
		}
		return ret;
	}

#No. 1407
#File: E:\bishe\1\AbstractCSVMessageBodyWriter.java
#Comment:
/**
 * TODO: Javadoc
 * 
 * @author Benjamin Pross
 */

#Code:
@Produces(MediaTypes.TEXT_CSV)
public abstract class AbstractCSVMessageBodyWriter<T> implements
		MessageBodyWriter<T>, CSVTrackEncoder<T> {

    private final Class<T> classType;

    public AbstractCSVMessageBodyWriter(Class<T> classType) {
        this.classType = classType;
    }
    
	public abstract InputStream encodeCSV(T t, MediaType mt);

	@Override
	public long getSize(T t, Class<?> type, Type genericType, Annotation[] annotations,
			MediaType mediaTyp) {
		return -1;
	}

	@Override
	public boolean isWriteable(Class<?> type, Type genericType, Annotation[] annotations,
			MediaType mediaType) {
        return this.classType.isAssignableFrom(type) &&
                mediaType.isCompatible(MediaTypes.TEXT_CSV_TYPE);
	}

	@Override
	public void writeTo(T t, Class<?> type, Type genericType, Annotation[] annotations,
			MediaType mediaType, MultivaluedMap<String, Object> h,
			OutputStream out) throws IOException, WebApplicationException {
		
		InputStream inputStream = encodeCSV(t, mediaType);
		
		IOUtils.copy(inputStream, out);
		
	}

}

#No. 1408
#File: E:\bishe\1\AbstractCSVTrackEncoder.java
#Comment:
/**
 * TODO JavaDoc
 *
 * @author Benjamin Pross
 */

#Code:
public abstract class AbstractCSVTrackEncoder<T>
        extends AbstractCSVMessageBodyWriter<T>
        implements CSVTrackEncoder<T> {
    private DateTimeFormatter dateTimeFormat;
    private Provider<AccessRights> rights;

    public AbstractCSVTrackEncoder(Class<T> classType) {
        super(classType);
    }

    public DateTimeFormatter getDateTimeFormat() {
        return dateTimeFormat;
    }

    @Inject
    public void setDateTimeFormat(DateTimeFormatter dateTimeFormat) {
        this.dateTimeFormat = dateTimeFormat;
    }

    @Inject
    public void setRights(Provider<AccessRights> rights) {
        this.rights = rights;
    }

    @Override
    public InputStream encodeCSV(T t, MediaType mt) {
        return encodeCSV(t, rights.get(), mt);
    }
}

#No. 1409
#File: E:\bishe\1\AbstractCursorLoader.java
#Comment:
  /** 
   * Runs on a worker thread, loading in our data. Delegates
   * the real work to concrete subclass' buildCursor() method. 
   */

#Code:
  @Override
  public Cursor loadInBackground() {
    Cursor cursor=buildCursor();

    if (cursor!=null) {
      // Ensure the cursor window is filled
      cursor.getCount();
    }
    
    return(cursor);
  }

#No. 1410
#File: E:\bishe\1\AbstractCursorLoader.java
#Comment:
  /**
   * Runs on the UI thread, routing the results from the
   * background thread to whatever is using the Cursor
   * (e.g., a CursorAdapter).
   */

#Code:
  @Override
  public void deliverResult(Cursor cursor) {
    if (isReset()) {
      // An async query came in while the loader is stopped
      if (cursor!=null) {
        cursor.close();
      }
      
      return;
    }
    
    Cursor oldCursor=lastCursor;
    lastCursor=cursor;

    if (isStarted()) {
      super.deliverResult(cursor);
    }

    if (oldCursor!=null && oldCursor!=cursor && !oldCursor.isClosed()) {
      oldCursor.close();
    }
  }

#No. 1411
#File: E:\bishe\1\AbstractCursorLoader.java
#Comment:
  /**
   * Starts an asynchronous load of the list data.
   * When the result is ready the callbacks will be called
   * on the UI thread. If a previous load has been completed
   * and is still valid the result may be passed to the
   * callbacks immediately.
   * 
   * Must be called from the UI thread.
   */

#Code:
  @Override
  protected void onStartLoading() {
    if (lastCursor!=null) {
      deliverResult(lastCursor);
    }
    
    if (takeContentChanged() || lastCursor==null) {
      forceLoad();
    }
  }

#No. 1412
#File: E:\bishe\1\AbstractCursorLoader.java
#Comment:
  /**
   * Must be called from the UI thread, triggered by a
   * call to stopLoading().
   */

#Code:
  @Override
  protected void onStopLoading() {
    // Attempt to cancel the current load task if possible.
    cancelLoad();
  }

#No. 1413
#File: E:\bishe\1\AbstractCursorLoader.java
#Comment:
  /**
   * Must be called from the UI thread, triggered by a
   * call to cancel(). Here, we make sure our Cursor
   * is closed, if it still exists and is not already closed.
   */

#Code:
  @Override
  public void onCanceled(Cursor cursor) {
    if (cursor!=null && !cursor.isClosed()) {
      cursor.close();
    }
  }

#No. 1414
#File: E:\bishe\1\AbstractCursorLoader.java
#Comment:
  /**
   * Must be called from the UI thread, triggered by a
   * call to reset(). Here, we make sure our Cursor
   * is closed, if it still exists and is not already closed.
   */

#Code:
  @Override
  protected void onReset() {
    super.onReset();

    // Ensure the loader is stopped
    onStopLoading();

    if (lastCursor!=null && !lastCursor.isClosed()) {
      lastCursor.close();
    }
    
    lastCursor=null;
  }

#No. 1415
#File: E:\bishe\1\AbstractCursor_Assert.java
#Comment:
/**
 * Assertions for {@link AbstractCursor} instances.
 * <p>
 * This class is final. To extend use {@link AbstractAbstractCursorAssert}.
 */

#Code:
public final class AbstractCursor_Assert
    extends AbstractAbstractCursorAssert<AbstractCursor_Assert, AbstractCursor> {
  public AbstractCursor_Assert(AbstractCursor actual) {
    super(actual, AbstractCursor_Assert.class);
  }
}

#No. 1416
#File: E:\bishe\1\AbstractCvs.java
#Comment:
    /**
     * JENKINS-18390: work around buggy client.
     * Cannot copy similarly-named method from {@link UpdateCommand} due to license mismatch.
     * Cannot easily call the method reflectively on the {@link Command} since {@link CheckoutCommand} has a different signature for it.
     * Pending a fix in the client library, do it ourselves when necessary.
     */

#Code:
    private static void pruneEmptyDirectories(File d, final TaskListener listener) throws IOException {
        File[] kids = d.listFiles();
        if (kids == null) {
            throw new IOException("could not examine " + d);
        }
        for (File kid : kids) {
            if (!kid.isDirectory()) {
                continue;
            }
            if (!new File(kid, "CVS").isDirectory()) {
                // not CVS-controlled, ignore
                continue;
            }

            if (isSymLink(kid,listener)) {
                listener.getLogger().println("pruneEmptyDirectories. prevent potential infinate loop, ignoring symlink:" + kid);
                continue;
            }

            pruneEmptyDirectories(kid,listener);
            File[] subkids = kid.listFiles();
            if (subkids != null && subkids.length == 1) {
                // Just CVS.
                Util.deleteRecursive(kid);
            }
        }
    }

#No. 1417
#File: E:\bishe\1\AbstractCvs.java
#Comment:
    /**
     * Gets an instance of the CVS client that can be used for connection to a repository. If the
     * repository specifies a password then the client's connection will be set with this password.
     * @param repository the repository to connect to
     * @param envVars variables to use for macro expansion
     * @return a CVS client capable of connecting to the specified repository
     */

#Code:
    public Client getCvsClient(final CvsRepository repository, final EnvVars envVars, final TaskListener listener) {
        return getCvsClient(repository, envVars, listener, true);
    }

#No. 1418
#File: E:\bishe\1\AbstractCvs.java
#Comment:
    /**
     * Calculates the level of compression that should be used for dealing with
     * the given repository.
     * <p>
     * If we're using a local repository then we don't use compression
     * (http://root.cern.ch/root/CVS.html#checkout), if no compression level has
     * been specifically set for this repository then we use the global setting,
     * otherwise we use the one set for this repository.
     *
     * @param repository
     *            the repository we're wanting to connect to
     * @param envVars
     *            the environmental variables to expand any parameters from
     * @return the level of compression to use between 0 and 9 (inclusive), with
     *         0 being no compression and 9 being maximum
     */

#Code:
    private int getCompressionLevel(final CvsRepository repository, final EnvVars envVars) {
        final String cvsroot = envVars.expand(repository.getCvsRoot());

        /*
         * CVS 1.11.22 manual: If the access method is omitted, then if the
         * repository starts with `/', then `:local:' is assumed. If it does not
         * start with `/' then either `:ext:' or `:server:' is assumed.
         */
        boolean local = cvsroot.startsWith("/") || cvsroot.startsWith(":local:") || cvsroot.startsWith(":fork:");

        // Use whatever the user has specified as the system default if the
        // repository doesn't specifically set one
        int compressionLevel = repository.getCompressionLevel() == -1 ? getDescriptor().getCompressionLevel()
                : repository.getCompressionLevel();

        // For local access, compression is senseless (always return 0),
        // otherwise return the calculated value
        return local ? 0 : compressionLevel;
    }

#No. 1419
#File: E:\bishe\1\AbstractCvs.java
#Comment:
    /**
     * Since we add the current SCMRevisionState as an action during the build
     * (so we can get the current workspace state), this method should never be
     * called. Just for safety, we get the action and return it.
     *
     * @see {@link SCM#calcRevisionsFromBuild(hudson.model.AbstractBuild, hudson.Launcher, TaskListener)}
     */

#Code:
    @Override
    public SCMRevisionState calcRevisionsFromBuild(final AbstractBuild<?, ?> build, final Launcher launcher,
                                                   final TaskListener listener) throws IOException, InterruptedException {
        return build.getAction(CvsRevisionState.class);
    }

#No. 1420
#File: E:\bishe\1\AbstractCvs.java
#Comment:
        /*
         * this flag will be used to check whether a build is needed (assuming
         * the local and remote states are comparable and no configuration has
         * changed between the last build and the current one)
         */

#Code:
        boolean changesPresent = false;

        // Schedule a new build if the baseline isn't valid
        if ((baseline == null || !(baseline instanceof CvsRevisionState))) {
            listener.getLogger().println("Invalid baseline detected, scheduling build");
            return new PollingResult(baseline, new CvsRevisionState(new HashMap<CvsRepository, List<CvsFile>>()),
                    PollingResult.Change.INCOMPARABLE);
        }

#No. 1421
#File: E:\bishe\1\AbstractCvs.java
#Comment:
            /*
             * this repository setting either didn't exist or has changed since
             * the last build so we'll force a new build now.
             */

#Code:
            if (!remoteState.containsKey(repository)) {
                listener.getLogger().println("Repository not found in workspace state, scheduling build");
                return new PollingResult(baseline, new CvsRevisionState(new HashMap<CvsRepository, List<CvsFile>>()),
                        PollingResult.Change.INCOMPARABLE);
            }

#No. 1422
#File: E:\bishe\1\AbstractCvs.java
#Comment:
    /**
     * Builds a list of files that have changed in the given repository between
     * any 2 time-stamps. This does not require the workspace to be checked out
     * and does not change the state of any checked out workspace. The list
     * returned does not have any filters set for exclude regions (i.e. it's
     * every file that's changed for the modules being watched).
     *
     * @param startTime
     *            the time-stamp to start filtering changes from
     * @param endTime
     *            the time-stamp to end filtering changes from
     * @param repository
     *            the repository to search for changes in. All modules under
     *            this repository will be checked
     * @param listener
     *            where to send log output
     * @param envVars the environmental variables to perform parameter expansion from
     * @return a list of changed files, including their versions and change
     *         comments
     * @throws IOException
     *             on communication failure (e.g. communication with slaves)
     */

#Code:
    protected List<CvsFile> calculateRepositoryState(final Date startTime, final Date endTime,
                                                     final CvsRepository repository, final TaskListener listener,
                                                     final EnvVars envVars, final FilePath workspace) throws IOException, InterruptedException {
        final List<CvsFile> files = new ArrayList<CvsFile>();

        for (final CvsRepositoryItem item : repository.getRepositoryItems()) {
            for (final CvsModule module : item.getModules()) {
                files.addAll(getRemoteLogForModule(repository, item, module, startTime, endTime, envVars, listener, workspace).getFiles());
            }
        }
        return files;
    }

#No. 1423
#File: E:\bishe\1\AbstractCvs.java
#Comment:
    /**
     * Builds a list of changes that have occurred in the given repository
     * between any 2 time-stamps. This does not require the workspace to be
     * checked out and does not change the state of any checked out workspace.
     * The list returned does not have any filters set for exclude regions (i.e.
     * it's every file that's changed for the modules being watched).
     *
     * @param startTime
     *            the time-stamp to start filtering changes from
     * @param endTime
     *            the time-stamp to end filtering changes from
     * @param repository
     *            the repository to search for changes in. All modules under
     *            this repository will be checked
     * @param listener
     *            where to send log output
     * @param envVars the environmental variables to perform parameter expansion from.
     * @return a list of changed files, including their versions and change
     *         comments
     * @throws IOException
     *             on communication failure (e.g. communication with slaves)
     * @throws InterruptedException
     *             on job cancellation
     */

#Code:
    protected List<CVSChangeLogSet.CVSChangeLog> calculateChangeLog(final Date startTime, final Date endTime,
                                                                    final CvsRepository repository,
                                                                    final TaskListener listener, final EnvVars envVars, FilePath workspace)
            throws IOException, InterruptedException {

        final List<CVSChangeLogSet.CVSChangeLog> changes = new ArrayList<CVSChangeLogSet.CVSChangeLog>();

        for (final CvsRepositoryItem item : repository.getRepositoryItems()) {
            for (final CvsModule module : item.getModules()) {
                changes.addAll(getRemoteLogForModule(repository, item, module, startTime, endTime, envVars, listener, workspace).getChanges());
            }
        }
        return changes;
    }

#No. 1424
#File: E:\bishe\1\AbstractCvs.java
#Comment:
    /**
     * Check if the given file is a symbolic link. Useful for preventing CSV recursing into directories infinitely.
     * @param file name of the file to test
     * @return whether the file if believed to be a symlink or not
     */

#Code:
    public static boolean isSymLink(File file, final TaskListener listener) {
        if (file == null) {
            return false;
        }
        try {
            File canon;
            if (file.getParent() == null) {
                canon = file;
            } else {
                File canonDir = file.getParentFile().getCanonicalFile();
                canon = new File(canonDir, file.getName());
            }
            return !canon.getCanonicalFile().equals(canon.getAbsoluteFile());
        } catch (IOException ex) { 
            ex.printStackTrace(listener.error("Ignoring exception when checking for symlink. file:" + 
                                              file + " exception:" + ex.getMessage()));
        }
        return false;
    }

#No. 1425
#File: E:\bishe\1\AbstractCvs.java
#Comment:
                /*
                 * we use the remote name because we're actually wanting the
                 * workspace represented as it would be in CVS. This then allows
                 * us to do a comparison against the file list returned by the
                 * rlog command (which wouldn't be possible if we use the local
                 * module name on a module that had been checked out as an alias
                 */

#Code:
                return buildFileList(moduleLocation, envVars.expand(module.getRemoteName()));
            }

			@Override
			public void checkRoles(RoleChecker checker)
					throws SecurityException {
				// Do nothing
			}

#No. 1426
#File: E:\bishe\1\AbstractCyclicAMISettingsPanel.java
#Comment:
    /*
     * Scenario:
     * 1) you set patch A to AMI and you set patch B as its neighbour
     * 2) patch A may already be an AMI patch with another neighbour (let say patch C)
     * 3) patch C should be reset to default type
     */

#Code:
    private void resetOldNeighbourPatch(Dictionary oldDict, Dictionary newDict) {
        if (oldDict.found(NEIGHBOUR_PATCH_KEY)) {
            String oldNeighbourPatchName = oldDict.lookup(NEIGHBOUR_PATCH_KEY);
            if (newDict.found(NEIGHBOUR_PATCH_KEY)) {
                String newNeighbourPatchName = newDict.lookup(NEIGHBOUR_PATCH_KEY);
                if (oldNeighbourPatchName.equals(newNeighbourPatchName)) {
                    // Same neighbour = nothing to do
                    return;
                } else {
                    Patch neighbourPatch = model.getPatches().toMap().get(oldNeighbourPatchName);
                    if (neighbourPatch != null && neighbourPatch.getPhysicalType().isCyclicAMI()) {
                        neighbourPatch.resetToDefault();
                    }
                }
            } else {
                Patch neighbourPatch = model.getPatches().toMap().get(oldNeighbourPatchName);
                if (neighbourPatch != null && neighbourPatch.getPhysicalType().isCyclicAMI()) {
                    neighbourPatch.resetToDefault();
                }
            }
        }
    }

#No. 1427
#File: E:\bishe\1\AbstractCyclicAMISettingsPanel.java
#Comment:
    /*
     * Scenario:
     * 1) you set patch A to AMI and you set patch B as its neighbour
     * 2) patch B may already be an AMI patch with its own neighbour (let say patch C)
     * 3) patch C should be reset to default type because you cannot have 2 patches with the same neighbour (patch B)
     * 4) of course only if patch C != patch A
     */

#Code:
    private void resetNeighbourOfNeighbourIfAny(Patch neighbourPatch, String patchName) {
        if (neighbourPatch.getPhysicalType().isCyclicAMI() && neighbourPatch.getDictionary().found(NEIGHBOUR_PATCH_KEY)) {
            String neighbour2PatchName = neighbourPatch.getDictionary().lookup(NEIGHBOUR_PATCH_KEY);
            if (neighbour2PatchName.equals(patchName)) {
                // nothing do do
                return;
            } else {
                Patch neighbour2Patch = model.getPatches().toMap().get(neighbour2PatchName);
                if (neighbour2Patch != null) {
                    neighbour2Patch.resetToDefault();
                }
            }

        }
    }

#No. 1428
#File: E:\bishe\1\AbstractDAOImple.java
#Comment:
    /**
     * copy file from xmlpath to newpath
     * 
     * @param xmlpath : the file to copy
     * @param newpath : the file copy to
     * @return true for copy success, or false for fail.
     */

#Code:
    protected boolean fileCopy(String xmlpath, String newpath) {
        int length = 1024 * 1024; //1MB
        try {
            FileInputStream in = new FileInputStream(xmlpath);
            FileOutputStream out = new FileOutputStream(newpath);
            FileChannel inC = in.getChannel();
            FileChannel outC = out.getChannel();
            ByteBuffer b = null;
            while (true) {
                if (inC.position() == inC.size()) {
                    inC.close();
                    outC.close();
                    return true;
                }
                if ((inC.size() - inC.position()) < length) {
                    length = (int) (inC.size() - inC.position());
                }
                b = ByteBuffer.allocateDirect(length);
                inC.read(b);
                b.flip();
                outC.write(b);
                outC.force(false);
            }
        } catch (FileNotFoundException e) {
            logger.error(e.getMessage(), e);
        } catch (IOException e) {
            logger.error(e.getMessage(), e);
        }
        return false;
    }

#No. 1429
#File: E:\bishe\1\AbstractDAOItemAdapter.java
#Comment:
	/**
	 * @deprecated See {@link #getItem(int)}.
	 */

#Code:
	public T getItemDAO(int position)
	{
		if (super.getItem(position) != null)
			return mItemDAO;
		else
			return null;
	}

#No. 1430
#File: E:\bishe\1\AbstractDAOItemAdapter.java
#Comment:
	/**
	 * Answers an appropriately positioned abstract DAO item for the given request.
	 *
	 * @return Positioned DAO item or null if the cursor is invalid.
	 */

#Code:
	public T getItem(int position)
	{
		return getItemDAO(position);
	}

#No. 1431
#File: E:\bishe\1\AbstractDaoService.java
#Comment:
  /**
   * @return the dialect
   */

#Code:
  public String getDialect() {
    return dialect;
  }

#No. 1432
#File: E:\bishe\1\AbstractDaoService.java
#Comment:
  /**
   * @param dialect the dialect to set
   */

#Code:
  public void setDialect(String dialect) {
    this.dialect = dialect;
  }

#No. 1433
#File: E:\bishe\1\AbstractDaoService.java
#Comment:
  /**
   * @return the jdbcTemplate
   */

#Code:
  public JdbcTemplate getJdbcTemplate() {
    return jdbcTemplate;
  }

#No. 1434
#File: E:\bishe\1\AbstractDaoService.java
#Comment:
  /**
   * @return the sourceDialect
   */

#Code:
  public String getSourceDialect() {
    return sourceDialect;
  }

#No. 1435
#File: E:\bishe\1\AbstractDaoService.java
#Comment:
  /**
   * @param sourceDialect the sourceDialect to set
   */

#Code:
  public void setSourceDialect(String sourceDialect) {
    this.sourceDialect = sourceDialect;
  }

#No. 1436
#File: E:\bishe\1\AbstractDaoService.java
#Comment:
  /**
   * @return the sourceName
   */

#Code:
  public String getSourceName() {
    return sourceName;
  }

#No. 1437
#File: E:\bishe\1\AbstractDaoService.java
#Comment:
  /**
   * @param sourceName the sourceName to set
   */

#Code:
  public void setSourceName(String sourceName) {
    this.sourceName = sourceName;
  }

#No. 1438
#File: E:\bishe\1\AbstractDaoService.java
#Comment:
  /**
   * @return the cdmVersion
   */

#Code:
  public String getCdmVersion() {
    return cdmVersion;
  }

#No. 1439
#File: E:\bishe\1\AbstractDaoService.java
#Comment:
  /**
   * @param cdmVersion the cdmVersion to set
   */

#Code:
  public void setCdmVersion(String cdmVersion) {
    this.cdmVersion = cdmVersion;
  }

#No. 1440
#File: E:\bishe\1\AbstractDaoService.java
#Comment:
  /**
   * @return the transactionTemplate
   */

#Code:
  public TransactionTemplate getTransactionTemplate() {
    return transactionTemplate;
  }

#No. 1441
#File: E:\bishe\1\AbstractDaoService.java
#Comment:
  /**
   * @return the transactionTemplateRequiresNew
   */

#Code:
  public TransactionTemplate getTransactionTemplateRequiresNew() {
    return transactionTemplateRequiresNew;
  }

#No. 1442
#File: E:\bishe\1\AbstractDaoService.java
#Comment:
  /**
   * @param transactionTemplateRequiresNew the transactionTemplateRequiresNew to
   * set
   */

#Code:
  public void setTransactionTemplateRequiresNew(TransactionTemplate transactionTemplateRequiresNew) {
    this.transactionTemplateRequiresNew = transactionTemplateRequiresNew;
  }

#No. 1443
#File: E:\bishe\1\AbstractDaoService.java
#Comment:
  /**
   * @return the ohdsiSchema
   */

#Code:
  public String getOhdsiSchema() {
      return ohdsiSchema;
  }

#No. 1444
#File: E:\bishe\1\AbstractDaoSessionTest.java
#Comment:
/**
 * Base class for DAO (master) related testing.
 * 
 * @author Markus
 * 
 * @param <T>
 *            Type of a concrete DAO master
 */

#Code:
public abstract class AbstractDaoSessionTest<T extends AbstractDaoMaster, S extends AbstractDaoSession>
        extends DbTest {

    private final Class<T> daoMasterClass;
    protected T daoMaster;
    protected S daoSession;

    public AbstractDaoSessionTest(Class<T> daoMasterClass) {
        this(daoMasterClass, true);
    }

    public AbstractDaoSessionTest(Class<T> daoMasterClass, boolean inMemory) {
        super(inMemory);
        this.daoMasterClass = daoMasterClass;
    }

	@SuppressWarnings("unchecked")
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        try {
            Constructor<T> constructor = daoMasterClass.getConstructor(Database.class);
            daoMaster = constructor.newInstance(db);

            Method createTableMethod = daoMasterClass.getMethod("createAllTables", Database.class, boolean.class);
            createTableMethod.invoke(null, db, false);
        } catch (Exception e) {
            throw new RuntimeException("Could not prepare DAO session test", e);
        }
        daoSession = (S) daoMaster.newSession();
    }

}
#No. 1445
#File: E:\bishe\1\AbstractDaoTestStringPk.java
#Comment:
/**
 * Base class for DAOs having a String as a PK.
 * 
 * @author Markus
 * 
 * @param <D>
 *            DAO class
 * @param <T>
 *            Entity type of the DAO
 */

#Code:
public abstract class AbstractDaoTestStringPk<D extends AbstractDao<T, String>, T> extends
        AbstractDaoTestSinglePk<D, T, String> {

    public AbstractDaoTestStringPk(Class<D> daoClass) {
        super(daoClass);
    }

    @Override
    protected String createRandomPk() {
        int len = 1 + random.nextInt(30);
        StringBuilder builder = new StringBuilder();
        for (int i = 0; i < len; i++) {
            char c = (char) ('a' + random.nextInt('z' - 'a'));
            builder.append(c);
        }
        return builder.toString();
    }

}

#No. 1446
#File: E:\bishe\1\AbstractDartProcessor.java
#Comment:
  /**
   * Returns {@code true} if the an annotation is found on the given element with the given class
   * name (not fully qualified).
   */

#Code:
  private static boolean hasAnnotationWithName(Element element, String simpleName) {
    for (AnnotationMirror mirror : element.getAnnotationMirrors()) {
      final Element annnotationElement = mirror.getAnnotationType().asElement();
      String annotationName = annnotationElement.getSimpleName().toString();
      if (simpleName.equals(annotationName)) {
        return true;
      }
    }
    return false;
  }

#No. 1447
#File: E:\bishe\1\AbstractDartProcessor.java
#Comment:
  /**
   * Returns {@code true} if an injection is deemed to be required. Returns false when a field is
   * annotated with any annotation named {@code Optional} or {@code Nullable}.
   */

#Code:
  private static boolean isRequiredInjection(Element element) {
    return !hasAnnotationWithName(element, "Nullable") && !hasAnnotationWithName(element,
        "Optional");
  }

#No. 1448
#File: E:\bishe\1\AbstractDartProcessor.java
#Comment:
  /**
   * Returns {@code true} if the an annotation is found on the given element with the given class
   * name (must be a fully qualified class name).
   */

#Code:
  private static boolean hasAnnotationWithFqcn(Element element, String annotationClassNameName) {
    if (element != null) {
      for (AnnotationMirror annotationMirror : element.getAnnotationMirrors()) {
        if (annotationMirror.getAnnotationType()
            .asElement()
            .toString()
            .equals(annotationClassNameName)) {
          return true;
        }
      }
    }
    return false;
  }

#No. 1449
#File: E:\bishe\1\AbstractDartProcessor.java
#Comment:
  /**
   * Returns true if the string is null or 0-length.
   *
   * @param str the string to be examined
   * @return true if str is null or zero length
   */

#Code:
  private static boolean isNullOrEmpty(String str) {
    return str == null || str.trim().length() == 0;
  }

#No. 1450
#File: E:\bishe\1\AbstractDartProcessor.java
#Comment:
  /**
   * Returns true if the string is a valid Java identifier.
   * See <a href="https://docs.oracle.com/cd/E19798-01/821-1841/bnbuk/index.html">Identifiers</a>
   *
   * @param str the string to be examined
   * @return true if str is a valid Java identifier
   */

#Code:
  static boolean isValidJavaIdentifier(String str) {
    if (isNullOrEmpty(str)) {
      return false;
    }
    if (JAVA_KEYWORDS.contains(str)) {
      return false;
    }
    if (!Character.isJavaIdentifierStart(str.charAt(0))) {
      return false;
    }
    for (int i = 1; i < str.length(); i++) {
      if (!Character.isJavaIdentifierPart(str.charAt(i))) {
        return false;
      }
    }
    return true;
  }

#No. 1451
#File: E:\bishe\1\AbstractDatabase.java
#Comment:
    /**
     * Find the loader that supports the source file and use it to load the data
     * into or execute the script against the database.
     *
     * @param logger Used to report errors and raise exceptions.
     * @param source The source file containing data or script.
     */

#Code:
    @Override
    public final void load(final Logger logger, final Source source) {
        if (source == null) {
            final String message = MessageUtil.getMessage(UNSUPPORTED_FILE_TYPE, "null");
            logger.logError(message);
        } else {
            final Loader[] loaders = getLoaders();
            int i = 0;
            while (i < loaders.length) {
                if (loaders[i].isSupported(logger, source)) {
                    loaders[i].load(logger, this, source);
                    break;
                }
                ++i;
            }
            if (i >= loaders.length) {
                final String message = MessageUtil.getMessage(UNSUPPORTED_FILE_TYPE, source.getSourceFile());
                logger.logError(message);
            }
        }
    }

#No. 1452
#File: E:\bishe\1\AbstractDatabaseObject.java
#Comment:
    /**
     * Converts a boolean to the SQL equivalent
     *
     * @param value that wants to be converted.
     * @return <code>int</code> with the boolean conversion.
     */

#Code:
    protected static int convertBooleanSqlite(final boolean value) {
        return value ? TRUE : FALSE;
    }

#No. 1453
#File: E:\bishe\1\AbstractDatabaseObject.java
#Comment:
    /**
     * Converts an object to a string that can be inserted inside an SQL sentence.
     *
     * @param value that wants to be inserted in a sql sentence.
     * @return {@link java.lang.String} with a valid SQLString
     */

#Code:
    @NonNull
    protected static String convertToSqlString(@Nullable final Object value) {
        if (value == null) {
            return NULL;
        }

#No. 1454
#File: E:\bishe\1\AbstractDatabaseObject.java
#Comment:
    /**
     * Converts an Integer to a SQL equivalent.
     *
     * @param value that wants to be converted.
     * @return {@link java.lang.String} with a valid SQLInteger
     */

#Code:
    @NonNull
    protected static String convertToSqlInteger(@Nullable final Integer value) {
        if (value == null) {
            return NULL;
        }

#No. 1455
#File: E:\bishe\1\AbstractDatabaseObject.java
#Comment:
    /**
     * Converts a Long to a SQL equivalent.
     *
     * @param value that wants to be converted.
     * @return {@link java.lang.String} with a valid SQLInteger
     */

#Code:
    @NonNull
    protected static String convertToSqlInteger(@Nullable final Long value) {
        if (value == null) {
            return NULL;
        }

#No. 1456
#File: E:\bishe\1\AbstractDatabaseObject.java
#Comment:
    /**
     * Converts a Double to a valid SQL float String.
     *
     * @param value that wants to be converted in a SQLiteFloat
     * @return {@link java.lang.String} with a valid SQLString.
     */

#Code:
    @NonNull
    protected static String convertToSqlFloat(@Nullable final Float value) {
        if (value == null) {
            return NULL;
        }

#No. 1457
#File: E:\bishe\1\AbstractDatabaseObject.java
#Comment:
    /**
     * Converts a Double to a valid SQL float String.
     *
     * @param value that wants to be converted in a SQLiteFloat
     * @return {@link java.lang.String} with a valid SQLString.
     */

#Code:
    @NonNull
    protected static String convertToSqlFloat(@Nullable final Double value) {
        if (value == null) {
            return NULL;
        }

#No. 1458
#File: E:\bishe\1\AbstractDatabaseObject.java
#Comment:
    /**
     * Obtains the type of database object. (Table or view)
     *
     * @return {@link DatabaseObjectType} with the type.
     */

#Code:
    @NonNull
    public DatabaseObjectType getType() {
        return mObjectType;
    }

#No. 1459
#File: E:\bishe\1\AbstractDatabaseObject.java
#Comment:
    /**
     * Obtains the SQL sentence for obtaining the last id inserted.
     *
     * @return {@link java.lang.String} with the sql sentence for obtaining the last id.
     */

#Code:
    @NonNull
    public String getLastIdSql() {
        return String.format(Locale.ENGLISH, "SELECT MAX (%s) FROM %s;", COLUMN_ID, getName());
    }

#No. 1460
#File: E:\bishe\1\AbstractDatabaseObject.java
#Comment:
    /**
     * Gets the name of the table.
     *
     * @return {@link java.lang.String} with the table name.
     */

#Code:
    @NonNull
    public String getName() {
        return mTableName;
    }

#No. 1461
#File: E:\bishe\1\AbstractDatabaseObject.java
#Comment:
    /**
     * Gets the SQL sentence with the total number of rows in a table.
     *
     * @return {@link java.lang.String} with the query for looking the total number of rows in the table.
     */

#Code:
    @NonNull
    public String getNumberRowsSql() {
        final String[] projectionIn = new String[]{"COUNT (*)"};
        return mQueryBuilder.buildQuery(projectionIn, null, null, null, null, null);
    }

#No. 1462
#File: E:\bishe\1\AbstractDatabaseObject.java
#Comment:
    /**
     * Returns the SQL sentence for creating the table.
     *
     * @return {@link java.lang.String} with the create table sentence.
     */

#Code:
    @NonNull
    public abstract String createSqlStatement();
}
#No. 1463
#File: E:\bishe\1\AbstractDatabaseResourceManager.java
#Comment:
	/**
	 * The constructor
	 *
	 * @param storage    the storage
	 * @param clazz      type class
	 * @param tableName  table name in the database
	 */

#Code:
	protected AbstractDatabaseResourceManager(Storage storage, Class<T> clazz, String tableName) {
		super(storage, clazz);
		this.tableName = tableName;
	}

#No. 1464
#File: E:\bishe\1\AbstractDatabaseResourceManager.java
#Comment:
	/**
	 * Gets column name
	 * as it is in the database
	 *
	 * @return column name
	 */

#Code:
	public final String getTableName() {
		return tableName;
	}

#No. 1465
#File: E:\bishe\1\AbstractDatabaseResourceManager.java
#Comment:
	/**
	 * Updates resource's UUID in the database
	 *
	 * @param resource resource instance
	 * @param id       resource's ID
	 */

#Code:
	protected void updateUUID(T resource, int id) {
		try {
			String sql = "UPDATE `" + Config.MYSQL_PREFIX.getString() + getTableName() + "` SET `uuid`=? WHERE `id`=?";
			PreparedStatement statement = getStorage().getConnection().prepareStatement(sql);
			statement.setString(1, resource.getUUID().toString()); //UUID
			statement.setInt(   2, id);                            //id
			statement.executeUpdate();
		}
		catch(SQLException e) {
			LoggerUtils.exception(e);
		}
	}

#No. 1466
#File: E:\bishe\1\AbstractDatabaseResourceManager.java
#Comment:
	/**
	 * Adds an object to update UUID queue
	 *
	 * @param t instance
	 */

#Code:
	public void addToUpdateUUIDQueue(T t) {
		if(!isInUpdateUUIDQueue(t)) {
			updateUUIDQueue.add(t);
		}
	}

#No. 1467
#File: E:\bishe\1\AbstractDatabaseResourceManager.java
#Comment:
	/**
	 * Checks if an object is in save queue
	 *
	 * @param t instance
	 * @return boolean
	 */

#Code:
	public boolean isInUpdateUUIDQueue(T t) {
		return updateUUIDQueue.contains(t);
	}

#No. 1468
#File: E:\bishe\1\AbstractDatabaseResourceManager.java
#Comment:
	/**
	 * Executes UUID update
	 *
	 * @return changed rows
	 */

#Code:
	public int executeUpdateUUID() {
		int count = 0;

		for(T t : updateUUIDQueue) {
			updateUUID(t);
			count++;
		}

		updateUUIDQueue.clear();

		return count;
	}

#No. 1469
#File: E:\bishe\1\AbstractDatabaseStorage.java
#Comment:
	/**
	 * Reconnects
	 *
	 * @return true if success
	 */

#Code:
	public abstract boolean connect();

	/**
	 * Returns generated key (id)
	 *
	 * @param statement The statement
	 * @return Generated id
	 */
	public abstract Integer returnGeneratedKey(Statement statement);

	/**
	 * Says whether does the implementation support statement's generated keys or not
	 *
	 * @return true if yes
	 */
	public abstract boolean isStatementReturnGeneratedKeysSupported();

	@Override
	public void registerManagers() {
		new ResourceManagerGuildImpl(this);
		new ResourceManagerPlayerImpl(this);
		new ResourceManagerRankImpl(this);
		new ResourceManagerRegionImpl(this);
	}

#No. 1470
#File: E:\bishe\1\AbstractDatabaseStorage.java
#Comment:
	/**
	 * Gets a prepared statement
	 *
	 * @param statement the enum
	 * @return the statement
	 * @throws SQLException when something goes wrong
	 */

#Code:
	public PreparedStatement getPreparedStatement(PreparedStatements statement) throws SQLException {
		if(preparedStatementMap.isEmpty() || !preparedStatementMap.containsKey(statement)) {
			prepareStatements();
		}

		if(preparedStatementMap.get(statement) != null && !(this instanceof SQLiteStorageImpl) && preparedStatementMap.get(statement).isClosed()) {
			prepareStatements();
		}

		PreparedStatement preparedStatement = preparedStatementMap.get(statement);
		preparedStatement.clearParameters();

		return preparedStatement;
	}

#No. 1471
#File: E:\bishe\1\AbstractDatabaseStorage.java
#Comment:
	/**
	 * Checks if tables exist in the database
	 *
	 * @return boolean
	 * @throws SQLException when something goes wrong
	 */

#Code:
	protected boolean checkTables() throws SQLException {
		DatabaseMetaData md = getConnection().getMetaData();
		ResultSet rs = md.getTables(null, null, Config.MYSQL_PREFIX.getString() + "%", null);
		return rs.next();
	}

#No. 1472
#File: E:\bishe\1\AbstractDatabaseStorage.java
#Comment:
	/**
	 * Adds tables to the database
	 * @throws SQLException when something goes wrong
	 * @throws IOException  when something goes wrong
	 */

#Code:
	protected void setupTables() throws SQLException, IOException {
		for(String tableCode : getSqlActions()) {
			Statement statement = getConnection().createStatement();
			statement.executeUpdate(tableCode);
			LoggerUtils.info("Table added to the database!");
		}
	}

#No. 1473
#File: E:\bishe\1\AbstractDatabaseStorage.java
#Comment:
	/**
	 * Analyzes the database
	 */

#Code:
	protected void analyze() {
		try {
			LoggerUtils.info("Analyzing the database...");
			DatabaseAnalyzer analyzer = new DatabaseAnalyzerImpl(getConnection());

			for(String action : getSqlActions()) {
				if(action.contains("CREATE TABLE")) {
					String table = StringUtils.split(action, '`')[1];
					LoggerUtils.info("Table: " + table, false);
					analyzer.analyze(table, action);
				}
			}

			analyzer.update();
		}
		catch(Exception e) {
			LoggerUtils.exception(e);
		}
	}

#No. 1474
#File: E:\bishe\1\AbstractDatabaseStorage.java
#Comment:
	/**
	 * Gets an array of SQL create table codes
	 *
	 * @return the array of strings
	 */

#Code:
	private String[] getSqlActions() throws IOException {
		InputStream inputStream = plugin.getResource("sql/" + (plugin.getConfigManager().getDataStorageType() == DataStorageType.MYSQL ? "mysql" : "sqlite") + ".sql");
		String sqlString = IOUtils.inputStreamToString(inputStream);

		if(sqlString.isEmpty() || !sqlString.contains("--")) {
			LoggerUtils.error("Invalid SQL");
			return new String[0];
		}

		sqlString = StringUtils.replace(sqlString, "{SQLPREFIX}", Config.MYSQL_PREFIX.getString());
		return sqlString.split("--");
	}

#No. 1475
#File: E:\bishe\1\AbstractDataConsumeFix.java
#Comment:
/**
 * A base class for data consume fix generated by {@link ReplicationPacketDataProducer} and consumed
 * by {@link ReplicationPacketDataConsumer}. Having this base class allows fixes classes to be
 * dynamically loaded by the target if it is unfamiliar with the code (older version)
 *
 * @author eitany
 * @since 8.0
 */

#Code:
public abstract class AbstractDataConsumeFix
        implements IDataConsumeFix {
    private static final long serialVersionUID = 1L;

    public abstract IExecutableReplicationPacketData<?> fix(IReplicationInContext context,
                                                            IDataConsumeFixFacade fixFacade,
                                                            ReplicationPacketDataConsumer consumer, IExecutableReplicationPacketData<?> data)
            throws Exception;
}

#No. 1476
#File: E:\bishe\1\AbstractDatagramSocketImpl.java
#Comment:
    /**
     * @see java.net.DatagramSocketImpl#close()
     */

#Code:
    protected final synchronized void close() {
        if (!closed) {
            this.closed = true;
            doClose();
            receiveQueue.close();
        }
    }

#No. 1477
#File: E:\bishe\1\AbstractDatagramSocketImpl.java
#Comment:
    /**
     * @see java.net.DatagramSocketImpl#create()
     */

#Code:
    protected void create() throws SocketException {
        // Nothing todo here
    }

#No. 1478
#File: E:\bishe\1\AbstractDatagramSocketImpl.java
#Comment:
    /**
     * @see java.net.SocketOptions#getOption(int)
     */

#Code:
    public final synchronized Object getOption(int option_id) throws SocketException {
        if (closed) {
            throw new SocketException("DatagramSocket closed");
        }
        switch (option_id) {
            case IP_TOS:
                return new Integer(tos);
            case SO_BINDADDR:
                return laddr;
            case SO_BROADCAST:
                return new Boolean(broadcast);
            case SO_RCVBUF:
                return new Integer(EthernetConstants.ETH_FRAME_LEN);
            case SO_SNDBUF:
                return new Integer(EthernetConstants.ETH_FRAME_LEN);
            case SO_TRANSMIT_IF:
                return (device == null) ? null : NetworkInterface.getByName(device.getId());
            case SO_TIMEOUT:
                return new Integer(timeout);
            default:
                return doGetOption(option_id);
        }
    }

#No. 1479
#File: E:\bishe\1\AbstractDatagramSocketImpl.java
#Comment:
    /**
     * @see java.net.DatagramSocketImpl#getTimeToLive()
     */

#Code:
    protected final int getTimeToLive() throws IOException {
        return ttl;
    }

#No. 1480
#File: E:\bishe\1\AbstractDatagramSocketImpl.java
#Comment:
    /**
     * @see java.net.DatagramSocketImpl#join(java.net.InetAddress)
     */

#Code:
    protected void join(InetAddress inetaddr) throws IOException {
        // TODO Auto-generated method stub
    }

#No. 1481
#File: E:\bishe\1\AbstractDatagramSocketImpl.java
#Comment:
    /**
     * @see java.net.DatagramSocketImpl#joinGroup(java.net.SocketAddress,
     *      java.net.NetworkInterface)
     */

#Code:
    protected void joinGroup(SocketAddress mcastaddr, NetworkInterface netIf) throws IOException {
        // TODO Auto-generated method stub
    }

#No. 1482
#File: E:\bishe\1\AbstractDatagramSocketImpl.java
#Comment:
    /**
     * @see java.net.DatagramSocketImpl#leave(java.net.InetAddress)
     */

#Code:
    protected void leave(InetAddress inetaddr) throws IOException {
        // TODO Auto-generated method stub
    }

#No. 1483
#File: E:\bishe\1\AbstractDatagramSocketImpl.java
#Comment:
    /**
     * @see java.net.DatagramSocketImpl#leaveGroup(java.net.SocketAddress,
     *      java.net.NetworkInterface)
     */

#Code:
    protected void leaveGroup(SocketAddress mcastaddr, NetworkInterface netIf) throws IOException {
        // TODO Auto-generated method stub
    }

#No. 1484
#File: E:\bishe\1\AbstractDatagramSocketImpl.java
#Comment:
    /**
     * @see java.net.DatagramSocketImpl#peek(java.net.InetAddress)
     */

#Code:
    protected int peek(InetAddress i) throws IOException {
        // TODO Auto-generated method stub
        return 0;
    }

#No. 1485
#File: E:\bishe\1\AbstractDatagramSocketImpl.java
#Comment:
    /**
     * @see java.net.DatagramSocketImpl#peekData(java.net.DatagramPacket)
     */

#Code:
    protected int peekData(DatagramPacket p) throws IOException {
        throw new IOException("Not implemented");
    }

#No. 1486
#File: E:\bishe\1\AbstractDatagramSocketImpl.java
#Comment:
    /**
     * @see java.net.DatagramSocketImpl#receive(java.net.DatagramPacket)
     */

#Code:
    protected final void receive(DatagramPacket p) throws IOException {
        if (closed) {
            throw new SocketException("DatagramSocket has been closed");
        }
        final SocketBuffer skbuf = (SocketBuffer) receiveQueue.get(timeout);
        if (skbuf == null) {
            if (closed) {
                throw new SocketException("DatagramSocket has been closed");
            } else {
                throw new SocketTimeoutException("Timeout in receive");
            }
        } else {
            onReceive(p, skbuf);
        }
    }

#No. 1487
#File: E:\bishe\1\AbstractDatagramSocketImpl.java
#Comment:
    /**
     * Deliver a packet to this socket. This will put the packet in the
     * receive queue if this socket has not been closed.
     * @param skbuf
     */

#Code:
    public final boolean deliverReceived(SocketBuffer skbuf) {
        if (!closed) {
            receiveQueue.add(skbuf);
            return true;
        } else {
            return false;
        }
    }

#No. 1488
#File: E:\bishe\1\AbstractDatagramSocketImpl.java
#Comment:
    /**
     * @see java.net.DatagramSocketImpl#setTimeToLive(int)
     */

#Code:
    protected final void setTimeToLive(int ttl) {
        this.ttl = ttl;
    }

#No. 1489
#File: E:\bishe\1\AbstractDatagramSocketImpl.java
#Comment:
    /**
     * Gets the local port of this socket 
     * @see java.net.DatagramSocketImpl#getLocalPort()
     */

#Code:
    public final int getLocalPort() {
        return super.getLocalPort();
    }

#No. 1490
#File: E:\bishe\1\AbstractDatagramSocketImpl.java
#Comment:
    /**
     * Gets the local port of this socket 
     */

#Code:
    public final InetAddress getLocalAddress() {
        return laddr;
    }

#No. 1491
#File: E:\bishe\1\AbstractDatagramSocketImpl.java
#Comment:
    /**
     * @see java.lang.Object#finalize()
     */

#Code:
    protected void finalize() throws Throwable {
        close();
        super.finalize();
    }

#No. 1492
#File: E:\bishe\1\AbstractDatagramSocketImpl.java
#Comment:
    /**
     * Gets the device used to send/receive packets.
     */

#Code:
    protected Device getDevice() {
        return device;
    }

#No. 1493
#File: E:\bishe\1\AbstractDatagramSocketImpl.java
#Comment:
    /**
     * Gets the timeout used in receive
     */

#Code:
    protected int getTimeout() {
        return timeout;
    }

#No. 1494
#File: E:\bishe\1\AbstractDatagramSocketImpl.java
#Comment:
    /**
     * Gets the Type of Service, used in send
     */

#Code:
    protected int getTos() {
        return tos;
    }

#No. 1495
#File: E:\bishe\1\AbstractDataGridModel.java
#Comment:
/**
 * Abstract <code>DataGridModel</code> implementation.
 * Provides listener management facilities.  
 */

#Code:
public abstract class AbstractDataGridModel 
implements DataGridModel {

    private EventListenerList listenerList = new EventListenerList();

    /**
     * @see nextapp.echo.extras.app.datagrid.DataGridModel#addDataGridModelListener(
     *      nextapp.echo.extras.app.event.DataGridModelListener)
     */
    public void addDataGridModelListener(DataGridModelListener l) {
        listenerList.addListener(DataGridModelListener.class, l);
    }

    /**
     * @see nextapp.echo.extras.app.datagrid.DataGridModel#removeDataGridModelListener(
     *      nextapp.echo.extras.app.event.DataGridModelListener)
     */
    public void removeDataGridModelListener(DataGridModelListener l) {
        listenerList.removeListener(DataGridModelListener.class, l);
    }

}

#No. 1496
#File: E:\bishe\1\AbstractDataHandle.java
#Comment:
/**
 * Abstract base class for {@link DataHandle} plugins.
 *
 * @author Curtis Rueden
 */

#Code:
public abstract class AbstractDataHandle<L extends Location> extends
	AbstractWrapperPlugin<L> implements DataHandle<L>
{

	// -- Fields --

	private ByteOrder order = ByteOrder.BIG_ENDIAN;
	private String encoding = "UTF-8";

	// -- DataHandle methods --

	@Override
	public ByteOrder getOrder() {
		return order;
	}

	@Override
	public void setOrder(final ByteOrder order) {
		this.order = order;
	}

	@Override
	public String getEncoding() {
		return encoding;
	}

	@Override
	public void setEncoding(final String encoding) {
		this.encoding = encoding;
	}

}

#No. 1497
#File: E:\bishe\1\AbstractDataLayer.java
#Comment:
    /**
     * 数据库集群引用.
     */

#Code:
    protected IDBCluster         dbCluster;

    /**
     * 一级缓存.
     */
    protected IPrimaryCache      primaryCache;

    /**
     * 二级缓存.
     */
    protected ISecondCache       secondCache;

    protected TransactionManager txManager;

    protected IEntityMetaManager entityMetaManager = DefaultEntityMetaManager.getInstance();

    @Override
    public IDBCluster getDBCluster() {
        return dbCluster;
    }

#No. 1498
#File: E:\bishe\1\AbstractDataLayer.java
#Comment:
    /**
     * 判断一级缓存是否可用
     * 
     * @return true:启用cache, false:不启用
     */

#Code:
    protected boolean isCacheAvailable(Class<?> clazz) {
        return primaryCache != null && entityMetaManager.isCache(clazz);
    }

#No. 1499
#File: E:\bishe\1\AbstractDataLayer.java
#Comment:
    /**
     * 判断二级缓存是否可用
     * 
     * @return true:启用cache, false:不启用
     */

#Code:
    protected boolean isSecondCacheAvailable(Class<?> clazz) {
        return secondCache != null && entityMetaManager.isCache(clazz);
    }

#No. 1500
#File: E:\bishe\1\AbstractDataLayer.java
#Comment:
    /**
     * 判断一级缓存是否可用
     * 
     * @return true:启用cache, false:不启用
     */

#Code:
    protected boolean isCacheAvailable(Class<?> clazz, boolean useCache) {
        return primaryCache != null && entityMetaManager.isCache(clazz) && useCache;
    }

#No. 1501
#File: E:\bishe\1\AbstractDataLayer.java
#Comment:
    /**
     * 判断二级缓存是否可用
     * 
     * @return true:启用cache, false:不启用
     */

#Code:
    protected boolean isSecondCacheAvailable(Class<?> clazz, boolean useCache) {
        return secondCache != null && entityMetaManager.isCache(clazz) && useCache;
    }

#No. 1502
#File: E:\bishe\1\AbstractDataMap.java
#Comment:
	/**
	 * put(String,Object[])的快捷写法
	 * 
	 * @param key
	 * @param value1
	 * @param value2
	 * @param more
	 */

#Code:
	public void put(String key, Object value1, Object value2, Object... more) {
		List<Object> list = new ArrayList<Object>();
		list.add(value1);
		list.add(value2);
		for (Object item : more) {
			list.add(item);
		}
		super.put(key, list.toArray(new Object[0]));
	}

#No. 1503
#File: E:\bishe\1\AbstractDataMap.java
#Comment:
	/**
	 * 批量转换DataMap列表
	 * 
	 * @param list
	 * @param key
	 * @param converter
	 */

#Code:
	public static void convert(Collection list, String key, ITypeConverter converter) {
		for (Object dm : list) {
			if (dm instanceof AbstractDataMap) {
				((AbstractDataMap) dm).convert(key, converter);
			}
		}
	}

#No. 1504
#File: E:\bishe\1\AbstractDataNodeMerge.java
#Comment:
    /**
     *row 有多少col
     */

#Code:
    protected int fieldCount;

    /**
     * 本次select的路由缓存集
     */
    protected final RouteResultset rrs;
    /**
     * 夸分片处理handler
     */
    protected MultiNodeQueryHandler multiQueryHandler = null;
    /**
     * 分片结束包
     */
    public PackWraper END_FLAG_PACK = new PackWraper();


    /**
     * 是否执行流式结果集输出
     */

    protected boolean isStreamOutputResult = false;

    /**
     * rowData缓存队列
     */
    protected BlockingQueue<PackWraper> packs = new LinkedBlockingQueue<PackWraper>();

    /**
     * 标志业务线程是否启动了？
     */
    protected final AtomicBoolean running = new AtomicBoolean(false);

    public AbstractDataNodeMerge(MultiNodeQueryHandler handler,RouteResultset rrs){
        this.rrs = rrs;
        this.multiQueryHandler = handler;
    }

#No. 1505
#File: E:\bishe\1\AbstractDataNodeMerge.java
#Comment:
    /**
     * Add a row pack, and may be wake up a business thread to work if not running.
     * @param pack row pack
     * @return true wake up a business thread, otherwise false
     *
     * @author Uncle-pan
     * @since 2016-03-23
     */

#Code:
    protected final boolean addPack(final PackWraper pack){
        packs.add(pack);
        if(running.get()){
            return false;
        }
        final MycatServer server = MycatServer.getInstance();
        server.getBusinessExecutor().execute(this);
        return true;
    }

#No. 1506
#File: E:\bishe\1\AbstractDataNodeMerge.java
#Comment:
    /**
     * 处理新进来每个row数据，通过PackWraper进行封装，
     * 投递到队列中进行后续处理即可。
     * process new record (mysql binary data),if data can output to client
     * ,return true
     *
     * @param dataNode
     *            DN's name (data from this dataNode)
     * @param rowData
     *            raw data
     */

#Code:
    public boolean onNewRecord(String dataNode, byte[] rowData) {
        final PackWraper data = new PackWraper();
        data.dataNode = dataNode;
        data.rowData = rowData;
        addPack(data);

        return false;
    }

#No. 1507
#File: E:\bishe\1\AbstractDataNodeMerge.java
#Comment:
    /**
     * 将Map对应的col字段集，返回row中对应的index数组
     * @param columns
     * @param toIndexMap
     * @return
     */

#Code:
    protected static int[] toColumnIndex(String[] columns, Map<String, ColMeta> toIndexMap) {
        int[] result = new int[columns.length];
        ColMeta curColMeta;
        for (int i = 0; i < columns.length; i++) {
            curColMeta = toIndexMap.get(columns[i].toUpperCase());
            if (curColMeta == null) {
                throw new IllegalArgumentException(
                        "all columns in group by clause should be in the selected column list.!"
                                + columns[i]);
            }
            result[i] = curColMeta.colIndex;
        }
        return result;
    }

#No. 1508
#File: E:\bishe\1\AbstractDataNodeMerge.java
#Comment:
    /**
     * 做最后的结果集输出
     * @return (最多i*(offset+size)行数据)
     */

#Code:
    public abstract List<RowDataPacket> getResults(byte[] eof);
    public abstract void clear();

}
}

#No. 1509
#File: E:\bishe\1\AbstractDataReaderSun.java
#Comment:
    /**
     * Tests if <code>line</code> starts with one of the strings in <code>lineStartStrings</code>.
     * If <code>trimLine</code> is <code>true</code>, then <code>line</code> is trimmed first.
     *
     * @param line line to be checked against
     * @param lineStartStrings list of strings to check
     * @param trimLine if <code>true</code> then trim <code>line</code>
     * @return <code>true</code>, if <code>line</code> starts with one of the strings in
     * <code>lineStartStrings</code>
     */

#Code:
    protected boolean startsWith(String line, List<String> lineStartStrings, boolean trimLine) {
        String lineToTest = trimLine ? line.trim() : line;
        for (String lineStartString : lineStartStrings) {
            if (lineToTest.startsWith(lineStartString)) {
                return true;
            }
        }

        return false;
    }

#No. 1510
#File: E:\bishe\1\AbstractDataReaderSun.java
#Comment:
    /**
     * Parses a datestamp in <code>line</code> at <code>pos</code>.
     *
     * @param line current line.
     * @param pos current parse position.
     * @return returns parsed datestamp if found one, <code>null</code> otherwise.
     * @throws ParseException if line could not be parsed.
     */

#Code:
    protected ZonedDateTime parseDatestamp(String line, ParseInformation pos) throws ParseException {
        ZonedDateTime zonedDateTime = null;
        if (nextIsDatestamp(line, pos)) {
            try {
                zonedDateTime = ZonedDateTime.parse(line.substring(pos.getIndex(), pos.getIndex() + LENGTH_OF_DATESTAMP - 1),
                        DATE_TIME_FORMATTER);
                pos.setIndex(pos.getIndex() + LENGTH_OF_DATESTAMP);
                if (pos.getFirstDateStamp() == null) {
                    pos.setFirstDateStamp(zonedDateTime);
                }
            } catch (DateTimeParseException e){
                 throw new ParseException(e.toString(), line);
            }
        }

        return zonedDateTime;
    }

#No. 1511
#File: E:\bishe\1\AbstractDataReaderSun.java
#Comment:
    /**
     * Returns <code>true</code> if text at parsePosition is a datestamp.
     *
     * @param line current line
     * @param pos current parse position
     * @return <code>true</code> if in current line at current parse position we have a datestamp
     */

#Code:
    protected boolean nextIsDatestamp(String line, ParseInformation pos) {
        if (line == null || line.length() < 10) {
            return false;
        }

        return line.indexOf("-", pos.getIndex()) == pos.getIndex()+4 && line.indexOf("-", pos.getIndex() + 5) == pos.getIndex()+7;
    }

#No. 1512
#File: E:\bishe\1\AbstractDataReaderSun.java
#Comment:
    /**
     * Skips a block of lines containing information like they are generated by
     * -XX:+PrintHeapAtGC or -XX:+PrintAdaptiveSizePolicy.
     *
     * @param in inputStream of the current log to be read
     * @param pos current parse position
     * @param lineStartStrings lines starting with these strings should be ignored
     * @throws IOException problem with reading from the file
     */

#Code:
    protected void skipLines(LineNumberReader in, ParseInformation pos, List<String> lineStartStrings) throws IOException {
        String line = "";

        if (!in.markSupported()) {
            getLogger().warning("input stream does not support marking!");
        }
        else {
            in.mark(200);
        }

        boolean startsWithString = true;
        while (startsWithString && (line = in.readLine()) != null) {
            pos.setLineNumber(in.getLineNumber());
            // for now just skip those lines
            startsWithString = startsWith(line, lineStartStrings, true);
            if (startsWithString) {
                // don't mark any more if line didn't match -> it is the first line that
                // is of interest after the skipped block
                if (in.markSupported()) {
                    in.mark(200);
                }
            }
        }

        // push last read line back into stream - it is the next event to be parsed
        if (in.markSupported()) {
            try {
                in.reset();
            }
            catch (IOException e) {
                throw new ParseException("problem resetting stream (" + e.toString() + ")", line, pos);
            }
        }
    }

#No. 1513
#File: E:\bishe\1\AbstractDataReaderSun.java
#Comment:
    /**
     * Skips until the end of the current detail event.
     *
     * @param line current line
     * @param pos current parse position
     * @param e exception that made skipping necessary
     */

#Code:
    private void skipUntilEndOfDetail(final String line, final ParseInformation pos, Exception e) {
        skipUntilEndOfDetail(line, pos, 1);

        if (getLogger().isLoggable(Level.FINE)) getLogger().fine("Skipping detail event because of " + e);
    }

#No. 1514
#File: E:\bishe\1\AbstractDataReaderSun.java
#Comment:
    /**
     * Skips until end of current detail event. If the detail event contains detail events
     * itself, those are skipped as well.
     *
     * @param line current line
     * @param pos current parse position
     * @param levelOfDetailEvent level of nesting within detail event
     */

#Code:
    private void skipUntilEndOfDetail(final String line, final ParseInformation pos, int levelOfDetailEvent) {
        // moving position to the end of this detail event -> skip it
        // if it contains other detail events, skip those as well (recursion)
        int indexOfNextOpeningBracket = line.indexOf("[", pos.getIndex());
        int indexOfNextClosingBracket = line.indexOf("]", pos.getIndex());
        if (indexOfNextOpeningBracket > 0 && indexOfNextOpeningBracket < indexOfNextClosingBracket) {
            ++levelOfDetailEvent;
            pos.setIndex(indexOfNextOpeningBracket + 1);
        }
        else if (indexOfNextClosingBracket > 0) {
            --levelOfDetailEvent;
            pos.setIndex(indexOfNextClosingBracket + 1);
        }
        else {
            // unexpected: no opening and no closing bracket -> skip out
            --levelOfDetailEvent;
        }

        if (levelOfDetailEvent > 0) {
            skipUntilEndOfDetail(line, pos, levelOfDetailEvent);
        }
    }

#No. 1515
#File: E:\bishe\1\AbstractDataSetChart.java
#Comment:
/**
 * The class AbstractDataSetChart provides chart data and options.
 * AbstractDataSetCharts are
 * <ul>
 * <li>{@link Bar}</li>
 * <li>{@link Line}</li>
 * <li>{@link Radar}</li>
 * </ul>
 * instead of simple color and value pairs, this type uses labels and datasets.
 *
 * @param <D>
 *           the generic type of chart data (has to extend
 *           {@link AbstractChartData}
 * @param <O>
 *           the generic type of chart options (has to extend
 *           {@link AbstractChartOptions}
 * @param <S>
 *           the generic type of a chart data set (has to extend
 *           {@link AbstractBaseDataSet}
 *
 * @author Martin Spielmann
 *
 */

#Code:
public abstract class AbstractDataSetChart<D extends AbstractChartData<S>, O extends AbstractChartOptions, S extends AbstractBaseDataSet>
extends AbstractChart<O>implements IDataSetChart<D, O, S> {

   private static final long serialVersionUID = 999846601210465414L;

   /** The data. */
   protected D data;

   /*
    * (non-Javadoc)
    *
    * @see com.pingunaut.wicket.chartjs.chart.IDataSetChart#getData()
    */
   @Override
   public D getData() {
      return data;
   }

   /*
    * (non-Javadoc)
    *
    * @see
    * com.pingunaut.wicket.chartjs.chart.IDataSetChart#setData(com.pingunaut
    * .wicket.chartjs.data.AbstractChartData)
    */
   @Override
   public void setData(final D data) {
      this.data = data;
   }

}

#No. 1516
#File: E:\bishe\1\AbstractDataSource.java
#Comment:
    /**
     * Returns 0, indicating the default system timeout is to be used.
     */

#Code:
    public int getLoginTimeout() throws SQLException {
        return 0;
    }

#No. 1517
#File: E:\bishe\1\AbstractDataSource.java
#Comment:
    /**
     * Setting a login timeout is not supported.
     */

#Code:
    public void setLoginTimeout(int timeout) throws SQLException {
        throw new SQLFeatureNotSupportedException("setLoginTimeout");
    }

#No. 1518
#File: E:\bishe\1\AbstractDataSource.java
#Comment:
    /**
     * LogWriter methods are not supported.
     */

#Code:
    public PrintWriter getLogWriter() {
        throw new UnsupportedOperationException("getLogWriter");
    }

#No. 1519
#File: E:\bishe\1\AbstractDataSource.java
#Comment:
    /**
     * LogWriter methods are not supported.
     */

#Code:
    public void setLogWriter(PrintWriter pw) throws SQLException {
        throw new SQLFeatureNotSupportedException("setLogWriter");
    }

#No. 1520
#File: E:\bishe\1\AbstractDataSourceModel.java
#Comment:
	/**
	 * @param data
	 */

#Code:
	public AbstractDataSourceModel(T data) {
		super(data);
		this.data = data;
	}

#No. 1521
#File: E:\bishe\1\AbstractDatastoreService.java
#Comment:
    /**
     * Testing only!
     */

#Code:
    public void clearCache() {
        getDelegate().clearCache();
    }

#No. 1522
#File: E:\bishe\1\AbstractDataWarehouseSupport.java
#Comment:
/**
 * Abstract foundation class for people implementing data warehouse support for specific clouds. This class provides
 * basic helper methods and default implementations of many methods.
 * <p>Created by George Reese: 2/9/14 4:41 PM</p>
 *
 * @author George Reese
 * @since 2014.03
 * @version 2014.03 initial version (issue #100)
 */

#Code:
public abstract class AbstractDataWarehouseSupport<T extends CloudProvider> extends AbstractProviderService<T> implements
        DataWarehouseSupport {

    protected AbstractDataWarehouseSupport(T provider) {
        super(provider);
    }

    @Override
    public void addSnapshotShare(@Nonnull String snapshotId, @Nonnull String accountNumber) throws CloudException, InternalException {
        throw new OperationNotSupportedException("Snapshot sharing is not supported in " + getContext().getRegionId() + " of " + getProvider().getCloudName());
    }

#No. 1523
#File: E:\bishe\1\AbstractDate.java
#Comment:
    /**
     * Get the new pattern from parameters.
     *
     * @param parameters the parameters map
     * @return a DatePattern object representing the pattern
     */

#Code:
    DatePattern getDateFormat(Map<String, String> parameters) {
        String pattern = "custom".equals(parameters.get(NEW_PATTERN)) ? parameters.get(CUSTOM_PATTERN) : parameters.get(NEW_PATTERN);
        try {
            if (StringUtils.isEmpty(pattern)) {
                throw new IllegalArgumentException();
            }
            return new DatePattern(pattern);
        } catch (IllegalArgumentException iae) {
            throw new IllegalArgumentException("pattern '" + pattern + "' is not a valid date pattern", iae);
        }
    }

#No. 1524
#File: E:\bishe\1\AbstractDate.java
#Comment:
    /**
     * Only works on 'date' columns.
     * @param column The column to check, returns <code>true</code> only for date columns.
     */

#Code:
    @Override
    public boolean acceptField(ColumnMetadata column) {
        final String domain = column.getDomain().toUpperCase();
        return DATE.equals(Type.get(column.getType())) || SemanticCategoryEnum.DATE.name().equals(domain);
    }

#No. 1525
#File: E:\bishe\1\AbstractDbAccess.java
#Comment:
    /**
     * dbInternalVersion is introduced in version 3.10.0
    **/

#Code:
    @BackwardCompatibility
    private int                          dbInternalVersion        = -1;

    /**
     * dbInitialVersion is introduced in version 3.10.0
    **/
    @BackwardCompatibility
    private int                          dbInitialVersion         = -1;

    static {
        DATE_FORMAT_IN_UTC.setTimeZone( TimeZone.getTimeZone( "UTC" ) );
    }

#No. 1526
#File: E:\bishe\1\AbstractDbAccess.java
#Comment:
    /**
     * SQL connection which could be shared between different method invocations
     * like in the sanity check case where test run data is inserted.
     * The code invoking methods of this class is required to:
     * <ol>
     * <li>get connection</li>
     * <li>assign it to this variable - {@link #setInternalConnection(Connection)}</li>
     * <li>invoke methods here</li>
     * <li>set local connection variable to null - {@link #clearInternalConnection()}</li>
     * <li>close connection from outside after dbAccess work is processed</li>
     */

#Code:
    protected Connection   connection;

    /**
     * The database connection information and provider for MsSQL DB connections.
     */
    protected DbConnection dbConnectionFactory;

    public AbstractDbAccess( DbConnection dbConnection ) {

        this.log = Logger.getLogger( this.getClass() );

        this.dbConnectionFactory = dbConnection;
    }

#No. 1527
#File: E:\bishe\1\AbstractDbAccess.java
#Comment:
    /**
     * Provide reference for connection for general use
     * @return
     * @throws DatabaseAccessException
     */

#Code:
    protected Connection getConnection() throws DatabaseAccessException {
        try {
            return ConnectionPool.getConnection( dbConnectionFactory );
        } catch( DbException dbe ) {
            throw new DatabaseAccessException( UNABLE_TO_CONNECT_ERRROR, dbe );
        }
    }

#No. 1528
#File: E:\bishe\1\AbstractDbAccess.java
#Comment:
    /**
     * Convert time in hours to full date and time
     * @param timeOffset time in hours
     * @return
     */

#Code:
    protected String formatDateFromEpoch( float timeOffset ) {

        Calendar fdate = Calendar.getInstance();
        fdate.setTimeInMillis( ( int ) ( timeOffset * 3600000 ) );
        return DATE_FORMAT_IN_UTC.format( fdate.getTime() );
    }

#No. 1529
#File: E:\bishe\1\AbstractDbAccess.java
#Comment:
    /**
     * Convert duration in seconds to days, hours, minutes and seconds
     * @param time time in seconds
     * @return
     */

#Code:
    public static String formatTimeDiffereceFromSecondsToString( int time ) {

        int days = time / DAY_IN_SECONDS;
        time -= days * DAY_IN_SECONDS;

        int hours = time / HOUR_IN_SECONDS;
        time -= hours * HOUR_IN_SECONDS;

        int minutes = time / MIN_IN_SECONDS;
        time -= minutes * MIN_IN_SECONDS;

        int seconds = time;

        NumberFormat nf = NumberFormat.getIntegerInstance();
        nf.setMinimumIntegerDigits( 2 );

        StringBuilder duration = new StringBuilder();
        if( days > 0 ) {
            duration.append( days );
            duration.append( " days, " );
        }
        duration.append( nf.format( hours ) );
        duration.append( ":" );
        duration.append( nf.format( minutes ) );
        duration.append( ":" );
        duration.append( nf.format( seconds ) );
        return duration.toString();
    }

#No. 1530
#File: E:\bishe\1\AbstractDbAppender.java
#Comment:
    /**
     * log4j system reads the "events" parameter from the log4j.xml and calls
     * this method
     *
     * @param maxNumberLogEvents
     */

#Code:
    public void setEvents(
                           String maxNumberLogEvents ) {

        this.appenderConfig.setMaxNumberLogEvents( maxNumberLogEvents );
    }

#No. 1531
#File: E:\bishe\1\AbstractDbAppender.java
#Comment:
    /**
     * @return the capacity of the logging queue
     */

#Code:
    public int getMaxNumberLogEvents() {

        return appenderConfig.getMaxNumberLogEvents();
    }

#No. 1532
#File: E:\bishe\1\AbstractDbAppender.java
#Comment:
    /**
     * @return the current size of the logging queue
     */

#Code:
    public int getNumberPendingLogEvents() {

        return queue.size();
    }

#No. 1533
#File: E:\bishe\1\AbstractDbAppender.java
#Comment:
    /**
     * @return if sending log messages in batch mode
     */

#Code:
    public boolean isBatchMode() {

        return appenderConfig.isBatchMode();
    }

#No. 1534
#File: E:\bishe\1\AbstractDbAppender.java
#Comment:
    /**
     * log4j system reads the "mode" parameter from the log4j.xml and calls this
     * method
     *
     * Expected value is "batch", everything else is skipped.
     *
     * @param mode
     */

#Code:
    public void setMode(
                         String mode ) {

        this.appenderConfig.setMode( mode );
    }

#No. 1535
#File: E:\bishe\1\AbstractDbAppender.java
#Comment:
    /**
     * Get the current run id
     *
     * @return the current run id
     */

#Code:
    public int getRunId() {

        return eventProcessor.getRunId();
    }

#No. 1536
#File: E:\bishe\1\AbstractDbAppender.java
#Comment:
    /**
     * Get the current suite id
     *
     * @return the current suite id
     */

#Code:
    public int getSuiteId() {

        return eventProcessor.getSuiteId();
    }

#No. 1537
#File: E:\bishe\1\AbstractDbAppender.java
#Comment:
    /**
     * Get the current run name
     *
     * @return the current run name
     */

#Code:
    public String getRunName() {

        return eventProcessor.getRunName();
    }

#No. 1538
#File: E:\bishe\1\AbstractDbAppender.java
#Comment:
    /**
     * Get the current run user note
     *
     * @return the current run user note
     */

#Code:
    public String getRunUserNote() {

        return eventProcessor.getRunUserNote();
    }

#No. 1539
#File: E:\bishe\1\AbstractDbAppender.java
#Comment:
    /**
     *
     * @return the current testcase id
     */

#Code:
    public int getTestCaseId() {

        return eventProcessor.getTestCaseId();
    }

#No. 1540
#File: E:\bishe\1\AbstractDbProvider.java
#Comment:
    /**
     * Convert an array of bytes to a HEX string
     *
     * @param data the byte array
     * @param size the number of bytes to read
     * @return a HEX string representing the binary data
     */

#Code:
    protected String bytesToHex( byte[] data, int size ) {

        StringBuffer buf = new StringBuffer();
        for( int i = 0; i < size; i++ ) {
            String hexString = Integer.toHexString( data[i] & 0xFF );
            if( hexString.length() == 1 ) {
                buf.append( "0" );
            }

            buf.append( hexString );
        }
        return buf.toString().toUpperCase();
    }

#No. 1541
#File: E:\bishe\1\AbstractDbProvider.java
#Comment:
    /**
     * @see com.axway.ats.core.dbaccess.DbProvider#isReservedWord(java.lang.String)
     */

#Code:
    public boolean isReservedWord( String value ) {

        if( value != null ) {
            for( String reservedWord : this.reservedWords ) {
                if( value.equals( reservedWord ) ) {
                    return true;
                }
            }
        }
        return false;
    }

#No. 1542
#File: E:\bishe\1\AbstractDbProvider.java
#Comment:
    /**
     * Reads bytes from stream and convert them to hex notation
     * @param sb buffer to fill with hex data
     * @param binInputStream input stream
     * @return the StringBuilder parameter used as a clarification
     * @throws IOException if exception is caused during reading from the input stream
     */

#Code:
    protected StringBuilder addBinDataAsHexAndCloseStream( StringBuilder sb,
                                                           InputStream binInputStream ) throws IOException {

        if( sb == null ) {
            throw new IllegalArgumentException( "Passed null for StringBuilder" );
        }
        if( binInputStream == null ) {
            throw new IllegalArgumentException( "Passed null for InputStream" );
        }
        // read the binary data from the stream and convert it to hex
        try {
            byte[] buffer = new byte[BYTE_BUFFER_SIZE];
            int bytesRead = binInputStream.read( buffer );
            while( bytesRead > 0 ) {
                sb.append( bytesToHex( buffer, bytesRead ) );
                bytesRead = binInputStream.read( buffer );
            }
        } finally {
            IoUtils.closeStream( binInputStream );
        }
        return sb;
    }

#No. 1543
#File: E:\bishe\1\AbstractDbProvider.java
#Comment:
    /**
     * Trace with Debug severity info about retrieved value such as the DB and JDBC type
     * @param value value already got from the database
     * @param index the column index (starting from 1) of the cell
     * @param resultSet needed for extra
     * @throws SQLException
     */

#Code:
    protected void logDebugInfoForDBValue( Object value, int index,
                                           ResultSet resultSet ) throws SQLException {

        if( log.isDebugEnabled() ) {
            // trace column type too
            ResultSetMetaData metaData = resultSet.getMetaData();
            String dbType = metaData.getColumnTypeName( index );
            int javaType = metaData.getColumnType( index );
            log.debug( "DB value is '" + value + "' (retrieved as " + value.getClass().getSimpleName()
                       + "), JDBC type " + javaType + ", DB type " + dbType );
        }
    }

#No. 1544
#File: E:\bishe\1\AbstractDbProvider.java
#Comment:
    /**
     * Each provider can put restrictions on the types of tables to be processed
     *
     * @param tablesResultSet
     * @param dbName
     * @param tableName
     * @return
     */

#Code:
    protected boolean isTableAccepted( ResultSet tableResultSet, String dbName, String tableName ) {

        return true;
    }

#No. 1545
#File: E:\bishe\1\AbstractDbSelectExecutor.java
#Comment:
    /**
     * It's fake method
     *
     * @return a list of 5 fake items
     */

#Code:
    public List<T> execute() {
        List<T> result = new ArrayList<>();
        //assert the query is not null
        String query = getQuery();
        if (query == null) return result;

        try {
            //generate 5 fake items
            for (int i = 1; i <= 5; i++) {
                T newItem = getNewInstanceOfGenericType();
                newItem.setId(i);
                newItem.setName(newItem.getClass().getSimpleName() + "-" + i);
                newItem.setDescription("Got by executing '" + query + "'");
                result.add(newItem);
            }
        } catch (InstantiationException | IllegalAccessException e) {
            e.printStackTrace();
        }
        return result;
    }

#No. 1546
#File: E:\bishe\1\AbstractDBSelector.java
#Comment:
    /**
     * 在一个数据库上执行，有单线程试读
     * 
     * @param <T>
     * @param dsHolder
     * @param failedDataSources
     * @param tryer
     * @param times
     * @param args
     * @return
     * @throws SQLException
     */

#Code:
    protected <T> T tryOnDataSourceHolder(DataSourceHolder dsHolder, Map<DataSource, SQLException> failedDataSources,
                                          DataSourceTryer<T> tryer, int times, Object... args) throws SQLException {
        List<SQLException> exceptions = new LinkedList<SQLException>();
        if (failedDataSources != null) {
            exceptions.addAll(failedDataSources.values());
        }
        if (failedDataSources != null && failedDataSources.containsKey(dsHolder.dsw)) {
            return tryer.onSQLException(exceptions, exceptionSorter, args);
        }

        try {
            if (dsHolder.isNotAvailable) {
                boolean toTry = System.currentTimeMillis() - dsHolder.lastRetryTime > retryBadDbInterval;
                if (toTry && dsHolder.lock.tryLock()) {
                    try {
                        T t = tryer.tryOnDataSource(dsHolder.dsw, args); // 同一个时间只会有一个线程继续使用这个数据源。
                        dsHolder.isNotAvailable = false; // 用一个线程重试，执行成功则标记为可用，自动恢复
                        return t;
                    } finally {
                        dsHolder.lastRetryTime = System.currentTimeMillis();
                        dsHolder.lock.unlock();
                    }
                } else {
                    exceptions.add(new NoMoreDataSourceException("dsKey:" + dsHolder.dsw.getDataSourceKey()
                                                                 + " not Available,toTry:" + toTry));
                    return tryer.onSQLException(exceptions, exceptionSorter, args);
                }
            } else {
                return tryer.tryOnDataSource(dsHolder.dsw, args); // 有一次成功直接返回
            }
        } catch (SQLException e) {
            if (exceptionSorter.isExceptionFatal(e)) {
                NagiosUtils.addNagiosLog(NagiosUtils.KEY_DB_NOT_AVAILABLE + "|" + dsHolder.dsw.getDataSourceKey(),
                    e.getMessage());
                dsHolder.isNotAvailable = true;
            }
            exceptions.add(e);
            return tryer.onSQLException(exceptions, exceptionSorter, args);
        }
    }

#No. 1547
#File: E:\bishe\1\AbstractDbService.java
#Comment:
    /**
     * Be sure we close resources before GC
     */

#Code:
    @Override
    protected void finalize() throws Throwable {
        try {
            close();
        } finally {
            super.finalize();
        }
    }

#No. 1548
#File: E:\bishe\1\AbstractDbService.java
#Comment:
    /**
     * Be sure to override in implementations to close the datasource completely, then call super.close(). This method
     * should be idempotent! (it might get called twice)
     */

#Code:
    @Override
    public void close() {
        jdbcTemplate = null;
    }

#No. 1549
#File: E:\bishe\1\AbstractDBStore.java
#Comment:
  /**
   * INDEXS table doesn't store type_length, so we need another resultToColumnProto method
   */

#Code:
  private ColumnProto indexResultToColumnProto(final ResultSet res) throws SQLException {
    ColumnProto.Builder builder = ColumnProto.newBuilder();
    builder.setName(res.getString("column_name").trim());

    Type type = getDataType(res.getString("data_type").trim());
    builder.setDataType(CatalogUtil.newSimpleDataType(type));

    return builder.build();
  }

#No. 1550
#File: E:\bishe\1\AbstractDBUnitHibernateMemoryTest.java
#Comment:
    /**
     * This operation inserts the dataset contents into the database. This
     * operation assumes that table data does not exist in the target database
     * and fails if this is not the case. To prevent problems with foreign keys,
     * tables must be sequenced appropriately in the dataset.
     *
     * @param dataSet
     * @throws Exception
     */

#Code:
    protected void insertIntoDatabase(IDataSet dataSet) throws Exception {
        IDatabaseConnection connection = null;

        try {
            connection = getConnection();
            DatabaseOperation.INSERT.execute(connection, dataSet);
        } finally {
            closeConnection(connection);
        }
    }

#No. 1551
#File: E:\bishe\1\AbstractDBUnitHibernateMemoryTest.java
#Comment:
    /**
     * Deletes all rows of tables present in the specified dataset. If the
     * dataset does not contains a particular table, but that table exists in
     * the database, the database table is not affected. Table are truncated in
     * reverse sequence.
     *
     * @param dataSet
     * @throws Exception
     */

#Code:
    protected void deleteFromDatabase(IDataSet dataSet) throws Exception {
        IDatabaseConnection connection = null;
        try {
            connection = getConnection();
            DatabaseOperation.DELETE.execute(connection, dataSet);
        } finally {
            closeConnection(connection);
        }
    }

#No. 1552
#File: E:\bishe\1\AbstractDBUnitHibernateMemoryTest.java
#Comment:
    /**
     * This composite operation performs a deleteAllFromDatabase operation
     * followed by an insertIntoDatabase operation. This is the safest approach
     * to ensure that the database is in a known state. This is appropriate for
     * tests that require the database to only contain a specific set of data.
     *
     * @param dataSet
     * @throws Exception
     */

#Code:
    protected void cleanInsertIntoDatabase(IDataSet dataSet) throws Exception {
        IDatabaseConnection connection = null;

        try {
            connection = getConnection();
            DatabaseOperation.CLEAN_INSERT.execute(connection, dataSet);
        } finally {
            closeConnection(connection);
        }
    }

#No. 1553
#File: E:\bishe\1\AbstractDBUnitLoader.java
#Comment:
    /**
     * Load a DBUnit data set into the in-memory database.
     *
     * @param logger   Used to report errors and raise exceptions.
     * @param database The in-memory database.
     * @param source   The source file containing the data set.
     */

#Code:
    public final void load(final Logger logger, final Database database,
                           final Source source) {
        assert database instanceof SQLDatabase;
        assert logger != null;
        assert source != null;

        try {
            final IDataSet dataSet = loadDataSet(source);
            final IDatabaseConnection connection = new DatabaseDataSourceConnection(
                    ((SQLDatabase)database).getDataSource());
            final Boolean qualifiedTableNames = source.getQualifiedTableNames();
            if (qualifiedTableNames != null) {
                final DatabaseConfig config = connection.getConfig();
                config.setProperty(
                        DatabaseConfig.FEATURE_QUALIFIED_TABLE_NAMES,
                        source.getQualifiedTableNames());
            }
            try {
                DatabaseOperation.INSERT.execute(connection, dataSet);
            } finally {
                connection.close();
            }
        } catch (final SQLException exception) {
            final String message = MessageUtil.getMessage(ERROR_PROCESSING_SOURCE_FILE, source.getSourceFile());
            logger.logError(message, exception);
        } catch (final DatabaseUnitException exception) {
            final String message = MessageUtil.getMessage(ERROR_PROCESSING_SOURCE_FILE, source.getSourceFile());
            logger.logError(message, exception);
        } catch (final IOException exception) {
            final String message = MessageUtil.getMessage(CANNOT_READ_SOURCE_FILE, source.getSourceFile());
            logger.logError(message, exception);
        }
    }

#No. 1554
#File: E:\bishe\1\AbstractDeadboltHandler.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public RoleHolder getRoleHolder()
    {
        return NullRoleHolder.NULL_OBJECT;
    }

#No. 1555
#File: E:\bishe\1\AbstractDeadboltHandler.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public void onAccessFailure(String controllerClassName)
    {
        Deadbolt.forbidden();
    }

#No. 1556
#File: E:\bishe\1\AbstractDeadboltHandler.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public ExternalizedRestrictionsAccessor getExternalizedRestrictionsAccessor()
    {
        return null;
    }

#No. 1557
#File: E:\bishe\1\AbstractDeadboltHandler.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public RestrictedResourcesHandler getRestrictedResourcesHandler()
    {
        return null;
    }

#No. 1558
#File: E:\bishe\1\AbstractDecompiler.java
#Comment:
    /**
     * Class preparation handlers.
     */

#Code:
    private final Map<DecompilationDescriptor.ClassPathType, ClassPreparer> classPreparers = new HashMap<DecompilationDescriptor.ClassPathType, ClassPreparer>() {
        {
            put(DecompilationDescriptor.ClassPathType.FS,
                    new ClassPreparer() {
                        public boolean execute(DecompilationContext context,
                                               DecompilationDescriptor descriptor) throws DecompilationException {
                            // no preparation required, class files already accessible.
                            return true;
                        }
                    });
            put(DecompilationDescriptor.ClassPathType.JAR,
                    new ClassPreparer() {
                        public boolean execute(DecompilationContext context,
                                               DecompilationDescriptor descriptor) throws DecompilationException {
                            JarDecompilationDescriptor jarDD = (JarDecompilationDescriptor) descriptor;
                            VirtualFile jarFile = jarDD.getJarFile();
                            boolean successful = false;
                            if (jarFile != null) {
                                extractClassFiles(jarFile,
                                        context,
                                        descriptor);
                                successful = true;
                            }
                            return successful;
                        }
                    });
        }
    };

#No. 1559
#File: E:\bishe\1\AbstractDecompiler.java
#Comment:
    /**
     * Reformats the content of the file to match the preferred code style.
     *
     * @param context the decompilation context
     * @param file    the file to reformat
     */

#Code:
    protected void reformatToStyle(@NotNull final DecompilationContext context,
                                   @NotNull final MemoryVF file) {
        Config config = context.getConfig();
        switch (CodeStyle.getByName(config.getReformatStyle())) {
            case DEBUGGABLE_STYLE:
                SourceReorganiser.reorganise(context, file);
                break;
            case PREFERRED_STYLE:
            default:
                StyleReformatter.reformat(context, file.asVirtualFile());
        }

#No. 1560
#File: E:\bishe\1\AbstractDecompiler.java
#Comment:
    /**
     * Run the external decompiler (i.e. Jad) to obtain the decompiled content.
     *
     * @param command the command to execute in the process
     * @param context the context of the decompilation
     * @param output  stream containing the process's output
     * @param err     stream containing the process's error output
     * @return the result of the operation
     * @throws IOException          if an IO exception occurs at any point
     * @throws InterruptedException if the stream pumping operations fail
     */

#Code:
    private ResultType runExternalDecompiler(String command,
                                             DecompilationContext context,
                                             ByteArrayOutputStream output,
                                             ByteArrayOutputStream err) throws IOException,
            InterruptedException {
        boolean debug = LOG.isDebugEnabled();
        if (debug) {
            LOG.debug("Running external decompiler: " + command);
        }

        Process process = Runtime.getRuntime().exec(command);
        ProcessGobbler gobbler = new ProcessGobbler(process);

        //magic code indicating InterruptedException
        int exitCode = gobbler.waitFor(context, output, err);

        return checkDecompilationStatus(exitCode, err, output);
    }

#No. 1561
#File: E:\bishe\1\AbstractDecompiler.java
#Comment:
    /**
     * Extract the class files from the library to the target directory.
     *
     * @param jarFile                 the library containing the class files
     * @param context                 the context
     * @param decompilationDescriptor the decompilation descriptor
     * @throws DecompilationException if an error occurs extracting the class files
     */

#Code:
    private void extractClassFiles(VirtualFile jarFile,
                                   DecompilationContext context,
                                   DecompilationDescriptor decompilationDescriptor) throws DecompilationException {
        try {
            JarFile lib = JarFileSystem.getInstance().getJarFile(jarFile);
            context.getConsoleContext().addMessage(ConsoleEntryType.JAR_OPERATION,
                    "message.examining",
                    jarFile.getPath());
            JarExtractor jarExtractor = new JarExtractor();
            jarExtractor.extract(context,
                    lib,
                    decompilationDescriptor.getPackageNameAsPath(),
                    decompilationDescriptor.getClassName());
        } catch (IOException e) {
            throw new DecompilationException(e);
        }
    }

#No. 1562
#File: E:\bishe\1\AbstractDecorTest.java
#Comment:
    /**
     * Get object under test.
     * @return The object
     */

#Code:
    protected final Object object() {
        return this.sut;
    }

#No. 1563
#File: E:\bishe\1\AbstractDeepNestingTest.java
#Comment:
	/**
	 * Indicates on which level of the nesting hierarchy a new value will be set by
	 * {@link AbstractDeepNestingTest#setNewValue(Observable, Level, Value) setNewValue}.
	 */

#Code:
	protected enum Level {

		/**
		 * The outer level.
		 */
		OUTER,

		/**
		 * A level below the outer level.
		 */
		NESTED,
	}

#No. 1564
#File: E:\bishe\1\AbstractDeepNestingTest.java
#Comment:
	/**
	 * Indicates what kind of value will be set by {@link AbstractDeepNestingTest#setNewValue(Observable, Level, Value)
	 * setNewValue}.
	 */

#Code:
	protected enum Value {

		/**
		 * The new value will be some fully initialized instance.
		 */
		ANY,

		/**
		 * The new value will be an instance whose observables are null
		 */
		ANY_WITH_NULL_OBSERVABLE,

		/**
		 * The new value will be null.
		 */
		NULL,

	}

#No. 1565
#File: E:\bishe\1\AbstractDefaultsProvider.java
#Comment:
    /**
     * 
     * @param stringOfState
     *            for example "(steady incompressible ras)"
     * @return for example "simpleFoam"
     */

#Code:
    public String toPrimalState(State state) {
        String state2String = state.state2String();

        Dictionary statesDict = getStates();

        // System.out.println("AbstractDefaultsProvider.toPrimalState() "+statesDict);

        if (statesDict != null) {
            Map<String, String> STATES = Util.invertMap(statesDict.getFieldsMap());

            if (STATES.containsKey(state2String)) {
                return STATES.get(state2String);
            } else {
                logger.warn("[ {} Provider ]: State '{}' NOT AVAILABLE", getName(), state2String);
                return null;
            }
        } else {
            logger.warn("[ {} Provider ]: State '{}' NOT AVAILABLE", getName(), state2String);
            return null;
        }
    }

#No. 1566
#File: E:\bishe\1\AbstractDeferredManager.java
#Comment:
	/**
	 * Should {@link Runnable} or {@link Callable} be submitted for execution automatically
	 * when any of the following are called
	 * <ul>
	 * <li>{@link #when(Runnable...)}</li>
	 * <li>{@link #when(Callable...)}</li>
	 * <li>{@link #when(DeferredFutureTask...))}</li>
	 * <li>{@link #when(DeferredCallable)}</li>
	 * <li>{@link #when(DeferredRunnable)}</li>
	 * <li>{@link #when(DeferredFutureTask))}</li>
	 * </ul>
	 * @return
	 */

#Code:
	public abstract boolean isAutoSubmit();
	
	@Override
	public Promise<MultipleResults, OneReject, MasterProgress> when(Runnable... runnables) {
		assertNotEmpty(runnables);
		
		Promise[] promises = new Promise[runnables.length];

		for (int i = 0; i < runnables.length; i++) {
			if (runnables[i] instanceof DeferredRunnable)
				promises[i] = when((DeferredRunnable) runnables[i]);
			else
				promises[i] = when(runnables[i]);
		}

		return when(promises);
	}

#No. 1567
#File: E:\bishe\1\AbstractDeferredManager.java
#Comment:
	/**
	 * This method is delegated by at least the following methods
	 * <ul>
	 * 	<li>{@link #when(Callable)}</li>
	 *  <li>{@link #when(Callable...)}</li>
	 *  <li>{@link #when(Runnable)}</li>
	 *  <li>{@link #when(Runnable..)}</li>
	 *  <li>{@link #when(java.util.concurrent.Future)}</li>
	 *  <li>{@link #when(java.util.concurrent.Future...)}</li>
	 *  <li>{@link #when(org.jdeferred.DeferredRunnable...)}</li>
	 *  <li>{@link #when(org.jdeferred.DeferredRunnable)}</li>
	 *  <li>{@link #when(org.jdeferred.DeferredCallable...)}</li>
	 *  <li>{@link #when(org.jdeferred.DeferredCallable)}</li>
	 *  <li>{@link #when(DeferredFutureTask...)}</li>
	 * </ul>
	 */

#Code:
	@Override
	public <D, P> Promise<D, Throwable, P> when(
			DeferredFutureTask<D, P> task) {
		if (task.getStartPolicy() == StartPolicy.AUTO 
				|| (task.getStartPolicy() == StartPolicy.DEFAULT && isAutoSubmit()))
			submit(task);
		
		return task.promise();
	}

#No. 1568
#File: E:\bishe\1\AbstractDefinePropertyMojo.java
#Comment:
    /**
     * The maven project
     */

#Code:
    @Parameter( readonly = true, defaultValue = "${project}" )
    private MavenProject project;

    protected void defineProperty( String name, String value )
    {
        if ( getLog().isDebugEnabled() )
        {
            getLog().debug( "define property " + name + " = \"" + value + "\"" );
        }

        project.getProperties().put( name, value );
    }

#No. 1569
#File: E:\bishe\1\AbstractDefinePropertyMojo.java
#Comment:
    /**
     * Get the current project instance.
     *
     * @return the project
     */

#Code:
    public MavenProject getProject()
    {
        return this.project;
    }

#No. 1570
#File: E:\bishe\1\AbstractDelegateKit.java
#Comment:
	/**
	 * Attempt to set or add a delegate; return false if this delegate is not
	 * recognized and therefore not set or added.
	 */

#Code:
	protected boolean trySetOrAddDelegate(IDelegate delegate)
	{
		if (delegate instanceof IRetrieverFactoryDelegate)
		{
			setRetrieverFactoryDelegate((IRetrieverFactoryDelegate) delegate);
			return true;
		}
		if (delegate instanceof ITileURLBuilderDelegate)
		{
			setTileURLBuilderDelegate((ITileURLBuilderDelegate) delegate);
			return true;
		}
		if (delegate instanceof ITileReaderDelegate)
		{
			addTileReaderDelegate((ITileReaderDelegate) delegate);
			return true;
		}
		if (delegate instanceof IImageTransformerDelegate)
		{
			addImageTransformerDelegate((IImageTransformerDelegate) delegate);
			return true;
		}
		if (delegate instanceof IRenderDelegate)
		{
			addRenderDelegate((IRenderDelegate) delegate);
			return true;
		}
		return false;
	}

#No. 1571
#File: E:\bishe\1\AbstractDelegateKit.java
#Comment:
	/* ********************
	 * Setters and adders *
	 ******************** */

#Code:

	@Override
	public void setTileFactoryDelegate(ITileFactoryDelegate<TILE, BOUNDS, LEVEL> delegate)
	{
		this.factoryDelegate = delegate;
	}

#No. 1572
#File: E:\bishe\1\AbstractDelegateKit.java
#Comment:
	/* ******************************
	 * Delegate Interface functions *
	 ****************************** */

#Code:

	@Override
	public BufferedImage transformImage(BufferedImage image, IDelegatorTile tile)
	{
		for (IImageTransformerDelegate transformer : transformerDelegates)
		{
			image = transformer.transformImage(image, tile);
		}
		return image;
	}

#No. 1573
#File: E:\bishe\1\AbstractDelegatingAxdtCompiler.java
#Comment:
	/**
	 * Caches compiler targets. Clients should implement and use singleton
	 * access.
	 */

#Code:
	protected AbstractDelegatingAxdtCompiler() {
		// TODO think about cache cleanup
		targets = Maps.newHashMap();
	}

#No. 1574
#File: E:\bishe\1\AbstractDelegatingAxdtCompiler.java
#Comment:
	/**
	 * Checks the cache and returns a target for the given file. If there is no
	 * cached target a new target is created.
	 * 
	 * @param file
	 *            the file to create a compiler target for
	 * @return the corresponding compiler target
	 */

#Code:
	public AxdtCompilerTarget getTargetFor(IFile file) {
		String key = file.getLocation().toOSString();
		if (!targets.containsKey(key)) {
			AxdtCompilerTarget target = createTargetFor(file);
			if (target != null)
				targets.put(key, target);
		}
		return targets.get(key);
	}

#No. 1575
#File: E:\bishe\1\AbstractDependencyFilenameStrategy.java
#Comment:
/**
 * Created on 1/6/14.
 *
 * @author Tony Chemit - dev@tchemit.fr
 * @since 1.0-beta-5
 */

#Code:
public abstract class AbstractDependencyFilenameStrategy
        implements DependencyFilenameStrategy
{

    /**
     * {@inheritDoc}
     */
    public String getDependencyFilename( Artifact artifact, Boolean outputJarVersion, Boolean useUniqueVersions )
    {
        String filename = getDependencyFileBasename( artifact, outputJarVersion, useUniqueVersions );

        filename += "." + getDependencyFileExtension( artifact );

        return filename;
    }

    /**
     * {@inheritDoc}
     */
    public String getDependencyFileExtension( Artifact artifact )
    {
        String extension = artifact.getArtifactHandler().getExtension();
        return extension;
    }

    /**
     * {@inheritDoc}
     */
    public String getDependencyFileVersion( Artifact artifact, Boolean useUniqueVersions )
    {
        if ( useUniqueVersions != null && useUniqueVersions )
        {
            return UniqueVersionsHelper.getUniqueVersion( artifact );
        }

        return artifact.getVersion();
    }

}

#No. 1576
#File: E:\bishe\1\AbstractDependencyGraphTraversingMojo.java
#Comment:
    /**
     * Traverses the whole dependency tree rooted at the project.
     */

#Code:
    protected void traverseProject() throws DependencyGraphBuilderException {
        visit(graphBuilder.buildDependencyGraph(project, null));
    }

#No. 1577
#File: E:\bishe\1\AbstractDependencyGraphTraversingMojo.java
#Comment:
    /**
     * Traverses a tree rooted at the given node.
     */

#Code:
    protected void visit(DependencyNode g) {
        if (accept(g)) {
            for (DependencyNode dn : g.getChildren()) {
                visit(dn);
            }
        }
    }

#No. 1578
#File: E:\bishe\1\AbstractDependencyMojo.java
#Comment:
    /**
     * @parameter expression="${localRepository}"
     * @required
     * @readonly
     */

#Code:
    private ArtifactRepository localRepository;

    protected final ArtifactRepository getLocalRepository()
    {
        return localRepository;
    }

#No. 1579
#File: E:\bishe\1\AbstractDeployment.java
#Comment:
    /**
     * The goal of the deployment.
     *
     * @return the goal of the deployment.
     */

#Code:
    public abstract String goal();

    @Override
    public final void execute() throws MojoExecutionException, MojoFailureException {
        if (skipExecution()) {
            getLog().debug(String.format("Skipping deployment of %s:%s", project.getGroupId(), project.getArtifactId()));
            return;
        }
        try (
                ModelControllerClient client = createClient();
                MavenModelControllerClientConfiguration configuration = getClientConfiguration()
        ) {
            final boolean isDomain = ServerHelper.isDomainServer(client);
            validate(isDomain);
            beforeDeployment(configuration);
            // Deploy the deployment
            getLog().debug("Executing deployment");

            final Deployment deployment = configureDeployment(createDeployment());

            final DeploymentResult result = executeDeployment(DeploymentManager.Factory.create(client), deployment);
            if (!result.successful()) {
                throw new MojoExecutionException(String.format("Failed to execute goal %s: %s", goal(), result.getFailureMessage()));
            }
            afterDeployment(configuration);
        } catch (IOException e) {
            throw new MojoFailureException(String.format("Failed to execute goal %s.", goal()), e);
        }
    }

#No. 1580
#File: E:\bishe\1\AbstractDeployment.java
#Comment:
    /**
     * Validates the deployment.
     *
     * @param isDomain {@code true} if this is a domain server, otherwise {@code false}
     *
     * @throws MojoDeploymentException if the deployment is invalid
     */

#Code:
    protected void validate(final boolean isDomain) throws MojoDeploymentException {
        final boolean hasServerGroups = hasServerGroups();
        if (isDomain) {
            if (!hasServerGroups) {
                throw new MojoDeploymentException(
                        "Server is running in domain mode, but no server groups have been defined.");
            }
        } else if (hasServerGroups) {
            throw new MojoDeploymentException("Server is running in standalone mode, but server groups have been defined.");
        }
    }

#No. 1581
#File: E:\bishe\1\AbstractDescriptionBuilder.java
#Comment:
    /**
     * @param num
     * @param singular
     * @param plural
     * @return
     * @deprecated Use plural(String, String, String) instead
     */

#Code:
    @Deprecated
    protected String plural(int num, String singular, String plural) {
        return plural(String.valueOf(num), singular, plural);
    }

#No. 1582
#File: E:\bishe\1\AbstractDescriptionBuilder.java
#Comment:
    /**
     * @param num
     * @param singular
     * @param plural
     * @return
     * @since https://github.com/RedHogs/cron-parser/issues/2
     */

#Code:
    protected String plural(String expression, String singular, String plural) {
        if (NumberUtils.isNumber(expression) && (Integer.parseInt(expression) > 1)) {
            return plural;
        } else if (StringUtils.contains(expression, ",")) {
            return plural;
        }
        return singular;
    }

#No. 1583
#File: E:\bishe\1\AbstractDestinationMetaData.java
#Comment:
    /**
     * If the destination should be available via the 'jboss/exported' JNDI context
     * for remote lookups
     */

#Code:
    private boolean exported = false;
    private String name;
    private String remoteHost;
    private String username;
    private String password;

}
}

#No. 1584
#File: E:\bishe\1\AbstractDetachableMultiServiceModel.java
#Comment:
    /**
     * This method will retrieve a service from the service registry, and remember the reference, so it can be closed after {@code doLoad returns}.
     *
     * @param <E>
     * @param serviceType The service type for which to retrieve an instance.
     * @return A service of the type defined by {@code serviceType}
     */

#Code:
    protected final <E extends Object> E getService(Class<E> serviceType){
	ServiceReference<E> ref = getServiceReference(serviceType);
	if(ref == null){
	    ref = context.getServiceReference(serviceType);
	    references.put(serviceType, ref);
	}
	return context.getService(ref);
    }

#No. 1585
#File: E:\bishe\1\AbstractDetectorForParameterArray.java
#Comment:
    /**
     * Check all private method invocation, to detect {@code SLF4J_FORMAT_SHOULD_BE_CONST}.
     * 
     * @see https://github.com/KengoTODA/findbugs-slf4j/issues/35
     */

#Code:
    private void validatePrivateMethodCall() {
        for (Cell<Method, Integer, List<BugInstance>> cell : potentialBugs.cellSet()) {
            Method method = cell.getRowKey();
            String methodSignature = method.getName() + method.getSignature();
            if (calledWithNonConstants.containsEntry(methodSignature, cell.getColumnKey())) {
                for (BugInstance bug : cell.getValue()) {
                    bugReporter.reportBug(bug);
                }
            }
        }
    }

#No. 1586
#File: E:\bishe\1\AbstractDetectorForParameterArray.java
#Comment:
        /**
         * 0 or greater value if item is `this` or argument. Otherwise -1.
         */

#Code:
        int argumentIndex = item.getRegisterNumber();
        Method method = this.getMethod();
        if (argumentIndex != -1 && method.isStatic()) {
            argumentIndex++;
        }

#No. 1587
#File: E:\bishe\1\AbstractDeviceImplHelper.java
#Comment:
    /**
     * Notify the IOs made to some peers.
     *
     * @param opBuilder
     *            Ibs updates to notify
     */

#Code:
    protected abstract void notifyIO(@Nonnull VvrRemote.RemoteOperation.Builder opBuilder);

    /**
     * Look for a block on remote nodes.
     *
     * @param key
     *            key of the block to search
     * @param srcNode
     *            preferred node
     * @return the block found or <code>null</code>
     */
    protected abstract ByteString getRemoteBuffer(@Nonnull byte[] key, @Nonnull UUID srcNode)
            throws InterruptedException;
}
}

#No. 1588
#File: E:\bishe\1\AbstractDeviceManager.java
#Comment:
    /**
     * Gets the default timeout for device startup.
     *
     * @return Returns the defaultStartTimeout.
     */

#Code:
    public final long getDefaultStartTimeout() {
        return this.defaultStartTimeout;
    }

#No. 1589
#File: E:\bishe\1\AbstractDeviceManager.java
#Comment:
    /**
     * Sets the default timeout for device startup.
     *
     * @param defaultStartTimeout The defaultStartTimeout to set.
     */

#Code:
    public final void setDefaultStartTimeout(long defaultStartTimeout) {
        this.defaultStartTimeout = defaultStartTimeout;
    }

#No. 1590
#File: E:\bishe\1\AbstractDiagnosticFormatter.java
#Comment:
    /**
     * Format the arguments of a given diagnostic.
     *
     * @param d diagnostic whose arguments are to be formatted
     * @param l locale object to be used for i18n
     * @return a Collection whose elements are the formatted arguments of the diagnostic
     */

#Code:
    protected Collection<String> formatArguments(JCDiagnostic d, Locale l) {
        ListBuffer<String> buf = new ListBuffer<String>();
        for (Object o : d.getArgs()) {
           buf.append(formatArgument(d, o, l));
        }
        return buf.toList();
    }

#No. 1591
#File: E:\bishe\1\AbstractDiagnosticFormatter.java
#Comment:
    /**
     * Format a single argument of a given diagnostic.
     *
     * @param d diagnostic whose argument is to be formatted
     * @param arg argument to be formatted
     * @param l locale object to be used for i18n
     * @return string representation of the diagnostic argument
     */

#Code:
    protected String formatArgument(JCDiagnostic d, Object arg, Locale l) {
        if (arg instanceof JCDiagnostic) {
            String s = null;
            depth++;
            try {
                s = formatMessage((JCDiagnostic)arg, l);
            }
            finally {
                depth--;
            }
            return s;
        }
        else if (arg instanceof JCExpression) {
            return expr2String((JCExpression)arg);
        }
        else if (arg instanceof Iterable<?>) {
            return formatIterable(d, (Iterable<?>)arg, l);
        }
        else if (arg instanceof Type) {
            return printer.visit((Type)arg, l);
        }
        else if (arg instanceof Symbol) {
            return printer.visit((Symbol)arg, l);
        }
        else if (arg instanceof JavaFileObject) {
            return ((JavaFileObject)arg).getName();
        }
        else if (arg instanceof Profile) {
            return ((Profile)arg).name;
        }
        else if (arg instanceof Formattable) {
            return ((Formattable)arg).toString(l, messages);
        }
        else {
            return String.valueOf(arg);
        }
    }

#No. 1592
#File: E:\bishe\1\AbstractDiagnosticFormatter.java
#Comment:
    /**
     * Format an iterable argument of a given diagnostic.
     *
     * @param d diagnostic whose argument is to be formatted
     * @param it iterable argument to be formatted
     * @param l locale object to be used for i18n
     * @return string representation of the diagnostic iterable argument
     */

#Code:
    protected String formatIterable(JCDiagnostic d, Iterable<?> it, Locale l) {
        StringBuilder sbuf = new StringBuilder();
        String sep = "";
        for (Object o : it) {
            sbuf.append(sep);
            sbuf.append(formatArgument(d, o, l));
            sep = ",";
        }
        return sbuf.toString();
    }

#No. 1593
#File: E:\bishe\1\AbstractDiagnosticFormatter.java
#Comment:
    /**
     * Format all the subdiagnostics attached to a given diagnostic.
     *
     * @param d diagnostic whose subdiagnostics are to be formatted
     * @param l locale object to be used for i18n
     * @return list of all string representations of the subdiagnostics
     */

#Code:
    protected List<String> formatSubdiagnostics(JCDiagnostic d, Locale l) {
        List<String> subdiagnostics = List.nil();
        int maxDepth = config.getMultilineLimit(MultilineLimit.DEPTH);
        if (maxDepth == -1 || depth < maxDepth) {
            depth++;
            try {
                int maxCount = config.getMultilineLimit(MultilineLimit.LENGTH);
                int count = 0;
                for (JCDiagnostic d2 : d.getSubdiagnostics()) {
                    if (maxCount == -1 || count < maxCount) {
                        subdiagnostics = subdiagnostics.append(formatSubdiagnostic(d, d2, l));
                        count++;
                    }
                    else
                        break;
                }
            }
            finally {
                depth--;
            }
        }
        return subdiagnostics;
    }

#No. 1594
#File: E:\bishe\1\AbstractDiagnosticFormatter.java
#Comment:
    /**
     * Format a subdiagnostics attached to a given diagnostic.
     *
     * @param parent multiline diagnostic whose subdiagnostics is to be formatted
     * @param sub subdiagnostic to be formatted
     * @param l locale object to be used for i18n
     * @return string representation of the subdiagnostics
     */

#Code:
    protected String formatSubdiagnostic(JCDiagnostic parent, JCDiagnostic sub, Locale l) {
        return formatMessage(sub, l);
    }

#No. 1595
#File: E:\bishe\1\AbstractDiagnosticFormatter.java
#Comment:
    /** Format the faulty source code line and point to the error.
     *  @param d The diagnostic for which the error line should be printed
     */

#Code:
    protected String formatSourceLine(JCDiagnostic d, int nSpaces) {
        StringBuilder buf = new StringBuilder();
        DiagnosticSource source = d.getDiagnosticSource();
        int pos = d.getIntPosition();
        if (d.getIntPosition() == Position.NOPOS)
            throw new AssertionError();
        String line = (source == null ? null : source.getLine(pos));
        if (line == null)
            return "";
        buf.append(indent(line, nSpaces));
        int col = source.getColumnNumber(pos, false);
        if (config.isCaretEnabled()) {
            buf.append("\n");
            for (int i = 0; i < col - 1; i++)  {
                buf.append((line.charAt(i) == '\t') ? "\t" : " ");
            }
            buf.append(indent("^", nSpaces));
        }
        return buf.toString();
    }

#No. 1596
#File: E:\bishe\1\AbstractDiagnosticFormatter.java
#Comment:
    /**
     * Converts a String into a locale-dependent representation accordingly to a given locale.
     *
     * @param l locale object to be used for i18n
     * @param key locale-independent key used for looking up in a resource file
     * @param args localization arguments
     * @return a locale-dependent string
     */

#Code:
    protected String localize(Locale l, String key, Object... args) {
        return messages.getLocalizedString(l, key, args);
    }

#No. 1597
#File: E:\bishe\1\AbstractDiagnosticFormatter.java
#Comment:
    /**
     * Creates a string with a given amount of empty spaces. Useful for
     * indenting the text of a diagnostic message.
     *
     * @param nSpaces the amount of spaces to be added to the result string
     * @return the indentation string
     */

#Code:
    protected String indentString(int nSpaces) {
        String spaces = "                        ";
        if (nSpaces <= spaces.length())
            return spaces.substring(0, nSpaces);
        else {
            StringBuilder buf = new StringBuilder();
            for (int i = 0 ; i < nSpaces ; i++)
                buf.append(" ");
            return buf.toString();
        }
    }

#No. 1598
#File: E:\bishe\1\AbstractDiagnosticFormatter.java
#Comment:
    /**
     * Indent a string by prepending a given amount of empty spaces to each line
     * of the string.
     *
     * @param s the string to be indented
     * @param nSpaces the amount of spaces that should be prepended to each line
     * of the string
     * @return an indented string
     */

#Code:
    protected String indent(String s, int nSpaces) {
        String indent = indentString(nSpaces);
        StringBuilder buf = new StringBuilder();
        String nl = "";
        for (String line : s.split("\n")) {
            buf.append(nl);
            buf.append(indent + line);
            nl = "\n";
        }
        return buf.toString();
    }

#No. 1599
#File: E:\bishe\1\AbstractDiagnosticFormatter.java
#Comment:
        /**
         * Shows a '^' sign under the source line displayed by the formatter
         * (if applicable).
         *
         * @param caretEnabled if true enables caret
         */

#Code:
        public void setCaretEnabled(boolean caretEnabled) {
            this.caretEnabled = caretEnabled;
        }

#No. 1600
#File: E:\bishe\1\AbstractDiagnosticFormatter.java
#Comment:
        /**
         * Tells whether the caret display is active or not.
         *
         * @return true if the caret is enabled
         */

#Code:
        public boolean isCaretEnabled() {
            return caretEnabled;
        }

#No. 1601
#File: E:\bishe\1\AbstractDiagnosticFormatter.java
#Comment:
    /**
     * An enhanced printer for formatting types/symbols used by
     * AbstractDiagnosticFormatter. Provides alternate numbering of captured
     * types (they are numbered starting from 1 on each new diagnostic, instead
     * of relying on the underlying hashcode() method which generates unstable
     * output). Also detects cycles in wildcard messages (e.g. if the wildcard
     * type referred by a given captured type C contains C itself) which might
     * lead to infinite loops.
     */

#Code:
    protected Printer printer = new Printer() {

        @Override
        protected String localize(Locale locale, String key, Object... args) {
            return AbstractDiagnosticFormatter.this.localize(locale, key, args);
        }
        @Override
        protected String capturedVarId(CapturedType t, Locale locale) {
            return "" + (allCaptured.indexOf(t) + 1);
        }
        @Override
        public String visitCapturedType(CapturedType t, Locale locale) {
            if (!allCaptured.contains(t)) {
                allCaptured = allCaptured.append(t);
            }
            return super.visitCapturedType(t, locale);
        }
    };

#No. 1602
#File: E:\bishe\1\AbstractDirector.java
#Comment:
	/**
	 * Allows you to construct a Page object by using reflection to bypass the access restrictions. This allows the director
	 * layer to instantiate a page object, and prevents any other class hierarchy from being able to do so
	 * @param <T>
	 * @param pageClass
	 * @return
	 */

#Code:
	protected <T extends IAutomationPage> T newPage( Class<T> pageClass ){
		try {
			Constructor<T> constructor = pageClass.getDeclaredConstructor();
			constructor.setAccessible( true );
			return constructor.newInstance();
		}
		catch ( InvocationTargetException ex ) {
			throw new RuntimeException( String.format( "Could not construct page class [%s]: [%s]", pageClass, ex.getTargetException() ) );
		}
		catch ( Exception ex ) {
			throw new RuntimeException( String.format( "Could not construct page class [%s]: [%s]", pageClass, ex.toString() ) );
		}
	}

#No. 1603
#File: E:\bishe\1\AbstractDisableUserResourcesTest.java
#Comment:
    /**
     * Disable authentification -> return untracked.
     */

#Code:
    private static final DisabledAuthenticator DISABLED_AUTHENTICATOR = new DisabledAuthenticator();

    /**
     * Simple authentification (just get username, we don't care about password) -> return username
     */
    private static final SimpleAuthenticator SIMPLE_AUTHENTICATOR = new SimpleAuthenticator();

    /**
     * Http return code.
     */
    public static final int CLIENT_ERROR = 422;

    /**
     * Create a resource.
     *
     * @param userProvider
     * @param resource
     * @return
     */
    protected static ResourceTestRule createResource(final ContainerRequestFilter userProvider, final Object resource) {
        return ResourceTestRule.builder()
                .addResource(resource)
                .addProvider(RolesAllowedDynamicFeature.class)
                .addProvider(new AuthDynamicFeature(userProvider))
                .addProvider(new AuthValueFactoryProvider.Binder<>(User.class))
                .addProvider(new DefaultExceptionMapper())
                .addProvider(new DuplicateResourceExceptionMapper())
                .addProvider(new IncoherentVersionExceptionMapper())
                .addProvider(new OutOfDateVersionExceptionMapper())
                .addProvider(new MissingResourceExceptionMapper())
                .addProvider(new IllegalArgumentExceptionMapper())
                .addProvider(new ForbiddenOperationExceptionMapper())
                .addProvider(new ForbiddenExceptionMapper())
                .build();

    }

#No. 1604
#File: E:\bishe\1\AbstractDiskHttpData.java
#Comment:
    /**
     * @return a new Temp File from getDiskFilename(), default prefix, postfix and baseDirectory
     */

#Code:
    private File tempFile() throws IOException {
        String newpostfix;
        String diskFilename = getDiskFilename();
        if (diskFilename != null) {
            newpostfix = '_' + diskFilename;
        } else {
            newpostfix = getPostfix();
        }
        File tmpFile;
        if (getBaseDirectory() == null) {
            // create a temporary file
            tmpFile = File.createTempFile(getPrefix(), newpostfix);
        } else {
            tmpFile = File.createTempFile(getPrefix(), newpostfix, new File(
                    getBaseDirectory()));
        }
        if (deleteOnExit()) {
            tmpFile.deleteOnExit();
        }
        return tmpFile;
    }

#No. 1605
#File: E:\bishe\1\AbstractDiskHttpData.java
#Comment:
    /**
     * Utility function
     * @return the array of bytes
     */

#Code:
    private static byte[] readFrom(File src) throws IOException {
        long srcsize = src.length();
        if (srcsize > Integer.MAX_VALUE) {
            throw new IllegalArgumentException(
                    "File too big to be loaded in memory");
        }
        FileInputStream inputStream = new FileInputStream(src);
        FileChannel fileChannel = inputStream.getChannel();
        byte[] array = new byte[(int) srcsize];
        ByteBuffer byteBuffer = ByteBuffer.wrap(array);
        int read = 0;
        while (read < srcsize) {
            read += fileChannel.read(byteBuffer);
        }
        fileChannel.close();
        return array;
    }

#No. 1606
#File: E:\bishe\1\AbstractDiskModelContentProxy.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    @Nullable
    @CallSuper
    @NotForUIThread
    public MODEL getModel(AccessPolicy policy, CacheableRequest<MODEL> request,
                          ContentUpdateCallback<MODEL> callback) throws Exception {
        return mContentLoader.load(policy, request, callback);
    }

#No. 1607
#File: E:\bishe\1\AbstractDiskModelContentProxy.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    @Nullable
    @CallSuper
    @NotForUIThread
    public MODEL getModel(AccessPolicy policy, CacheableRequest<MODEL> request) throws Exception {
        return mContentLoader.load(policy, request, null);
    }

#No. 1608
#File: E:\bishe\1\AbstractDiskModelContentProxy.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    @CallSuper
    @NotForUIThread
    public void putModel(final MODEL model) {
        if (model == null) {
            return; // fail-safe attitude
        }
        // auto-generate key
        final String key = generateModelKey(model);
        putModel(key, model);
    }

#No. 1609
#File: E:\bishe\1\AbstractDiskModelContentProxy.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    @CallSuper
    @NotForUIThread
    public void putModel(@NonNull final String key, final MODEL model) {
        if (model == null) {
            return; // fail-safe attitude
        }

#No. 1610
#File: E:\bishe\1\AbstractDiskModelContentProxy.java
#Comment:
        /*
		 * Run the "task" in this thread: it's just getting in return a value we
		 * already have, in order to be able to store it as a Future we need to
		 * execute it
		 */

#Code:
        innerFuture.run();
        // update model into caches
        mModelCache.put(key, innerFuture);
        if (mModelDisk != null) {
            mModelDisk.put(key, model);
        }

#No. 1611
#File: E:\bishe\1\AbstractDiskModelContentProxy.java
#Comment:
    /**
     * Removes the model with the passed key from the cache. This must be used in specific cases
     * where we need to explicitly invalidate an item only.
     *
     * @param key The string key for the model to remove
     */

#Code:
    @CallSuper
    @NotForUIThread
    protected void invalidateModel(@NonNull String key) {
        mModelCache.remove(key);
        if (mModelDisk != null) {
            mModelDisk.remove(key);
        }

#No. 1612
#File: E:\bishe\1\AbstractDiskModelContentProxy.java
#Comment:
    /**
     * Needed from some subclasses to properly generate the key to store a model into the cache.
     *
     * The base implementation throws an {@link IllegalArgumentException}.
     *
     * @param model The model to generate the key from
     * @return The generated key
     */

#Code:
    protected String generateModelKey(@NonNull MODEL model) {
        throw new IllegalArgumentException("Not implemented");
    }

    /**
     * {@inheritDoc}<br> Always call to the superclass when overriding.
     */
    @Override
    @CallSuper
    public void clearMemoryCache() {
        mModelCache.clear();
    }

#No. 1613
#File: E:\bishe\1\AbstractDiskModelContentProxy.java
#Comment:
    /**
     * {@inheritDoc}<br> Always call to the superclass when overriding.
     */

#Code:
    @Override
    @CallSuper
    public void scheduleClearDiskCache() {
        if (mModelDisk != null) {
            mModelDisk.clear();
        }
    }

#No. 1614
#File: E:\bishe\1\AbstractDiskModelContentProxy.java
#Comment:
    /**
     * {@inheritDoc}<br> Always call to the superclass when overriding.
     */

#Code:
    @Override
    @NotForUIThread
    @CallSuper
    public void clearDiskCache(SimpleDiskCache.ClearMode mode) {
        if (mModelDisk != null) {
            mModelDisk.clear(mode);
        }
    }

#No. 1615
#File: E:\bishe\1\AbstractDiskModelListContentProxy.java
#Comment:
/**
 * Generic, abstract extension of an {@link AbstractDiskModelContentProxy} that handles the
 * retrieval of {@link JsonModel}s that can be grouped in a list.
 *
 * This is useful to handle the case where a content can be provided as a single JSON model object
 * or as a list of models with the same representation, which is grouped in another {@link
 * JsonModel}. When this happens, we usually want to automatically update the "single model" cache
 * when we get a fresh list of models and invalidate the list of models when we get a fresh single
 * model.
 *
 * @author Marco Salis
 * @since 1.0
 */

#Code:
@Beta
@ThreadSafe
public abstract class AbstractDiskModelListContentProxy<MODEL extends JsonModel, LIST extends JsonModel>
        extends AbstractDiskModelContentProxy<MODEL> implements ContentUpdateCallback<LIST> {

    private final ListContentProxy mListContentProxy;

    public AbstractDiskModelListContentProxy(@NonNull Context context,
                                             @NonNull ObjectMapper mapper, @NonNull Class<MODEL> modelClass, int modelsInCache,
                                             @NonNull Class<LIST> modelListClass, int listsInCache, @NonNull String diskFolder,
                                             final long expiration,
                                             @NonNull ModelDiskContentLoaderFactory<CacheableRequest<MODEL>, MODEL> loaderFactory,
                                             @NonNull ModelDiskContentLoaderFactory<CacheableRequest<LIST>, LIST> listLoaderFactory) {
        super(context, mapper, modelClass, modelsInCache, diskFolder, expiration, loaderFactory);
        final String subFolder = diskFolder + File.separator + "list";
        mListContentProxy = new ListContentProxy(context, mapper, modelListClass, listsInCache,
                subFolder, expiration, listLoaderFactory);
    }

#No. 1616
#File: E:\bishe\1\AbstractDiskModelListContentProxy.java
#Comment:
    /**
     * Retrieves a model list from the content proxy. See {@link ContentLoader}.
     *
     * @param policy  The {@link AccessPolicy} to use
     * @param request The {@link CacheableRequest} for the list
     * @return The model list, or null of unsuccessful
     * @throws Exception
     */

#Code:
    @NotForUIThread
    public final LIST getModelList(AccessPolicy policy, CacheableRequest<LIST> request)
            throws Exception {
        return mListContentProxy.getModel(policy, request, this);
    }

#No. 1617
#File: E:\bishe\1\AbstractDiskModelListContentProxy.java
#Comment:
    /**
     * See {@link AbstractDiskModelContentProxy#putModel(com.luluvise.android.api.model.JsonModel)}
     *
     * <b>Warning:</b> With the invalidate flag set to on, this call will invalidate all the model
     * list caches, in order not to retrieve outdated content from future cache queries.
     *
     * @param model The model to put into the cache
     */

#Code:
    @NotForUIThread
    public final void putModel(final MODEL model, boolean invalidate) {
        super.putModel(model);
        // clear list caches to avoid stale data if needed
        if (invalidate) {
            clearListCache();
        }
    }

#No. 1618
#File: E:\bishe\1\AbstractDiskModelListContentProxy.java
#Comment:
    /**
     * Uses {@link #putModel(JsonModel, boolean)} with invalidate flag set by default to true.
     */

#Code:
    @Override
    @NotForUIThread
    public final void putModel(final MODEL model) {
        putModel(model, true);
    }

#No. 1619
#File: E:\bishe\1\AbstractDiskModelListContentProxy.java
#Comment:
    /**
     * Forces a model list object to be put into the cache.<br> This must be ONLY used for injection
     * testing purposes.
     *
     * @param list The model list to put into the cache
     */

#Code:
    public final void putModelList(String key, final LIST list) {
        if (list == null) {
            return; // fail-safe attitude
        }
        // update model into caches
        mListContentProxy.putModel(key, list);
        // TODO: call onContentUpdated?
    }

#No. 1620
#File: E:\bishe\1\AbstractDiskModelListContentProxy.java
#Comment:
    /**
     * Clears the model lists memory and disk caches.
     *
     * It's safe to execute this method from the UI thread.
     */

#Code:
    public void clearListCache() {
        mListContentProxy.clearCache();
    }

#No. 1621
#File: E:\bishe\1\AbstractDiskSpeedStrategy.java
#Comment:
    /**
     * Override this method to return the speed property on which the selection should be made.
     *
     * @param diskInfo the {@link DiskInfoProvider} that contains R/W {@link Disk} speed
     * @return the value represented by the R/W speed
     */

#Code:
    protected abstract int getDiskSpeed(@Nonnull DiskInfoProvider diskInfo);
}
}

#No. 1622
#File: E:\bishe\1\AbstractDistOpHandler.java
#Comment:
    /**
     * Gets the local {@link TransactionManager}.
     * 
     * @return the transaction manager instance or <code>null</code> if it could not be retrieved
     */

#Code:
    protected final TransactionManager getTransactionManager() {

        if (hazelcastInstance == null) {
            return null;
        }

        final ManagedContext managedContext = hazelcastInstance.getConfig().getManagedContext();
        if (!(managedContext instanceof ManagedDtxContext)) {
            return null;
        }

        return ((ManagedDtxContext) managedContext).getTransactionManager();
    }

#No. 1623
#File: E:\bishe\1\AbstractDistOpHandler.java
#Comment:
    /**
     * Gets the local node ID.
     * 
     * @return the {@link UUID} of this node or <code>null</code> if it could not be retrieved
     */

#Code:
    protected final UUID getNodeId() {
        if (hazelcastInstance == null) {
            return null;
        }

        final ManagedContext managedContext = hazelcastInstance.getConfig().getManagedContext();
        if (!(managedContext instanceof ManagedDtxContext)) {
            return null;
        }

        return ((ManagedDtxContext) managedContext).getNodeId();
    }

#No. 1624
#File: E:\bishe\1\AbstractDistOpHandler.java
#Comment:
    /**
     * Gets the list of participants.
     * 
     * @return (possibly empty) {@link List}t of {@link TxNode}s
     */

#Code:
    protected final List<TxNode> getParticipants() {
        return participants;
    }

#No. 1625
#File: E:\bishe\1\AbstractDistOpHandler.java
#Comment:
    /**
     * Gets the local hazelcast instance.
     * 
     * @return a non-<code>null</code> {@link HazelcastInstance}
     */

#Code:
    final HazelcastInstance getHazelcastInstance() {
        return hazelcastInstance;
    }

#No. 1626
#File: E:\bishe\1\AbstractDistributionHistogramExecutor.java
#Comment:
	/**
	 * <p>Constructor for AbstractDistributionHistogramExecutor.</p>
	 *
	 * @param distribution a {@link lupos.distributed.storage.distributionstrategy.IDistribution} object.
	 */

#Code:
	public AbstractDistributionHistogramExecutor(final IDistribution<K> distribution){
		this.distribution = distribution;
	}

#No. 1627
#File: E:\bishe\1\AbstractDistributionHistogramExecutor.java
#Comment:
	/**
	 * Must be overridden to implement that the request (for histogram or min/max computations) is transmitted over network to the node with a certain key
	 *
	 * @param request the request for histograms or min/max computations serialized as json string
	 * @param key the address of the node to which the request is sent to.
	 * @return the result string (serialized as json string) from the node addressed by key
	 */

#Code:
	public abstract String sendJSONRequest(String request, K key);

	/**
	 * This method is called whenever the type of triple pattern is not supported (e.g. triple pattern with only variables).
	 * Can be overridden to broadcast the request to all nodes.
	 * The default is returning null, which leads to throwing the TriplePatternNotSupportedError.
	 *
	 * @param request the request to be broadcasted
	 * @return the response of all the nodes...
	 */
	public String[] sendJSONRequest(final String request){
		return null;
	}

#No. 1628
#File: E:\bishe\1\AbstractDockerMojo.java
#Comment:
  /**
   * Get the email from the server configuration in <code>~/.m2/settings.xml</code>.
   *
   * <pre>
   * <servers>
   *   <server>
   *     <id>my-private-docker-registry</id>
   *     [...]
   *     <configuration>
   *       <email>foo@bar.com</email>
   *     </configuration>
   *   </server>
   * </servers>
   * </pre>
   *
   * The above <code>settings.xml</code> would return "foo@bar.com".
   *
   * @param server {@link org.apache.maven.settings.Server}
   * @return email string.
   */

#Code:
  private String getEmail(final Server server) {
    String email = null;

    final Xpp3Dom configuration = (Xpp3Dom) server.getConfiguration();

    if (configuration != null) {
      final Xpp3Dom emailNode = configuration.getChild("email");

      if (emailNode != null) {
        email = emailNode.getValue();
      }
    }

    return email;
  }

#No. 1629
#File: E:\bishe\1\AbstractDockerMojo.java
#Comment:
  /**
   * Checks for incomplete private Docker registry authorization settings.
   * @param username Auth username.
   * @param password Auth password.
   * @param email    Auth email.
   * @return boolean true if any of the three credentials are present but not all. False otherwise.
   */

#Code:
  private boolean incompleteAuthSettings(final String username, final String password,
                                         final String email) {
    return (!isNullOrEmpty(username) || !isNullOrEmpty(password) || !isNullOrEmpty(email))
           && (isNullOrEmpty(username) || isNullOrEmpty(password) || isNullOrEmpty(email));

  }

#No. 1630
#File: E:\bishe\1\AbstractDoclet.java
#Comment:
    /**
     * Iterate through all classes and construct documentation for them.
     *  
     * @param root      the RootDoc of source to document.
     * @param classtree the data structure representing the class tree.
     */

#Code:
    protected void generateClassFiles(RootDoc root, ClassTree classtree) {
        generateClassFiles(classtree);
        PackageDoc[] packages = root.specifiedPackages();
        for (int i = 0; i < packages.length; i++) {
            generateClassFiles(packages[i].allClasses(), classtree);
        }
    }    

#No. 1631
#File: E:\bishe\1\AbstractDoclet.java
#Comment:
    /**
     * Generate the class files for single classes specified on the command line.
     * 
     * @param classtree the data structure representing the class tree.
     */

#Code:
    private void generateClassFiles(ClassTree classtree) {
        String[] packageNames = configuration.classDocCatalog.packageNames();
        for (int packageNameIndex = 0; packageNameIndex < packageNames.length; 
                packageNameIndex++) {
            generateClassFiles(configuration.classDocCatalog.allClasses(
                packageNames[packageNameIndex]), classtree);
        }
    }

#No. 1632
#File: E:\bishe\1\AbstractDocSet.java
#Comment:
  /**
   * Internal Decompression Method
   * 
   * @return
   */

#Code:
  private int[] decompress(MyOpenBitSet packedSet) {
    System.err.println("Method not implemented");
    return null;
  }

#No. 1633
#File: E:\bishe\1\AbstractDocSet.java
#Comment:
  /**
   * Internal Decompression Method
   * 
   * @return decompressed in the form of integer array
   */

#Code:
  protected int[] decompress(BitSet packedSet) {
    System.err.println("Method not implemented");
    return null;
  }

#No. 1634
#File: E:\bishe\1\AbstractDocSet.java
#Comment:
  /**
   * Number of compressed units plus the last block
   * @return docset size
   */

#Code:
  public int size() {
    return blob.size() * BATCH_SIZE + current_size;
  }

#No. 1635
#File: E:\bishe\1\AbstractDocSet.java
#Comment:
  /**
   * Add document to this set
   * 
   
  public void addDoc(int docid) {
    if (size() == 0) {
      initSet();
      current[current_size++] = docid;
      current_base = docid;
      lastAdded = current_base;
    }

    else if (current_size == BATCH_SIZE) {

      int exceptionCount = 0;

      // formulate b value. Minimum bits used is 5.
      for (int k = 31; k > 3; k--) {
        // System.out.print(bVal[k]+":");
        exceptionCount += bVal[k];
        if (exceptionCount >= BATCH_OVER) {
          current_b = k;
          exceptionCount -= bVal[k];
          break;
        }
      }

      // Compensate for extra bit
      current_b += 1;

      // set current_exception_count
      current_ex_count = exceptionCount;

      MyOpenBitSet myop = (MyOpenBitSet) compress();
      compressedBits+=myop.capacity();
      blob.add(myop);

      // roll the batch
      current_size = 1;
      current_base = docid;
      lastAdded = current_base;
      current[0] = current_base;
      current_ex_count = 0;

      bVal = new int[33];

    }// end batch boundary

    else {
      try {

        current[current_size] = docid - lastAdded;
        lastAdded = docid;
        if (current[current_size] != 0)
          bVal[(int) (Math.log(current[current_size]) / logBase2) + 1]++;

        current_size++;
      } catch (ArrayIndexOutOfBoundsException w) {
        System.err.println("Error inserting DOC:" + docid);

      }

    } // end append to end of array

  }*/

#Code:

  private static final int[] NUMBITS = new int[256];
  static {
    NUMBITS[0] = 1;
    for(int i = 1; i < 256; i++)
    {
      int j = 7;
      while(j > 0)
      {
        if((i & (1 << j)) != 0) break;
        j--;
      }
      NUMBITS[i] = j + 1;
    }
  }

#No. 1636
#File: E:\bishe\1\AbstractDOMable.java
#Comment:
    /**
     * The property descriptor.
     */

#Code:
    private final PropertyDescriptor<T> propertyDescriptor;

    /**
     * Initialises a new instance of this class.
     *
     * @param propertyDescriptor the property descriptor
     */
    protected AbstractDOMable(@NotNull PropertyDescriptor<T> propertyDescriptor)
    {
        this.propertyDescriptor = propertyDescriptor;
    }

#No. 1637
#File: E:\bishe\1\AbstractDOMableCollection.java
#Comment:
    /**
     *
     */

#Code:
    private final Converter<V> converter;

    /**
     * Initialise a new instance of this class.
     * 
     * @param propertyDescriptor the property descriptor
     * @param converter the persistence converters
     */
    public AbstractDOMableCollection(@NotNull PropertyDescriptor propertyDescriptor,
                                     @NotNull Converter<V> converter)
    {
        super(propertyDescriptor);
        this.converter = converter;
    }

#No. 1638
#File: E:\bishe\1\AbstractDOMableCollection.java
#Comment:
    /**
     * Create a new element with the collection attributes populated.
     *
     * @return a new element
     */

#Code:
    protected Element createCollectionElement()
    {
        Element e = new Element(getPropertyDescriptor().getName());
        e.setAttribute(DOMableType.TYPE,
                       getDOMableType().getName());
        e.setAttribute(DOMableCollectionContentType.CONTENT_TYPE,
                       converter.getContentType().getName());

        return e;
    }

#No. 1639
#File: E:\bishe\1\AbstractDOMableCollection.java
#Comment:
    /**
     * Gets the converter for the content type.
     *
     * @return the converter
     */

#Code:
    @NotNull
    protected Converter<V> getConverter()
    {
        return converter;
    }

#No. 1640
#File: E:\bishe\1\AbstractDomainCanvas.java
#Comment:
  /**
   * Constructor used to export tree without showing it in a dockable
   */

#Code:
  public AbstractDomainCanvas(ValuationDomain values) {
    super(null);
    this.configuration = new DefaultConfiguration<Node>(Options.canv_gapBetweenLevels, Options.canv_gapBetweenNodes);
    this.setFocus(null);
    this.values = values;
    this.marked = new HashMap<Node, Color>();
    this.markEditable = false;
  }

#No. 1641
#File: E:\bishe\1\AbstractDomainCanvas.java
#Comment:
  /**
   * Determines if this instance is markEditable.
   *
   * @return The markEditable.
   */

#Code:
  public boolean isMarkEditable() {
    return this.markEditable;
  }

#No. 1642
#File: E:\bishe\1\AbstractDomainCanvas.java
#Comment:
  /**
   * Sets whether or not this instance is markEditable.
   *
   * @param markEditable
   *          The markEditable.
   */

#Code:
  public void setMarkEditable(boolean markEditable) {
    this.markEditable = markEditable;
    repaint();
  }

#No. 1643
#File: E:\bishe\1\AbstractDomainCanvas.java
#Comment:
  /**
   * {@inheritDoc}
   *
   * @see ADTreeCanvas#getLabel(ADTreeNode)
   */

#Code:
  public String getLabel(Node n) {
    String result;
    if (n == null) {
      return "Null node";
    }
    if (showLabels) {
      result = n.getName() + "\n";
    } else {
      result = "";
    }
    if (this.values.hasEvaluator()) {
      if (this.isSand()) {
        result = result + this.valueToStr(this.values.getTermValue((SandNode) n));
      } else {
        if (((ADTNode) n).hasDefault() && ((ADTNode) n).isCountered()) {
          if (values.isShowAllLabels()) {
            result = result + this.valueToStr(this.values.getTermValue((ADTNode) n)) + "\n";
          }
          result = result + this.valueToStr(values.getValue((ADTNode) n));
        } else {
          result = result + this.valueToStr(this.values.getTermValue((ADTNode) n));
        }
      }
    }
    return result;
  }

#No. 1644
#File: E:\bishe\1\AbstractDomainCanvas.java
#Comment:
  /**
   * Function called whenever a new value is assigned to leaf node
   */

#Code:
  public void valuesUpdated(boolean removeOld) {
    if (this.isSand()) {
      if (removeOld) {
        this.values.treeChanged((SandNode) tree.getRoot(true));
      }
      else {
        this.values.valuesUpdated((SandNode) tree.getRoot(true));
      }
    } else {
      if (removeOld) {
        this.values.treeChanged((ADTNode) tree.getRoot(true));
      }
      else {
        this.values.valuesUpdated((ADTNode) tree.getRoot(true));
      }
    }
    if (controller != null) {
      ValuationsDockable valuationsDockable = (ValuationsDockable) controller.getControl()
          .getSingleDockable(ValuationsDockable.ID_VALUATIONVIEW);
      if (valuationsDockable != null && valuationsDockable.getCanvas() == this) {
        valuationsDockable.setCanvas(this);
        controller.getFrame().getRankingView().setCanvas(this);
      }
      RankingDockable rank = controller.getFrame().getRankingView();
      if (rank != null && rank.getCanvas() == this) {
        rank.setFocus(this, this.getFocused(), true);
      }
    }
    tree.getSharedExtentProvider().updateTreeSize(tree.getRoot(true));
    if (!this.localExtentProvider) {
      tree.getSharedExtentProvider().notifyTreeChanged();
    } else {
      this.treeChanged();
    }
  }

#No. 1645
#File: E:\bishe\1\AbstractDomainCanvas.java
#Comment:
  /**
   * Sets whether or not this instance has a local Extent Provider.
   *
   * @param localExtentProvider
   *          The localExtentProvider.
   */

#Code:
  public void setLocalExtentProvider(boolean localExtentProvider) {
    this.localExtentProvider = localExtentProvider;
    if (localExtentProvider) {
      tree.getSharedExtentProvider().deregisterCanvas(this);
      this.treeChanged();
    } else {
      tree.getSharedExtentProvider().registerCanvas(this);
    }
    getSharedExtentProvider().updateTreeSize(tree.getRoot(true));
    tree.getSharedExtentProvider().notifyTreeChanged();
  }

#No. 1646
#File: E:\bishe\1\AbstractDomainCanvas.java
#Comment:
  /**
   * {@inheritDoc}
   *
   * Used by addEditAction - overriden so edit actions are shared by tree canvas
   * and domain canvases.
   *
   */

#Code:
  public AbstractTreeCanvas getTreeCanvas() {
    TreeDockable currentTree = (TreeDockable) getController().getControl()
        .getMultipleDockable(TreeDockable.TREE_ID + Integer.toString(getTreeId()));
    if (currentTree != null) {
      return currentTree.getCanvas();
    }
    return null;
  }

#No. 1647
#File: E:\bishe\1\AbstractDomEventConverterTest.java
#Comment:
	/**
	 * Creates a DOM event and dispatches it with the specified target. A listener on the same target catches any event
	 * and returns it.
	 *
	 * @param target
	 *            the {@link EventTarget} which will {@link EventTarget#dispatchEvent(Event) dispatch} the created event
	 * @param eventType
	 *            the type of the event as specified here: http://www.w3.org/TR/DOM-Level-3-Events/#event-types-list
	 * @return the DOM-{@link Event} caught from the target
	 */

#Code:
	private static Event createDispatchAndCatchEvent(EventTarget target, String eventType) {
		return createDispatchAndCatchEvent(target, eventType, true, true);
	}

#No. 1648
#File: E:\bishe\1\AbstractDomEventConverterTest.java
#Comment:
	/**
	 * Creates a DOM event and dispatches it with the specified target. A listener on the same target catches any event
	 * and returns it.
	 *
	 * @param target
	 *            the {@link EventTarget} which will {@link EventTarget#dispatchEvent(Event) dispatch} the created event
	 * @param eventType
	 *            the type of the event as specified here: http://www.w3.org/TR/DOM-Level-3-Events/#event-types-list
	 * @param canBubbleArg
	 *            indicates whether the event can bubble
	 * @param cancelableArg
	 *            indicates whether the event can be canceled
	 * @return the DOM-{@link Event} caught from the target
	 */

#Code:
	private static Event createDispatchAndCatchEvent(
			EventTarget target, String eventType, boolean canBubbleArg, boolean cancelableArg) {

		Property<Event> caughtEvent = new SimpleObjectProperty<>();
		target.addEventListener(eventType, caughtEvent::setValue, false);

		Event createdEvent = createEvent(eventType, canBubbleArg, cancelableArg);
		target.dispatchEvent(createdEvent);

		return caughtEvent.getValue();
	}

#No. 1649
#File: E:\bishe\1\AbstractDomEventConverterTest.java
#Comment:
	/**
	 * Creates and initializes a DOM event from the specified arguments.
	 *
	 * @param eventType
	 *            the type of the event as specified here: http://www.w3.org/TR/DOM-Level-3-Events/#event-types-list
	 * @param canBubbleArg
	 *            indicates whether the event can bubble
	 * @param cancelableArg
	 *            indicates whether the event can be canceled
	 * @return the created and initialized DOM-{@link Event}
	 */

#Code:
	private static Event createEvent(String eventType, boolean canBubbleArg, boolean cancelableArg) {
		Event event = new EventImpl();
		event.initEvent(eventType, canBubbleArg, cancelableArg);
		return event;
	}

#No. 1650
#File: E:\bishe\1\AbstractDosgiTest.java
#Comment:
    /**
     * Sleeps for a short interval, throwing an exception if timeout has been reached. Used to facilitate a
     * retry interval with timeout when used in a loop.
     *
     * @param startTime the start time of the entire operation in milliseconds
     * @param timeout the timeout duration for the entire operation in seconds
     * @param message the error message to use when timeout occurs
     * @throws InterruptedException if interrupted while sleeping
     */

#Code:
    private static void sleepOrTimeout(long startTime, long timeout, String message)
        throws InterruptedException, TimeoutException {
        timeout *= 1000; // seconds to millis
        long elapsed = System.currentTimeMillis() - startTime;
        long remaining = timeout - elapsed;
        if (remaining <= 0) {
            throw new TimeoutException(message);
        }
        long interval = Math.min(remaining, 1000);
        Thread.sleep(interval);
    }

#No. 1651
#File: E:\bishe\1\AbstractDoubleList.java
#Comment:
    /**
     * Returns the index of the first occurrence of the specified element.
     * Returns <code>-1</code> if the receiver does not contain this element.
     * 
     * @param element
     *            the element to be searched for.
     * @return the index of the first occurrence of the element in the receiver;
     *         returns <code>-1</code> if the element is not found.
     */

#Code:
    public int indexOf(double element) { // delta
        return indexOfFromTo(element, 0, size - 1);
    }

#No. 1652
#File: E:\bishe\1\AbstractDoubleList.java
#Comment:
    /**
     * Returns the index of the first occurrence of the specified element.
     * Returns <code>-1</code> if the receiver does not contain this element.
     * Searches between <code>from</code>, inclusive and <code>to</code>,
     * inclusive. Tests for identity.
     * 
     * @param element
     *            element to search for.
     * @param from
     *            the leftmost search position, inclusive.
     * @param to
     *            the rightmost search position, inclusive.
     * @return the index of the first occurrence of the element in the receiver;
     *         returns <code>-1</code> if the element is not found.
     * @exception IndexOutOfBoundsException
     *                index is out of range (
     *                <tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>
     *                ).
     */

#Code:
    public int indexOfFromTo(double element, int from, int to) {
        checkRangeFromTo(from, to, size);

        for (int i = from; i <= to; i++) {
            if (element == getQuick(i))
                return i; // found
        }
        return -1; // not found
    }

#No. 1653
#File: E:\bishe\1\AbstractDoubleList.java
#Comment:
    /**
     * Returns the index of the last occurrence of the specified element.
     * Returns <code>-1</code> if the receiver does not contain this element.
     * 
     * @param element
     *            the element to be searched for.
     * @return the index of the last occurrence of the element in the receiver;
     *         returns <code>-1</code> if the element is not found.
     */

#Code:
    public int lastIndexOf(double element) {
        return lastIndexOfFromTo(element, 0, size - 1);
    }

#No. 1654
#File: E:\bishe\1\AbstractDoubleList.java
#Comment:
    /**
     * Returns the index of the last occurrence of the specified element.
     * Returns <code>-1</code> if the receiver does not contain this element.
     * Searches beginning at <code>to</code>, inclusive until <code>from</code>,
     * inclusive. Tests for identity.
     * 
     * @param element
     *            element to search for.
     * @param from
     *            the leftmost search position, inclusive.
     * @param to
     *            the rightmost search position, inclusive.
     * @return the index of the last occurrence of the element in the receiver;
     *         returns <code>-1</code> if the element is not found.
     * @exception IndexOutOfBoundsException
     *                index is out of range (
     *                <tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>
     *                ).
     */

#Code:
    public int lastIndexOfFromTo(double element, int from, int to) {
        checkRangeFromTo(from, to, size());

        for (int i = to; i >= from; i--) {
            if (element == getQuick(i))
                return i; // found
        }
        return -1; // not found
    }

#No. 1655
#File: E:\bishe\1\AbstractDoubleList.java
#Comment:
    /**
     * Sorts the specified range of the receiver into ascending order.
     * 
     * The sorting algorithm is a modified mergesort (in which the merge is
     * omitted if the highest element in the low sublist is less than the lowest
     * element in the high sublist). This algorithm offers guaranteed n*log(n)
     * performance, and can approach linear performance on nearly sorted lists.
     * 
     * <p>
     * <b>You should never call this method unless you are sure that this
     * particular sorting algorithm is the right one for your data set.</b> It
     * is generally better to call <tt>sort()</tt> or <tt>sortFromTo(...)</tt>
     * instead, because those methods automatically choose the best sorting
     * algorithm.
     * 
     * @param from
     *            the index of the first element (inclusive) to be sorted.
     * @param to
     *            the index of the last element (inclusive) to be sorted.
     * @exception IndexOutOfBoundsException
     *                index is out of range (
     *                <tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>
     *                ).
     */

#Code:

    public void mergeSortFromTo(int from, int to) {
        int mySize = size();
        checkRangeFromTo(from, to, mySize);

        double[] myElements = elements();
        cern.colt.Sorting.mergeSort(myElements, from, to + 1);
        elements(myElements);
        setSizeRaw(mySize);
    }

#No. 1656
#File: E:\bishe\1\AbstractDoubleList.java
#Comment:
    /**
     * Sorts the receiver according to the order induced by the specified
     * comparator. All elements in the range must be <i>mutually comparable</i>
     * by the specified comparator (that is, <tt>c.compare(e1, e2)</tt> must not
     * throw a <tt>ClassCastException</tt> for any elements <tt>e1</tt> and
     * <tt>e2</tt> in the range).
     * <p>
     * 
     * This sort is guaranteed to be <i>stable</i>: equal elements will not be
     * reordered as a result of the sort.
     * <p>
     * 
     * The sorting algorithm is a modified mergesort (in which the merge is
     * omitted if the highest element in the low sublist is less than the lowest
     * element in the high sublist). This algorithm offers guaranteed n*log(n)
     * performance, and can approach linear performance on nearly sorted lists.
     * 
     * @param from
     *            the index of the first element (inclusive) to be sorted.
     * @param to
     *            the index of the last element (inclusive) to be sorted.
     * @param c
     *            the comparator to determine the order of the receiver.
     * @throws ClassCastException
     *             if the array contains elements that are not <i>mutually
     *             comparable</i> using the specified comparator.
     * @throws IllegalArgumentException
     *             if <tt>fromIndex &gt; toIndex</tt>
     * @throws ArrayIndexOutOfBoundsException
     *             if <tt>fromIndex &lt; 0</tt> or
     *             <tt>toIndex &gt; a.length</tt>
     * @exception IndexOutOfBoundsException
     *                index is out of range (
     *                <tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>
     *                ).
     */

#Code:
    public void mergeSortFromTo(int from, int to, DoubleComparator c) {
        int mySize = size();
        checkRangeFromTo(from, to, mySize);

        double[] myElements = elements();
        cern.colt.Sorting.mergeSort(myElements, from, to + 1, c);
        elements(myElements);
        setSizeRaw(mySize);
    }

#No. 1657
#File: E:\bishe\1\AbstractDoubleList.java
#Comment:
    /**
     * Returns a new list of the part of the receiver between <code>from</code>,
     * inclusive, and <code>to</code>, inclusive.
     * 
     * @param from
     *            the index of the first element (inclusive).
     * @param to
     *            the index of the last element (inclusive).
     * @return a new list
     * @exception IndexOutOfBoundsException
     *                index is out of range (
     *                <tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>
     *                ).
     */

#Code:
    public AbstractDoubleList partFromTo(int from, int to) {
        checkRangeFromTo(from, to, size);

        int length = to - from + 1;
        DoubleArrayList part = new DoubleArrayList(length);
        part.addAllOfFromTo(this, from, to);
        return part;
    }

#No. 1658
#File: E:\bishe\1\AbstractDoubleList.java
#Comment:
    /**
     * Sorts the specified range of the receiver into ascending numerical order.
     * The sorting algorithm is a tuned quicksort, adapted from Jon L. Bentley
     * and M. Douglas McIlroy's "Engineering a Sort Function", Software-Practice
     * and Experience, Vol. 23(11) P. 1249-1265 (November 1993). This algorithm
     * offers n*log(n) performance on many data sets that cause other quicksorts
     * to degrade to quadratic performance.
     * 
     * <p>
     * <b>You should never call this method unless you are sure that this
     * particular sorting algorithm is the right one for your data set.</b> It
     * is generally better to call <tt>sort()</tt> or <tt>sortFromTo(...)</tt>
     * instead, because those methods automatically choose the best sorting
     * algorithm.
     * 
     * @param from
     *            the index of the first element (inclusive) to be sorted.
     * @param to
     *            the index of the last element (inclusive) to be sorted.
     * @exception IndexOutOfBoundsException
     *                index is out of range (
     *                <tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>
     *                ).
     */

#Code:

    public void quickSortFromTo(int from, int to) {
        int mySize = size();
        checkRangeFromTo(from, to, mySize);

        double[] myElements = elements();
        java.util.Arrays.sort(myElements, from, to + 1);
        // cern.colt.Sorting.mergeSort(myElements, from, to+1); // TODO just for
        // debugging

        elements(myElements);
        setSizeRaw(mySize);
    }

#No. 1659
#File: E:\bishe\1\AbstractDoubleList.java
#Comment:
    /**
     * Sorts the receiver according to the order induced by the specified
     * comparator. All elements in the range must be <i>mutually comparable</i>
     * by the specified comparator (that is, <tt>c.compare(e1, e2)</tt> must not
     * throw a <tt>ClassCastException</tt> for any elements <tt>e1</tt> and
     * <tt>e2</tt> in the range).
     * <p>
     * 
     * The sorting algorithm is a tuned quicksort, adapted from Jon L. Bentley
     * and M. Douglas McIlroy's "Engineering a Sort Function", Software-Practice
     * and Experience, Vol. 23(11) P. 1249-1265 (November 1993). This algorithm
     * offers n*log(n) performance on many data sets that cause other quicksorts
     * to degrade to quadratic performance.
     * 
     * @param from
     *            the index of the first element (inclusive) to be sorted.
     * @param to
     *            the index of the last element (inclusive) to be sorted.
     * @param c
     *            the comparator to determine the order of the receiver.
     * @throws ClassCastException
     *             if the array contains elements that are not <i>mutually
     *             comparable</i> using the specified comparator.
     * @throws IllegalArgumentException
     *             if <tt>fromIndex &gt; toIndex</tt>
     * @throws ArrayIndexOutOfBoundsException
     *             if <tt>fromIndex &lt; 0</tt> or
     *             <tt>toIndex &gt; a.length</tt>
     * @exception IndexOutOfBoundsException
     *                index is out of range (
     *                <tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>
     *                ).
     */

#Code:
    public void quickSortFromTo(int from, int to, DoubleComparator c) {
        int mySize = size();
        checkRangeFromTo(from, to, mySize);

        double[] myElements = elements();
        cern.colt.Sorting.quickSort(myElements, from, to + 1, c);
        elements(myElements);
        setSizeRaw(mySize);
    }

#No. 1660
#File: E:\bishe\1\AbstractDoubleList.java
#Comment:
    /**
     * Removes from the receiver all elements that are contained in the
     * specified list. Tests for identity.
     * 
     * @param other
     *            the other list.
     * @return <code>true</code> if the receiver changed as a result of the
     *         call.
     */

#Code:
    public boolean removeAll(AbstractDoubleList other) {
        if (other.size() == 0)
            return false; // nothing to do
        int limit = other.size() - 1;
        int j = 0;

        for (int i = 0; i < size; i++) {
            if (other.indexOfFromTo(getQuick(i), 0, limit) < 0)
                setQuick(j++, getQuick(i));
        }

        boolean modified = (j != size);
        setSize(j);
        return modified;
    }

#No. 1661
#File: E:\bishe\1\AbstractDoubleList.java
#Comment:
    /**
     * Removes from the receiver all elements whose index is between
     * <code>from</code>, inclusive and <code>to</code>, inclusive. Shifts any
     * succeeding elements to the left (reduces their index). This call shortens
     * the list by <tt>(to - from + 1)</tt> elements.
     * 
     * @param from
     *            index of first element to be removed.
     * @param to
     *            index of last element to be removed.
     * @exception IndexOutOfBoundsException
     *                index is out of range (
     *                <tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>
     *                ).
     */

#Code:

    public void removeFromTo(int from, int to) {
        checkRangeFromTo(from, to, size);
        int numMoved = size - to - 1;
        if (numMoved > 0) {
            replaceFromToWithFrom(from, from - 1 + numMoved, this, to + 1);
            // fillFromToWith(from+numMoved, size-1, 0.0f); //delta
        }
        int width = to - from + 1;
        if (width > 0)
            setSizeRaw(size - width);
    }

#No. 1662
#File: E:\bishe\1\AbstractDoubleList.java
#Comment:
    /**
     * Replaces a number of elements in the receiver with the same number of
     * elements of another list. Replaces elements in the receiver, between
     * <code>from</code> (inclusive) and <code>to</code> (inclusive), with
     * elements of <code>other</code>, starting from <code>otherFrom</code>
     * (inclusive).
     * 
     * @param from
     *            the position of the first element to be replaced in the
     *            receiver
     * @param to
     *            the position of the last element to be replaced in the
     *            receiver
     * @param other
     *            list holding elements to be copied into the receiver.
     * @param otherFrom
     *            position of first element within other list to be copied.
     */

#Code:
    public void replaceFromToWithFrom(int from, int to, AbstractDoubleList other, int otherFrom) {
        int length = to - from + 1;
        if (length > 0) {
            checkRangeFromTo(from, to, size());
            checkRangeFromTo(otherFrom, otherFrom + length - 1, other.size());

            // unambiguous copy (it may hold other==this)
            if (from <= otherFrom) {
                for (; --length >= 0;)
                    setQuick(from++, other.getQuick(otherFrom++));
            } else {
                int otherTo = otherFrom + length - 1;
                for (; --length >= 0;)
                    setQuick(to--, other.getQuick(otherTo--));
            }

        }
    }

#No. 1663
#File: E:\bishe\1\AbstractDoubleList.java
#Comment:
    /**
     * Replaces the part between <code>from</code> (inclusive) and
     * <code>to</code> (inclusive) with the other list's part between
     * <code>otherFrom</code> and <code>otherTo</code>. Powerful (and tricky)
     * method! Both parts need not be of the same size (part A can both be
     * smaller or larger than part B). Parts may overlap. Receiver and other
     * list may (but most not) be identical. If <code>from &gt; to</code>, then
     * inserts other part before <code>from</code>.
     * 
     * @param from
     *            the first element of the receiver (inclusive)
     * @param to
     *            the last element of the receiver (inclusive)
     * @param other
     *            the other list (may be identical with receiver)
     * @param otherFrom
     *            the first element of the other list (inclusive)
     * @param otherTo
     *            the last element of the other list (inclusive)
     * 
     *            <p>
     *            <b>Examples:</b>
     * 
     *            <pre>
     * a=[0, 1, 2, 3, 4, 5, 6, 7]
     * b=[50, 60, 70, 80, 90]
     * a.R(...)=a.replaceFromToWithFromTo(...)
     * 
     * a.R(3,5,b,0,4)--&gt;[0, 1, 2, 50, 60, 70, 80, 90, 6, 7]
     * a.R(1,6,b,0,4)--&gt;[0, 50, 60, 70, 80, 90, 7]
     * a.R(0,6,b,0,4)--&gt;[50, 60, 70, 80, 90, 7]
     * a.R(3,5,b,1,2)--&gt;[0, 1, 2, 60, 70, 6, 7]
     * a.R(1,6,b,1,2)--&gt;[0, 60, 70, 7]
     * a.R(0,6,b,1,2)--&gt;[60, 70, 7]
     * a.R(5,3,b,0,4)--&gt;[0, 1, 2, 3, 4, 50, 60, 70, 80, 90, 5, 6, 7]
     * a.R(5,0,b,0,4)--&gt;[0, 1, 2, 3, 4, 50, 60, 70, 80, 90, 5, 6, 7]
     * a.R(5,3,b,1,2)--&gt;[0, 1, 2, 3, 4, 60, 70, 5, 6, 7]
     * a.R(5,0,b,1,2)--&gt;[0, 1, 2, 3, 4, 60, 70, 5, 6, 7]
     * 
     * Extreme cases:
     * a.R(5,3,b,0,0)--&gt;[0, 1, 2, 3, 4, 50, 5, 6, 7]
     * a.R(5,3,b,4,4)--&gt;[0, 1, 2, 3, 4, 90, 5, 6, 7]
     * a.R(3,5,a,0,1)--&gt;[0, 1, 2, 0, 1, 6, 7]
     * a.R(3,5,a,3,5)--&gt;[0, 1, 2, 3, 4, 5, 6, 7]
     * a.R(3,5,a,4,4)--&gt;[0, 1, 2, 4, 6, 7]
     * a.R(5,3,a,0,4)--&gt;[0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 5, 6, 7]
     * a.R(0,-1,b,0,4)--&gt;[50, 60, 70, 80, 90, 0, 1, 2, 3, 4, 5, 6, 7]
     * a.R(0,-1,a,0,4)--&gt;[0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 5, 6, 7]
     * a.R(8,0,a,0,4)--&gt;[0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4]
     * </pre>
     */

#Code:
    public void replaceFromToWithFromTo(int from, int to, AbstractDoubleList other, int otherFrom, int otherTo) {
        if (otherFrom > otherTo) {
            throw new IndexOutOfBoundsException("otherFrom: " + otherFrom + ", otherTo: " + otherTo);
        }

        if (this == other && to - from != otherTo - otherFrom) { // avoid
            // stumbling
            // over my
            // own feet
            replaceFromToWithFromTo(from, to, partFromTo(otherFrom, otherTo), 0, otherTo - otherFrom);
            return;
        }

        int length = otherTo - otherFrom + 1;
        int diff = length;
        int theLast = from - 1;

        if (to >= from) {
            diff -= (to - from + 1);
            theLast = to;
        }

        if (diff > 0) {
            beforeInsertDummies(theLast + 1, diff);
        } else {
            if (diff < 0) {
                removeFromTo(theLast + diff, theLast - 1);
            }
        }

        if (length > 0) {
            replaceFromToWithFrom(from, from + length - 1, other, otherFrom);
        }
    }

#No. 1664
#File: E:\bishe\1\AbstractDoubleList.java
#Comment:
    /**
     * Replaces the part of the receiver starting at <code>from</code>
     * (inclusive) with all the elements of the specified collection. Does not
     * alter the size of the receiver. Replaces exactly
     * <tt>Math.max(0,Math.min(size()-from, other.size()))</tt> elements.
     * 
     * @param from
     *            the index at which to copy the first element from the
     *            specified collection.
     * @param other
     *            Collection to replace part of the receiver
     * @exception IndexOutOfBoundsException
     *                index is out of range (index &lt; 0 || index &gt;=
     *                size()).
     */

#Code:

    public void replaceFromWith(int from, java.util.Collection other) {
        checkRange(from, size());
        java.util.Iterator e = other.iterator();
        int index = from;
        int limit = Math.min(size() - from, other.size());
        for (int i = 0; i < limit; i++)
            set(index++, ((Number) e.next()).doubleValue()); // delta
    }

#No. 1665
#File: E:\bishe\1\AbstractDoubleList.java
#Comment:
    /**
     * Retains (keeps) only the elements in the receiver that are contained in
     * the specified other list. In other words, removes from the receiver all
     * of its elements that are not contained in the specified other list.
     * 
     * @param other
     *            the other list to test against.
     * @return <code>true</code> if the receiver changed as a result of the
     *         call.
     */

#Code:
    public boolean retainAll(AbstractDoubleList other) {
        if (other.size() == 0) {
            if (size == 0)
                return false;
            setSize(0);
            return true;
        }

        int limit = other.size() - 1;
        int j = 0;
        for (int i = 0; i < size; i++) {
            if (other.indexOfFromTo(getQuick(i), 0, limit) >= 0)
                setQuick(j++, getQuick(i));
        }

        boolean modified = (j != size);
        setSize(j);
        return modified;
    }

#No. 1666
#File: E:\bishe\1\AbstractDoubleList.java
#Comment:
    /**
     * Reverses the elements of the receiver. Last becomes first, second last
     * becomes second first, and so on.
     */

#Code:

    public void reverse() {
        double tmp;
        int limit = size() / 2;
        int j = size() - 1;

        for (int i = 0; i < limit;) { // swap
            tmp = getQuick(i);
            setQuick(i++, getQuick(j));
            setQuick(j--, tmp);
        }
    }

#No. 1667
#File: E:\bishe\1\AbstractDoubleList.java
#Comment:
    /**
     * Replaces the element at the specified position in the receiver with the
     * specified element.
     * 
     * @param index
     *            index of element to replace.
     * @param element
     *            element to be stored at the specified position.
     * @throws IndexOutOfBoundsException
     *             if <tt>index &lt; 0 || index &gt;= size()</tt>.
     */

#Code:
    public void set(int index, double element) {
        if (index >= size || index < 0)
            throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size);
        setQuick(index, element);
    }

#No. 1668
#File: E:\bishe\1\AbstractDoubleList.java
#Comment:
    /**
     * Sets the size of the receiver without modifying it otherwise. This method
     * should not release or allocate new memory but simply set some instance
     * variable like <tt>size</tt>.
     * 
     * If your subclass overrides and delegates size changing methods to some
     * other object, you must make sure that those overriding methods not only
     * update the size of the delegate but also of this class. For example:
     * public DatabaseList extends AbstractDoubleList { ... public void
     * removeFromTo(int from,int to) { myDatabase.removeFromTo(from,to);
     * this.setSizeRaw(size-(to-from+1)); } }
     */

#Code:
    protected void setSizeRaw(int newSize) {
        size = newSize;
    }

#No. 1669
#File: E:\bishe\1\AbstractDoubleList.java
#Comment:
    /**
     * Randomly permutes the part of the receiver between <code>from</code>
     * (inclusive) and <code>to</code> (inclusive).
     * 
     * @param from
     *            the index of the first element (inclusive) to be permuted.
     * @param to
     *            the index of the last element (inclusive) to be permuted.
     * @exception IndexOutOfBoundsException
     *                index is out of range (
     *                <tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>
     *                ).
     */

#Code:

    public void shuffleFromTo(int from, int to) {
        checkRangeFromTo(from, to, size());

        cern.jet.random.tdouble.DoubleUniform gen = new cern.jet.random.tdouble.DoubleUniform(
                AbstractDoubleDistribution.makeDefaultGenerator());
        for (int i = from; i < to; i++) {
            int random = gen.nextIntFromTo(i, to);

            // swap(i, random)
            double tmpElement = getQuick(random);
            setQuick(random, getQuick(i));
            setQuick(i, tmpElement);
        }
    }

#No. 1670
#File: E:\bishe\1\AbstractDoubleList.java
#Comment:
    /**
     * Returns the number of elements contained in the receiver.
     * 
     * @return the number of elements contained in the receiver.
     */

#Code:

    public int size() {
        return size;
    }

#No. 1671
#File: E:\bishe\1\AbstractDoubleList.java
#Comment:
    /**
     * Returns a list which is a concatenation of <code>times</code> times the
     * receiver.
     * 
     * @param times
     *            the number of times the receiver shall be copied.
     */

#Code:
    public AbstractDoubleList times(int times) {
        AbstractDoubleList newList = new DoubleArrayList(times * size());
        for (int i = times; --i >= 0;) {
            newList.addAllOfFromTo(this, 0, size() - 1);
        }
        return newList;
    }

#No. 1672
#File: E:\bishe\1\AbstractDoubleList.java
#Comment:
    /**
     * Returns a <code>java.util.ArrayList</code> containing all the elements in
     * the receiver.
     */

#Code:

    public java.util.ArrayList toList() {
        int mySize = size();
        java.util.ArrayList list = new java.util.ArrayList(mySize);
        for (int i = 0; i < mySize; i++)
            list.add(new Double(get(i)));
        return list;
    }

#No. 1673
#File: E:\bishe\1\AbstractDoubleList.java
#Comment:
    /**
     * Returns a string representation of the receiver, containing the String
     * representation of each element.
     */

#Code:

    public String toString() {
        return cern.colt.Arrays.toString(partFromTo(0, size() - 1).elements());
    }

#No. 1674
#File: E:\bishe\1\AbstractDownloadLicensesMojo.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public boolean isIncludeTransitiveDependencies()
    {
        return includeTransitiveDependencies;
    }

#No. 1675
#File: E:\bishe\1\AbstractDownloadLicensesMojo.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public boolean isExcludeTransitiveDependencies()
    {
        return excludeTransitiveDependencies;
    }

#No. 1676
#File: E:\bishe\1\AbstractDownloadLicensesMojo.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public List<String> getExcludedScopes()
    {
        return MojoHelper.getParams( excludedScopes );
    }

#No. 1677
#File: E:\bishe\1\AbstractDownloadLicensesMojo.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public List<String> getIncludedScopes()
    {
        return MojoHelper.getParams( includedScopes );
    }

#No. 1678
#File: E:\bishe\1\AbstractDownloadLicensesMojo.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public String getIncludedArtifacts()
    {
        return includedArtifacts;
    }

#No. 1679
#File: E:\bishe\1\AbstractDownloadLicensesMojo.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public String getIncludedGroups()
    {
        return includedGroups;
    }

#No. 1680
#File: E:\bishe\1\AbstractDownloadLicensesMojo.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public String getExcludedGroups()
    {
        return excludedGroups;
    }

#No. 1681
#File: E:\bishe\1\AbstractDownloadLicensesMojo.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public String getExcludedArtifacts()
    {
        return excludedArtifacts;
    }

#No. 1682
#File: E:\bishe\1\AbstractDownloadLicensesMojo.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public boolean isVerbose()
    {
        return getLog().isDebugEnabled();
    }

#No. 1683
#File: E:\bishe\1\AbstractDownloadLicensesMojo.java
#Comment:
    /**
     * Load the license information contained in a file if it exists. Will overwrite existing license information in the
     * map for dependencies with the same id. If the config file does not exist, the method does nothing.
     *
     * @param configuredDepLicensesMap A map between the dependencyId and the license info
     * @param licenseConfigFile        The license configuration file to load
     * @param previouslyDownloaded     Whether these licenses were already downloaded
     * @throws MojoExecutionException if could not load license infos
     */

#Code:
    private void loadLicenseInfo( Map<String, ProjectLicenseInfo> configuredDepLicensesMap, File licenseConfigFile,
                                  boolean previouslyDownloaded )
        throws MojoExecutionException
    {
        FileInputStream fis = null;
        try
        {
            fis = new FileInputStream( licenseConfigFile );
            List<ProjectLicenseInfo> licensesList = LicenseSummaryReader.parseLicenseSummary( fis );
            for ( ProjectLicenseInfo dep : licensesList )
            {
                configuredDepLicensesMap.put( dep.getId(), dep );
                if ( previouslyDownloaded )
                {
                    for ( License license : dep.getLicenses() )
                    {
                        // Save the URL so we don't download it again
                        downloadedLicenseURLs.add( license.getUrl() );
                    }
                }
            }
        }
        catch ( Exception e )
        {
            throw new MojoExecutionException( "Unable to parse license summary output file: " + licenseConfigFile, e );
        }
        finally
        {
            FileUtil.tryClose( fis );
        }
    }

#No. 1684
#File: E:\bishe\1\AbstractDownloadLicensesMojo.java
#Comment:
    /**
     * Returns the project ID for the artifact
     *
     * @param artifact the artifact
     * @return groupId:artifactId
     */

#Code:
    private String getArtifactProjectId( Artifact artifact )
    {
        return artifact.getGroupId() + ":" + artifact.getArtifactId();
    }

#No. 1685
#File: E:\bishe\1\AbstractDownloadLicensesMojo.java
#Comment:
    /**
     * Create a simple DependencyProject object containing the GAV and license info from the Maven Artifact
     *
     * @param depMavenProject the dependency maven project
     * @return DependencyProject with artifact and license info
     */

#Code:
    private ProjectLicenseInfo createDependencyProject( MavenProject depMavenProject )
    {
        ProjectLicenseInfo dependencyProject =
            new ProjectLicenseInfo( depMavenProject.getGroupId(), depMavenProject.getArtifactId(),
                                    depMavenProject.getVersion() );
        List<?> licenses = depMavenProject.getLicenses();
        for ( Object license : licenses )
        {
            dependencyProject.addLicense( (License) license );
        }
        return dependencyProject;
    }

#No. 1686
#File: E:\bishe\1\AbstractDownloadLicensesMojo.java
#Comment:
    /**
     * Determine filename to use for downloaded license file. The file name is based on the configured name of the
     * license (if available) and the remote filename of the license.
     *
     * @param depProject the project containing the license
     * @param license    the license
     * @return A filename to be used for the downloaded license file
     * @throws MalformedURLException if the license url is malformed
     */

#Code:
    private String getLicenseFileName( ProjectLicenseInfo depProject, License license )
        throws MalformedURLException
    {
        String defaultExtension = ".txt";

        URL licenseUrl = new URL( license.getUrl() );
        File licenseUrlFile = new File( licenseUrl.getPath() );

        String licenseFileName;

        if ( organizeLicensesByDependencies )
        {
            licenseFileName = String.format( "%s.%s%s", depProject.getGroupId(), depProject.getArtifactId(),
                                             license.getName() != null
                                                 ? "_" + license.getName()
                                                 : "" ).toLowerCase().replaceAll( "\\s+", "_" );
        }
        else
        {
            licenseFileName = licenseUrlFile.getName();

            if ( license.getName() != null )
            {
                licenseFileName = license.getName().replaceAll( "/", "_" ) + " - " + licenseUrlFile.getName();
            }

            // Check if the file has a valid file extention
            int extensionIndex = licenseFileName.lastIndexOf( "." );
            if ( extensionIndex == -1 || extensionIndex > ( licenseFileName.length() - 3 ) )
            {
                // This means it isn't a valid file extension, so append the default
                licenseFileName = licenseFileName + defaultExtension;
            }

            // Force lower case so we don't end up with multiple copies of the same license
            licenseFileName = licenseFileName.toLowerCase();
        }
        return licenseFileName;
    }

#No. 1687
#File: E:\bishe\1\AbstractDownloadMojo.java
#Comment:
/**
 * Downloads any dependent NAR files. This includes the noarch and aol type NAR files.
 */

#Code:
public abstract class AbstractDownloadMojo
    extends AbstractDependencyMojo
{

    /**
     * Artifact resolver, needed to download the attached nar files.
     * 
     * @component role="org.apache.maven.artifact.resolver.ArtifactResolver"
     * @required
     * @readonly
     */
    protected ArtifactResolver artifactResolver;

    /**
     * Remote repositories which will be searched for nar attachments.
     * 
     * @parameter expression="${project.remoteArtifactRepositories}"
     * @required
     * @readonly
     */
    protected List remoteArtifactRepositories;

    /**
     * List of classifiers which you want download. Example ppc-MacOSX-g++, x86-Windows-msvc, i386-Linux-g++.
     * 
     * @parameter expression=""
     */
    protected List classifiers;
}

#No. 1688
#File: E:\bishe\1\AbstractDownloadTaskModel.java
#Comment:
	/**
	 * @return 该节点的索引，仅用于按时间排序（越晚索引越大）
	 */

#Code:
	public int getIndex() {
		return idx;
	}

#No. 1689
#File: E:\bishe\1\AbstractDownloadTaskModel.java
#Comment:
	/**
	 * @return 如果该任务因异常中止，则返回此异常，否则返回null
	 */

#Code:
	public Throwable getException() {
		return exception;
	}

#No. 1690
#File: E:\bishe\1\AbstractDownloadTaskModel.java
#Comment:
	/**
	 * @return 任务是否因取消而中止
	 */

#Code:
	public boolean isCancelled() {
		return future.isCancelled();
	}

#No. 1691
#File: E:\bishe\1\AbstractDownloadTaskModel.java
#Comment:
	/**
	 * @return 任务是否已完成（成功、失败或取消）
	 */

#Code:
	public boolean isDone() {
		return future.isDone();
	}

#No. 1692
#File: E:\bishe\1\AbstractDPMM.java
#Comment:
        /**
         * Alpha value of Dirichlet process
         */

#Code:
        private double alpha;    
        
        private int maxIterations = 1000;
        
        /**
         * Initialization method enum.
         */
        public enum Initialization {
            /**
             * One cluster per record.
             */
            ONE_CLUSTER_PER_RECORD,
            
            /**
             * Random Assignment in a*log(n) clusters.
             */
            RANDOM_ASSIGNMENT;
        }

#No. 1693
#File: E:\bishe\1\AbstractDPMM.java
#Comment:
        /**
         * Getter for Alpha hyperparameter.
         * 
         * @return 
         */

#Code:
        public double getAlpha() {
            return alpha;
        }

#No. 1694
#File: E:\bishe\1\AbstractDPMM.java
#Comment:
        /**
         * Setter for Alpha hyperparameter.
         * 
         * @param alpha 
         */

#Code:
        public void setAlpha(double alpha) {
            this.alpha = alpha;
        }

#No. 1695
#File: E:\bishe\1\AbstractDPMM.java
#Comment:
        /**
         * Getter for the maximum permitted iterations during training.
         * 
         * @return 
         */

#Code:
        public int getMaxIterations() {
            return maxIterations;
        }

#No. 1696
#File: E:\bishe\1\AbstractDPMM.java
#Comment:
        /**
         * Setter for the maximum permitted iterations during training.
         * 
         * @param maxIterations 
         */

#Code:
        public void setMaxIterations(int maxIterations) {
            this.maxIterations = maxIterations;
        }

#No. 1697
#File: E:\bishe\1\AbstractDPMM.java
#Comment:
        /**
         * Getter for the initialization method that we use.
         * 
         * @return 
         */

#Code:
        public Initialization getInitializationMethod() {
            return initializationMethod;
        }

#No. 1698
#File: E:\bishe\1\AbstractDPMM.java
#Comment:
        /**
         * Setter for the initialization method that we use.
         * 
         * @param initializationMethod 
         */

#Code:
        public void setInitializationMethod(Initialization initializationMethod) {
            this.initializationMethod = initializationMethod;
        }

#No. 1699
#File: E:\bishe\1\AbstractDPMM.java
#Comment:
    /**
     * @param trainingParameters
     * @param configuration
     * @see AbstractTrainer#AbstractTrainer(AbstractTrainer.AbstractTrainingParameters, Configuration)
     */

#Code:
    protected AbstractDPMM(TP trainingParameters, Configuration configuration) {
        super(trainingParameters, configuration);
    }

#No. 1700
#File: E:\bishe\1\AbstractDPMM.java
#Comment:
    /**
     * @param storageName
     * @param configuration
     * @see AbstractTrainer#AbstractTrainer(String, Configuration)
     */

#Code:
    protected AbstractDPMM(String storageName, Configuration configuration) {
        super(storageName, configuration);
    }

#No. 1701
#File: E:\bishe\1\AbstractDPMM.java
#Comment:
    /**
     * Always use this method to get the cluster from the clusterMap because it 
     * ensures that the featureIds are set.
     * The featureIds can be unset if we use a data structure which stores
     * stuff in file. Since the featureIds field of cluster is transient, the
     * information gets lost. This function ensures that it sets it back.
     * 
     * @param clusterId
     * @param clusterMap
     * @return 
     */

#Code:
    private CL getFromClusterMap(int clusterId, Map<Integer, CL> clusterMap) {
        CL c = clusterMap.get(clusterId);
        if(c.getFeatureIds() == null) {
            c.setFeatureIds(knowledgeBase.getModelParameters().getFeatureIds()); //fetch the featureIds from model parameters object
        }
        return c;
    }

#No. 1702
#File: E:\bishe\1\AbstractDragAndDropData.java
#Comment:
/**
 * Abstract superclass for {@link DragAndDropData} implementations.
 * 
 * @author Curtis Rueden
 */

#Code:
public abstract class AbstractDragAndDropData extends AbstractContextual
	implements DragAndDropData
{
	// NB: No implementation needed.
}

#No. 1703
#File: E:\bishe\1\AbstractDrawCommand.java
#Comment:
    /**
     * Get a java.awt.Color from a String
     * @param value A String value
     * @return The java.awt.Color
     */

#Code:
    protected Color getColor(String value) {
        String[] parts = value.split(",");
        int r = Integer.parseInt(parts[0]);
        int g = Integer.parseInt(parts[1]);
        int b = Integer.parseInt(parts[2]);
        int a = 255;
        if (parts.length > 3) {
            a = Integer.parseInt(parts[3]);
        }
        return new Color(r, g, b, a);
    }

#No. 1704
#File: E:\bishe\1\AbstractDrawCommand.java
#Comment:
    /**
     * Get an Envelope either from the Geometry or from the DrawOptions bounds property
     * @param geometry The input Geometry
     * @param options The DrawOptions
     * @return An Envelope
     */

#Code:
    protected Envelope getEnvelope(Geometry geometry, T options) {
        Envelope env;
        String bounds = options.getBounds();
        if (bounds != null && bounds.split(",").length == 4) {
            String[] parts = bounds.split(",");
            double minX = Double.parseDouble(parts[0].trim());
            double minY = Double.parseDouble(parts[1].trim());
            double maxX = Double.parseDouble(parts[2].trim());
            double maxY = Double.parseDouble(parts[3].trim());
            env = new Envelope(minX, maxX, minY, maxY);
        } else {
            env = geometry.getEnvelopeInternal();
            env.expandBy(env.getWidth() * 0.1);
        }
        if (env.getWidth() == 0 || env.getHeight() == 0) {
            if (env.getHeight() > 0) {
                double h = env.getHeight() / 2.0;
                env = new Envelope(env.getMinX() - h, env.getMaxX() + h, env.getMinY(), env.getMaxY());
            }
            else if (env.getWidth() > 0) {
                double w = env.getWidth() / 2.0;
                env = new Envelope(env.getMinX(), env.getMaxX(), env.getMinY() - w, env.getMaxY() + w);
            }
            else {
                env = geometry.getFactory().createPoint(new Coordinate(env.getMinX(), env.getMinY())).buffer(0.1).getEnvelopeInternal();
            }
            env.expandBy(env.getWidth() * 0.1);
        }
        return env;
    }

#No. 1705
#File: E:\bishe\1\AbstractDraweeController.java
#Comment:
    /**
     * Sets the hierarchy.
     *
     * <p>The controller should be detached when this method is called.
     * @param hierarchy This must be an instance of {@link SettableDraweeHierarchy}
     */

#Code:
    @Override
    public void setHierarchy(@Nullable DraweeHierarchy hierarchy) {
        if (FLog.isLoggable(FLog.VERBOSE)) {
            FLog.v(
                    TAG,
                    "controller %x %s: setHierarchy: %s",
                    System.identityHashCode(this),
                    mId,
                    hierarchy);
        }

#No. 1706
#File: E:\bishe\1\AbstractDraweeControllerBuilder.java
#Comment:
/**
 * 一个基本的Drawee controller 建造者
 * Base implementation for Drawee controller builders.
 */

#Code:
public abstract class AbstractDraweeControllerBuilder <
        BUILDER extends AbstractDraweeControllerBuilder<BUILDER, REQUEST, IMAGE, INFO>,
        REQUEST,
        IMAGE,
        INFO>
        implements SimpleDraweeControllerBuilder {

    private static final ControllerListener<Object> sAutoPlayAnimationsListener =
            new BaseControllerListener<Object>() {
                @Override
                public void onFinalImageSet(String id, @Nullable Object info, @Nullable Animatable anim) {
                    if (anim != null) {
                        anim.start();
                    }
                }
            };

#No. 1707
#File: E:\bishe\1\AbstractDraweeControllerBuilder.java
#Comment:
    /**
     * Sets the array of first-available image requests that will be probed in order.
     * <p> For performance reasons, the array is not deep-copied, but only stored by reference.
     * Please don't modify once submitted.
     */

#Code:
    public BUILDER setFirstAvailableImageRequests(REQUEST[] firstAvailableImageRequests) {
        return setFirstAvailableImageRequests(firstAvailableImageRequests, true);
    }

#No. 1708
#File: E:\bishe\1\AbstractDraweeControllerBuilder.java
#Comment:
    /**
     * Sets the array of first-available image requests that will be probed in order.
     * <p> For performance reasons, the array is not deep-copied, but only stored by reference.
     * Please don't modify once submitted.
     *
     * @param tryCacheOnlyFirst if set, bitmap cache only requests will be tried in order before
     *    the supplied requests.
     */

#Code:
    public BUILDER setFirstAvailableImageRequests(
            REQUEST[] firstAvailableImageRequests,
            boolean tryCacheOnlyFirst) {
        mMultiImageRequests = firstAvailableImageRequests;
        mTryCacheOnlyFirst = tryCacheOnlyFirst;
        return getThis();
    }

#No. 1709
#File: E:\bishe\1\AbstractDraweeControllerBuilder.java
#Comment:
    /**
     * Gets the array of first-available image requests.
     * <p> For performance reasons, the array is not deep-copied, but only stored by reference.
     * Please don't modify.
     */

#Code:
    @Nullable
    public REQUEST[] getFirstAvailableImageRequests() {
        return mMultiImageRequests;
    }

#No. 1710
#File: E:\bishe\1\AbstractDraweeControllerBuilder.java
#Comment:
    /**
     * 在创建之前调用validate()，如果只有一个低级请求，
     * 那么把它当做最后的请求，然后调用 buildController()返回。
     * ied controller. */

#Code:
    @Override
    public AbstractDraweeController build() {
        validate();

        if (mImageRequest == null && mMultiImageRequests == null && mLowResImageRequest != null) {
            mImageRequest = mLowResImageRequest;
            mLowResImageRequest = null;
        }

        return buildController();
    }

#No. 1711
#File: E:\bishe\1\AbstractDraweeControllerBuilder.java
#Comment:
    /**
     * 判断设置的请求是否正确，若错误就抛出异常
     * Validates the parameters before building a controller. */

#Code:
    protected void validate() {
        Preconditions.checkState(
                (mMultiImageRequests == null) || (mImageRequest == null),
                "Cannot specify both ImageRequest and FirstAvailableImageRequests!");
        Preconditions.checkState(
                (mDataSourceSupplier == null) ||
                        (mMultiImageRequests == null && mImageRequest == null && mLowResImageRequest == null),
                "Cannot specify DataSourceSupplier with other ImageRequests! Use one or the other.");
    }

#No. 1712
#File: E:\bishe\1\AbstractDraweeControllerBuilder.java
#Comment:
    /**
     * 调用obtainController()获取AbstractDraweeController，设置AbstractDraweeController的一些值，
     * maybeBuildAndSetRetryManager(controller)、maybeAttachListeners(controller)。
     * Builds a regular controller. */

#Code:
    protected AbstractDraweeController buildController() {
        AbstractDraweeController controller = obtainController();
        controller.setRetainImageOnFailure(getRetainImageOnFailure());
        controller.setContentDescription(getContentDescription());
        controller.setControllerViewportVisibilityListener(getControllerViewportVisibilityListener());
        maybeBuildAndSetRetryManager(controller);
        maybeAttachListeners(controller);
        return controller;
    }

#No. 1713
#File: E:\bishe\1\AbstractDraweeControllerBuilder.java
#Comment:
    /**
     * 如果已经有就返回，如果low、hight、Multi三种请求中有一种不为null，
     * 就通过getDataSourceSupplierForRequest(ImageRequest)来获取DataSourceSupplier，
     * 如果请求都为null就返回null。
     * Gets the top-level data source supplier to be used by a controller. */

#Code:
    protected Supplier<DataSource<IMAGE>> obtainDataSourceSupplier() {
        if (mDataSourceSupplier != null) {
            return mDataSourceSupplier;
        }

        Supplier<DataSource<IMAGE>> supplier = null;

        // final image supplier;
        if (mImageRequest != null) {
            supplier = getDataSourceSupplierForRequest(mImageRequest);
        } else if (mMultiImageRequests != null) {
            supplier = getFirstAvailableDataSourceSupplier(mMultiImageRequests, mTryCacheOnlyFirst);
        }

        // increasing-quality supplier; highest-quality supplier goes first
        if (supplier != null && mLowResImageRequest != null) {
            List<Supplier<DataSource<IMAGE>>> suppliers = new ArrayList<>(2);
            suppliers.add(supplier);
            suppliers.add(getDataSourceSupplierForRequest(mLowResImageRequest));
            supplier = IncreasingQualityDataSourceSupplier.create(suppliers);
        }

        // no image requests; use null data source supplier
        if (supplier == null) {
            supplier = DataSources.getFailedDataSourceSupplier(NO_REQUEST_EXCEPTION);
        }

        return supplier;
    }

#No. 1714
#File: E:\bishe\1\AbstractDraweeControllerBuilder.java
#Comment:
    /**
     * 创建一个Supplier<DataSource<IMAGE>>()，内部重写了get()，
     * get内部调用了getDataSourceForRequest(imageRequest, callerContext, cacheLevel)为抽象方法，
     * 在子类中实现。
     * Creates a data source supplier for the given image request. */

#Code:
    protected Supplier<DataSource<IMAGE>> getDataSourceSupplierForRequest(
            final REQUEST imageRequest,
            final CacheLevel cacheLevel) {
        final Object callerContext = getCallerContext();
        return new Supplier<DataSource<IMAGE>>() {
            @Override
            public DataSource<IMAGE> get() {
                return getDataSourceForRequest(imageRequest, callerContext, cacheLevel);
            }
            @Override
            public String toString() {
                return Objects.toStringHelper(this)
                        .add("request", imageRequest.toString())
                        .toString();
            }
        };
    }

#No. 1715
#File: E:\bishe\1\AbstractDraweeControllerBuilder.java
#Comment:
    /**
     * 为AbstractDraweeController添加本对象中所有Listenner
     * Attaches listeners (if specified) to the given controller. */

#Code:
    protected void maybeAttachListeners(AbstractDraweeController controller) {
        if (mBoundControllerListeners != null) {
            for (ControllerListener<? super INFO> listener : mBoundControllerListeners) {
                controller.addControllerListener(listener);
            }
        }
        if (mControllerListener != null) {
            controller.addControllerListener(mControllerListener);
        }
        if (mAutoPlayAnimations) {
            controller.addControllerListener(sAutoPlayAnimationsListener);
        }
    }

#No. 1716
#File: E:\bishe\1\AbstractDraweeControllerBuilder.java
#Comment:
    /**
     * 为AbstractDraweeController添加点击重试，并调用maybeBuildAndSetGestureDetector()。
     * Installs a retry manager (if specified) to the given controller. */

#Code:
    protected void maybeBuildAndSetRetryManager(AbstractDraweeController controller) {
        if (!mTapToRetryEnabled) {
            return;
        }
        RetryManager retryManager = controller.getRetryManager();
        if (retryManager == null) {
            retryManager = new RetryManager();
            controller.setRetryManager(retryManager);
        }
        retryManager.setTapToRetryEnabled(mTapToRetryEnabled);
        maybeBuildAndSetGestureDetector(controller);
    }

#No. 1717
#File: E:\bishe\1\AbstractDraweeControllerBuilder.java
#Comment:
    /**
     * 为AbstractDraweeController添加手势代理
     * Installs a gesture detector to the given controller. */

#Code:
    protected void maybeBuildAndSetGestureDetector(AbstractDraweeController controller) {
        GestureDetector gestureDetector = controller.getGestureDetector();
        if (gestureDetector == null) {
            gestureDetector = GestureDetector.newInstance(mContext);
            controller.setGestureDetector(gestureDetector);
        }
    }

#No. 1718
#File: E:\bishe\1\AbstractDrawerActivity.java
#Comment:
        /* Pass the event to ActionBarDrawerToggle, if it returns
         true, then it has handled the app icon touch event */

#Code:
        if (isDrawerActionBarToggleEnabled() && mDrawerToggle.onOptionsItemSelected(item)) {
            return true;
        }

#No. 1719
#File: E:\bishe\1\AbstractDrawerItem.java
#Comment:
    /**
     * set the identifier of this item
     *
     * @param identifier
     * @return
     */

#Code:
    public T withIdentifier(long identifier) {
        this.mIdentifier = identifier;
        return (T) this;
    }

#No. 1720
#File: E:\bishe\1\AbstractDrawerItem.java
#Comment:
    /**
     * returns the identifier of this item
     * -1 is the default not set state
     *
     * @return
     */

#Code:
    @Override
    public long getIdentifier() {
        return mIdentifier;
    }

#No. 1721
#File: E:\bishe\1\AbstractDrawerItem.java
#Comment:
    /**
     * set the tag of this item
     *
     * @param object
     * @return
     */

#Code:
    public T withTag(Object object) {
        this.mTag = object;
        return (T) this;
    }

#No. 1722
#File: E:\bishe\1\AbstractDrawerItem.java
#Comment:
    /**
     * @return the tag of this item
     */

#Code:
    @Override
    public Object getTag() {
        return mTag;
    }

#No. 1723
#File: E:\bishe\1\AbstractDrawerItem.java
#Comment:
    /**
     * set if this item is enabled
     *
     * @param enabled true if this item is enabled
     * @return
     */

#Code:
    public T withEnabled(boolean enabled) {
        this.mEnabled = enabled;
        return (T) this;
    }

#No. 1724
#File: E:\bishe\1\AbstractDrawerItem.java
#Comment:
    /**
     * @return if this item is enabled
     */

#Code:
    @Override
    public boolean isEnabled() {
        return mEnabled;
    }

#No. 1725
#File: E:\bishe\1\AbstractDrawerItem.java
#Comment:
    /**
     * set if this item is selected
     *
     * @param selected true if this item is selected
     * @return
     */

#Code:
    @Override
    public T withSetSelected(boolean selected) {
        this.mSelected = selected;
        return (T) this;
    }

#No. 1726
#File: E:\bishe\1\AbstractDrawerItem.java
#Comment:
    /**
     * @return if this item is selected
     */

#Code:
    @Override
    public boolean isSelected() {
        return mSelected;
    }

#No. 1727
#File: E:\bishe\1\AbstractDrawerItem.java
#Comment:
    /**
     * set if this item is selectable
     *
     * @param selectable true if this item is selectable
     * @return
     */

#Code:
    @Override
    public T withSelectable(boolean selectable) {
        this.mSelectable = selectable;
        return (T) this;
    }

#No. 1728
#File: E:\bishe\1\AbstractDrawerItem.java
#Comment:
    /**
     * @return if this item is selectable
     */

#Code:
    @Override
    public boolean isSelectable() {
        return mSelectable;
    }

#No. 1729
#File: E:\bishe\1\AbstractDrawerItem.java
#Comment:
    /**
     * set if this item is selectable
     *
     * @param selectedBackgroundAnimated true if this item's background should fade when it is (de) selected
     * @return
     */

#Code:
    public T withSelectedBackgroundAnimated(boolean selectedBackgroundAnimated) {
        this.mSelectedBackgroundAnimated = selectedBackgroundAnimated;
        return (T) this;
    }

#No. 1730
#File: E:\bishe\1\AbstractDrawerItem.java
#Comment:
    /**
     * @return if this item is selectable
     */

#Code:
    public boolean isSelectedBackgroundAnimated() {
        return mSelectedBackgroundAnimated;
    }

#No. 1731
#File: E:\bishe\1\AbstractDrawerItem.java
#Comment:
    /**
     * this listener is called when an item is clicked in the drawer.
     * WARNING: don't overwrite this in the Switch / Toggle drawerItems if you want the toggle / switch to be selected
     * if the item is clicked and the item is not selectable.
     *
     * @param onDrawerItemClickListener
     * @return
     */

#Code:
    public T withOnDrawerItemClickListener(Drawer.OnDrawerItemClickListener onDrawerItemClickListener) {
        this.mOnDrawerItemClickListener = onDrawerItemClickListener;
        return (T) this;
    }

#No. 1732
#File: E:\bishe\1\AbstractDrawerItem.java
#Comment:
    /**
     * add this listener and hook in if you want to modify a drawerItems view without creating a custom drawer item
     *
     * @param onPostBindViewListener
     * @return
     */

#Code:
    public T withPostOnBindViewListener(OnPostBindViewListener onPostBindViewListener) {
        this.mOnPostBindViewListener = onPostBindViewListener;
        return (T) this;
    }

#No. 1733
#File: E:\bishe\1\AbstractDrawerItem.java
#Comment:
    /**
     * is called after bindView to allow some post creation setps
     *
     * @param drawerItem the drawerItem which is bound to the view
     * @param view       the currently view which will be bound
     */

#Code:
    public void onPostBindView(IDrawerItem drawerItem, View view) {
        if (mOnPostBindViewListener != null) {
            mOnPostBindViewListener.onBindView(drawerItem, view);
        }
    }

#No. 1734
#File: E:\bishe\1\AbstractDrawerItem.java
#Comment:
    /**
     * @return the parent of this item
     */

#Code:
    @Override
    public IDrawerItem getParent() {
        return mParent;
    }

#No. 1735
#File: E:\bishe\1\AbstractDrawerItem.java
#Comment:
    /**
     * the parent for this item
     *
     * @param parent it's parent
     * @return this
     */

#Code:
    @Override
    public IDrawerItem withParent(IDrawerItem parent) {
        this.mParent = parent;
        return this;
    }

#No. 1736
#File: E:\bishe\1\AbstractDrawerItem.java
#Comment:
    /**
     * a list of subItems
     *
     * @param subItems
     * @return
     */

#Code:
    public T withSubItems(List<IDrawerItem> subItems) {
        this.mSubItems = IdDistributor.checkIds(subItems);
        return (T) this;
    }

#No. 1737
#File: E:\bishe\1\AbstractDrawerItem.java
#Comment:
    /**
     * an array of subItems
     *
     * @param subItems
     * @return
     */

#Code:
    public T withSubItems(IDrawerItem... subItems) {
        if (mSubItems == null) {
            mSubItems = new ArrayList<>();
        }
        Collections.addAll(mSubItems, IdDistributor.checkIds(subItems));
        return (T) this;
    }

#No. 1738
#File: E:\bishe\1\AbstractDrawerItem.java
#Comment:
    /**
     * @return the subItems for this item
     */

#Code:
    @Override
    public List<IDrawerItem> getSubItems() {
        return mSubItems;
    }

#No. 1739
#File: E:\bishe\1\AbstractDrawerItem.java
#Comment:
    /**
     * @param expanded defines if this item is now expanded or not
     * @return this
     */

#Code:
    @Override
    public T withIsExpanded(boolean expanded) {
        mExpanded = expanded;
        return (T) this;
    }

#No. 1740
#File: E:\bishe\1\AbstractDrawerItem.java
#Comment:
    /**
     * @return if this item is currently expaneded
     */

#Code:
    @Override
    public boolean isExpanded() {
        return mExpanded;
    }

#No. 1741
#File: E:\bishe\1\AbstractDrawerItem.java
#Comment:
    /**
     * overwrite this method and return true if the item should auto expand on click, false if you want to disable this
     *
     * @return true if this item should auto expand in the adapter
     */

#Code:
    @Override
    public boolean isAutoExpanding() {
        return true;
    }

#No. 1742
#File: E:\bishe\1\AbstractDrawerItem.java
#Comment:
    /**
     * generates a view by the defined LayoutRes
     *
     * @param ctx
     * @return
     */

#Code:
    @Override
    public View generateView(Context ctx) {
        VH viewHolder = getViewHolder(LayoutInflater.from(ctx).inflate(getLayoutRes(), null, false));
        bindView(viewHolder, Collections.emptyList());
        return viewHolder.itemView;
    }

#No. 1743
#File: E:\bishe\1\AbstractDrawerItem.java
#Comment:
    /**
     * generates a view by the defined LayoutRes and pass the LayoutParams from the parent
     *
     * @param ctx
     * @param parent
     * @return
     */

#Code:
    @Override
    public View generateView(Context ctx, ViewGroup parent) {
        VH viewHolder = getViewHolder(LayoutInflater.from(ctx).inflate(getLayoutRes(), parent, false));
        bindView(viewHolder, Collections.emptyList());
        return viewHolder.itemView;
    }

#No. 1744
#File: E:\bishe\1\AbstractDrawerItem.java
#Comment:
    /**
     * called when the view is unbound
     *
     * @param holder
     */

#Code:
    @Override
    public void unbindView(VH holder) {

    }

#No. 1745
#File: E:\bishe\1\AbstractDrawerItem.java
#Comment:
    /**
     * View got attached to the window
     *
     * @param holder
     */

#Code:
    @Override
    public void attachToWindow(VH holder) {

    }

#No. 1746
#File: E:\bishe\1\AbstractDrawerItem.java
#Comment:
    /**
     * View got detached from the window
     *
     * @param holder
     */

#Code:
    @Override
    public void detachFromWindow(VH holder) {

    }

#No. 1747
#File: E:\bishe\1\AbstractDrawerItem.java
#Comment:
    /**
     * This method returns the ViewHolder for our item, using the provided View.
     *
     * @param parent
     * @return the ViewHolder for this Item
     */

#Code:
    @Override
    public VH getViewHolder(ViewGroup parent) {
        return getViewHolder(LayoutInflater.from(parent.getContext()).inflate(getLayoutRes(), parent, false));
    }

#No. 1748
#File: E:\bishe\1\AbstractDrawerItem.java
#Comment:
    /**
     * This method returns the ViewHolder for our item, using the provided View.
     *
     * @param v
     * @return the ViewHolder for this Item
     */

#Code:
    public abstract VH getViewHolder(View v);

    /**
     * If this item equals to the given identifier
     *
     * @param id
     * @return
     */
    @Override
    public boolean equals(long id) {
        return id == mIdentifier;
    }

#No. 1749
#File: E:\bishe\1\AbstractDrawerItem.java
#Comment:
    /**
     * If this item equals to the given object
     *
     * @param o
     * @return
     */

#Code:
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        AbstractDrawerItem<?, ?> that = (AbstractDrawerItem<?, ?>) o;
        return mIdentifier == that.mIdentifier;
    }

#No. 1750
#File: E:\bishe\1\AbstractDrawerItem.java
#Comment:
    /**
     * the hashCode implementation
     *
     * @return
     */

#Code:
    @Override
    public int hashCode() {
        return Long.valueOf(mIdentifier).hashCode();
    }

#No. 1751
#File: E:\bishe\1\AbstractDriveService.java
#Comment:
  /**
   * Build and return a Drive service object based on given request parameters.
   * @return Drive service object that is ready to make requests, 
   * or null if there was a problem.
   */

#Code:
  public Drive getDriveService() {
    return this.drive;
  }

#No. 1752
#File: E:\bishe\1\AbstractDropboxRiverSimpleTest.java
#Comment:
	/**
	 * We wait for 5 seconds before each test
	 */

#Code:
	@Override
	public long waitingTime() throws Exception {
		return 5;
	}

#No. 1753
#File: E:\bishe\1\AbstractDropboxRiverTest.java
#Comment:
	/**
	 * Define a unique index name
	 * @return The unique index name (could be this.getClass().getSimpleName())
	 */

#Code:
	protected String indexName() {
		return this.getClass().getSimpleName().toLowerCase();
	}

#No. 1754
#File: E:\bishe\1\AbstractDsAnnotationAstVisitor.java
#Comment:
  /**
   * <p>
   * </p>
   * 
   * @param annotation
   * @return
   */

#Code:
  private boolean isReferenceAnnotation(Annotation annotation) {
    return getDsAnnotationFQName(annotation).equals(Reference.class.getName());
  }

#No. 1755
#File: E:\bishe\1\AbstractDsAnnotationAstVisitor.java
#Comment:
  /**
   * <p>
   * </p>
   * 
   * @param annotation
   * @return
   */

#Code:
  private boolean isComponentAnnotation(Annotation annotation) {
    return getDsAnnotationFQName(annotation).equals(Component.class.getName());
  }

#No. 1756
#File: E:\bishe\1\AbstractDsAnnotationAstVisitor.java
#Comment:
  /**
   * <p>
   * </p>
   * 
   * @param annotation
   * @return
   */

#Code:
  private boolean isActivateAnnotation(Annotation annotation) {
    return getDsAnnotationFQName(annotation).equals(Activate.class.getName());
  }

#No. 1757
#File: E:\bishe\1\AbstractDsAnnotationAstVisitor.java
#Comment:
  /**
   * <p>
   * </p>
   * 
   * @param annotation
   * @return
   */

#Code:
  private boolean isDeactivateAnnotation(Annotation annotation) {
    return getDsAnnotationFQName(annotation).equals(Deactivate.class.getName());
  }

#No. 1758
#File: E:\bishe\1\AbstractDsAnnotationAstVisitor.java
#Comment:
  /**
   * <p>
   * </p>
   * 
   * @param annotation
   * @return
   */

#Code:
  private boolean isModifiedAnnotation(Annotation annotation) {
    return getDsAnnotationFQName(annotation).equals(Modified.class.getName());
  }

#No. 1759
#File: E:\bishe\1\AbstractDsAnnotationAstVisitor.java
#Comment:
  /**
   * <p>
   * </p>
   * 
   * @param annotation
   * @return
   */

#Code:
  private String getDsAnnotationFQName(Annotation annotation) {
    return annotation.resolveTypeBinding().getQualifiedName();
  }

#No. 1760
#File: E:\bishe\1\AbstractDualBidiMap.java
#Comment:
    /**
     * Obtains a <code>MapIterator</code> over the map.
     * The iterator implements <code>ResetableMapIterator</code>.
     * This implementation relies on the entrySet iterator.
     * <p/>
     * The setValue() methods only allow a new value to be set.
     * If the value being set is already in the map, an IllegalArgumentException
     * is thrown (as setValue cannot change the size of the map).
     *
     * @return a map iterator
     */

#Code:
    public MapIterator<K, V> mapIterator() {
        return new BidiMapIterator<K, V>(this);
    }

#No. 1761
#File: E:\bishe\1\AbstractDualBidiMap.java
#Comment:
    /**
     * Gets a keySet view of the map.
     * Changes made on the view are reflected in the map.
     * The set supports remove and clear but not add.
     *
     * @return the keySet view
     */

#Code:
    public Set<K> keySet() {
        if (keySet == null) {
            keySet = new KeySet<K, V>(this);
        }
        return keySet;
    }

#No. 1762
#File: E:\bishe\1\AbstractDualBidiMap.java
#Comment:
    /**
     * Creates a key set iterator.
     * Subclasses can override this to return iterators with different properties.
     *
     * @param iterator the iterator to decorate
     * @return the keySet iterator
     */

#Code:
    protected Iterator<K> createKeySetIterator(Iterator<K> iterator) {
        return new KeySetIterator<K, V>(iterator, this);
    }

#No. 1763
#File: E:\bishe\1\AbstractDualBidiMap.java
#Comment:
    /**
     * Gets a values view of the map.
     * Changes made on the view are reflected in the map.
     * The set supports remove and clear but not add.
     *
     * @return the values view
     */

#Code:
    public Set<V> values() {
        if (values == null) {
            values = new Values<K, V>(this);
        }
        return values;
    }

#No. 1764
#File: E:\bishe\1\AbstractDualBidiMap.java
#Comment:
    /**
     * Creates a values iterator.
     * Subclasses can override this to return iterators with different properties.
     *
     * @param iterator the iterator to decorate
     * @return the values iterator
     */

#Code:
    protected Iterator<V> createValuesIterator(Iterator<V> iterator) {
        return new ValuesIterator<K, V>(iterator, this);
    }

#No. 1765
#File: E:\bishe\1\AbstractDualBidiMap.java
#Comment:
    /**
     * Gets an entrySet view of the map.
     * Changes made on the set are reflected in the map.
     * The set supports remove and clear but not add.
     * <p/>
     * The Map Entry setValue() method only allow a new value to be set.
     * If the value being set is already in the map, an IllegalArgumentException
     * is thrown (as setValue cannot change the size of the map).
     *
     * @return the entrySet view
     */

#Code:
    public Set<Map.Entry<K, V>> entrySet() {
        if (entrySet == null) {
            entrySet = new EntrySet<K, V>(this);
        }
        return entrySet;
    }

#No. 1766
#File: E:\bishe\1\AbstractDualBidiMap.java
#Comment:
    /**
     * Creates an entry set iterator.
     * Subclasses can override this to return iterators with different properties.
     *
     * @param iterator the iterator to decorate
     * @return the entrySet iterator
     */

#Code:
    protected Iterator<Map.Entry<K, V>> createEntrySetIterator(Iterator<Map.Entry<K, V>> iterator) {
        return new EntrySetIterator<K, V>(iterator, this);
    }

#No. 1767
#File: E:\bishe\1\AbstractDVOTest.java
#Comment:
		/*
		// Oracle DATE would truncate millisecond
		dvo.getData().put("date5", new oracle.sql.DATE(date2));
		System.out.println(date2.getTime());
		System.out.println(new oracle.sql.DATE(date2).timestampValue().getTime());
		TestCase.assertTrue(date2.equals(dvo.getDate("date5")));
		*/

#Code:
	}
	
	public void testBlob() throws Exception {
		String s = "abcdefghijklmnopqrstuvwxzy";
		
		dvo.put("byte1", s.getBytes());
		TestCase.assertTrue(s.equals(new String((byte[])dvo.get("byte1"))));
		
		dvo.setString("byte2", s);
		TestCase.assertEquals(s, (String)dvo.get("byte2"));

	}

#No. 1768
#File: E:\bishe\1\AbstractDwr.java
#Comment:
    /**
     * If set then Json Exports will appear under this keyname
     * e.g.
     * "topLevelKeyName":{
     *   "keyName":[
     *     {
     *       "prop1":"value1",
     *       "prop2":"value2"
     *     }
     *   ]
     * }
     */

#Code:
    protected String topLevelKeyName;
    
    public AbstractDwr(DAO dao, String keyName) {
        super(dao);
        this.keyName = keyName;
    }

#No. 1769
#File: E:\bishe\1\AbstractDwr.java
#Comment:
    /**
     * Save the VO
     * 
     * Conversion for the VO must be added by extending DwrConversionDefinition
     * 
     * @return
     */

#Code:
    @DwrPermission(admin = true)
    public ProcessResult save(VO vo) {
        ProcessResult response = new ProcessResult();
        if (vo.getXid() == null) {
            vo.setXid(dao.generateUniqueXid());
        }
        vo.validate(response);
        if(!response.getHasMessages()) {
            try {
                dao.save(vo);
            } catch(Exception e) {
                // Handle the exceptions.
                LOG.error(e);
                
                String context = vo.getName();
                if (context == null) {
                    context = vo.getXid();
                }
                if (context == null) {
                    context = Integer.toString(vo.getId());
                }
                
                if(e instanceof DuplicateKeyException)
                    response.addContextualMessage(context, "table.edit.alreadyExists");
                else
                    response.addContextualMessage(context, "table.edit.unableToSave", e.getMessage());
            }
        }
        response.addData("vo", vo);
        response.addData("id", vo.getId()); //Add in case it fails
        return response;
    }

#No. 1770
#File: E:\bishe\1\AbstractDwr.java
#Comment:
    /**
     * Save the VO AND FDAO Data
     * 
     * Conversion for the VO must be added by extending DwrConversionDefinition
     * 
     * @return
     */

#Code:
    @DwrPermission(admin = true)
    public ProcessResult saveFull(VO vo) { // TODO combine with save()
        ProcessResult response = new ProcessResult();
        if (vo.getXid() == null) {
            vo.setXid(dao.generateUniqueXid());
        }
        vo.validate(response);
        if(!response.getHasMessages()) {
            try {
                dao.saveFull(vo);
            } catch(Exception e) {
                // Handle the exceptions.
                LOG.error(e);
                
                String context = vo.getName();
                if (context == null) {
                    context = vo.getXid();
                }
                if (context == null) {
                    context = vo.getXid();
                }
                if (context == null) {
                    context = Integer.toString(vo.getId());
                }
                
                if(e instanceof DuplicateKeyException)
                    response.addContextualMessage(context, "table.edit.alreadyExists");
                else
                    response.addContextualMessage(context, "table.edit.unableToSave", e.getMessage());
            }
        }
        response.addData("vo", vo);
        response.addData("id", vo.getId()); //Add in case it fails
        return response;
    }

#No. 1771
#File: E:\bishe\1\AbstractDwr.java
#Comment:
    /**
     * Delete a VO
     * @param id
     * @return
     */

#Code:
    @DwrPermission(admin = true)
    public ProcessResult remove(int id) {
        ProcessResult response = new ProcessResult();
        try {
            dao.delete(id);
        } catch(Exception e) {
            // Handle the exceptions.
            LOG.error(e);
            VO vo = dao.get(id);
            if(e instanceof DataIntegrityViolationException)
                response.addContextualMessage(vo.getName(), "table.edit.unableToDeleteDueToConstraints");
            else
                response.addContextualMessage(vo.getName(), "table.edit.unableToDelete", e.getMessage());
        }
        
        response.addData("id", id);
        return response;
    }

#No. 1772
#File: E:\bishe\1\AbstractDwr.java
#Comment:
    /**
     * Delete a VO and its associated points
     * @param id
     * @return
     */

#Code:
    @DwrPermission(admin = true)
    public ProcessResult removeIncludingPoints(int id) {
        return remove(id);
    }

#No. 1773
#File: E:\bishe\1\AbstractDwr.java
#Comment:
    /**
     * Export a VO
     * @param id
     * @return
     */

#Code:
    @DwrPermission(user = true)
    public String jsonExport(int id) {
        Map<String, Object> data = new LinkedHashMap<String, Object>();
        List<VO> vos = new ArrayList<VO>();
        //Get the Full VO for the export
        vos.add(dao.getFull(id));
        data.put(keyName, vos);
        
        if (topLevelKeyName != null) {
            Map<String, Object> topData = new LinkedHashMap<String, Object>();
            topData.put(topLevelKeyName, data);
            data = topData;
        }
        
        return EmportDwr.export(data, 3);
    }

#No. 1774
#File: E:\bishe\1\AbstractDynamicMBean.java
#Comment:
    //**********************************************************
    //*  The MBean implementor should override next methods in
    //*  order to provide the custom MBean metadata information.
    //**********************************************************

    protected MBeanAttributeInfo[] createMBeanAttributesInfo() {
        return m_attributes.toArray(new MBeanAttributeInfo[m_attributes.size()]);
    }

    protected MBeanOperationInfo[] createMBeanOperationsInfo() {
        return m_operations.toArray(new MBeanOperationInfo[m_operations.size()]);
    }

    protected MBeanNotificationInfo[] createMBeanNotificationsInfo() {
        return m_notifications.toArray(new MBeanNotificationInfo[m_notifications.size()]);
    }

    protected MBeanConstructorInfo[] createMBeanConstructorsInfo() {
        if (m_constructors.size() <= 0)
            return createMBeanConstructorsInfo1();
        else
            return m_constructors.toArray(new MBeanConstructorInfo[m_constructors.size()]);
    }

    protected String getMBeanDescription() {
        return m_description;
    }
    //***************************
    //* End for override methods
    //***************************

    private MBeanConstructorInfo[] createMBeanConstructorsInfo1() {
        Constructor[] constructors = this.getClass().getConstructors();
        MBeanConstructorInfo[] dConstructors = new MBeanConstructorInfo[constructors.length];
        for (int i = 0; i < constructors.length; i++) {
            //if (constructors[i].getParameterTypes().length > 0)
            dConstructors[i] = new MBeanConstructorInfo(
                    "Instantiate " + THIS_CLASS_NAME + " with the specified container.",
                    constructors[i]);
        }
        return dConstructors;
    }

    /**
     * Convert a specified character of string in upper case.
     */

#Code:
    protected String toUpperCase(String str, int charIndex) {
        char[] name = str.toCharArray();
        name[0] = Character.toUpperCase(name[charIndex]);
        return new String(name);
    }

#No. 1775
#File: E:\bishe\1\AbstractDynamicMBean.java
#Comment:
    /**
     * Enables the to get the values of several attributes of the Dynamic MBean.
     */

#Code:
    public AttributeList getAttributes(String[] attributeNames) {
        if (attributeNames == null)
            throw new RuntimeOperationsException(new IllegalArgumentException(
                    "attributeNames[] can not be null"),
                    "Can not invoke a getter of " + THIS_CLASS_NAME);

        AttributeList resultList = new AttributeList();

        // if attributeNames is empty, return an empty result list
        if (attributeNames.length == 0)
            return resultList;

        // build the result attribute list
        for (int i = 0; i < attributeNames.length; i++) {
            try {
                Object value = getAttribute(attributeNames[i]);
                resultList.add(new Attribute(attributeNames[i], value));
            } catch (Exception e) {
                //we already log the exception in the method getAttribute()
            }
        }
        return resultList;
    }

#No. 1776
#File: E:\bishe\1\AbstractDynamicMBean.java
#Comment:
    /**
     * Sets the values of several attributes of the Dynamic MBean, and returns the list of
     * attributes that have been set.
     */

#Code:
    public AttributeList setAttributes(AttributeList attributes) {
        if (attributes == null)
            throw new RuntimeOperationsException(new IllegalArgumentException(
                    "AttributeList attributes can not be null"),
                    "Can not invoke a setter of " + THIS_CLASS_NAME);

        AttributeList resultList = new AttributeList();

        // if attributeNames is empty, nothing more to do
        if (attributes.isEmpty())
            return resultList;

        // for each attribute, try to set it and add to the result list if successful
        for (Iterator i = attributes.iterator(); i.hasNext(); ) {
            Attribute attr = (Attribute) i.next();
            try {
                setAttribute(attr);
                String name = attr.getName();
                Object value = getAttribute(name);
                resultList.add(new Attribute(name, value));
            } catch (Exception e) {
                if (_logger.isLoggable(Level.WARNING)) {
                    _logger.log(Level.WARNING, e.toString(), e);
                }
            }
        }
        return resultList;
    }

#No. 1777
#File: E:\bishe\1\AbstractDynamicMBean.java
#Comment:
    /**
     * Allows an operation to be invoked on the Dynamic MBean.
     */

#Code:
    public Object invoke(String operationName, Object[] params, String[] signature)
            throws MBeanException, ReflectionException {
        if (operationName == null)
            throw new RuntimeOperationsException(new IllegalArgumentException(
                    "Operation name can not be null"),
                    "Can not invoke a null operation in " + THIS_CLASS_NAME);

        // Check for a recognized operation name and call the corresponding operation
        try {
            Class[] clazz = null;
            if (signature != null) {
                clazz = new Class[signature.length];
                for (int i = 0; i < signature.length; i++)
                    clazz[i] = ClassLoaderHelper.loadClass(signature[i]);
            }

            return getClass().getMethod(operationName, clazz).invoke(this, params);

        }
        // unrecognized operation name
        catch (NoSuchMethodException ex) {
            if (_logger.isLoggable(Level.WARNING)) {
                _logger.log(Level.WARNING, ex.toString(), ex);
            }
            throw new ReflectionException(ex, "Can not find the operation " +
                    operationName + " in " + THIS_CLASS_NAME);
        } catch (Exception ex) {
            if (_logger.isLoggable(Level.WARNING)) {
                _logger.log(Level.WARNING, ex.toString(), ex);
            }
            throw new MBeanException(new Exception(ex.getCause()));
        }
    }

#No. 1778
#File: E:\bishe\1\AbstractDynamicMBean.java
#Comment:
    /**
     * This method provides the exposed attributes and operations of the Dynamic MBean. It provides
     * this information using an MBeanInfo object.
     */

#Code:
    public MBeanInfo getMBeanInfo() {
        MBeanInfo info = null;
        try {
            info = new MBeanInfo(THIS_CLASS_NAME, getMBeanDescription(),
                    createMBeanAttributesInfo(), createMBeanConstructorsInfo(),
                    createMBeanOperationsInfo(), createMBeanNotificationsInfo());
        } catch (Exception ex) {
            if (_logger.isLoggable(Level.WARNING)) {
                _logger.log(Level.WARNING, ex.toString(), ex);
            }
        }
        return info;

    }

#No. 1779
#File: E:\bishe\1\AbstractDynamicService.java
#Comment:
    /**
     * Helper method to create a new endpoint.
     *
     * @return the endpoint to create.
     */

#Code:
    protected Endpoint createEndpoint() {
        return endpointFactory.create(hostname, bucket, username, password, port, env, responseBuffer);
    }

#No. 1780
#File: E:\bishe\1\AbstractDynamicService.java
#Comment:
    /**
     * Simple log helper to give logs a common prefix.
     *
     * @param hostname the address.
     * @param service the service.
     * @return a prefix string for logs.
     */

#Code:
    protected static String logIdent(final String hostname, final Service service) {
        return "[" + hostname + "][" + service.getClass().getSimpleName() + "]: ";
    }

#No. 1781
#File: E:\bishe\1\AbstractDynamicService.java
#Comment:
    /**
     * Returns the current list of endpoints.
     *
     * @return the list of endpoints.
     */

#Code:
    protected List<Endpoint> endpoints() {
        return Arrays.asList(endpoints);
    }

#No. 1782
#File: E:\bishe\1\AbstractDynamicService.java
#Comment:
    /**
     * Returns the underlying endpoint state zipper.
     *
     * @return the underlying state zipper.
     */

#Code:
    protected EndpointStateZipper endpointStates() {
        return endpointStates;
    }

#No. 1783
#File: E:\bishe\1\AbstractDynamicService.java
#Comment:
    /**
     * Waits until the endpoint goes into the given state, calls the action and then unsubscribes.
     *
     * @param endpoint the endpoint to monitor.
     * @param wanted the wanted state.
     * @param then the action to execute when the state is reached.
     */

#Code:
    protected static void whenState(final Endpoint endpoint, final LifecycleState wanted, Action1<LifecycleState> then) {
        endpoint
                .states()
                .filter(new Func1<LifecycleState, Boolean>() {
                    @Override
                    public Boolean call(LifecycleState state) {
                        return state == wanted;
                    }
                })
                .take(1)
                .subscribe(then);
    }

#No. 1784
#File: E:\bishe\1\AbstractEdgeGridRequestSigner.java
#Comment:
    /**
     * Signs {@code request} with appropriate credentials using EdgeGrid signer algorithm and
     * replaces {@code request}'s host name with the one specified by the credential.
     *
     * @param request an HTTP request to sign
     * @throws RequestSigningException       if failed to sign a request
     * @throws NoMatchingCredentialException if acquiring a {@link ClientCredential} throws {@code
     *                                       NoMatchingCredentialException} or returns {@code null}
     */

#Code:
    public void sign(RequestT request) throws RequestSigningException {
        Request req = map(request);
        ClientCredential credential;
        try {
            credential = clientCredentialProvider.getClientCredential(req);
        } catch (NoMatchingCredentialException e) {
            throw e;
        }
        if (credential == null) {
            throw new NoMatchingCredentialException();
        }
        setHost(request, credential.getHost());
        String authorization = edgeGridSigner.getSignature(req, credential);
        setAuthorization(request, authorization);
    }

#No. 1785
#File: E:\bishe\1\AbstractEditableStringListFieldEditor.java
#Comment:
  /**
   * {@inheritDoc}
   */

#Code:
  @Override
  protected void doLoadDefault() {
    if (this.list != null) {
      this.list.removeAll();
      String preferenceString = getPreferenceStore().getDefaultString(getPreferenceName());
      java.util.List<String> valueList = parsePreferenceString(preferenceString);
      for (String item : valueList) {
        this.list.add(item);
      }
    }
  }

#No. 1786
#File: E:\bishe\1\AbstractEditableStringListFieldEditor.java
#Comment:
  /**
   * Gets the text accessor.
   *
   * @return the text accessor
   */

#Code:
  public ITextAccessor getTextAccessor() {
    return this.textAccessor;
  }

#No. 1787
#File: E:\bishe\1\AbstractEditableStringListFieldEditor.java
#Comment:
  /**
   * Gets the list items.
   *
   * @return the list items
   */

#Code:
  public java.util.List<String> getListItems() {
    return Arrays.asList(this.list.getItems());
  }

#No. 1788
#File: E:\bishe\1\AbstractEditableStringListFieldEditor.java
#Comment:
  /**
   * Gets a new item for the list.
   *
   * @return the new list item
   */

#Code:
  public abstract String getNewListItem();

  /**
   * Edit a list item.
   *
   * @param item the list item to edit
   * @return the new version of the list item
   */
  public abstract String editListItem(String item);
}
}

#No. 1789
#File: E:\bishe\1\AbstractEditComponent.java
#Comment:
  /**
   * Process view after created.
   *
   * @param editText
   */

#Code:
  protected void appleStyleAfterCreated(WXEditText editText) {
    String alignStr = (String) mDomObj.style.get(WXDomPropConstant.WX_TEXTALIGN);
    int textAlign = getTextAlign(alignStr);
    if (textAlign <= 0) {
      textAlign = Gravity.LEFT;
    }
    editText.setGravity(textAlign | Gravity.CENTER_VERTICAL);
    int colorInt = WXResourceUtils.getColor("#999999");
    if (colorInt != Integer.MIN_VALUE) {
      editText.setHintTextColor(colorInt);
    }

    editText.setTextSize(TypedValue.COMPLEX_UNIT_PX, WXStyle.getFontSize(mDomObj.style));
    editText.setText((String) mDomObj.attr.get("value"));
  }

#No. 1790
#File: E:\bishe\1\AbstractEditor.java
#Comment:
    /**
     * Proxy for different editor types
     */

#Code:
    public AbstractEditor(final @Nullable IWorkbenchPart editorPart) {
        this();
        wPart = editorPart;
        if(editorPart instanceof FormEditor){
            FormEditor fe = (FormEditor)editorPart;
            wPart = fe.getActiveEditor();
            multipage = true;
        } else if(editorPart instanceof MultiPageEditorPart){
            MultiPageEditorPart me = (MultiPageEditorPart)editorPart;
            // followed is because "getActiveEditor" method is protected in
            // MultiPageEditorPart class.
            try {
                Method method = MultiPageEditorPart.class.getDeclaredMethod(
                        "getActiveEditor", null);
                method.setAccessible(true);
                wPart = (IEditorPart) method.invoke(me, null);
                multipage = true;
            } catch (Exception e) {
                AnyEditToolsPlugin.logError("Can't get current page", e);
            }
        } else if(editorPart!= null

#No. 1791
#File: E:\bishe\1\AbstractEditor.java
#Comment:
            /*
             * added to support different multipage editors which are not extending
             * MultiPageEditorPart, like adobe Flex family editors
             */

#Code:
            try {
                Method[] declaredMethods = editorPart.getClass().getDeclaredMethods();
                for (int i = 0; i < declaredMethods.length; i++) {
                    Method method = declaredMethods[i];
                    String methodName = method.getName();
                    if(("getActiveEditor".equals(methodName)
                            // lines below are for Flex 3, above for Flex 2
                            ||  "getCodeEditor".equals(methodName)
                            ||  "getTextEditor".equals(methodName))
                            && method.getParameterTypes().length == 0){
                        method.setAccessible(true);
                        IEditorPart ePart = (IEditorPart) method.invoke(editorPart, null);
                        if(ePart == null) {
                            continue;
                        }
                        wPart = ePart;
                        multipage = true;
                        break;
                    }
                }
            } catch (Exception e) {
                AnyEditToolsPlugin.logError("Can't get current page", e);
            }

#No. 1792
#File: E:\bishe\1\AbstractEditor.java
#Comment:
    /**
     * @return may return null
     */

#Code:
    @Nullable
    public IDocumentProvider getDocumentProvider() {
        if (wPart == null) {
            return null;
        }
        if (wPart instanceof ITextEditor) {
            return ((ITextEditor) wPart).getDocumentProvider();
        }

        IDocumentProvider docProvider = getAdapter(wPart, IDocumentProvider.class);
        return docProvider;
    }

#No. 1793
#File: E:\bishe\1\AbstractEditor.java
#Comment:
    /**
     * @return may return null
     */

#Code:
    @Nullable
    public IEditorInput getInput() {
        if (!(wPart instanceof IEditorPart)) {
            return null;
        }
        return ((IEditorPart) wPart).getEditorInput();
    }

#No. 1794
#File: E:\bishe\1\AbstractEditor.java
#Comment:
    /**
     * @return may return null
     */

#Code:
    @Nullable
    public IFile getIFile(){
        if(wPart == null){
            return null;
        }
        IEditorInput input = getInput();
        if(input != null){
            IFile adapter = EclipseUtils.getIFile(input, true);
            if(adapter != null){
                return adapter;
            }
        }
        IFile adapter = EclipseUtils.getIFile(wPart, true);
        return adapter;
    }

#No. 1795
#File: E:\bishe\1\AbstractEditor.java
#Comment:
    /**
     * @see ITypedElement#getType()
     */

#Code:
    @Nullable
    public String getContentType(){
        URI uri = getURI();
        String path;
        if(uri != null) {
            path = uri.toString();
        } else {
            File file = getFile();
            if(file == null) {
                return null;
            }
            path = file.getAbsolutePath();
        }
        int dot = path.lastIndexOf('.') + 1;
        if(dot >= 0){
            return path.substring(dot);
        }
        return path;
    }

#No. 1796
#File: E:\bishe\1\AbstractEditor.java
#Comment:
    /**
     * @return may return null
     */

#Code:
    @Nullable
    private URI getURI(){
        return EclipseUtils.getURI(getInput());
    }

#No. 1797
#File: E:\bishe\1\AbstractEditor.java
#Comment:
    /**
     * Sets the sequential rewrite mode of the viewer's document.
     */

#Code:
    public void stopSequentialRewriteMode(DocumentRewriteSession session) {
        IDocument document = getDocument();
        if (document instanceof IDocumentExtension4) {
            IDocumentExtension4 extension= (IDocumentExtension4) document;
            extension.stopRewriteSession(session);
        } else if (document instanceof IDocumentExtension) {
            IDocumentExtension extension= (IDocumentExtension)document;
            extension.stopSequentialRewrite();
        }

        IRewriteTarget target = getAdapterFromPart(IRewriteTarget.class);
        if (target != null) {
            target.endCompoundChange();
            target.setRedraw(true);
        }
    }

#No. 1798
#File: E:\bishe\1\AbstractEditor.java
#Comment:
    /**
     * Starts  the sequential rewrite mode of the viewer's document.
     * @param normalized <code>true</code> if the rewrite is performed
     * from the start to the end of the document
     */

#Code:
    @Nullable
    public DocumentRewriteSession startSequentialRewriteMode(boolean normalized) {
        // de/activate listeners etc, prepare multiple replace
        IRewriteTarget target = getAdapterFromPart(IRewriteTarget.class);
        if (target != null) {
            target.setRedraw(false);
            target.beginCompoundChange();
        }

        DocumentRewriteSession rewriteSession = null;
        IDocument document = getDocument();
        if (document instanceof IDocumentExtension4) {
            IDocumentExtension4 extension= (IDocumentExtension4) document;
            if (normalized) {
                rewriteSession = extension
                        .startRewriteSession(DocumentRewriteSessionType.STRICTLY_SEQUENTIAL);
            } else {
                rewriteSession = extension
                        .startRewriteSession(DocumentRewriteSessionType.SEQUENTIAL);
            }
        } else if (document instanceof IDocumentExtension) {
            IDocumentExtension extension = (IDocumentExtension) document;
            extension.startSequentialRewrite(normalized);
        }
        return rewriteSession;
    }

#No. 1799
#File: E:\bishe\1\AbstractEditor.java
#Comment:
    /**
     * clean reference to wrapped "real" editor object
     */

#Code:
    public void dispose(){
        wPart = null;
    }

#No. 1800
#File: E:\bishe\1\AbstractEditorPresenter.java
#Comment:
    /**
     * Set dirty state and notify expressions
     *
     * @param dirty
     */

#Code:
    protected void updateDirtyState(boolean dirty) {
        dirtyState = dirty;
        firePropertyChange(EditorPartPresenter.TITLE_PROPERTY);
        firePropertyChange(PROP_DIRTY);
    }

#No. 1801
#File: E:\bishe\1\AbstractEJBBoundMetaData.java
#Comment:
    /**
     * Get the ejbName.
     *
     * @return the ejbName.
     */

#Code:
    public String getEjbName() {
        return getName();
    }

#No. 1802
#File: E:\bishe\1\AbstractEJBBoundMetaData.java
#Comment:
    /**
     * Set the ejbName.
     *
     * @param ejbName the ejbName.
     * @throws IllegalArgumentException for a null ejbName
     */

#Code:
    public void setEjbName(String ejbName) {
        setName(ejbName);
    }

#No. 1803
#File: E:\bishe\1\AbstractElementPanel.java
#Comment:
  /**
   * Creates an empty flow panel.
   */

#Code:
  public AbstractElementPanel() {
    setElement(createElement());
  }

#No. 1804
#File: E:\bishe\1\AbstractElementPanel.java
#Comment:
  /**
   * Adds a new child widget to the panel.
   * 
   * @param w the widget to be added
   */

#Code:
  @Override
  public void add(Widget w) {
    super.add(w, getElement());
  }

#No. 1805
#File: E:\bishe\1\AbstractElementPanel.java
#Comment:
  /**
   * Inserts a widget before the specified index.
   * 
   * @param w the widget to be inserted
   * @param beforeIndex the index before which it will be inserted
   * @throws IndexOutOfBoundsException if <code>beforeIndex</code> is out of
   *           range
   */

#Code:
  public void insert(Widget w, int beforeIndex) {
    super.insert(w, getElement(), beforeIndex, true);
  }

#No. 1806
#File: E:\bishe\1\AbstractElementPredicate.java
#Comment:
    /**
     * @return a TraversalPredicate that will include the immediate parent of
     *     elements when traversing that are found acceptable by the predicate
     *     logic of this ElementPredicate.
     */

#Code:
    public TraversalPredicate onParent() {
        return new AbstractTraversalPredicate("<") {
            @NotNull
            @Override
            public PsiElementCollection traverse(@NotNull Collection<PsiElement> current) {
                PsiElementCollection buffer = new PsiElementCollection();
                for (PsiElement element : current) {
                    element = element.getParent();
                    if (element != null && !(element instanceof PsiDirectory)) {
                        buffer.add(element);
                    }
                }
                return buffer;
            }
        };

#No. 1807
#File: E:\bishe\1\AbstractElementPredicate.java
#Comment:
    /**
     * @return a TraversalPredicate that will include the first ancestor found
     *     acceptable by the predicate logic of this ElementPredicate.
     */

#Code:
    public TraversalPredicate onFirstAncestor() {
        return new FirstAncestorTraversalPredicate();
    }

#No. 1808
#File: E:\bishe\1\AbstractElementPredicate.java
#Comment:
    /**
     * The traversal predicate returned here can return a large number of
     * elements to process through {@link #test(com.intellij.psi.PsiElement)}.
     * Caution should be used to ensure that this traversal is used only when
     * necessary. {@link #onDescendants(int)} should be considered as a more
     * efficient alternative.
     * @return a TraversalPredicate that will include ALL descendants of
     *     elements when traversing that are found acceptable by the predicate
     *     logic of this ElementPredicate.
     */

#Code:
    public TraversalPredicate onAllDescendants() {
        return new AbstractTraversalPredicate(">>") {
            @NotNull
            @Override
            public PsiElementCollection traverse(@NotNull Collection<PsiElement> current) {
                PsiElementCollection buffer = new PsiElementCollection();
                Deque<PsiElement> queue = new LinkedList<PsiElement>(current);
                while (!queue.isEmpty()) {
                    List<PsiElement> children = Arrays.asList(queue.pop().getChildren());
                    buffer.addAll(children);
                    queue.addAll(children);
                }
                return buffer;
            }
        };

#No. 1809
#File: E:\bishe\1\AbstractElementPredicate.java
#Comment:
    /**
     * @param depth Maximum depth to descend into the psi tree.
     * @return a TraversalPredicate that will include descendants of elements
     *     when traversing that are found acceptable by the predicate logic
     *     of this ElementPredicate.
     */

#Code:
    public TraversalPredicate onDescendants(final int depth) {
        return onDescendants(1, depth);
    }

#No. 1810
#File: E:\bishe\1\AbstractElementPredicate.java
#Comment:
    /**
     * @param from Minimum depth in the psi tree to begin finding elements.
     * @param to Maximum depth to descend into the psi tree.
     * @return a TraversalPredicate that will include descendants of elements
     *     when traversing that are found acceptable by the predicate logic
     *     of this ElementPredicate.
     */

#Code:
    public TraversalPredicate onDescendants(final int from, final int to) {
        if (from <= 0) {
            throw new IllegalArgumentException("'from' depth must be a positive integer");
        }
        if (from > to) {
            throw new IllegalArgumentException("'from' must be less than 'to'");
        }
        if (to <= 0) {
            throw new IllegalArgumentException("'to' depth must be a positive integer");
        }
        if (from == 1 && to == 1) {
            return onChildren();
        }
        return new AbstractTraversalPredicate(">>{" + from + ".." + to + "}") {
            @NotNull
            @Override
            public PsiElementCollection traverse(@NotNull Collection<PsiElement> current) {
                PsiElementCollection buffer = new PsiElementCollection();
                Deque<Pair<Integer,PsiElement>> queue = new LinkedList<Pair<Integer,PsiElement>>();
                for (PsiElement element : current) {
                    queue.add(Pair.create(1, element));
                }
                while (!queue.isEmpty()) {
                    Pair<Integer,PsiElement> pair = queue.pop();
                    int d = pair.first;
                    List<PsiElement> children = Arrays.asList(pair.second.getChildren());
                    if (d >= from) {
                        buffer.addAll(children);
                    }
                    if (d < to) {
                        for (PsiElement element : children) {
                            queue.add(Pair.create(d + 1, element));
                        }
                    }
                }
                return buffer;
            }
        };

#No. 1811
#File: E:\bishe\1\AbstractElementPredicate.java
#Comment:
    /**
     * @return a TraversalPredicate that will include first direct child of
     *     elements when traversing that are found acceptable by the predicate
     *     logic of this ElementPredicate.
     */

#Code:
    public TraversalPredicate onFirstChild() {
        return new AbstractTraversalPredicate(">:1") {
            @NotNull
            @Override
            public PsiElementCollection traverse(@NotNull Collection<PsiElement> current) {
                PsiElementCollection buffer = new PsiElementCollection();
                for (PsiElement element : current) {
                    for (PsiElement child : element.getChildren()) {
                        if (AbstractElementPredicate.this.test(child)) {
                            buffer.add(child);
                            break;
                        }
                    }
                }
                return buffer;
            }
        };

#No. 1812
#File: E:\bishe\1\AbstractElementPredicate.java
#Comment:
    /**
     * @return a TraversalPredicate that will include all direct children of
     *     elements when traversing that are found acceptable by the predicate
     *     logic of this ElementPredicate.
     */

#Code:
    public TraversalPredicate onChildren() {
        return new AbstractTraversalPredicate(">") {
            @NotNull
            @Override
            public PsiElementCollection traverse(@NotNull Collection<PsiElement> current) {
                PsiElementCollection buffer = new PsiElementCollection();
                for (PsiElement element : current) {
                    buffer.addAll(Arrays.asList(element.getChildren()));
                }
                return buffer;
            }
        };

#No. 1813
#File: E:\bishe\1\AbstractElementPredicate.java
#Comment:
    /**
     * @return a TraversalPredicate that will include children of child
     *     elements when traversing that are found acceptable by the predicate
     *     logic of this ElementPredicate.
     */

#Code:
    public TraversalPredicate onChildrenOfChildren() {
        return new AbstractTraversalPredicate("> >") {
            @NotNull
            @Override
            public PsiElementCollection traverse(@NotNull Collection<PsiElement> current) {
                PsiElementCollection buffer = new PsiElementCollection();
                for (PsiElement child : current) {
                    for (PsiElement grandChild : child.getChildren()) {
                        buffer.addAll(Arrays.asList(grandChild.getChildren()));
                    }
                }
                return buffer;
            }
        };

#No. 1814
#File: E:\bishe\1\AbstractElementPredicate.java
#Comment:
    /**
     * @return a TraversalPredicate that will include the previous sibling of
     *     elements when traversing that are found acceptable by the predicate
     *     logic of this ElementPredicate.
     */

#Code:
    public TraversalPredicate onPreviousSibling() {
        return new AbstractTraversalPredicate("{.}s") {
            @NotNull
            @Override
            public PsiElementCollection traverse(@NotNull Collection<PsiElement> current) {
                PsiElementCollection buffer = new PsiElementCollection();
                for (PsiElement element : current) {
                    PsiElement e = element.getPrevSibling();
                    if (e != null) {
                        buffer.add(e);
                    }
                }
                return buffer;
            }
        };

#No. 1815
#File: E:\bishe\1\AbstractElementPredicate.java
#Comment:
    /**
     * @param andSelf true if the returned collection should also include the
     *                starting elements, false otherwise.
     * @return a TraversalPredicate that will include the previous sibling of
     *     elements when traversing that are found acceptable by the predicate
     *     logic of this ElementPredicate.
     */

#Code:
    public TraversalPredicate onPreviousSiblings(final boolean andSelf) {
        return new AbstractTraversalPredicate(andSelf ? "{..s}" : "{..}s") {
            @NotNull
            @Override
            public PsiElementCollection traverse(@NotNull Collection<PsiElement> current) {
                PsiElementCollection buffer = new PsiElementCollection();
                for (PsiElement element : current) {
                    for (PsiElement e = andSelf ? element : element.getPrevSibling();
                         e != null;
                         e = e.getPrevSibling()) {
                        buffer.add(e);
                    }
                }
                return buffer;
            }
        };

#No. 1816
#File: E:\bishe\1\AbstractElementPredicate.java
#Comment:
    /**
     * @return a TraversalPredicate that will include the previous sibling of
     *     elements when traversing that are found acceptable by the predicate
     *     logic of this ElementPredicate.
     */

#Code:
    public TraversalPredicate onNextSibling() {
        return new AbstractTraversalPredicate("s{.}") {
            @NotNull
            @Override
            public PsiElementCollection traverse(@NotNull Collection<PsiElement> current) {
                PsiElementCollection buffer = new PsiElementCollection();
                for (PsiElement element : current) {
                    PsiElement e = element.getNextSibling();
                    if (e != null) {
                        buffer.add(e);
                    }
                }
                return buffer;
            }
        };

#No. 1817
#File: E:\bishe\1\AbstractElementPredicate.java
#Comment:
    /**
     * @param andSelf true if the returned collection should also include the
     *                starting elements, false otherwise.
     * @return a TraversalPredicate that will include the previous sibling of
     *     elements when traversing that are found acceptable by the predicate
     *     logic of this ElementPredicate.
     */

#Code:
    public TraversalPredicate onNextSiblings(final boolean andSelf) {
        return new AbstractTraversalPredicate(andSelf ? "{s..}" : "s{..}") {
            @NotNull
            @Override
            public PsiElementCollection traverse(@NotNull Collection<PsiElement> current) {
                PsiElementCollection buffer = new PsiElementCollection();
                for (PsiElement element : current) {
                    for (PsiElement e = andSelf ? element : element.getNextSibling();
                         e != null;
                         e = e.getNextSibling()) {
                        buffer.add(e);
                    }
                }
                return buffer;
            }
        };

#No. 1818
#File: E:\bishe\1\AbstractElementPredicate.java
#Comment:
    /**
     * @return A TraversalPredicate that does not navigate the psi tree.
     */

#Code:
    public TraversalPredicate onSelf() {
        return new AbstractTraversalPredicate("{s}") {
            @NotNull
            @Override
            public PsiElementCollection traverse(@NotNull Collection<PsiElement> current) {
                return PsiElementCollection.castOrCopy(current);
            }
        };

#No. 1819
#File: E:\bishe\1\AbstractElementVisitor6.java
#Comment:
    /**
     * Visits any program element as if by passing itself to that
     * element's {@link Element#accept accept} method and passing
     * {@code null} for the additional parameter.  The invocation
     * {@code v.visit(elem)} is equivalent to {@code elem.accept(v,
     * null)}.
     *
     * @param e  the element to visit
     * @return a visitor-specified result
     */

#Code:
    public final R visit(Element e) {
	return e.accept(this, null);
    }

#No. 1820
#File: E:\bishe\1\AbstractElementVisitor6.java
#Comment:
    /**
     * {@inheritDoc}
     *
     * <p> The default implementation of this method in
     * {@code AbstractElementVisitor6} will always throw
     * {@code UnknownElementException}.
     * This behavior is not required of a subclass.
     *
     * @param e  the element to visit
     * @param p  a visitor-specified parameter
     * @return a visitor-specified result
     * @throws UnknownElementException
     *		a visitor implementation may optionally throw this exception
     */

#Code:
    public R visitUnknown(Element e, P p) {
	throw new UnknownElementException(e, p);
    }

#No. 1821
#File: E:\bishe\1\AbstractELResolver.java
#Comment:
	/**
	 * Called to determine if the property is read only. This method will only be called is {@link #isAvailable()}
	 * returns <tt>true</tt>. By default this method returns <tt>true</tt>
	 * @param property The property
	 * @return <tt>true</tt> if the property is read-only or <tt>false</tt> if the property is mutable.
	 * @see #set(String, Object)
	 */

#Code:
	protected boolean isReadOnly(String property) {
		return true;
	}

#No. 1822
#File: E:\bishe\1\AbstractELResolver.java
#Comment:
	/**
	 * Called to set the property value. This method will only be called is {@link #isAvailable()} and
	 * {@link #isReadOnly(String)} return <tt>true</tt>. By default his method will throw a
	 * {@link PropertyNotWritableException}.
	 * @param property The property
	 * @param value The value to set
	 * @throws PropertyNotWritableException if the property is not writable.
	 * @see #isReadOnly(String)
	 */

#Code:
	protected void set(String property, Object value) throws PropertyNotWritableException {
		throw new PropertyNotWritableException("The property " + property + " is not writable.");
	}

#No. 1823
#File: E:\bishe\1\AbstractELResolver.java
#Comment:
	/**
	 * Template method used to handle searching for the property and invoking some operation on the scope.
	 * @param <T> the property type
	 * @param elContext the EL context
	 * @param base the base object
	 * @param property the property
	 * @param operation Callback interface used to execute the operation
	 * @return Result of the operation
	 */

#Code:
	protected <T> T handle(ELContext elContext, Object base, Object property, ELOperation<T> operation) {
		if (base != null || !isAvailable()) {
			return null;
		}
		String propertyString = (property == null ? null : property.toString());
		if (handles(propertyString)) {
			elContext.setPropertyResolved(true);
			return operation.execute(propertyString);
		}
		return null;
	}

#No. 1824
#File: E:\bishe\1\AbstractEmbeddedCassandraIntegrationTest.java
#Comment:
	/**
	 * Whether to clear the cluster before the next test.
	 */

#Code:
	protected boolean clear = false;
	/**
	 * Whether to connect to Cassandra.
	 */
	protected boolean connect = true;
	/**
	 * The {@link Cluster} that's connected to Cassandra.
	 */
	protected Cluster cluster;
	/**
	 * If not <code>null</code>, get a {@link Session} for the from the {@link #cluster}.
	 */
	protected String keyspace = "ks" + UUID.randomUUID().toString().replace("-", "");
	/**
	 * The {@link Session} for the {@link #keyspace} from the {@link #cluster}.
	 */
	protected Session session;

	/**
	 * Returns whether we're currently connected to the cluster.
	 */
	public boolean connected() {
		return session != null;
	}

#No. 1825
#File: E:\bishe\1\AbstractEmbeddedServer.java
#Comment:
    /**
     * @return true if parentLoaderPriority should be enabled.
     */

#Code:
    protected boolean getParentLoaderPriority() {
        return false;
    }

#No. 1826
#File: E:\bishe\1\AbstractEmbeddedServer.java
#Comment:
    /**
     * @return the absolute path of the war file.
     */

#Code:
    public abstract String getWarPath();

    @Override
    public String toString() {
        return getServerName();
    }

#No. 1827
#File: E:\bishe\1\AbstractEmbedVaadinTomcat.java
#Comment:
    /**
     * Returns the {@link Tomcat} instance.
     */

#Code:
    protected Tomcat getTomcat() {
        return tomcat;
    }

#No. 1828
#File: E:\bishe\1\AbstractEmbedVaadinTomcat.java
#Comment:
    /**
     * Returns the {@link Context} to use for the webapp.
     */

#Code:
    protected Context getContext() {
        if (context == null) {
            context = getTomcat().addContext(getConfig().getContextPath(),
                    getConfig().getContextRootDirectory().getAbsolutePath());
        }
        return context;
    }

#No. 1829
#File: E:\bishe\1\AbstractEmbedVaadinTomcat.java
#Comment:
    /**
     * Adds the basic and default configuration of the the current {@link Tomcat}
     * instance with the current {@link EmbedVaadinConfig config}.
     * <p/>
     * Does not map any servlet, though. Sub-classes are responsible to do this
     */

#Code:
    protected void initConfiguration() {
        getTomcat().setBaseDir(baseDir.getAbsolutePath());

        // Setup HTTP port listening
        getTomcat().setPort(getConfig().getPort());

        // Setup vaadin production mode
        getContext().addParameter(PRODUCTION_MODE_PARAM, String.valueOf(getConfig().isProductionMode()));
    }

#No. 1830
#File: E:\bishe\1\AbstractEmbedVaadinTomcat.java
#Comment:
    /**
     * Initializes the vaadin servlet and maps it to <tt>/*</tt>.
     * <p/>
     * Returns the associated {@link Wrapper} for further customization.
     *
     * @param servlet the servlet to use to handle vaadin calls.
     * @param <T> the type of the servlet
     * @return the created wrapper for the servlet
     */

#Code:
    protected <T extends VaadinServlet> Wrapper initializeVaadinServlet(T servlet) {
        // Setup vaadin servlet
        final Wrapper wrapper = Tomcat.addServlet(getContext(),
                "vaadin", servlet);
        if (getConfig().getWidgetSet() != null) {
            wrapper.addInitParameter("widgetset", getConfig().getWidgetSet());
        }

        wrapper.addMapping("/*");
        return wrapper;
    }

#No. 1831
#File: E:\bishe\1\AbstractEmbedVaadinTomcat.java
#Comment:
    /**
     * Fires the embedded tomcat that is assumed to be fully configured.
     *
     * @throws LifecycleException if tomcat failed to start
     */

#Code:
    private void doStart() throws LifecycleException {
        tomcat.getServer().addLifecycleListener(new TomcatLifecycleListener());
        logger.info("Deploying application to [" + getConfig().getDeployUrl() + "]");
        tomcat.start();

        // Let's set the port that was used to actually start the application if necessary
        if (getConfig().getPort() == EmbedVaadinConfig.DEFAULT_PORT) {
            getConfig().setPort(getTomcat().getConnector().getLocalPort());
        }

        logger.info("Application has been deployed to [" + getConfig().getDeployUrl() + "]");
        if (config.shouldOpenBrowser()) {
            BrowserUtils.openBrowser(getConfig().getOpenBrowserUrl());
        }
        if (isWaiting()) {
            tomcat.getServer().await();
        }
    }

#No. 1832
#File: E:\bishe\1\AbstractEmbedVaadinTomcat.java
#Comment:
    /**
     * Stops the embedded tomcat.
     *
     * @throws LifecycleException if tomcat failed to stop
     */

#Code:
    private void doStop() throws LifecycleException {
        logger.info("Stopping tomcat.");
        long startTime = System.currentTimeMillis();
        tomcat.stop();
        long duration = System.currentTimeMillis() - startTime;
        logger.info("Tomcat shutdown finished in " + duration + " ms.");
    }

#No. 1833
#File: E:\bishe\1\AbstractEmbedVaadinTomcat.java
#Comment:
    /**
     * Adds a  shutdown hook to stop the server when the JVM is stopped.
     */

#Code:
    private void addShutdownHook() {
        Runtime.getRuntime().addShutdownHook(shutdownThread);
    }

#No. 1834
#File: E:\bishe\1\AbstractEmbedVaadinTomcat.java
#Comment:
    /**
     * Removes the shutdown hook in case the server is stopped manually
     */

#Code:
    private void removeShutdownHook() {
        Runtime.getRuntime().removeShutdownHook(shutdownThread);
    }

#No. 1835
#File: E:\bishe\1\AbstractEmbedVaadinTomcat.java
#Comment:
        /**
         * Stops the server when the VM exits.
         */

#Code:
        public void run() {
            try {
                tomcat.stop();
                logger.info("Stopped Tomcat");
            } catch (LifecycleException e) {
                logger.warn("Failed to stop Tomcat", e);
            }
        }

#No. 1836
#File: E:\bishe\1\AbstractEmbedVaadinTomcat.java
#Comment:
        /**
         * Listens for stop event only in order to remove the shutdown hook before the VM
         * actually shuts down.
         *
         * @param event the event to listen to.
         */

#Code:
        public void lifecycleEvent(LifecycleEvent event) {
            if (event.getType().equals(Lifecycle.STOP_EVENT)) {
                removeShutdownHook();
            }
        }

#No. 1837
#File: E:\bishe\1\AbstractEmitterContext.java
#Comment:
    /**
     * Gets the current {@link EmitterSet}.
     */

#Code:
    public EmitterSet getEmitterSet() {
        return this.set;
    }

#No. 1838
#File: E:\bishe\1\AbstractEmitterContext.java
#Comment:
    /**
     * Sets the current {@link EmitterSet}.
     */

#Code:
    public void setEmitterSet(EmitterSet set) {
        this.set = checkNotNull(set, "set");
    }

#No. 1839
#File: E:\bishe\1\AbstractEmitterContext.java
#Comment:
    /**
     * Gets the current type being emitted.
     */

#Code:
    @Nullable
    public TypeEntry getType() {
        return this.type;
    }

#No. 1840
#File: E:\bishe\1\AbstractEmitterContext.java
#Comment:
    /**
     * Sets the current type being emitted.
     */

#Code:
    public void setType(@Nullable TypeEntry type) {
        this.type = type;
    }

    /**
     * Gets the current outer type being emitted.
     */
    @Nullable
    public TypeEntry getOuterType() {
        return this.outer_type;
    }

#No. 1841
#File: E:\bishe\1\AbstractEmitterContext.java
#Comment:
    /**
     * Gets the current method being emitted.
     */

#Code:
    @Nullable
    public MethodEntry getMethod() {
        return this.method;
    }

#No. 1842
#File: E:\bishe\1\AbstractEmitterContext.java
#Comment:
    /**
     * Sets the current method being emitted.
     */

#Code:
    public void setMethod(@Nullable MethodEntry mth) {
        this.method = mth;
    }

    /**
     * Gets the current field being emitted.
     */
    @Nullable
    public FieldEntry getField() {
        return this.field;
    }

#No. 1843
#File: E:\bishe\1\AbstractEmitterContext.java
#Comment:
    /**
     * Sets the current field being emitted.
     */

#Code:
    public void setField(@Nullable FieldEntry fld) {
        this.field = fld;
    }

    /**
     * Gets the current statement being emitted.
     */
    public Statement getStatement() {
        return this.statement;
    }

#No. 1844
#File: E:\bishe\1\AbstractEmitterContext.java
#Comment:
    /**
     * Sets the current statement being emitted.
     */

#Code:
    public void setStatement(Statement stmt) {
        this.statement = stmt;
    }

#No. 1845
#File: E:\bishe\1\AbstractEmitterContext.java
#Comment:
    /**
     * Gets the current instruction stack.
     */

#Code:
    public Deque<Instruction> getCurrentInstructionStack() {
        return this.insn_stack;
    }

#No. 1846
#File: E:\bishe\1\AbstractEmoFieldUDF.java
#Comment:
    /**
     * Converts a field to a list of segments.  For example, "source.country.lang" becomes ("source", "country", "lang").
     * Dots are escaped using "\." and slashes are escaped using "\\".
     */

#Code:
    private List<String> getFieldPath(String field) {
        String[] paths = field.split("(?<!\\\\)\\.");
        ImmutableList.Builder<String> fields = ImmutableList.builder();
        for (String path : paths) {
            fields.add(path.replaceAll("\\\\\\.", ".").replaceAll("\\\\\\\\", "\\\\"));
        }
        return fields.build();
    }

#No. 1847
#File: E:\bishe\1\AbstractEmoFieldUDF.java
#Comment:
    /**
     * Don't materialize the entire parser content, do a targeted search for the value that matches the path.
     */

#Code:
    private boolean moveParserToField(JsonParser parser, String path)
            throws IOException {
        List<String> segments = getFieldPath(path);

        for (String segment : segments) {
            if (parser.getCurrentToken() != JsonToken.START_OBJECT) {
                // Always expect the path to be fields in a JSON map
                return false;
            }

            boolean found = false;

            JsonToken currentToken = parser.nextToken();
            while (!found && currentToken != JsonToken.END_OBJECT) {
                if (currentToken != JsonToken.FIELD_NAME) {
                    // This should always be a field.  Something is amiss.
                    throw new IOException("Field not found at expected location");
                }
                String fieldName = parser.getText();
                if (fieldName.equals(segment)) {
                    // Move to the next token, which is the field value
                    found = true;
                    currentToken = parser.nextToken();
                } else {
                    parser.nextValue();
                    currentToken = skipValue(parser);
                }
            }

            if (!found) {
                // Field was not found
                return false;
            }
        }

        // The current location in the parser is the value.
        return true;
    }

#No. 1848
#File: E:\bishe\1\AbstractEmoFieldUDF.java
#Comment:
    /**
     * Skips to the first token after the object at the current parser token.
     */

#Code:
    protected JsonToken skipValue(JsonParser parser)
            throws IOException {
        return parser
                .skipChildren()
                .nextToken();
    }

#No. 1849
#File: E:\bishe\1\AbstractEmoFieldUDF.java
#Comment:
    /**
     * Narrow the Json object at the current parser location to the field's type.
     */

#Code:
    abstract protected T narrow(JsonParser parser)
            throws IOException;

    protected BooleanWritable narrowToBoolean(JsonParser parser)
            throws IOException {
        switch (parser.getCurrentToken()) {
            case VALUE_TRUE:
                return new BooleanWritable(true);
            case VALUE_FALSE:
                return new BooleanWritable(false);
            case VALUE_NUMBER_INT:
                return new BooleanWritable(parser.getIntValue() != 0);
            case VALUE_NUMBER_FLOAT:
                return new BooleanWritable(parser.getFloatValue() != 0);
            default:
                return null;
        }
    }

#No. 1850
#File: E:\bishe\1\AbstractEmptyEnum.java
#Comment:
/*
 * @test
 * @bug 5009601
 * @summary empty enum cannot be abstract
 * @author Joseph D. Darcy
 *
 * @compile/fail -source 1.5 AbstractEmptyEnum.java
 */

#Code:

public enum AbstractEmptyEnum {
    ;
    abstract void m();
}

#No. 1851
#File: E:\bishe\1\AbstractEnabledCircuitBreakerAvailability.java
#Comment:
/**
 * Abstract composite that determines Availability by
 * checking the Enabled configuration and a CircuitBreaker.
 *
 * To use this, the service must implement ServiceCircuitBreaker, and its ConfigurationComposite
 * must extend Enabled.
 */

#Code:
@Mixins(AbstractEnabledCircuitBreakerAvailability.Mixin.class)
public interface AbstractEnabledCircuitBreakerAvailability
   extends Availability
{
   class Mixin
      implements Availability
   {
      @This
      Configuration<Enabled> config;

      @This
      ServiceCircuitBreaker circuitBreaker;

      public boolean isAvailable()
      {
         return config.configuration().enabled().get() && circuitBreaker.getCircuitBreaker().getStatus() == CircuitBreaker.Status.on;
      }
   }
}

#No. 1852
#File: E:\bishe\1\AbstractEncoding.java
#Comment:
    /** CTYPE_TO_BIT
     */

#Code:
    private static int CTypeToBit(int ctype) {
        return 1 << ctype;
    }

#No. 1853
#File: E:\bishe\1\AbstractEncoding.java
#Comment:
    /** ONIGENC_IS_XXXXXX_CODE_CTYPE
     */

#Code:
    protected final boolean isCodeCTypeInternal(int code, int ctype) {
        return (CTypeTable[code] & CTypeToBit(ctype)) != 0;
    }

#No. 1854
#File: E:\bishe\1\AbstractEncoding.java
#Comment:
    /** onigenc_is_mbc_newline_0x0a / used also by multibyte encodings
     *
     */

#Code:
    @Override
    public boolean isNewLine(byte[]bytes, int p, int end) {
        return p < end ? bytes[p] == (byte)0x0a : false;
    }

#No. 1855
#File: E:\bishe\1\AbstractEncoding.java
#Comment:
    /** onigenc_ascii_mbc_case_fold
     */

#Code:
    @Override
    public int mbcCaseFold(int flag, byte[]bytes, IntHolder pp, int end, byte[]lower) {
        return asciiMbcCaseFold(flag, bytes, pp, end, lower);
    }

#No. 1856
#File: E:\bishe\1\AbstractEncoding.java
#Comment:
    /** onigenc_ascii_apply_all_case_fold / used also by multibyte encodings
     */

#Code:
    @Override
    public void applyAllCaseFold(int flag, ApplyAllCaseFoldFunction fun, Object arg) {
        asciiApplyAllCaseFold(flag, fun, arg);
    }

#No. 1857
#File: E:\bishe\1\AbstractEncoding.java
#Comment:
    /** onigenc_ascii_get_case_fold_codes_by_str / used also by multibyte encodings
     */

#Code:
    @Override
    public CaseFoldCodeItem[]caseFoldCodesByString(int flag, byte[]bytes, int p, int end) {
        return asciiCaseFoldCodesByString(flag, bytes, p, end);
    }

#No. 1858
#File: E:\bishe\1\AbstractEncoding.java
#Comment:
    /** onigenc_minimum_property_name_to_ctype
     *  notably overridden by unicode encodings
     */

#Code:
    @Override
    public int propertyNameToCType(byte[]bytes, int p, int end) {
        Integer ctype = PosixBracket.PBSTableUpper.get(bytes, p, end);
        if (ctype != null) return ctype;
        throw new CharacterPropertyException(ErrorMessages.ERR_INVALID_CHAR_PROPERTY_NAME, new String(bytes, p, end - p));
    }

#No. 1859
#File: E:\bishe\1\AbstractEncounterCounter.java
#Comment:
    /**
     *  @return how many times have I seen this object before?
     */

#Code:
    public long encounter(Object o)
    {
	Long oldLong = (Long) m.get(o);
	Long newLong;
	long out;
	if (oldLong == null)
	    {
		out = 0;
		newLong = ONE;
	    }
	else
	    {
		out = oldLong.longValue(); 
		newLong = new Long(out + 1);
	    }
	m.put( o, newLong );
	return out;
    }

#No. 1860
#File: E:\bishe\1\AbstractEndLevel.java
#Comment:
	/*static int NUMANIMS[NUMEPISODES] =
	{
	 sizeof(epsd0animinfo)/sizeof(anim_t),
	 sizeof(epsd1animinfo)/sizeof(anim_t),
	 sizeof(epsd2animinfo)/sizeof(anim_t)
	};*/

#Code:

	// MAES: cute, but we can do it in a more Java-friendly way :-p

	public static final int[] NUMANIMS={epsd0animinfo.length,epsd1animinfo.length,epsd2animinfo.length};

	/** ATTENTION: there's a difference between these "anims" and those used in p_spec.c */

	public static final anim_t[][] anims =
	{
	 epsd0animinfo,
	 epsd1animinfo,
	 epsd2animinfo
	};

}

#No. 1861
#File: E:\bishe\1\AbstractEngineRepoProvider.java
#Comment:
	/**
	 * Returns a list of all {@link DownloadableCordovaEngine}s that are
	 * available from this repository.
	 * 
	 * @return list of Cordova engines
	 * @throws CoreException
	 */

#Code:
	public abstract List<DownloadableCordovaEngine> getEngines()
			throws CoreException;

}
}

#No. 1862
#File: E:\bishe\1\AbstractEngineTest.java
#Comment:
    /**
     * After a simple share+reconstruct step the reconstructed data should be
     * the same as the original data
     *
     * @throws WeakSecurityException   should not happen due to fixed setup
     * @throws ReconstructionException should not happen due to fixed setup
     */

#Code:
    @Test
    public void simpleShareReconstructRound() throws ReconstructionException, WeakSecurityException {
        Share shares[] = algorithm.share(data);
        assertThat(shares.length).isEqualTo(n);
        ReconstructionResult reconstructedData = algorithm.reconstruct(shares);
        assertThat(reconstructedData.getData()).isEqualTo(data);
    }

#No. 1863
#File: E:\bishe\1\AbstractEngineTest.java
#Comment:
    /**
     * Reconstruct should work as long as share count > k
     *
     * @throws WeakSecurityException   should not happen due to fixed setup
     * @throws ReconstructionException should not happen due to fixed setup
     */

#Code:
    @Test
    public void reconstructWithSufficientSubSet() throws ReconstructionException, WeakSecurityException {
        Share shares[] = algorithm.share(data);

        for (int i = k + 1; i < n; i++) {
            Share shares1[] = Arrays.copyOfRange(shares, 0, i);
            ReconstructionResult reconstructedData = algorithm.reconstruct(shares1);
            assertThat(reconstructedData.getData()).isEqualTo(data);
        }
    }

#No. 1864
#File: E:\bishe\1\AbstractEngineTest.java
#Comment:
    /**
     * Reconstruct should work with shuffled shares
     *
     * @throws WeakSecurityException   should not happen due to fixed setup
     * @throws ReconstructionException should not happen due to fixed setup
     */

#Code:
    @Test
    public void reconstructShuffledShares() throws ReconstructionException, WeakSecurityException {
        Share shares[] = algorithm.share(data);
        Collections.shuffle(Arrays.asList(shares));

        ReconstructionResult reconstructedData = algorithm.reconstruct(shares);
        assertThat(reconstructedData.getData()).isEqualTo(data);
    }

#No. 1865
#File: E:\bishe\1\AbstractEngineTest.java
#Comment:
    /**
     * Reconstruct should fail if insufficient shares were provided
     *
     * @throws WeakSecurityException should not happen due to fixed setup
     */

#Code:
    @Test
    public void notEnoughSharesTest() throws WeakSecurityException {
        Share shares[] = algorithm.share(data);

        for (int i = 0; i < k; i++) {
            Share[] shares1 = Arrays.copyOfRange(shares, 0, i);
            ReconstructionResult result = algorithm.reconstruct(shares1);
            assertThat(result.isOkay()).isFalse();
        }
    }

#No. 1866
#File: E:\bishe\1\AbstractEnterpriseBeanMetaData.java
#Comment:
    /**
     * Set the enterpriseBeansMetaData.
     *
     * @param enterpriseBeansMetaData the enterpriseBeansMetaData.
     */

#Code:
    public void setEnterpriseBeansMetaData(EnterpriseBeansMetaData enterpriseBeansMetaData) {
        this.enterpriseBeansMetaData = enterpriseBeansMetaData;
    }

#No. 1867
#File: E:\bishe\1\AbstractEnterpriseBeanMetaData.java
#Comment:
    /**
     * Get the ejbJarMetaData.
     *
     * @return the ejbJarMetaData.
     */

#Code:
    public EjbJarMetaData getEjbJarMetaData() {
        if (enterpriseBeansMetaData == null)
            return null;
        return enterpriseBeansMetaData.getEjbJarMetaData();
    }

#No. 1868
#File: E:\bishe\1\AbstractEnterpriseBeanMetaData.java
#Comment:
    /**
     * Get the assembly descriptor
     *
     * @return the ejbJarMetaData.
     */

#Code:
    public AssemblyDescriptorMetaData getAssemblyDescriptor() {
        EjbJarMetaData ejbJar = getEjbJarMetaData();
        if (ejbJar == null)
            return null;
        return ejbJar.getAssemblyDescriptor();
    }

#No. 1869
#File: E:\bishe\1\AbstractEnterpriseBeanMetaData.java
#Comment:
    /**
     * Get the ejbName.
     *
     * @return the ejbName.
     */

#Code:
    public String getEjbName() {
        return getName();
    }

#No. 1870
#File: E:\bishe\1\AbstractEnterpriseBeanMetaData.java
#Comment:
    /**
     * Set the ejbName.
     *
     * @param ejbName the ejbName.
     * @throws IllegalArgumentException for a null ejbName
     */

#Code:
    public void setEjbName(String ejbName) {
        setName(ejbName);
    }

#No. 1871
#File: E:\bishe\1\AbstractEnterpriseBeanMetaData.java
#Comment:
    /**
     * Whether this is a session bean
     *
     * @return true when a session bean
     */

#Code:
    public final boolean isSession() {
        assertNotUnknown();
        return getEjbType() == EjbType.SESSION;
    }

#No. 1872
#File: E:\bishe\1\AbstractEnterpriseBeanMetaData.java
#Comment:
    /**
     * Whether this is a message driven bean
     *
     * @return true when a message driven bean
     */

#Code:
    public final boolean isMessageDriven() {
        assertNotUnknown();
        return getEjbType() == EjbType.MESSAGE_DRIVEN;
    }

#No. 1873
#File: E:\bishe\1\AbstractEnterpriseBeanMetaData.java
#Comment:
    /**
     * Whether this is an entity bean
     *
     * @return true when an entity bean
     */

#Code:
    public final boolean isEntity() {
        assertNotUnknown();
        return getEjbType() == EjbType.ENTITY;
    }

#No. 1874
#File: E:\bishe\1\AbstractEnterpriseBeanMetaData.java
#Comment:
    /**
     * Get the transactionType.
     *
     * @return the transactionType.
     */

#Code:
    public TransactionManagementType getTransactionType() {
        return TransactionManagementType.CONTAINER;
    }

#No. 1875
#File: E:\bishe\1\AbstractEnterpriseBeanMetaData.java
#Comment:
    /**
     * Is this container managed transactions
     *
     * @return true when CMT
     */

#Code:
    public boolean isCMT() {
        TransactionManagementType type = getTransactionType();
        if (type == null)
            return true;
        else
            return type == TransactionManagementType.CONTAINER;
    }

#No. 1876
#File: E:\bishe\1\AbstractEnterpriseBeanMetaData.java
#Comment:
    /**
     * Is this bean managed transactions
     *
     * @return true when BMT
     */

#Code:
    public boolean isBMT() {
        return isCMT() == false;
    }

#No. 1877
#File: E:\bishe\1\AbstractEnterpriseBeanMetaData.java
#Comment:
    /**
     * Get the mappedName.
     *
     * @return the mappedName.
     */

#Code:
    public String getMappedName() {
        return mappedName;
    }

#No. 1878
#File: E:\bishe\1\AbstractEnterpriseBeanMetaData.java
#Comment:
    /**
     * Set the mappedName.
     *
     * @param mappedName the mappedName.
     * @throws IllegalArgumentException for a null mappedName
     */

#Code:
    public void setMappedName(String mappedName) {
        if (mappedName == null)
            throw new IllegalArgumentException("Null mappedName");
        this.mappedName = mappedName;
    }

#No. 1879
#File: E:\bishe\1\AbstractEnterpriseBeanMetaData.java
#Comment:
    /**
     * Get the ejbClass.
     *
     * @return the ejbClass.
     */

#Code:
    public String getEjbClass() {
        return ejbClass;
    }

#No. 1880
#File: E:\bishe\1\AbstractEnterpriseBeanMetaData.java
#Comment:
    /**
     * Set the ejbClass.
     *
     * @param ejbClass the ejbClass.
     * @throws IllegalArgumentException for a null ejbClass
     */

#Code:
    public void setEjbClass(String ejbClass) {
        if (ejbClass == null)
            throw new IllegalArgumentException("Null ejbClass");
        this.ejbClass = ejbClass;
    }

#No. 1881
#File: E:\bishe\1\AbstractEnterpriseBeanMetaData.java
#Comment:
    /**
     * Get the jndiEnvironmentRefsGroup.
     *
     * @return the jndiEnvironmentRefsGroup.
     */

#Code:
    public Environment getJndiEnvironmentRefsGroup() {
        return jndiEnvironmentRefsGroup;
    }

#No. 1882
#File: E:\bishe\1\AbstractEnterpriseBeanMetaData.java
#Comment:
    /**
     * Set the jndiEnvironmentRefsGroup.
     *
     * @param jndiEnvironmentRefsGroup the jndiEnvironmentRefsGroup.
     * @throws IllegalArgumentException for a null jndiEnvironmentRefsGroup
     */

#Code:
    public void setJndiEnvironmentRefsGroup(Environment jndiEnvironmentRefsGroup) {
        if (jndiEnvironmentRefsGroup == null)
            throw new IllegalArgumentException("Null jndiEnvironmentRefsGroup");
        this.jndiEnvironmentRefsGroup = (EnvironmentRefsGroupMetaData) jndiEnvironmentRefsGroup;
    }

#No. 1883
#File: E:\bishe\1\AbstractEnterpriseBeanMetaData.java
#Comment:
    /**
     * Get the securityIdentity.
     *
     * @return the securityIdentity.
     */

#Code:
    public SecurityIdentityMetaData getSecurityIdentity() {
        return securityIdentity;
    }

#No. 1884
#File: E:\bishe\1\AbstractEnterpriseBeanMetaData.java
#Comment:
    /**
     * Set the securityIdentity.
     *
     * @param securityIdentity the securityIdentity.
     * @throws IllegalArgumentException for a null securityIdentity
     */

#Code:
    public void setSecurityIdentity(SecurityIdentityMetaData securityIdentity) {
        if (securityIdentity == null)
            throw new IllegalArgumentException("Null securityIdentity");
        this.securityIdentity = securityIdentity;
    }

#No. 1885
#File: E:\bishe\1\AbstractEnterpriseBeanMetaData.java
#Comment:
    /**
     * Get the securityRoleRefs.
     *
     * @return the securityRoleRefs.
     */

#Code:
    public SecurityRoleRefsMetaData getSecurityRoleRefs() {
        return securityRoleRefs;
    }

#No. 1886
#File: E:\bishe\1\AbstractEnterpriseBeanMetaData.java
#Comment:
    /**
     * Set the securityRoleRefs.
     *
     * @param securityRoleRefs the securityRoleRefs.
     * @throws IllegalArgumentException for a null securityRoleRefs
     */

#Code:
    public void setSecurityRoleRefs(SecurityRoleRefsMetaData securityRoleRefs) {
        if (securityRoleRefs == null)
            throw new IllegalArgumentException("Null securityRoleRefs");
        this.securityRoleRefs = securityRoleRefs;
    }

#No. 1887
#File: E:\bishe\1\AbstractEnterpriseBeanMetaData.java
#Comment:
    /**
     * Get the methods permissions
     *
     * @return the method permissions or null for no result
     */

#Code:
    public MethodPermissionsMetaData getMethodPermissions() {
        org.jboss.metadata.common.ejb.IAssemblyDescriptorMetaData assemblyDescriptor = getAssemblyDescriptor();
        if (assemblyDescriptor == null)
            return null;
        return assemblyDescriptor.getMethodPermissionsByEjbName(getEjbName());
    }

#No. 1888
#File: E:\bishe\1\AbstractEnterpriseBeanMetaData.java
#Comment:
    /**
     * Get the container transactions
     *
     * @return the container transactions or null for no result
     */

#Code:
    public ContainerTransactionsMetaData getContainerTransactions() {
        if (cachedContainerTransactions != null)
            return cachedContainerTransactions;
        org.jboss.metadata.common.ejb.IAssemblyDescriptorMetaData assemblyDescriptor = getAssemblyDescriptor();
        if (assemblyDescriptor == null)
            return null;
        return assemblyDescriptor.getContainerTransactionsByEjbName(getEjbName());
    }

#No. 1889
#File: E:\bishe\1\AbstractEnterpriseBeanMetaData.java
#Comment:
    /**
     * Get the method transaction type
     *
     * @param methodName the method name
     * @param params     the parameters
     * @param iface      the interface type
     * @return the method transaction type
     */

#Code:
    public TransactionAttributeType getMethodTransactionType(String methodName, Class<?>[] params, MethodInterfaceType iface) {
        // default value
        TransactionAttributeType result = null;

        ContainerTransactionsMetaData containerTransactions = getContainerTransactions();
        if (containerTransactions == null || containerTransactions.isEmpty())
            return result;

        ContainerTransactionMetaData bestMatchTransaction = null;
        MethodMetaData bestMatch = null;
        for (ContainerTransactionMetaData transaction : containerTransactions) {
            MethodMetaData match = transaction.bestMatch(methodName, params, iface, bestMatch);
            if (match != bestMatch) {
                bestMatchTransaction = transaction;
                bestMatch = match;
            }
        }

        if (bestMatchTransaction != null)
            result = bestMatchTransaction.getTransAttribute();

        return result;
    }

#No. 1890
#File: E:\bishe\1\AbstractEnterpriseBeanMetaData.java
#Comment:
    /**
     * Get the transaction type
     *
     * @param m     the method
     * @param iface the interface type
     * @return the transaction type
     */

#Code:
    public TransactionAttributeType getMethodTransactionType(Method m, MethodInterfaceType iface) {
        if (m == null)
            return TransactionAttributeType.SUPPORTS;

        TransactionAttributeType result = null;
        if (methodTx != null) {
            result = methodTx.get(m);
            if (result != null)
                return result;
        }

        result = getMethodTransactionType(m.getName(), m.getParameterTypes(), iface);

        // provide default if method is not found in descriptor
        if (result == null)
            result = TransactionAttributeType.REQUIRED;

        if (methodTx == null)
            methodTx = new ConcurrentHashMap<Method, TransactionAttributeType>();
        methodTx.put(m, result);
        return result;
    }

#No. 1891
#File: E:\bishe\1\AbstractEnterpriseBeanMetaData.java
#Comment:
    /**
     * Get the exclude list
     *
     * @return the exclude list or null for no result
     */

#Code:
    public ExcludeListMetaData getExcludeList() {
        org.jboss.metadata.common.ejb.IAssemblyDescriptorMetaData assemblyDescriptor = getAssemblyDescriptor();
        if (assemblyDescriptor == null)
            return null;
        return assemblyDescriptor.getExcludeListByEjbName(getEjbName());
    }

#No. 1892
#File: E:\bishe\1\AbstractEnterpriseBeanMetaData.java
#Comment:
    /**
     * Merge two EnterpriseBeanMetaDatas
     *
     * @param override
     * @param original
     */

#Code:
    public void merge(AbstractEnterpriseBeanMetaData override, AbstractEnterpriseBeanMetaData original) {
        NamedMetaDataWithDescriptionGroupMerger.merge(this, override, original);
        this.ejbType = override(override != null ? override.ejbType : null, original != null ? original.ejbType : null);
        if (override != null && override.mappedName != null)
            setMappedName(override.mappedName);
        else if (original != null && original.mappedName != null)
            setMappedName(original.mappedName);
        if (override != null && override.ejbClass != null)
            setEjbClass(override.ejbClass);
        else if (original != null && original.ejbClass != null)
            setEjbClass(original.ejbClass);
        if (jndiEnvironmentRefsGroup == null)
            jndiEnvironmentRefsGroup = new EnvironmentRefsGroupMetaData();
        Environment env1 = override != null ? override.getJndiEnvironmentRefsGroup() : null;
        Environment env2 = original != null ? original.getJndiEnvironmentRefsGroup() : null;
        EnvironmentRefsGroupMetaDataMerger.merge(jndiEnvironmentRefsGroup, env1, env2, "", "", false);
        securityIdentity = merged(new SecurityIdentityMetaData(), override != null ? override.securityIdentity : null, original != null ? original.securityIdentity : null);
        securityRoleRefs = augment(new SecurityRoleRefsMetaData(), override != null ? override.securityRoleRefs : null, original != null ? original.securityRoleRefs : null);
    }

#No. 1893
#File: E:\bishe\1\AbstractEnterpriseBeanMetaData.java
#Comment:
    /**
     * @see org.jboss.metadata.javaee.spec.Environment#getDataSources()
     */

#Code:
    @Override
    public DataSourcesMetaData getDataSources() {
        if (jndiEnvironmentRefsGroup != null)
            return jndiEnvironmentRefsGroup.getDataSources();
        return null;
    }

#No. 1894
#File: E:\bishe\1\AbstractEnterpriseBeanMetaData.java
#Comment:
    /**
     * @see org.jboss.metadata.javaee.spec.Environment#getDataSourceByName(java.lang.String)
     */

#Code:
    @Override
    public DataSourceMetaData getDataSourceByName(String name) {
        return AbstractMappedMetaData.getByName(name, getDataSources());
    }

#No. 1895
#File: E:\bishe\1\AbstractEntityHibernateDaoSupport.java
#Comment:
  /**
   * Count an entity based on the provided {@link CriteriaCallback}
   * implementation provicountDistinctded. Allows extending DAOs to quickly
   * query an entity by specifying only the filtration fields on the criteria
   * <p>
   * <b>Note</b>: consumers do not have to explicitly call
   * {@link Criteria#setProjection(org.hibernate.criterion.Projection)} within
   * {@link CriteriaCallback#prepare(GenericCriteria)} as this method will do it
   * for them.
   * 
   * @param criteriaCallback
   *          an instance of the criteria callback which specifies the fields to
   *          filter by
   * @return an {@link Integer} value representing the count derived by
   *         executing the associated criteria
   */

#Code:
  protected Integer count(final CriteriaCallback criteriaCallback) {
    return getHibernateTemplate().execute(new HibernateCallback<Integer>() {

      @Override
      public Integer doInHibernate(final Session session) throws HibernateException, SQLException {
        final Criteria criteria = session.createCriteria(getEntityClass());
        criteriaCallback.prepare(criteria);
        criteria.setProjection(Projections.rowCount());
        return (Integer) criteria.uniqueResult();
      }
    });
  }

#No. 1896
#File: E:\bishe\1\AbstractEntityProtocol.java
#Comment:
    /**
     * All the players tracking this entity.
     */

#Code:
    private final Set<LanternPlayer> trackers = new HashSet<>();

    /**
     * The entity that is being tracked.
     */
    protected final E entity;

    /**
     * The entity id of the entity.
     */
    private int entityId = INVALID_ENTITY_ID;

    /**
     * The amount of ticks between every update.
     */
    private int tickRate = 4;

    /**
     * The tracking range of the entity.
     */
    private double trackingRange = 64;

    private int tickCounter = 0;

    final Object2LongMap<Player> playerInteractTimes = new Object2LongOpenHashMap<>();

    final List<EntityEvent> entityEvents = new ArrayList<>();

    public AbstractEntityProtocol(E entity) {
        this.entity = entity;
    }

#No. 1897
#File: E:\bishe\1\AbstractEntityProtocol.java
#Comment:
    /**
     * Sets the tick rate of this entity protocol.
     *
     * @param tickRate The tick rate
     */

#Code:
    public void setTickRate(int tickRate) {
        this.tickRate = tickRate;
    }

#No. 1898
#File: E:\bishe\1\AbstractEntityProtocol.java
#Comment:
    /**
     * Gets the tick rate of this entity protocol.
     *
     * @return The tick rate
     */

#Code:
    public int getTickRate() {
        return this.tickRate;
    }

#No. 1899
#File: E:\bishe\1\AbstractEntityProtocol.java
#Comment:
    /**
     * Gets the tracking range of the entity.
     *
     * @return The tracking range
     */

#Code:
    public double getTrackingRange() {
        return this.trackingRange;
    }

#No. 1900
#File: E:\bishe\1\AbstractEntityProtocol.java
#Comment:
    /**
     * Sets the tracking range of the entity.
     *
     * @param trackingRange The tracking range
     */

#Code:
    public void setTrackingRange(double trackingRange) {
        this.trackingRange = trackingRange;
    }

#No. 1901
#File: E:\bishe\1\AbstractEntityProtocol.java
#Comment:
    /**
     * Destroys the entity. This removes all the trackers and sends a destroy
     * message to the client.
     *
     * @param context The entity protocol context
     */

#Code:
    void destroy(EntityProtocolInitContext context) {
        if (!this.trackers.isEmpty()) {
            // Destroy the entity on all the clients
            final SimpleEntityProtocolContext ctx = new SimpleEntityProtocolContext();
            final TempEvents events = processEvents(true, true);
            ctx.trackers = this.trackers;
            if (events != null && events.deathOrAlive != null) {
                events.deathOrAlive.forEach(event -> handleEvent(ctx, event));
            }
            destroy(ctx);
            this.trackers.clear();
            synchronized (this.playerInteractTimes) {
                this.playerInteractTimes.clear();
            }
        }
        remove(context);
    }

#No. 1902
#File: E:\bishe\1\AbstractEntityProtocol.java
#Comment:
    /**
     * Initializes this entity protocol. This acquires the ids
     * that are required to spawn the entity.
     *
     * @param context The entity protocol context
     */

#Code:
    protected void init(EntityProtocolInitContext context) {
        if (this.entity instanceof NetworkIdHolder) {
            initRootId(((NetworkIdHolder) this.entity).getNetworkId());
        } else {
            // Allocate the next free id
            initRootId(context.acquire());
        }
    }

#No. 1903
#File: E:\bishe\1\AbstractEntityProtocol.java
#Comment:
    /**
     * Initializes the root entity id of this protocol.
     *
     * @param rootEntityId The root entity id
     */

#Code:
    protected final void initRootId(int rootEntityId) {
        checkArgument(rootEntityId != INVALID_ENTITY_ID, "The root entity id cannot be invalid.");
        checkState(this.entityId == INVALID_ENTITY_ID, "This entity protocol is already initialized.");
        this.entityId = rootEntityId;
    }

#No. 1904
#File: E:\bishe\1\AbstractEntityProtocol.java
#Comment:
    /**
     * Gets whether the tracked entity is visible for the tracker.
     *
     * @param tracker The tracker
     * @return Whether the tracker can see the entity
     */

#Code:
    protected boolean isVisible(LanternPlayer tracker) {
        return tracker.canSee(this.entity);
    }

#No. 1905
#File: E:\bishe\1\AbstractEntityProtocol.java
#Comment:
    /**
     * Is called when the specified {@link LanternPlayer} tries to interact
     * with this entity, or at least one of the ids assigned to it.
     *
     * @param player The player that interacted with the entity
     * @param entityId The entity the player interacted with
     * @param position The position where the player interacted with the entity, if present
     */

#Code:
    protected void playerInteract(LanternPlayer player, int entityId, @Nullable Vector3d position) {
    }

    /**
     * Is called when the specified {@link LanternPlayer} tries to attach
     * this entity, or at least one of the ids assigned to it.
     *
     * @param player The player that attack the entity
     * @param entityId The entity id the player attacked
     */
    protected void playerAttack(LanternPlayer player, int entityId) {
    }

#No. 1906
#File: E:\bishe\1\AbstractEntitySpawner.java
#Comment:
    /*
     * (@Override)
     * @see cn.nukkit.entity.ai.IEntitySpawner#spawn(java.util.List, java.util.List)
     */

#Code:
    public void spawn(Collection<Player> onlinePlayers) {
        // first spawn everything for online players ...
        if (isSpawnAllowedByDifficulty()) {
            SpawnResult lastSpawnResult = null;
            for (Player player : onlinePlayers) {
                if (isWorldSpawnAllowed(player.getLevel())) {
                    lastSpawnResult = spawn(player);
                    if (lastSpawnResult.equals(SpawnResult.MAX_SPAWN_REACHED)) {
                        break;
                    }
                }
            }
        } else {
            FileLogger.debug(String.format("[%s] Spawn not allowed because of difficulty [entityName:%s]", getLogprefix(), getEntityName()));
        }

    }

#No. 1907
#File: E:\bishe\1\AbstractEntitySpawner.java
#Comment:
    /**
     * Checks if the given level's name is on blacklist for auto spawn
     *
     * @param level the level to be checked
     * @return <code>true</code> when world spawn is allowed
     */

#Code:
    private boolean isWorldSpawnAllowed(Level level) {
        for (String worldName : this.disabledSpawnWorlds) {
            if (level.getName().toLowerCase().equals(worldName.toLowerCase())) {
                return false;
            }
        }
        return true;
    }

#No. 1908
#File: E:\bishe\1\AbstractEntitySpawner.java
#Comment:
    /**
     * A simple method that evaluates based on the difficulty set in server if a spawn is allowed or not
     *
     * @return
     */

#Code:
    protected boolean isSpawnAllowedByDifficulty() {

        int randomNumber = Utils.rand(0, 4);

        switch (getCurrentDifficulty()) {
            case PEACEFUL:
                return randomNumber == 0;
            case EASY:
                return randomNumber <= 1;
            case NORMAL:
                return randomNumber <= 2;
            case HARD:
                return true; // in hard: always spawn
            default:
                return true;
        }
    }

#No. 1909
#File: E:\bishe\1\AbstractEntitySpawner.java
#Comment:
    /**
     * Returns currently set difficulty as en {@link Enum}
     *
     * @return a {@link Difficulty} instance
     */

#Code:
    protected Difficulty getCurrentDifficulty() {
        return Difficulty.getByDiffculty(this.server.getDifficulty());
    }

#No. 1910
#File: E:\bishe\1\AbstractEntropySplit.java
#Comment:
    /**
     * Returns a single discrete interval for the specified attribute. This
     * method uses the conditions created by
     * {@link #multiple(Dataset, Dataset.Instance[], int)} to choose the best
     * interval. The interval returned is the interval with the lowest entropy,
     * or when there are more than two intervals with the same entropy value,
     * the one that has more instances.
     * 
     * @param dataset
     *            the current dataset.
     * @param instances
     *            the covered instances flags.
     * @param attribute
     *            the index of the continuous attribute.
     * 
     * @return the attribute condition representing a single discrete interval
     *         for the specified attribute.
     */

#Code:
    @Override
    public Condition single(Dataset dataset,
			    Instance[] instances,
			    int attribute) {
	Condition[] conditions = multiple(dataset, instances, attribute);
	Condition best = null;

	if (conditions != null && conditions.length > 0) {
	    for (Condition c : conditions) {
		if ((best == null) || (c.entropy < best.entropy)
			|| (c.entropy == best.entropy
				&& c.length > best.length)) {
		    best = c;
		}
	    }
	}

	return best;
    }

#No. 1911
#File: E:\bishe\1\AbstractEntropySplit.java
#Comment:
    /**
     * Returns the <i>base 2</i> logarithm of a <code>double</code> value.
     * 
     * @param value
     *            a value.
     * 
     * @return the <i>base 2</i> logarithm of <code>value</code>.
     */

#Code:
    protected double log2(double value) {
	return Math.log(value) / Math.log(2.0);
    }

#No. 1912
#File: E:\bishe\1\AbstractEntryClient.java
#Comment:
    /**
     * Grab the descriptor for an entry. TODO: descriptorType should probably be an enum, may need to play with generics to make it
     * dependent on the type of entry
     *
     * @param descriptorType type of descriptor
     * @param entry          a unique identifier for an entry, called a path for workflows and tools ex:
     *                       quay.io/collaboratory/seqware-bwa-workflow:develop for a tool
     */

#Code:
    private void handleDescriptor(String descriptorType, String entry) {
        try {
            SourceFile file = getDescriptorFromServer(entry, descriptorType);

            if (file.getContent() != null && !file.getContent().isEmpty()) {
                out(file.getContent());
            } else {
                errorMessage("No " + descriptorType + " file found", Client.COMMAND_ERROR);
            }
        } catch (ApiException | IOException ex) {
            exceptionMessage(ex, "", Client.API_ERROR);
        }
    }

#No. 1913
#File: E:\bishe\1\AbstractEntryClient.java
#Comment:
    /**
     * private helper methods
     */

#Code:

    public void publish(List<String> args) {
        if (args.isEmpty()) {
            handleListNonpublishedEntries();
        } else if (containsHelpRequest(args)) {
            publishHelp();
        } else {
            String first = reqVal(args, "--entry");
            String entryname = optVal(args, "--entryname", null);
            final boolean unpublishRequest = args.contains("--unpub");
            handlePublishUnpublish(first, entryname, unpublishRequest);
        }
    }

#No. 1914
#File: E:\bishe\1\AbstractEntryClient.java
#Comment:
    /*
    Generate label string given add set, remove set, and existing labels
      */

#Code:
    String generateLabelString(Set<String> addsSet, Set<String> removesSet, List<Label> existingLabels) {
        Set<String> newLabelSet = new HashSet<>();

        // Get existing labels and store in a List
        for (Label existingLabel : existingLabels) {
            newLabelSet.add(existingLabel.getValue());
        }

        // Add new labels to the List of labels
        for (String add : addsSet) {
            final String label = add.toLowerCase();
            newLabelSet.add(label);
        }
        // Remove labels from the list of labels
        for (String remove : removesSet) {
            final String label = remove.toLowerCase();
            newLabelSet.remove(label);
        }

        return Joiner.on(",").join(newLabelSet);
    }

#No. 1915
#File: E:\bishe\1\AbstractEntryClient.java
#Comment:
    /**
     * this function will validate CWL file
     * using this command: cwltool --non-strict --validate <file_path>
     * @param cwlFilePath
     */

#Code:
    private boolean validateCWL(String cwlFilePath) {
        final String[] s = { "cwltool", "--non-strict", "--validate", cwlFilePath };
        try {
            io.cwl.avro.Utilities.executeCommand(Joiner.on(" ").join(Arrays.asList(s)), false,  Optional.absent(), Optional.absent());
            return true;
        } catch (RuntimeException e) {
            // when invalid, executeCommand will throw a RuntimeException
            return false;
        } catch (Exception e) {
            throw new RuntimeException("An unexpected exception unrelated to validation has occurred");
        }
    }

#No. 1916
#File: E:\bishe\1\AbstractEntryPacket.java
#Comment:
    /**
     * Previous entry version, 0 if no previous version was provided.
     */

#Code:
    private int _previousVersion;


    /**
     * Default constructor required by {@link java.io.Externalizable}.
     */
    protected AbstractEntryPacket() {
    }

#No. 1917
#File: E:\bishe\1\AbstractEntryPacket.java
#Comment:
    /**
     * true if the entry packet has an array of fixed properties
     */

#Code:
    public boolean hasFixedPropertiesArray() {
        return false;
    }

#No. 1918
#File: E:\bishe\1\AbstractEntryPoint.java
#Comment:
	/**
	 * According to hidden variable to decide if page is in offline.jsp
	 * 
	 * @return
	 */

#Code:
	public static boolean isOffline() {

	    //remove some offline_code here(0726)
//		// hidden type
//		Element offlineDiv = DOM.getElementById("offlineDiv");
//		if(offlineDiv != null){
//			String offlineStr = DOM.getElementAttribute(offlineDiv, "value");
//	
//			if ("true".equalsIgnoreCase(offlineStr))
//				return true;
//		}
		
		return false;
	}

#No. 1919
#File: E:\bishe\1\AbstractEnum1.java
#Comment:
/*
 * @test
 * @bug 5054976
 * @summary compiler fails to flag an enum abstract
 * @author gafter
 *
 * @compile -source 1.5 AbstractEnum1.java
 * @run main AbstractEnum1
 */

#Code:

import java.lang.reflect.Modifier;

public enum AbstractEnum1 implements AE1_I {
    toto {
        public void m() {
        }
    }
    ;
    public static void main(String[] args) {
        if (!Modifier.isAbstract(AbstractEnum1.class.getModifiers()))
            throw new Error();
    }
}

#No. 1920
#File: E:\bishe\1\AbstractEnvironment.java
#Comment:
	/**
	 * Initialise a set of {@link ActionHandler}s which the environment will use
	 * to process {@link Action}s.
	 * 
	 * @return
	 */

#Code:
	protected Set<ActionHandler> initialiseActionHandlers() {
		final Set<ActionHandler> handlers = new HashSet<ActionHandler>();
		return handlers;
	}

#No. 1921
#File: E:\bishe\1\AbstractEnvironment.java
#Comment:
	/**
	 * Initialise the global environment services this environment will provide.
	 * 
	 * This services will then be provided through the
	 * {@link EnvironmentServiceProvider} interface.
	 * 
	 * @return {@link Set} of global services to provide.
	 */

#Code:
	protected Set<EnvironmentService> initialiseGlobalEnvironmentServices() {
		final Set<EnvironmentService> services = new HashSet<EnvironmentService>();
		services.add(new EnvironmentMembersService(sharedState));
		return services;
	}

#No. 1922
#File: E:\bishe\1\AbstractEnvironment.java
#Comment:
	/**
	 * Return a global environment service for the given class name.
	 */

#Code:
	@SuppressWarnings("unchecked")
	@Override
	public <T extends EnvironmentService> T getEnvironmentService(Class<T> type)
			throws UnavailableServiceException {
		// force NullPointerException if type is null
		type.toString();

		for (EnvironmentService s : this.globalEnvironmentServices) {
			if (type.isInstance(s)) {
				return (T) s;
			}
		}
		throw new UnavailableServiceException(type);
	}

#No. 1923
#File: E:\bishe\1\AbstractEnvironment.java
#Comment:
	/**
	 * <p>
	 * Deregister a participant with the environment.
	 * 
	 * @see uk.ac.imperial.presage2.core.environment.EnvironmentConnector#deregister(java.util.UUID,
	 *      java.util.UUID)
	 */

#Code:
	@Override
	public void deregister(UUID participantID, UUID authkey) {
		if (participantID == null) {
			UnregisteredParticipantException e = new UnregisteredParticipantException(
					"Attempted deregister with null participant ID");
			this.logger.warn(e);
			throw e;
		}
		if (authkeys.get(participantID) == null) {
			UnregisteredParticipantException e = new UnregisteredParticipantException(
					"Unregistered participant " + participantID
							+ " attempting to deregister");
			this.logger.warn(e);
			throw e;
		} else if (authkeys.get(participantID) != authkey) {
			InvalidAuthkeyException e = new InvalidAuthkeyException("Agent "
					+ participantID
					+ " attempting to deregister with incorrect authkey!");
			this.logger.warn(e);
			throw e;
		}
		if (this.logger.isInfoEnabled()) {
			this.logger.info("Deregistering participant " + participantID + "");
		}
		registeredParticipants.remove(participantID);
		synchronized (authkeys) {
			authkeys.remove(participantID);
		}
	}

#No. 1924
#File: E:\bishe\1\AbstractEnvironmentHandler.java
#Comment:
    /**
     * Add a table to backup
     *
     * @param dbTable   an instance of DbTable describing the database table
     * @see com.axway.ats.environment.database.model.BackupHandler#addTable(com.axway.ats.environment.database.model.DbTable)
     */

#Code:
    public void addTable(
                          DbTable dbTable ) {

        if( dbTables.containsKey( dbTable.getTableName() ) ) {
            log.warn( "DB table with name '" + dbTable.getTableName()
                      + "' has already been added for backup." );
        } else {
            dbTables.put( dbTable.getTableName(), dbTable );
        }

    }

#No. 1925
#File: E:\bishe\1\AbstractEnvironmentHandler.java
#Comment:
    /**
     * Enable or disable the foreign key check prior to restoring the
     * database - default value should be true
     *
     * @param foreignKeyCheck   enable or disable
     * @see com.axway.ats.environment.database.model.BackupHandler#setForeignKeyCheck(boolean)
     */

#Code:
    public void setForeignKeyCheck(
                                    boolean foreignKeyCheck ) {

        this.disableForeignKeys = foreignKeyCheck;

    }

#No. 1926
#File: E:\bishe\1\AbstractEnvironmentHandler.java
#Comment:
    /**
     * Choose whether to include "DELETE FROM *" SQL statements in
     * the backup - the default value should be true. If this option is
     * turned on, tables will be deleted prior to inserting data in them
     *
     * @param includeDeleteStatements   enable or disable
     * @see com.axway.ats.environment.database.model.BackupHandler#setIncludeDeleteStatements(boolean)
     */

#Code:
    public void setIncludeDeleteStatements(
                                            boolean includeDeleteStatements ) {

        this.includeDeleteStatements = includeDeleteStatements;

    }

#No. 1927
#File: E:\bishe\1\AbstractEnvironmentHandler.java
#Comment:
    /**
     * Choose whether to lock the tables during restore - default
     * value should be true, as other processes might modify the tables
     * during restore, which may lead to inconsistency
     *
     * @param lockTables    enable or disable
     * @see com.axway.ats.environment.database.model.BackupHandler#setLockTables(boolean)
     */

#Code:
    public void setLockTables(
                               boolean lockTables ) {

        this.addLocks = lockTables;

    }

#No. 1928
#File: E:\bishe\1\AbstractEnvironmentHandler.java
#Comment:
    /**
     * Release the database connection
     */

#Code:
    @Override
    public void disconnect() {

        this.dbProvider.disconnect();
    }

#No. 1929
#File: E:\bishe\1\AbstractEnvironmentModule.java
#Comment:
	/**
	 * <p>
	 * Module to bind components required for an {@link AbstractEnvironment}.
	 * </p>
	 * 
	 * @param environmentImplementation
	 *            Environment implementation to use.
	 * @param environmentServices
	 *            Set of global {@link EnvironmentService}s to use.
	 * @param actionHandlers
	 *            Set of {@link ActionHandler}s to use.
	 */

#Code:
	public AbstractEnvironmentModule(
			Class<? extends AbstractEnvironment> environmentImplementation,
			Set<Class<? extends EnvironmentService>> environmentServices,
			Set<Class<? extends ActionHandler>> actionHandlers) {
		super();
		this.environmentImplementation = environmentImplementation;
		this.environmentServices = environmentServices;
		this.actionHandlers = actionHandlers;
		this.participantEnvironmentServices = new HashSet<Class<? extends EnvironmentService>>();
		this.participantGlobalEnvironmentServices = new HashSet<Class<? extends EnvironmentService>>();
	}

#No. 1930
#File: E:\bishe\1\AbstractEnvironmentModule.java
#Comment:
	/**
	 * <p>
	 * Module to bind components required for an {@link AbstractEnvironment}.
	 * </p>
	 * 
	 * @param environmentImplementation
	 *            Environment implementation to use.
	 */

#Code:
	public AbstractEnvironmentModule(
			Class<? extends AbstractEnvironment> environmentImplementation) {
		this(environmentImplementation,
				new HashSet<Class<? extends EnvironmentService>>(),
				new HashSet<Class<? extends ActionHandler>>());
	}

#No. 1931
#File: E:\bishe\1\AbstractEnvironmentModule.java
#Comment:
	/**
	 * <p>
	 * Module to bind components required for an {@link AbstractEnvironment}.
	 * </p>
	 */

#Code:
	public AbstractEnvironmentModule() {
		this(AbstractEnvironment.class,
				new HashSet<Class<? extends EnvironmentService>>(),
				new HashSet<Class<? extends ActionHandler>>());
	}

#No. 1932
#File: E:\bishe\1\AbstractEnvironmentModule.java
#Comment:
	/**
	 * Add global environment services to be bound to the environment's service
	 * provider.
	 * 
	 * @param services
	 *            {@link EnvironmentService} classes to add
	 * @return this
	 */

#Code:
	public AbstractEnvironmentModule addGlobalEnvironmentServices(
			Class<? extends EnvironmentService>... services) {
		for (Class<? extends EnvironmentService> s : services) {
			this.environmentServices.add(s);
		}
		return this;
	}

#No. 1933
#File: E:\bishe\1\AbstractEnvironmentModule.java
#Comment:
	/**
	 * Add a global environment service to be bound to the environment's service
	 * provider.
	 * 
	 * @param service
	 *            {@link EnvironmentService} class to add
	 * @return this
	 */

#Code:
	public AbstractEnvironmentModule addGlobalEnvironmentService(
			Class<? extends EnvironmentService> service) {
		this.environmentServices.add(service);
		return this;
	}

#No. 1934
#File: E:\bishe\1\AbstractEnvironmentModule.java
#Comment:
	/**
	 * Add {@link ActionHandler}s to be bound to the environment.
	 * 
	 * @param handlers
	 *            {@link ActionHandler}s to bind.
	 * @return this
	 */

#Code:
	public AbstractEnvironmentModule addActionHandlers(
			Class<? extends ActionHandler>... handlers) {
		for (Class<? extends ActionHandler> h : handlers) {
			this.actionHandlers.add(h);
		}
		return this;
	}

#No. 1935
#File: E:\bishe\1\AbstractEnvironmentModule.java
#Comment:
	/**
	 * Add an {@link ActionHandler} to be bound to the environment.
	 * 
	 * @param handler
	 *            {@link ActionHandler} to bind.
	 * @return this.
	 */

#Code:
	public AbstractEnvironmentModule addActionHandler(
			Class<? extends ActionHandler> handler) {
		this.actionHandlers.add(handler);
		return this;
	}

#No. 1936
#File: E:\bishe\1\AbstractEnvironmentModule.java
#Comment:
	/**
	 * Add {@link EnvironmentService}s which will be provided to
	 * {@link Participant}s on registration with the environment.
	 * 
	 * @param services
	 *            {@link EnvironmentService}s to add.
	 * @return this
	 */

#Code:
	public AbstractEnvironmentModule addParticipantEnvironmentServices(
			Class<? extends EnvironmentService>... services) {
		for (Class<? extends EnvironmentService> s : services) {
			this.participantEnvironmentServices.add(s);
		}
		return this;
	}

#No. 1937
#File: E:\bishe\1\AbstractEnvironmentModule.java
#Comment:
	/**
	 * Add an {@link EnvironmentService} which will be provided to
	 * {@link Participant}s on registration with the environment.
	 * 
	 * @param services
	 *            {@link EnvironmentService} to add.
	 * @return this
	 */

#Code:
	public AbstractEnvironmentModule addParticipantEnvironmentService(
			Class<? extends EnvironmentService> service) {
		this.participantEnvironmentServices.add(service);
		return this;
	}

#No. 1938
#File: E:\bishe\1\AbstractEnvironmentModule.java
#Comment:
	/**
	 * Add global {@link EnvironmentService}s which will be provided to
	 * {@link Participant}s on registration with the environment.
	 * 
	 * @param services
	 *            {@link EnvironmentService}s to add.
	 * @return this
	 */

#Code:
	public AbstractEnvironmentModule addParticipantGlobalEnvironmentServices(
			Class<? extends EnvironmentService>... services) {
		for (Class<? extends EnvironmentService> s : services) {
			this.environmentServices.add(s);
			this.participantGlobalEnvironmentServices.add(s);
		}
		return this;
	}

#No. 1939
#File: E:\bishe\1\AbstractEnvironmentModule.java
#Comment:
	/**
	 * Add a global {@link EnvironmentService} which will be provided to
	 * {@link Participant}s on registration with the environment.
	 * 
	 * @param services
	 *            {@link EnvironmentService} to add.
	 * @return this
	 */

#Code:
	public AbstractEnvironmentModule addParticipantGlobalEnvironmentService(
			Class<? extends EnvironmentService> service) {
		this.environmentServices.add(service);
		this.participantGlobalEnvironmentServices.add(service);
		return this;
	}

#No. 1940
#File: E:\bishe\1\AbstractEnvironmentModule.java
#Comment:
	/**
	 * Takes the sets of {@link EnvironmentService}s and {@link ActionHandler}s,
	 * examines their {@link ServiceDependencies} and adds them to the set of
	 * {@link EnvironmentService}s
	 */

#Code:
	final private void processServiceDependencies() {
		final Set<Class<? extends EnvironmentService>> dependencies = new HashSet<Class<? extends EnvironmentService>>();
		for (Class<? extends EnvironmentService> service : environmentServices) {
			if (service.isAnnotationPresent(ServiceDependencies.class)) {
				for (Class<? extends EnvironmentService> dep : service
						.getAnnotation(ServiceDependencies.class).value()) {
					dependencies.add(dep);
				}
			}
		}
		for (Class<? extends ActionHandler> handler : actionHandlers) {
			if (handler.isAnnotationPresent(ServiceDependencies.class)) {
				for (Class<? extends EnvironmentService> dep : handler
						.getAnnotation(ServiceDependencies.class).value()) {
					dependencies.add(dep);
				}
			}
		}
		this.environmentServices.addAll(dependencies);
	}

#No. 1941
#File: E:\bishe\1\AbstractErrorEventDefinitionBuilder.java
#Comment:
  /**
   * Sets the error code variable attribute.
   */

#Code:
  public B errorCodeVariable(String errorCodeVariable) {
    element.setCamundaErrorCodeVariable(errorCodeVariable);
    return myself;
  }

#No. 1942
#File: E:\bishe\1\AbstractErrorEventDefinitionBuilder.java
#Comment:
  /**
   * Sets the error message variable attribute.
   */

#Code:
  public B errorMessageVariable(String errorMessageVariable) {
    element.setCamundaErrorMessageVariable(errorMessageVariable);
    return myself;
  }

#No. 1943
#File: E:\bishe\1\AbstractErrorEventDefinitionBuilder.java
#Comment:
  /**
   * Sets the error attribute with errorCode.
   */

#Code:
  public B error(String errorCode) {
    element.setError(findErrorForNameAndCode(errorCode));
    return myself;
  }

#No. 1944
#File: E:\bishe\1\AbstractErrorEventDefinitionBuilder.java
#Comment:
  /**
   * Finishes the building of a error event definition.
   *
   * @param <T>
   * @return the parent event builder
   */

#Code:
  @SuppressWarnings({ "rawtypes", "unchecked" })
  public <T extends AbstractFlowNodeBuilder> T errorEventDefinitionDone() {
    return (T) ((Event) element.getParentElement()).builder();
  }

#No. 1945
#File: E:\bishe\1\AbstractESMetricsDispatcher.java
#Comment:
            /**
             * Gradle doesn't include a complete SLF4J implementation, so when the provider tries to access MDC
             * features a warning is output. So we need to expose a method to remove the provider.
             */

#Code:
            JsonProviders<ILoggingEvent> providers = layout.getProviders();
            MdcJsonProvider provider = FluentIterable.from(providers.getProviders()).filter(MdcJsonProvider.class).first().get();
            layout.getProviders().removeProvider(provider);
            layout.setTimeZone("UTC");
            layout.setCustomFields(String.format("{\"@source\":\"%s\"}", buildId.get()));
            layout.start();
            return layout;
        }
    });


    public AbstractESMetricsDispatcher(MetricsPluginExtension extension, boolean async) {
        super(extension, async);
    }

#No. 1946
#File: E:\bishe\1\AbstractEvaluator.java
#Comment:
	/** Evaluates an expression.
	 * @param expression The expression to evaluate.
	 * @return the result of the evaluation.
	 * @throws IllegalArgumentException if the expression is not correct.
	 */

#Code:
	public T evaluate(String expression) {
		return evaluate(expression, null);
	}

#No. 1947
#File: E:\bishe\1\AbstractEvaluator.java
#Comment:
	/** Gets the operators supported by this evaluator.
	 * @return a collection of operators.
	 */

#Code:
	public Collection<Operator> getOperators() {
		ArrayList<Operator> result = new ArrayList<Operator>();
		Collection<List<Operator>> values = this.operators.values();
		for (List<Operator> list : values) {
			result.addAll(list);
		}
		return result;
	}

#No. 1948
#File: E:\bishe\1\AbstractEvaluator.java
#Comment:
	/** Gets the functions supported by this evaluator.
	 * @return a collection of functions.
	 */

#Code:
	public Collection<Function> getFunctions() {
		return this.functions.values();
	}

#No. 1949
#File: E:\bishe\1\AbstractEvaluator.java
#Comment:
	/** Gets the constants supported by this evaluator.
	 * @return a collection of constants.
	 */

#Code:
	public Collection<Constant> getConstants() {
		return this.constants.values();
	}

#No. 1950
#File: E:\bishe\1\AbstractEvaluator.java
#Comment:
	/** Converts the evaluated expression into tokens.
	 * <br>Example: The result for the expression "<i>-1+min(10,3)</i>" is an iterator on "-", "1", "+", "min", "(", "10", ",", "3", ")".
	 * <br>By default, the operators symbols, the brackets and the function argument separator are used as delimiter in the string.
	 * @param expression The expression that is evaluated
	 * @return A string iterator.
	 */

#Code:
	protected Iterator<String> tokenize(String expression) {
		return tokenizer.tokenize(expression);
	}

#No. 1951
#File: E:\bishe\1\AbstractEventDetectorModel.java
#Comment:
	/**
	 * @param data
	 */

#Code:
	public AbstractEventDetectorModel(T data) {
		super(data);
	}

#No. 1952
#File: E:\bishe\1\AbstractEventDetectorModel.java
#Comment:
	/**
	 * @param def
	 */

#Code:
	@JsonIgnore
	public void setDefinition(EventDetectorDefinition<?> def) {
		this.data.setDefinition(def);
	}

#No. 1953
#File: E:\bishe\1\AbstractEventDetectorVO.java
#Comment:
	/**
	 * Our defintion
	 */

#Code:
	protected EventDetectorDefinition<T> definition;
	
	/**
     * Return the Model Representation of the Event Detector Source
     * @return
     */
    public AbstractEventDetectorModel<T> asModel(){
    	return this.definition.createModel(this);
    }

#No. 1954
#File: E:\bishe\1\AbstractEventDetectorVO.java
#Comment:
	/**
	 * Our type name defintion
	 * @return
	 */

#Code:
	public String getDetectorType(){
		return this.definition.getEventDetectorTypeName();
	}

#No. 1955
#File: E:\bishe\1\AbstractEventDetectorVO.java
#Comment:
	/**
	 * Our source type name
	 * @return
	 */

#Code:
	public String getDetectorSourceType(){
		return this.definition.getSourceTypeName();
	}

#No. 1956
#File: E:\bishe\1\AbstractEventDetectorVO.java
#Comment:
    /**
	 * @param xid
	 * @param sourceTypeName
	 * @param sourceId2
	 * @return
	 */

#Code:
	protected boolean isXidUnique(String xid, String sourceType, int sourceId) {
		return EventDetectorDao.instance.isXidUnique(xid, id, sourceType, sourceId);
	}

#No. 1957
#File: E:\bishe\1\AbstractEventHandlerModel.java
#Comment:
	/**
	 * @param data
	 */

#Code:
	public AbstractEventHandlerModel(T data) {
		super(data);
	}

#No. 1958
#File: E:\bishe\1\AbstractEventHandlerVO.java
#Comment:
    /**
     * Create the runtime handler
     * @return
     */

#Code:
    public abstract EventHandlerRT<?> createRuntime();
    
    /**
     * Return a model of this
     * @return
     */
    public abstract AbstractEventHandlerModel<?> asModel();

    public TranslatableMessage getMessage() {
        if (!StringUtils.isBlank(name))
            return new TranslatableMessage("common.default", name);
        return getTypeMessage();
    }

#No. 1959
#File: E:\bishe\1\AbstractEventListenerBehavior.java
#Comment:
    /**
     * Serialize the event object in varName to JSON
     */

#Code:
    protected String toJson(String varName)
    {
        return "null";
    }

#No. 1960
#File: E:\bishe\1\AbstractEventListenerBehavior.java
#Comment:
    /**
     * Parses the JSON string and fills the event info
     */

#Code:
    protected Object fromJson(String json)
    {
        if (json == null) {
            return null;
        }
        
        // the object serialized can be null or an object
        if (json.equals("null")) {
            return null;
        }
        
        try {
            JSONObject obj = new JSONObject(json);
            return parseObject(obj);
        }
        catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

#No. 1961
#File: E:\bishe\1\AbstractEventListenerContainer.java
#Comment:
    /**
     * Validate the configuration of this container.
     */

#Code:
    protected void validateConfiguration() {
        Assert.notNull(gigaSpace, "gigaSpace property is required");
        if (transactionManager != null && !disableTransactionValidation) {
            if (!getGigaSpace().getTxProvider().isEnabled()) {
                throw new IllegalStateException(message("event container is configured to run under transactions (transaction manager is provided) " +
                        "but GigaSpace is not transactional. Please pass the transaction manager to the GigaSpace bean as well"));
            }
        }
    }

#No. 1962
#File: E:\bishe\1\AbstractEventListenerContainer.java
#Comment:
    /**
     * Calls {@link #shutdown()} when the BeanFactory destroys the container instance.
     *
     * @see #shutdown()
     */

#Code:
    public void destroy() {
        shutdown();
    }

#No. 1963
#File: E:\bishe\1\AbstractEventListenerContainer.java
#Comment:
    /**
     * Stop container, call {@link #doShutdown()}, and close this container.
     */

#Code:
    public void shutdown() throws DataAccessException {
        if (logger.isDebugEnabled()) {
            logger.debug(message("Shutting down Space Event listener container"));
        }
        synchronized (this.lifecycleMonitor) {
            this.active = false;
            this.running = false;
            this.lifecycleMonitor.notifyAll();
            unregisterMetrics();
        }

        if (registerSpaceModeListener) {
            if (!SpaceUtils.isRemoteProtocol(gigaSpace.getSpace())) {
                IJSpace clusterMemberSpace = SpaceUtils.getClusterMemberSpace(gigaSpace.getSpace());
                try {
                    ISpaceModeListener remoteListener = (ISpaceModeListener) clusterMemberSpace.getDirectProxy().getStubHandler()
                            .exportObject(primaryBackupListener);
                    ((IInternalRemoteJSpaceAdmin) clusterMemberSpace.getAdmin()).removeSpaceModeListener(remoteListener);
                } catch (RemoteException e) {
                    logger.warn("Failed to unregister space mode listener with space [" + gigaSpace.getSpace() + "]", e);
                }
            }
        }

        // Shut down the invokers.
        doShutdown();
    }

#No. 1964
#File: E:\bishe\1\AbstractEventListenerContainer.java
#Comment:
    /**
     * Start this container.
     *
     * @see #doStart
     */

#Code:
    public void start() throws DataAccessException {
        if (!autoStart) {
            autoStart = true;
        }
        if (!activeWhenPrimary) {
            doStart();
        } else {
            if (currentSpaceMode != null && currentSpaceMode == SpaceMode.PRIMARY) {
                doStart();
            }
        }
    }

#No. 1965
#File: E:\bishe\1\AbstractEventListenerContainer.java
#Comment:
    /**
     * Only start if we have a listener registered. If we don't, then explicit start should be
     * called.
     */

#Code:
    protected void doStart() throws DataAccessException {
        if (!autoStart || running || quiesced || getEventListener() == null)
            return;

        synchronized (this.lifecycleMonitor) {
            if (running || quiesced)
                return;

            this.running = true;
            registerMetrics();
            this.lifecycleMonitor.notifyAll();
            for (Iterator<Object> it = this.pausedTasks.iterator(); it.hasNext(); ) {
                doRescheduleTask(it.next());
                it.remove();
            }
        }
        doAfterStart();
    }

#No. 1966
#File: E:\bishe\1\AbstractEventListenerContainer.java
#Comment:
    /**
     * Stop this container.
     *
     * @see #doStop
     */

#Code:
    public void stop() throws DataAccessException {
        doStop();
    }

#No. 1967
#File: E:\bishe\1\AbstractEventListenerContainer.java
#Comment:
    /**
     * Notify all invoker tasks to stop
     */

#Code:
    protected void doStop() throws DataAccessException {
        if (!running) {
            return;
        }
        doBeforeStop();
        synchronized (this.lifecycleMonitor) {
            this.running = false;
            this.resumeAfterUnquiesce = false;
            this.lifecycleMonitor.notifyAll();
            unregisterMetrics();
        }
    }

#No. 1968
#File: E:\bishe\1\AbstractEventListenerContainer.java
#Comment:
    /**
     * If the {@link #setActiveWhenPrimary(boolean)} is set to <code>true</code> (the default), the
     * container lifecycle will be controlled by the space mode. The container will start when the
     * space is in <code>PRIMARY</code> mode, and will stop when the space is in <code>BACKUP</code>
     * mode.
     *
     * <p>Note, this might cause {@link #doStart()} or {@link #doStop()} to be called several times
     * in a row, and sub classes should take this into account.
     */

#Code:
    public void onApplicationEvent(ApplicationEvent applicationEvent) {
        if (activeWhenPrimary) {
            if (applicationEvent instanceof AfterSpaceModeChangeEvent) {
                AfterSpaceModeChangeEvent spEvent = (AfterSpaceModeChangeEvent) applicationEvent;
                if (spEvent.isPrimary() && SpaceUtils.isSameSpace(spEvent.getSpace(), gigaSpace.getSpace())) {
                    if (logger.isTraceEnabled()) {
                        logger.trace(message("Space [" + getGigaSpace() + "] became primary, starting the container"));
                    }
                    doStart();
                }
            } else if (applicationEvent instanceof BeforeSpaceModeChangeEvent) {
                BeforeSpaceModeChangeEvent spEvent = (BeforeSpaceModeChangeEvent) applicationEvent;
                if (!spEvent.isPrimary() && SpaceUtils.isSameSpace(spEvent.getSpace(), gigaSpace.getSpace())) {
                    if (logger.isTraceEnabled()) {
                        logger.trace(message("Space [" + getGigaSpace() + "] became backup, stopping the container"));
                    }
                    doStop();
                }
                currentSpaceMode = spEvent.getSpaceMode();
            }
        }
    }

#No. 1969
#File: E:\bishe\1\AbstractEventListenerContainer.java
#Comment:
    /**
     * Wait while this container is not running.
     *
     * <p>To be called by asynchronous tasks that want to block while the container is in stopped
     * state.
     */

#Code:
    protected final void waitWhileNotRunning() {
        while (this.active && !this.running) {
            synchronized (this.lifecycleMonitor) {
                if (this.active && !this.running) {
                    try {
                        this.lifecycleMonitor.wait();
                    } catch (InterruptedException ex) {
                        // Re-interrupt current thread, to allow other threads to react.
                        Thread.currentThread().interrupt();
                    }
                }
            }
        }
    }

#No. 1970
#File: E:\bishe\1\AbstractEventListenerContainer.java
#Comment:
    /**
     * Take the given task object and reschedule it, either immediately if this container is
     * currently running, or later once this container has been restarted.
     *
     * <p>If this container has already been shut down, the task will not get rescheduled at all.
     *
     * @param task the task object to reschedule
     * @return whether the task has been rescheduled (either immediately or for a restart of this
     * container)
     * @see #doRescheduleTask
     */

#Code:
    protected final boolean rescheduleTaskIfNecessary(Object task) {
        Assert.notNull(task, "Task object must not be null");
        if (this.running) {
            doRescheduleTask(task);
            return true;
        } else if (this.active) {
            synchronized (lifecycleMonitor) {
                if (this.running) {
                    doRescheduleTask(task);
                    return true;
                }
                this.pausedTasks.add(task);
                return true;
            }
        } else {
            return false;
        }
    }

#No. 1971
#File: E:\bishe\1\AbstractEventListenerContainer.java
#Comment:
    /**
     * Reschedule the given task object immediately.
     *
     * <p>To be implemented by subclasses if they ever call <code>rescheduleTaskIfNecessary</code>.
     * This implementation throws an UnsupportedOperationException.
     *
     * @param task the task object to reschedule
     * @see #rescheduleTaskIfNecessary
     */

#Code:
    protected void doRescheduleTask(Object task) {
        throw new UnsupportedOperationException(ClassUtils.getShortName(getClass())
                + " does not support rescheduling of tasks");
    }

#No. 1972
#File: E:\bishe\1\AbstractEventListenerContainer.java
#Comment:
    /**
     * Executes the given listener if the container is running ({@link #isRunning()}.
     *
     * @param eventData The event data object
     * @param txStatus  An optional transaction status allowing to rollback a transaction
     *                  programmatically
     * @param source    An optional source (or additional event information)
     */

#Code:
    protected void executeListener(SpaceDataEventListener eventListener, Object eventData, TransactionStatus txStatus, Object source) throws Throwable {
        if (!isRunning()) {
            return;
        }
        invokeListener(eventListener, eventData, txStatus, source);
    }

#No. 1973
#File: E:\bishe\1\AbstractEventListenerContainer.java
#Comment:
    /**
     * Invokes the configured {@link org.openspaces.events.SpaceDataEventListener} based on the
     * provided data. Currently simply delegates to {@link org.openspaces.events.SpaceDataEventListener#onEvent(Object,
     * org.openspaces.core.GigaSpace, org.springframework.transaction.TransactionStatus, Object)}.
     *
     * @param eventData The event data object
     * @param txStatus  An optional transaction status allowing to rollback a transaction
     *                  programmatically
     * @param source    An optional source (or additional event information)
     */

#Code:
    protected void invokeListener(SpaceDataEventListener eventListener, Object eventData, TransactionStatus txStatus, Object source) throws Throwable {
        if (exceptionHandler != null) {
            try {
                eventListener.onEvent(eventData, getGigaSpace(), txStatus, source);
                exceptionHandler.onSuccess(eventData, getGigaSpace(), txStatus, source);
            } catch (Throwable e) {
                if (!(e instanceof ListenerExecutionFailedException)) {
                    e = new ListenerExecutionFailedException(e.getMessage(), e);
                }
                exceptionHandler.onException((ListenerExecutionFailedException) e, eventData, getGigaSpace(), txStatus, source);
            }
        } else {
            eventListener.onEvent(eventData, getGigaSpace(), txStatus, source);
        }
        processedEvents.inc();
    }

#No. 1974
#File: E:\bishe\1\AbstractEventListenerContainer.java
#Comment:
    /**
     * Handles exception that occurs during the event listening process. Currently simply logs it.
     *
     * @param ex the exception to handle
     */

#Code:
    protected void handleListenerException(Throwable ex) {
        if (ex instanceof Exception) {
            invokeExceptionListener((Exception) ex);
        }
        if (isActive()) {
            incrementFailedEvents();
            // Regular case: failed while active. Log at error level.
            logger.error(message("Execution of event listener failed"), ex);
        } else {
            // Rare case: listener thread failed after container shutdown.
            // Log at debug level, to avoid spamming the shutdown log.
            logger.debug(message("Listener exception after container shutdown"), ex);
        }
    }

#No. 1975
#File: E:\bishe\1\AbstractEventListenerContainer.java
#Comment:
    /**
     * Sets the specified template to be used with the polling space operation.
     *
     * @see org.openspaces.core.GigaSpace#take(Object, long)
     */

#Code:
    public void setTemplate(Object template) {
        this.template = template;
    }

#No. 1976
#File: E:\bishe\1\AbstractEventListenerContainer.java
#Comment:
    /**
     * Returns the template that will be used. Note, in order to perform receive operations, the
     * {@link #getReceiveTemplate()} should be used.
     */

#Code:
    protected Object getTemplate() {
        return this.template;
    }

#No. 1977
#File: E:\bishe\1\AbstractEventListenerContainer.java
#Comment:
    /**
     * Called before each take and read polling operation to change the template Overrides any
     * template defined with {@link #setTemplate(Object)}
     *
     * @param dynamicTemplate - An object that implements {@link DynamicEventTemplateProvider} or
     *                        has a method annotated with {@link DynamicEventTemplateProvider}
     */

#Code:
    public void setDynamicTemplate(Object dynamicTemplate) {
        this.dynamicTemplateRef = dynamicTemplate;
    }

#No. 1978
#File: E:\bishe\1\AbstractEventListenerContainer.java
#Comment:
    /**
     * Returns whether dynamic template is configured
     */

#Code:
    protected boolean isDynamicTemplate() {
        return dynamicTemplate != null;
    }

#No. 1979
#File: E:\bishe\1\AbstractEventListenerContainer.java
#Comment:
    /**
     * If set to <code>true</code> will perform snapshot operation on the provided template before
     * invoking registering as an event listener.
     *
     * @see org.openspaces.core.GigaSpace#snapshot(Object)
     */

#Code:
    public void setPerformSnapshot(boolean performSnapshot) {
        this.performSnapshot = performSnapshot;
    }

#No. 1980
#File: E:\bishe\1\AbstractEventListenerContainer.java
#Comment:
    /**
     * Returns the template to be used for receive operations. If {@link
     * #setPerformSnapshot(boolean)} is set to <code>true</code> (the default) will return the
     * snapshot of the provided template.
     */

#Code:
    protected Object getReceiveTemplate() {

        if (dynamicTemplate != null) {
            return dynamicTemplate.getDynamicTemplate();
        }

        return receiveTemplate;
    }

#No. 1981
#File: E:\bishe\1\AbstractEventListenerContainer.java
#Comment:
    /**
     * Specify the Spring {@link org.springframework.transaction.PlatformTransactionManager} to use
     * for transactional wrapping of listener execution.
     *
     * <p> Default is none, not performing any transactional wrapping.
     */

#Code:
    public void setTransactionManager(PlatformTransactionManager transactionManager) {
        this.transactionManager = transactionManager;
    }

#No. 1982
#File: E:\bishe\1\AbstractEventListenerContainer.java
#Comment:
    /**
     * Return the Spring PlatformTransactionManager to use for transactional wrapping of message
     * reception plus listener execution.
     */

#Code:
    protected final PlatformTransactionManager getTransactionManager() {
        return this.transactionManager;
    }

#No. 1983
#File: E:\bishe\1\AbstractEventListenerContainer.java
#Comment:
    /**
     * Specify the transaction name to use for transactional wrapping. Default is the bean name of
     * this listener container, if any.
     *
     * @see org.springframework.transaction.TransactionDefinition#getName()
     */

#Code:
    public void setTransactionName(String transactionName) {
        this.transactionDefinition.setName(transactionName);
    }

#No. 1984
#File: E:\bishe\1\AbstractEventListenerContainer.java
#Comment:
    /**
     * Specify the transaction timeout to use for transactional wrapping, in <b>seconds</b>. Default
     * is none, using the transaction manager's default timeout.
     *
     * @see org.springframework.transaction.TransactionDefinition#getTimeout()
     */

#Code:
    public void setTransactionTimeout(int transactionTimeout) {
        this.transactionDefinition.setTimeout(transactionTimeout);
    }

#No. 1985
#File: E:\bishe\1\AbstractEventListenerContainer.java
#Comment:
    /**
     * Specify the transaction isolation to use for transactional wrapping.
     *
     * @see org.springframework.transaction.support.DefaultTransactionDefinition#setIsolationLevel(int)
     */

#Code:
    public void setTransactionIsolationLevel(int transactionIsolationLevel) {
        this.transactionDefinition.setIsolationLevel(transactionIsolationLevel);
    }

#No. 1986
#File: E:\bishe\1\AbstractEventListenerContainer.java
#Comment:
    /**
     * Specify the transaction isolation to use for transactional wrapping.
     *
     * @see org.springframework.transaction.support.DefaultTransactionDefinition#setIsolationLevelName(String)
     */

#Code:
    public void setTransactionIsolationLevelName(String transactionIsolationLevelName) {
        this.transactionDefinition.setIsolationLevelName(transactionIsolationLevelName);
    }

#No. 1987
#File: E:\bishe\1\AbstractEventListenerContainer.java
#Comment:
    /**
     * Should transaction validation be enabled or not (verify and fail if transaction manager is
     * provided and the GigaSpace is not transactional). Default to <code>false</code>.
     */

#Code:
    public void setDisableTransactionValidation(boolean disableTransactionValidation) {
        this.disableTransactionValidation = disableTransactionValidation;
    }

#No. 1988
#File: E:\bishe\1\AbstractExamplePane.java
#Comment:
	/**
	 * @return the exampleTitle
	 */

#Code:
	public final String getExampleTitle() {
		return exampleTitle.getText();
	}

#No. 1989
#File: E:\bishe\1\AbstractExamplePane.java
#Comment:
	/**
	 * @return the exampleImage
	 */

#Code:
	public final ImageView getExampleImage() {
		return exampleImage;
	}

#No. 1990
#File: E:\bishe\1\AbstractExamplePane.java
#Comment:
	/**
	 * @return the contentPane
	 */

#Code:
	public final AnchorPane getContentPane() {
		return contentPane;
	}

#No. 1991
#File: E:\bishe\1\AbstractExceptionMapper.java
#Comment:
/**
 * TODO JavaDoc
 *
 * @author Christian Autermann <autermann@uni-muenster.de>
 */

#Code:
public class AbstractExceptionMapper<T extends Throwable> implements
        ExceptionMapper<T> {
    private static final Logger log = LoggerFactory
            .getLogger(AbstractExceptionMapper.class);
    private final Status status;

    public AbstractExceptionMapper(Status status) {
        this.status = status;
    }

    @Override
    public Response toResponse(T exception) {
        log.info("Mapping exception", exception);
        return Response
                .status(status)
                .type(MediaType.TEXT_PLAIN)
                .entity(exception.getMessage())
                .build();
    }
}

#No. 1992
#File: E:\bishe\1\AbstractExchangeStrategy.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public List<Movie> parseResponse(@NonNull Connection.Response response) {
        return parser.parse(response.body());
    }
}
}

#No. 1993
#File: E:\bishe\1\AbstractExecTest.java
#Comment:
    /**
     * Resolve the OS-specific test file to execute.
     */

#Code:
    protected File resolveTestScript(String baseName) {
        final File result = TestUtil.resolveScriptForOS(testDir + "/" + baseName);
        if (!result.exists()) {
            throw new IllegalArgumentException("Unable to find the following file: " + result.getAbsolutePath());
        }
        return result;
    }

#No. 1994
#File: E:\bishe\1\AbstractExecTest.java
#Comment:
    /**
     * Resolve the OS-specific test file to execute.
     */

#Code:
    protected File resolveTestScript(String directoryName, String baseName) {
        final File result = TestUtil.resolveScriptForOS(testDir + "/" + directoryName + "/" + baseName);
        if (!result.exists()) {
            throw new IllegalArgumentException("Unable to find the following file: " + result.getAbsolutePath());
        }
        return result;
    }

#No. 1995
#File: E:\bishe\1\AbstractExecTest.java
#Comment:
    /**
     * Get the name of the currently executed test.
     */

#Code:
    protected String getName() {
        return name.getMethodName();
    }

#No. 1996
#File: E:\bishe\1\AbstractExecuteCommandListener.java
#Comment:
	/**
	 * (Server-side) error message handling.
	 *
	 * NOTE: There exists 'onClientError'. In this execute listener we are
	 * solely interested in error handling <em>after</em> the command has been
	 * executed. In case an exception is thrown during the initial execution,
	 * then it will be discovered immediately.
	 *
	 * @param aMsg the error message
	 */

#Code:
	@Override
	public void onError(ErrorMessage aMsg)
	{
		if (!getIRCState().isConnected())
		{
			connectListener.onError(aMsg);
		}

		if (getIRCState() instanceof IRCStateImpl)
		{
			((IRCStateImpl) (getIRCState())).setConnected(false);
		}
	}

#No. 1997
#File: E:\bishe\1\AbstractExecuteOperation.java
#Comment:
/**
 * 
 * @author Alex Shvid
 * 
 * @param <O> Operation type
 */

#Code:
public abstract class AbstractExecuteOperation<O extends StatementOperation<ResultSet, O>> extends
		AbstractStatementOperation<ResultSet, O> implements StatementCreator {

	protected AbstractExecuteOperation(CqlTemplate cqlTemplate) {
		super(cqlTemplate);
	}

	@Override
	public ResultSet execute() {
		Statement query = doCreateQuery(this);
		return doExecute(query);
	}

	@Override
	public CassandraFuture<ResultSet> executeAsync() {
		Statement query = doCreateQuery(this);
		return doExecuteAsync(query);
	}

	@Override
	public void executeAsync(final CallbackHandler<ResultSet> cb) {
		Statement query = doCreateQuery(this);
		doExecuteAsync(query, cb);
	}

	@Override
	public ResultSet executeNonstop(int timeoutMls) throws TimeoutException {
		Statement query = doCreateQuery(this);
		return doExecuteNonstop(query, timeoutMls);
	}

	@Override
	public Statement toStatement() {
		return doCreateQuery(this);
	}

}

#No. 1998
#File: E:\bishe\1\AbstractExecution.java
#Comment:
  /**
   * Creates a new Execution for the {@code retryPolicy} and {@code circuitBreaker}.
   * 
   * @throws NullPointerException if {@code retryPolicy} is null
   */

#Code:
  AbstractExecution(FailsafeConfig<Object, ?> config) {
    super(new Duration(System.nanoTime(), TimeUnit.NANOSECONDS));
    this.config = config;
    retryPolicy = config.retryPolicy;
    this.circuitBreaker = config.circuitBreaker;
    waitNanos = delayNanos = retryPolicy.getDelay().toNanos();
  }

#No. 1999
#File: E:\bishe\1\AbstractExecution.java
#Comment:
  /**
   * Returns the last failure that was recorded.
   */

#Code:
  @SuppressWarnings("unchecked")
  public <T extends Throwable> T getLastFailure() {
    return (T) lastFailure;
  }

#No. 2000
#File: E:\bishe\1\AbstractExecution.java
#Comment:
  /**
   * Returns the last result that was recorded.
   */

#Code:
  @SuppressWarnings("unchecked")
  public <T> T getLastResult() {
    return (T) lastResult;
  }

#No. 2001
#File: E:\bishe\1\AbstractExecution.java
#Comment:
  /**
   * Returns the time to wait before the next execution attempt.
   */

#Code:
  public Duration getWaitTime() {
    return new Duration(waitNanos, TimeUnit.NANOSECONDS);
  }

#No. 2002
#File: E:\bishe\1\AbstractExecution.java
#Comment:
  /**
   * Returns whether the execution is complete.
   */

#Code:
  public boolean isComplete() {
    return completed;
  }

#No. 2003
#File: E:\bishe\1\AbstractExecutionThreadService.java
#Comment:
  /**
   * Constructor for use by subclasses.
   */

#Code:
  protected AbstractExecutionThreadService() {}

  /**
   * Start the service. This method is invoked on the execution thread.
   * 
   * <p>By default this method does nothing.
   */
  protected void startUp() throws Exception {}

  /**
   * Run the service. This method is invoked on the execution thread.
   * Implementations must respond to stop requests. You could poll for lifecycle
   * changes in a work loop:
   * <pre>
   *   public void run() {
   *     while ({@link #isRunning()}) {
   *       // perform a unit of work
   *     }
   *   }

#No. 2004
#File: E:\bishe\1\AbstractExecutionThreadService.java
#Comment:
  /**
   * Stop the service. This method is invoked on the execution thread.
   * 
   * <p>By default this method does nothing.
   */

#Code:
  // TODO: consider supporting a TearDownTestCase-like API
  protected void shutDown() throws Exception {}

  /**
   * Invoked to request the service to stop.
   * 
   * <p>By default this method does nothing.
   */
  protected void triggerShutdown() {}

  /**
   * Returns the {@link Executor} that will be used to run this service.
   * Subclasses may override this method to use a custom {@link Executor}, which
   * may configure its worker thread with a specific name, thread group or
   * priority. The returned executor's {@link Executor#execute(Runnable)
   * execute()} method is called when this service is started, and should return

#No. 2005
#File: E:\bishe\1\AbstractExecutorService.java
#Comment:
    /**
     * Returns a <tt>RunnableFuture</tt> for the given runnable and default
     * value.
     *
     * @param runnable the runnable task being wrapped
     * @param value the default value for the returned future
     * @return a <tt>RunnableFuture</tt> which when run will run the
     * underlying runnable and which, as a <tt>Future</tt>, will yield
     * the given value as its result and provide for cancellation of
     * the underlying task.
     * @since 1.6
     */

#Code:
    protected <T> RunnableFuture<T> newTaskFor(Runnable runnable, T value) {
        return new FutureTask<T>(runnable, value);
    }

#No. 2006
#File: E:\bishe\1\AbstractExecutorService.java
#Comment:
    /**
     * Returns a <tt>RunnableFuture</tt> for the given callable task.
     *
     * @param callable the callable task being wrapped
     * @return a <tt>RunnableFuture</tt> which when run will call the
     * underlying callable and which, as a <tt>Future</tt>, will yield
     * the callable's result as its result and provide for
     * cancellation of the underlying task.
     * @since 1.6
     */

#Code:
    protected <T> RunnableFuture<T> newTaskFor(Callable<T> callable) {
        return new FutureTask<T>(callable);
    }

#No. 2007
#File: E:\bishe\1\AbstractExecutorService.java
#Comment:
    /**
     * @throws RejectedExecutionException {@inheritDoc}
     * @throws NullPointerException       {@inheritDoc}
     */

#Code:
    public Future<?> submit(Runnable task) {
        if (task == null) throw new NullPointerException();
        RunnableFuture<Void> ftask = newTaskFor(task, null);
        execute(ftask);
        return ftask;
    }

#No. 2008
#File: E:\bishe\1\AbstractExecutorService.java
#Comment:
    /**
     * @throws RejectedExecutionException {@inheritDoc}
     * @throws NullPointerException       {@inheritDoc}
     */

#Code:
    public <T> Future<T> submit(Runnable task, T result) {
        if (task == null) throw new NullPointerException();
        RunnableFuture<T> ftask = newTaskFor(task, result);
        execute(ftask);
        return ftask;
    }

#No. 2009
#File: E:\bishe\1\AbstractExecutorService.java
#Comment:
    /**
     * @throws RejectedExecutionException {@inheritDoc}
     * @throws NullPointerException       {@inheritDoc}
     */

#Code:
    public <T> Future<T> submit(Callable<T> task) {
        if (task == null) throw new NullPointerException();
        RunnableFuture<T> ftask = newTaskFor(task);
        execute(ftask);
        return ftask;
    }

#No. 2010
#File: E:\bishe\1\AbstractExhaustiveIsomorphismInspector.java
#Comment:
    /**
     * For each edge in g1, get the Correspondence edge and test the pair.
     *
     * @param resultRelation
     * @param edgeComparator if null, always return true.
     */

#Code:
    protected boolean areAllEdgesEquivalent(
        IsomorphismRelation<V, E> resultRelation,
        EquivalenceComparator<? super E, ? super Graph<V, E>> edgeComparator)
    {
        boolean checkResult = true;

        if (edgeComparator == null) {
            // nothing to check
            return true;
        }

        try {
            Set<E> edgeSet = this.graph1.edgeSet();

            for (E currEdge : edgeSet) {
                E correspondingEdge =
                    resultRelation.getEdgeCorrespondence(currEdge, true);

                // if one edge test fail , fail the whole method
                if (!edgeComparator.equivalenceCompare(
                        currEdge,
                        correspondingEdge,
                        this.graph1,
                        this.graph2))
                {
                    checkResult = false;
                    break;
                }
            }
        } catch (IllegalArgumentException illegal) {
            checkResult = false;
        }

        return checkResult;
    }

#No. 2011
#File: E:\bishe\1\AbstractExhaustiveIsomorphismInspector.java
#Comment:
    /**
     * return nextElement() casted as IsomorphismRelation
     */

#Code:
    public IsomorphismRelation nextIsoRelation()
    {
        return next();
    }

#No. 2012
#File: E:\bishe\1\AbstractExhaustiveIsomorphismInspector.java
#Comment:
    /**
     * Efficiency: The value is known after the first check for isomorphism
     * activated on this class and returned there after in O(1). If called on a
     * new ("virgin") class, it activates 1 iso-check.
     *
     * @return <code>true</code> iff the two graphs are isomorphic
     */

#Code:
    public boolean isIsomorphic()
    {
        return !(this.nextSupplier.isEnumerationStartedEmpty());
    }

#No. 2013
#File: E:\bishe\1\AbstractExhaustiveIsomorphismInspector.java
#Comment:
    /**
     * @see java.util.Iterator#next()
     */

#Code:
    public IsomorphismRelation next()
    {
        return this.nextSupplier.nextElement();
    }

#No. 2014
#File: E:\bishe\1\AbstractExpandableHeaderItem.java
#Comment:
/**
 * Generic implementation of {@link IExpandable} interface combined with {@link IHeader} interface
 * with most useful methods to manage expandable sections with sticky headers and sub items of
 * type {@link ISectionable}.
 * <p>This abstract class extends {@link AbstractExpandableItem}.</p>
 * Call {@code super()} in the constructor to auto-configure the section status as: shown,
 * expanded, not selectable.
 *
 * @param <VH> {@link ExpandableViewHolder}
 * @param <S>  The sub item of type {@link ISectionable}
 * @author Davide Steduto
 * @since 01/04/2016 Created
 * <br/>18/06/2016 Changed signature with ExpandableViewHolder
 */

#Code:
public abstract class AbstractExpandableHeaderItem<VH extends ExpandableViewHolder, S extends ISectionable>
		extends AbstractExpandableItem<VH, S>
		implements IHeader<VH> {

	/**
	 * By default, expandable header is shown, expanded and not selectable.
	 */
	public AbstractExpandableHeaderItem() {
		setHidden(false);
		setExpanded(true);
		setSelectable(false);
	}

}
#No. 2015
#File: E:\bishe\1\AbstractExpandableItemAdapter.java
#Comment:
    /**
     * This method will not be called.
     * Override {@link #onCreateGroupViewHolder(android.view.ViewGroup, int)} and
     * {@link #onCreateChildViewHolder(android.view.ViewGroup, int)} instead.
     *
     * @param parent   not used
     * @param viewType not used
     * @return null
     */

#Code:
    @Override
    public final RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
        return null;
    }

#No. 2016
#File: E:\bishe\1\AbstractExpandableItemAdapter.java
#Comment:
    /**
     * This method will not be called.
     * Override {@link #getGroupId(int)} and {@link #getChildId(int, int)} instead.
     *
     * @param position not used
     * @return {@link RecyclerView#NO_ID}
     */

#Code:
    @Override
    public final long getItemId(int position) {
        return RecyclerView.NO_ID;
    }

#No. 2017
#File: E:\bishe\1\AbstractExpandableItemAdapter.java
#Comment:
    /**
     * This method will not be called.
     * Override {@link #getGroupItemViewType(int)} and {@link #getChildItemViewType(int, int)} instead.
     *
     * @param position not used
     * @return 0
     */

#Code:
    @Override
    public final int getItemViewType(int position) {
        return 0;
    }

#No. 2018
#File: E:\bishe\1\AbstractExpandableItemAdapter.java
#Comment:
    /**
     * This method will not be called.
     * Override {@link #getGroupCount()} and {@link #getChildCount(int)} instead.
     *
     * @return 0
     */

#Code:
    @Override
    public final int getItemCount() {
        return 0;
    }

#No. 2019
#File: E:\bishe\1\AbstractExpandableItemAdapter.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public int getGroupItemViewType(int groupPosition) {
        return 0;
    }

#No. 2020
#File: E:\bishe\1\AbstractExpandableItemAdapter.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public int getChildItemViewType(int groupPosition, int childPosition) {
        return 0;
    }

#No. 2021
#File: E:\bishe\1\AbstractExpandableItemAdapter.java
#Comment:
    /**
     * This method will not be called.
     * Override {@link #onBindGroupViewHolder(RecyclerView.ViewHolder, int, int)} ()} and
     * {@link #onBindChildViewHolder(RecyclerView.ViewHolder, int, int, int)} instead.
     *
     * @param holder not used
     * @param position not used
     */

#Code:
    @Override
    public final void onBindViewHolder(RecyclerView.ViewHolder holder, int position) {
    }

#No. 2022
#File: E:\bishe\1\AbstractExpandableItemAdapter.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public void onBindGroupViewHolder(GVH holder, int groupPosition, int viewType, List<Object> payloads) {
        onBindGroupViewHolder(holder, groupPosition, viewType);
    }

#No. 2023
#File: E:\bishe\1\AbstractExpandableItemAdapter.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public void onBindChildViewHolder(CVH holder, int groupPosition, int childPosition, int viewType, List<Object> payloads) {
        onBindChildViewHolder(holder, groupPosition, childPosition, viewType);
    }

#No. 2024
#File: E:\bishe\1\AbstractExpandableItemAdapter.java
#Comment:
    /**
     * Override this method if need to customize the behavior.
     * {@inheritDoc}
     */

#Code:
    @Override
    public boolean onHookGroupExpand(int groupPosition, boolean fromUser) {
        return true;
    }

#No. 2025
#File: E:\bishe\1\AbstractExpandableItemAdapter.java
#Comment:
    /**
     * Override this method if need to customize the behavior.
     * {@inheritDoc}
     */

#Code:
    @Override
    public boolean onHookGroupExpand(int groupPosition, boolean fromUser, Object payload) {
        return onHookGroupExpand(groupPosition, fromUser);
    }

#No. 2026
#File: E:\bishe\1\AbstractExpandableItemAdapter.java
#Comment:
    /**
     * Override this method if need to customize the behavior.
     * {@inheritDoc}
     */

#Code:
    @Override
    public boolean onHookGroupCollapse(int groupPosition, boolean fromUser) {
        return true;
    }

#No. 2027
#File: E:\bishe\1\AbstractExpandableItemAdapter.java
#Comment:
    /**
     * Override this method if need to customize the behavior.
     * {@inheritDoc}
     */

#Code:
    @Override
    public boolean onHookGroupCollapse(int groupPosition, boolean fromUser, Object payload) {
        return onHookGroupCollapse(groupPosition, fromUser);
    }

#No. 2028
#File: E:\bishe\1\AbstractExpandableItemAdapter.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public boolean getInitialGroupExpandedState(int groupPosition) {
        return false;
    }

#No. 2029
#File: E:\bishe\1\AbstractExperimentPage.java
#Comment:
	/*
	 * private BioPEPAModel model;
	 * 
	 * public Constructor (BioPEPAModel model) { super(wizardPageName);
	 * this.model = model;
	 * setTitle("Rate Variables Setup and Experimentation Page");
	 * setDescription("Set up the rate variables"); experimentObjectNames = ...
	 * ; }
	 */

#Code:

	protected LinkedList<ArrayInput> arrayInputs = new LinkedList<ArrayInput>();
	public LinkedList<ArrayInput> getArrayInputs () {
		return arrayInputs;
	}

#No. 2030
#File: E:\bishe\1\AbstractExperimentPage.java
#Comment:
	/*
	 * A simple method to create a grid data object for text object, since I
	 * think it is better to create a new one for each text object such that any
	 * changes are not then global.
	 */

#Code:
	private GridData newTextGridData() {
		GridData textGridData = new GridData();
		// textGridData.widthHint = 80;
		textGridData.horizontalAlignment = GridData.FILL;
		textGridData.grabExcessHorizontalSpace = true;
		return textGridData;
	}

#No. 2031
#File: E:\bishe\1\AbstractExperimentPage.java
#Comment:
		/*
		 * Allows the callers to obtain the double values without worrying about
		 * any errors. All errors should be caught before the user presses
		 * finish and not allow the user to press finish when there exists some
		 * errors.
		 */

#Code:
		public Number[] getDoubleValues() {
			try {
				return obtainDoubleValues();
			} catch (Exception e) {
				System.out.println(e.getMessage());
				return new Number[0];
			}
		}

#No. 2032
#File: E:\bishe\1\AbstractExperimentPage.java
#Comment:
		/*
		 * Returns the empty string in the case that the array input is valid
		 * and some error message otherwise
		 */

#Code:
		public String validString() {
			try {
				obtainDoubleValues();
			} catch (Exception e) {
				return e.getMessage();
			}
			// If we haven't returned by now then we must
			// have a valid array input.
			return "";
		}

#No. 2033
#File: E:\bishe\1\AbstractExporterComponent.java
#Comment:
    /**
     * Stop the exporter, iPOJO Invalidate instance callback.
     * Must be override !
     */

#Code:
    protected void stop() {
        declarationBindManager.unbindAll();
    }

#No. 2034
#File: E:\bishe\1\AbstractExporterComponent.java
#Comment:
    /**
     * Start the endpoint-creator component, iPOJO Validate instance callback.
     * Must be override !
     */

#Code:
    protected void start() {
        //
    }

#No. 2035
#File: E:\bishe\1\AbstractExporterComponent.java
#Comment:
    /**
     * @param exportDeclaration The {@link ExportDeclaration} of the service to be exported.
     */

#Code:
    public void addDeclaration(ExportDeclaration exportDeclaration) throws BinderException {
        declarationBindManager.addDeclaration(exportDeclaration);
    }

#No. 2036
#File: E:\bishe\1\AbstractExporterComponent.java
#Comment:
    /**
     * @param exportDeclaration The {@link ExportDeclaration} of the service to stop to be exported.
     */

#Code:
    public void removeDeclaration(ExportDeclaration exportDeclaration) throws BinderException {
        declarationBindManager.removeDeclaration(exportDeclaration);
    }

#No. 2037
#File: E:\bishe\1\AbstractExpressionContainer.java
#Comment:
	/**
	 * <p>Constructor for AbstractExpressionContainer.</p>
	 */

#Code:
	public AbstractExpressionContainer() {
		super();
	}

#No. 2038
#File: E:\bishe\1\AbstractExpressionContainer.java
#Comment:
	/**
	 * <p>addExpr.</p>
	 *
	 * @param expr a {@link lupos.rif.IExpression} object.
	 */

#Code:
	public abstract void addExpr(IExpression expr);

	/**
	 * <p>isEmpty.</p>
	 *
	 * @return a boolean.
	 */
	public boolean isEmpty() {
		return exprs.isEmpty();
	}

#No. 2039
#File: E:\bishe\1\AbstractExpressionContainer.java
#Comment:
	/**
	 * <p>containsOnlyVariables.</p>
	 *
	 * @return a boolean.
	 */

#Code:
	public boolean containsOnlyVariables() {
		for (IExpression expr : exprs)
			if (!expr.containsOnlyVariables())
				return false;
		return true;
	}

#No. 2040
#File: E:\bishe\1\AbstractExpressionContainer.java
#Comment:
	/**
	 * <p>getVariables.</p>
	 *
	 * @return a {@link java.util.Set} object.
	 */

#Code:
	public Set<RuleVariable> getVariables() {
		Set<RuleVariable> variables = new HashSet<RuleVariable>();
		for (IExpression expr : exprs)
			variables.addAll(expr.getVariables());
		return variables;
	}

#No. 2041
#File: E:\bishe\1\AbstractExpressionContainer.java
#Comment:
	/**
	 * <p>getPredicates.</p>
	 *
	 * @return a {@link java.util.List} object.
	 */

#Code:
	public List<Uniterm> getPredicates() {
		List<Uniterm> terms = new ArrayList<Uniterm>();
		for (IExpression expr : exprs)
			terms.addAll(expr.getPredicates());
		return terms;
	}

#No. 2042
#File: E:\bishe\1\AbstractExpressionContainer.java
#Comment:
	/**
	 * <p>getChildren.</p>
	 *
	 * @return a {@link java.util.List} object.
	 */

#Code:
	public List<IRuleNode> getChildren() {
		return new ArrayList<IRuleNode>(exprs);
	}

#No. 2043
#File: E:\bishe\1\AbstractExternalSetMatcher.java
#Comment:
    /**
     * In following method, order is determined by the order in which the node
     * appear in the query.
     *
     * @return - an ordered view of the QueryModelNodes appearing tuple
     *
     */

#Code:
    @Override
    public List<QueryModelNode> getOrderedNodes() {
        return Collections.unmodifiableList(segmentNodeList);
    }

#No. 2044
#File: E:\bishe\1\AbstractExtractorHandler.java
#Comment:
                    /*
                     * if (cleanRef.startsWith("/")) cleanRef = cleanRef.substring(1);
                     */

#Code:
                    // extract filename and filepath from cleanref
                    final String fileName = FilenameUtils.getName(cleanRef);
                    String filePath = FilenameUtils.getFullPath(cleanRef);
                    if (filePath.startsWith("/") && filePath.contains(":")) // (absolute) DOS-Path with starting "/" ???
                        filePath = filePath.substring(1);
                    systemId = ResourceUtils.getRelativePath(filePath + fileName, FilenameUtils.separatorsToUnix(rootDir.getAbsolutePath()), "/");
                }
                int line = locator.getLineNumber();
                if (line > 0) {
                    msg.addSourceReference(systemId, line);
                } else {
                    msg.addSourceReference(systemId);
                }

#No. 2045
#File: E:\bishe\1\AbstractFacetBuilder.java
#Comment:
    /**
     * Sets the nested path the facet will execute on. A match (root object) will then cause all the
     * nested objects matching the path to be computed into the facet.
     */

#Code:
    public AbstractFacetBuilder nested(String nested) {
        this.nested = nested;
        return this;
    }

#No. 2046
#File: E:\bishe\1\AbstractFacetBuilder.java
#Comment:
    /**
     * Marks the facet to run in a global scope, not bounded by any query.
     */

#Code:
    public AbstractFacetBuilder global(boolean global) {
        this.scope = Scopes.GLOBAL;
        return this;
    }

#No. 2047
#File: E:\bishe\1\AbstractFacetBuilder.java
#Comment:
    /**
     * Marks the facet to run in a specific scope.
     */

#Code:
    public AbstractFacetBuilder scope(String scope) {
        this.scope = scope;
        return this;
    }

#No. 2048
#File: E:\bishe\1\AbstractFact.java
#Comment:
	/**
	 * SerialVersionUID
	 */

#Code:
	private static final long serialVersionUID = 1L;

	private final String id;
	
	public AbstractFact(String id) {
		this.id = id;
	}

#No. 2049
#File: E:\bishe\1\AbstractFactorValueMappingHelper.java
#Comment:
    /**
     * Wraps the factor names with other information, such as the study.
     */

#Code:
    @Override
    public Factor getType() {
        if (type != null) {
            return type;
        }
        type = super.getType();

        SectionInstance sectionInstance = getSectionInstance();
        FormatInstance formatInstance = sectionInstance.getParent();
        String fileId = formatInstance.getFileId();

        if (fileId == null) {
            log.trace("No file ID specified for format " + formatInstance.getFormat().getId());
            return type;
        }

        BIIObjectStore store = getStore();
        Study study = mappingUtils.getStudyFromSection(sectionInstance);

        if (study == null) {
            throw new TabMissingValueException(i18n.msg("cannot_find_assay_file", fileId));
        }

        FactorTypeHelper declaredFactor = (FactorTypeHelper) store.get(
                FactorTypeHelper.class, study.getAcc() + "\\" + type.getValue()
        );
        if (declaredFactor == null) {
            throw new TabMissingValueException(i18n.msg("missing_factor_type", type.getValue()));
        }

        // TODO: clone()
        for (OntologyTerm term : declaredFactor.getOntologyTerms()) {
            type.addOntologyTerm(term);
        }

        type.setOrder(getFieldIndex());
        log.trace("Mapping the factor type: " + type + "/" + type.getOntologyTerms());
        return type;
    }

#No. 2050
#File: E:\bishe\1\AbstractFactoryClient.java
#Comment:
/**
 * 抽象工厂模式
 * <p>
 * 与工厂模式区别：
 * 工厂模式直接生产具体产品。
 * 抽象工厂生产每个系列产品的工厂，每个系列产品的工厂生产具体产品
 *
 * @author wei.Li by 15/3/31 (gourderwa@163.com).
 */

#Code:
class AbstractFactoryClient {

    public static void main(String[] args) {

        final ColorFactory factory = ((ColorFactory) FactoryProducer.getFactory(ColorFactory.class));
        final Blue blue = (Blue) factory.getColor(Blue.class);
        blue.fill();

    }
}

#No. 2051
#File: E:\bishe\1\AbstractFactoryClient.java
#Comment:
/**
 * ShapeFactory 工厂  -  生产具体对象
 */

#Code:
class ShapeFactory extends AbstractFactory {

    @Override
    public <T extends Shape> Shape getShape(Class<T> aClass) {

        Shape shape = null;
        try {
            shape = (Shape) Class.forName(aClass.getName()).newInstance();
        } catch (InstantiationException | IllegalAccessException | ClassNotFoundException e) {
            e.printStackTrace();
        }
        return shape;
    }

    @Override
    public <T extends Color> Color getColor(Class<T> aClass) {
        return null;
    }
}

#No. 2052
#File: E:\bishe\1\AbstractFactoryClient.java
#Comment:
/**
 * ColorFactory 工厂  - 生产具体对象
 */

#Code:
class ColorFactory extends AbstractFactory {

    @Override
    public <T extends Shape> Shape getShape(Class<T> aClass) {
        return null;
    }

    @Override
    public <T extends Color> Color getColor(Class<T> aClass) {
        Color color = null;
        try {
            color = (Color) Class.forName(aClass.getName()).newInstance();
        } catch (InstantiationException | IllegalAccessException | ClassNotFoundException e) {
            e.printStackTrace();
        }
        return color;
    }
}

#No. 2053
#File: E:\bishe\1\AbstractFactoryClient.java
#Comment:
/**
 * 工厂制造者 - 生产抽象工厂
 */

#Code:
class FactoryProducer {

    /**
     * @param aClass aClass
     * @param <T>    T extends AbstractFactory
     * @return AbstractFactory
     */
    static <T extends AbstractFactory> AbstractFactory getFactory(Class<T> aClass) {

        AbstractFactory abstractFactory = null;
        try {
            abstractFactory = (AbstractFactory) Class.forName(aClass.getName()).newInstance();
        } catch (InstantiationException | IllegalAccessException | ClassNotFoundException e) {
            e.printStackTrace();
        }
        return abstractFactory;
    }
}

#No. 2054
#File: E:\bishe\1\AbstractFailsafeTest.java
#Comment:
  /**
   * Does a failsafe get with an optional executor.
   */

#Code:
  <T> T failsafeGet(RetryPolicy retryPolicy, Callable<T> callable) throws ExecutionException, InterruptedException {
    ScheduledExecutorService executor = getExecutor();
    return unwrapExceptions(() -> executor == null ? (T) Failsafe.with(retryPolicy).get(callable)
        : (T) Failsafe.with(retryPolicy).with(executor).get(callable).get());
  }

#No. 2055
#File: E:\bishe\1\AbstractFailsafeTest.java
#Comment:
  /**
   * Does a failsafe get with an optional executor.
   */

#Code:
  <T> T failsafeGet(CircuitBreaker circuitBreaker, Callable<T> callable) throws ExecutionException, InterruptedException {
    ScheduledExecutorService executor = getExecutor();
    return unwrapExceptions(() -> executor == null ? (T) Failsafe.with(circuitBreaker).get(callable)
        : (T) Failsafe.with(circuitBreaker).with(executor).get(callable).get());
  }

#No. 2056
#File: E:\bishe\1\AbstractFailsafeTest.java
#Comment:
  /**
   * Does a failsafe run with an optional executor.
   */

#Code:
  void failsafeRun(CircuitBreaker breaker, CheckedRunnable runnable) throws ExecutionException, InterruptedException {
    ScheduledExecutorService executor = getExecutor();
    if (executor == null)
      Failsafe.with(breaker).run(runnable);
    else
      Failsafe.with(breaker).with(executor).run(runnable);
  }

#No. 2057
#File: E:\bishe\1\AbstractFailsafeTest.java
#Comment:
  /**
   * Does a failsafe get with an optional executor.
   */

#Code:
  <T> T failsafeGet(CircuitBreaker breaker, CheckedBiFunction<T, Throwable, T> fallback, Callable<T> callable)
      throws ExecutionException, InterruptedException {
    ScheduledExecutorService executor = getExecutor();
    return unwrapExceptions(() -> executor == null ? (T) Failsafe.with(breaker).withFallback(fallback).get(callable)
        : (T) Failsafe.with(breaker).with(executor).withFallback(fallback).get(callable).get());
  }

#No. 2058
#File: E:\bishe\1\AbstractFailsafeTest.java
#Comment:
  /**
   * Does a failsafe get with an optional executor.
   */

#Code:
  <T> T failsafeGet(RetryPolicy retryPolicy, CheckedBiFunction<T, Throwable, T> fallback, Callable<T> callable)
      throws ExecutionException, InterruptedException {
    ScheduledExecutorService executor = getExecutor();
    return unwrapExceptions(() -> executor == null ? (T) Failsafe.with(retryPolicy).withFallback(fallback).get(callable)
        : (T) Failsafe.with(retryPolicy).with(executor).withFallback(fallback).get(callable).get());
  }

#No. 2059
#File: E:\bishe\1\AbstractFailsafeTest.java
#Comment:
  /**
   * Asserts that retries are not attempted after a successful execution.
   */

#Code:
  public void shouldSucceedWithoutRetries() throws Throwable {
    // Given retries not allowed
    reset(service);
    when(service.connect()).thenReturn(false);

    // When / Then
    assertEquals(failsafeGet(retryNever, service::connect), Boolean.FALSE);
    verify(service).connect();
  }

#No. 2060
#File: E:\bishe\1\AbstractFailsafeTest.java
#Comment:
  /**
   * Asserts that retries are performed then a non-retryable failure is thrown.
   */

#Code:
  @SuppressWarnings("unchecked")
  public void shouldThrowOnNonRetriableFailure() throws Throwable {
    // Given
    when(service.connect()).thenThrow(ConnectException.class, ConnectException.class, IllegalStateException.class);
    RetryPolicy retryPolicy = new RetryPolicy().retryOn(ConnectException.class);

    // When / Then
    assertThrows(() -> failsafeGet(retryPolicy, service::connect), IllegalStateException.class);
    verify(service, times(3)).connect();
  }

#No. 2061
#File: E:\bishe\1\AbstractFailsafeTest.java
#Comment:
  /**
   * Should throw CircuitBreakerOpenException when max half-open executions are occurring.
   */

#Code:
  public void shouldRejectExcessiveExecutionsThroughHalfOpenCircuit() throws Throwable {
    // Given
    CircuitBreaker breaker = new CircuitBreaker().withSuccessThreshold(3);
    breaker.halfOpen();
    Waiter waiter = new Waiter();
    for (int i = 0; i < 3; i++)
      Testing.runInThread(() -> failsafeRun(breaker, () -> {
        waiter.resume();
        Thread.sleep(1000);
      }));

    // When / Then
    waiter.await(10000, 3);
    for (int i = 0; i < 5; i++)
      assertThrows(() -> failsafeGet(breaker, () -> null), CircuitBreakerOpenException.class);
  }

#No. 2062
#File: E:\bishe\1\AbstractFailsafeTest.java
#Comment:
  /**
   * Asserts that fallback works as expected after retries.
   */

#Code:
  public void shouldFallbackAfterFailureWithRetries() throws Throwable {
    // Given
    RetryPolicy retryPolicy = new RetryPolicy().withMaxRetries(2);
    Exception failure = new ConnectException();
    when(service.connect()).thenThrow(failures(3, failure));
    Waiter waiter = new Waiter();

    // When / Then
    assertEquals(failsafeGet(retryPolicy, (r, f) -> {
      waiter.assertNull(r);
      waiter.assertEquals(failure, f);
      return false;
    }, () -> service.connect()), Boolean.FALSE);
    verify(service, times(3)).connect();

    // Given
    reset(service);
    when(service.connect()).thenThrow(failures(3, failure));

    // When / Then
    assertThrows(() -> failsafeGet(retryPolicy, (r, f) -> {
      waiter.assertNull(r);
      waiter.assertEquals(failure, f);
      throw new RuntimeException(f);
    }, () -> service.connect()), RuntimeException.class, ConnectException.class);
    verify(service, times(3)).connect();
  }

#No. 2063
#File: E:\bishe\1\AbstractFailsafeTest.java
#Comment:
  /**
   * Asserts that fallback works after a failure with a breaker configured.
   */

#Code:
  public void shouldFallbackAfterFailureWithCircuitBreaker() throws Throwable {
    // Given
    CircuitBreaker breaker = new CircuitBreaker().withSuccessThreshold(3).withDelay(1, TimeUnit.MINUTES);
    Exception failure = new ConnectException();
    when(service.connect()).thenThrow(failure);
    Waiter waiter = new Waiter();

    // When / Then
    assertEquals(failsafeGet(breaker, (r, f) -> {
      waiter.assertNull(r);
      waiter.assertEquals(failure, f);
      return false;
    }, () -> service.connect()), Boolean.FALSE);
    verify(service).connect();

    // Given
    reset(service);
    breaker.close();
    when(service.connect()).thenThrow(failure);

    // When / Then
    assertThrows(() -> failsafeGet(breaker, (r, f) -> {
      waiter.assertNull(r);
      waiter.assertEquals(failure, f);
      throw new RuntimeException(f);
    }, () -> service.connect()), RuntimeException.class, ConnectException.class);
    verify(service).connect();
  }

#No. 2064
#File: E:\bishe\1\AbstractFailsafeTest.java
#Comment:
  /**
   * Asserts that fallback works when a circuit breaker is open.
   */

#Code:
  public void shouldFallbackWhenCircuitBreakerIsOpen() throws Throwable {
    // Given
    CircuitBreaker breaker = new CircuitBreaker().withSuccessThreshold(3).withDelay(1, TimeUnit.MINUTES);
    breaker.open();
    Exception failure = new ConnectException();
    when(service.connect()).thenThrow(failure);
    Waiter waiter = new Waiter();

    // When / Then
    assertEquals(failsafeGet(breaker, (r, f) -> {
      waiter.assertNull(r);
      waiter.assertTrue(f instanceof CircuitBreakerOpenException);
      return false;
    }, service::connect), Boolean.FALSE);
    verify(service, times(0)).connect();
  }

#No. 2065
#File: E:\bishe\1\AbstractFaultDetectionHandler.java
#Comment:
    /**
     * @see FaultDetectionHandler#register
     */

#Code:
    public void register(FaultDetectionListener<ServiceID> listener) {
        if(listener!=null) {
            synchronized (listeners) {
                listeners.add(listener);
            }
        }
    }

#No. 2066
#File: E:\bishe\1\AbstractFaultDetectionHandler.java
#Comment:
    /**
     * @see FaultDetectionHandler#unregister
     */

#Code:
    public void unregister(FaultDetectionListener<ServiceID> listener) {
        if(listener!=null) {
            synchronized (listeners) {
                listeners.remove(listener);
            }
        }
    }

#No. 2067
#File: E:\bishe\1\AbstractFaultDetectionHandler.java
#Comment:
    /**
     * @see FaultDetectionHandler#monitor
     */

#Code:
    public void monitor(Object proxy, ServiceID id) {
        if(proxy == null)
            throw new IllegalArgumentException("proxy is null");
        if(id == null)
            throw new IllegalArgumentException("id is null");
        this.proxy = proxy;
        this.serviceID = id;

        serviceMonitor = getServiceMonitor();        
    }

#No. 2068
#File: E:\bishe\1\AbstractFaultDetectionHandler.java
#Comment:
    /**
     * @see FaultDetectionHandler#terminate
     */

#Code:
    public void terminate() {
        if(terminating)
            return;
        terminating = true;        
        if(lCache != null && fdhListener!=null) {
            try {
                lCache.removeListener(fdhListener);
            } catch (Throwable t) {
                logger.warn("Exception {} removing Listener from LookupCache", t.getClass().getName());
            }
        }
        if(serviceMonitor != null) {
            serviceMonitor.drop();
        }
        listeners.clear();
    }

#No. 2069
#File: E:\bishe\1\AbstractFaultDetectionHandler.java
#Comment:
    /**
     * Notify FaultDetectionListener instances the service has been removed
     */

#Code:
    @SuppressWarnings("unchecked")
    protected void notifyListeners() {
        FaultDetectionListener<ServiceID>[] ls;
        synchronized(listeners) {
            ls = listeners.toArray(new FaultDetectionListener[listeners.size()]);
        }
        for(FaultDetectionListener<ServiceID> l : ls) {
            l.serviceFailure(proxy, serviceID);
        }
    }

#No. 2070
#File: E:\bishe\1\AbstractFeatureGrapher.java
#Comment:
	/**
	 * Draw and render the graph.
	 */

#Code:
	public abstract void render();

	/*
	 * UTILS
	 */
	
	/**
	 * Render and display a frame containing all the char panels, grouped by dimension
	 */
	protected final void renderCharts(final List<ExportableChartPanel> chartPanels) {
		// The Panel
		JPanel panel = new JPanel();
		BoxLayout panelLayout = new BoxLayout(panel, BoxLayout.Y_AXIS);
		panel.setLayout(panelLayout);
		for(ExportableChartPanel chartPanel : chartPanels)  {
			panel.add(chartPanel);
			panel.add(Box.createVerticalStrut(5));
		}
		
		// Scroll pane
		JScrollPane scrollPane = new JScrollPane();
		scrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
		scrollPane.setViewportView(panel);

		// The frame
		JFrame frame = new JFrame();
		frame.setTitle("Feature plot for Track scheme");
		frame.setIconImage(TRACK_SCHEME_ICON.getImage());
		frame.getContentPane().add(scrollPane);
		frame.validate();
		frame.setSize(new java.awt.Dimension(520, 320));
		frame.setVisible(true);
	}

#No. 2071
#File: E:\bishe\1\AbstractFeatureGrapher.java
#Comment:
	/**
	 * @return the unique mapped values in the given map, for the collection of keys given.
	 */

#Code:
	protected final <K, V> Set<V> getUniqueValues(Iterable<K> keys, Map<K,V> map) {
		HashSet<V> mapping = new HashSet<V>();
		for (K key : keys) {
			mapping.add(map.get(key));
		}
		return mapping;
	}

#No. 2072
#File: E:\bishe\1\AbstractFeatureGrapher.java
#Comment:
	/**
	 * @return  the collection of keys amongst the given ones, 
	 * that point to the target value in the given map.
	 * @param targetValue the common value to search
	 * @param keys the keys to inspect
	 * @param map the map to search in
	 */

#Code:
	protected final <K, V> List<K> getCommonKeys(final V targetValue, final Iterable<K> keys, final Map<K,V> map) {
		ArrayList<K> foundKeys = new ArrayList<K>();
		for (K key : keys) {
			if (map.get(key).equals(targetValue)) {
				foundKeys.add(key);
			}
		}
		return foundKeys;
	}

#No. 2073
#File: E:\bishe\1\AbstractFeatureGrapher.java
#Comment:
	/**
	 * @return a suitable plot title built from the given target features
	 */

#Code:
	
	protected final String buildPlotTitle(final Iterable<String> yFeatures, final Map<String, String> featureNames) {
		StringBuilder sb = new StringBuilder("Plot of ");
		Iterator<String> it = yFeatures.iterator();
		sb.append(featureNames.get(it.next()) );
		while(it.hasNext()) {
			sb.append(", ");
			sb.append(featureNames.get(it.next()));
		}
		sb.append(" vs ");
		sb.append(featureNames.get(xFeature));
		sb.append(".");
		return sb.toString();
	}

#No. 2074
#File: E:\bishe\1\AbstractFeatureGrapher.java
#Comment:
	/**
	 * @return the list of links that have their source and target in the given spot list.
	 */

#Code:
	protected final List<DefaultWeightedEdge> getInsideEdges(final Collection<Spot> spots) {
		int nspots = spots.size();
		ArrayList<DefaultWeightedEdge> edges = new ArrayList<DefaultWeightedEdge>(nspots);
		TrackModel trackModel = model.getTrackModel();
		for (DefaultWeightedEdge edge : trackModel.edgeSet()) {
			Spot source = trackModel.getEdgeSource(edge);
			Spot target = trackModel.getEdgeTarget(edge);
			if (spots.contains(source) && spots.contains(target)) {
				edges.add(edge);
			}
		}
		return edges;
	}

#No. 2075
#File: E:\bishe\1\AbstractFeatureManager.java
#Comment:
    /**
     * Invoked to handle Back Pressed event received by the {@link FeatureContainer}.
     *
     * @return A {@code boolean} value indicating if the event was consumed by this method.
     */

#Code:
    @Override
    public boolean onBackPressed() {

        final List<Feature> foregroundFeatures = getForegroundFeatures();

        for (final Feature feature : foregroundFeatures) {
            if (feature.hasForegroundView()) {
                if (feature.isBackPressedEventHandler()) {
                    if (feature.canGoBack()) {
                        feature.goBack();
                        return true;
                    }
                }
            }
        }
        return false;
    }

#No. 2076
#File: E:\bishe\1\AbstractFeaturePresenter.java
#Comment:
/**
 * {@link AbstractFeaturePresenter} extends {@link AbstractPresenter} to provide an abstract base class
 * for implementing {@link FeaturePresenter}s that are controlled by {@link Feature}s.
 */

#Code:
public abstract class AbstractFeaturePresenter<T_View extends View> extends AbstractPresenter<T_View>
        implements FeaturePresenter {

    private Feature feature;
    private DependencyScope scope;

    @SuppressWarnings("unchecked")
    @Override
    public Feature getFeature() {
        return feature;
    }

    @Override
    public void setFeature(final Feature feature) {
        this.feature = feature;
    }

    @Override
    public DependencyScope getScope() {
        return scope;
    }

    @Override
    public void setScope(final DependencyScope scope) {
        this.scope = scope;
    }
}

#No. 2077
#File: E:\bishe\1\AbstractFeedDisplay.java
#Comment:
    /**
     * Releases all links and resources and prepares itself to be garbage collected.
     */

#Code:
    public void prepareForDismiss()
    {
        if (model != null) model.prepareToDismiss();
        if (config != null) config.setListener(null);
        setViewport(null);
    }

#No. 2078
#File: E:\bishe\1\AbstractFeedDisplay.java
#Comment:
    /**
     * Sets the viewport which will be used for showing this component.
     *
     * @param aViewport viewport.
     */

#Code:
    public void setViewport(JViewport aViewport)
    {
        viewport = aViewport;
        if (noContentPanel != null) noContentPanel.setViewport(aViewport);
    }

#No. 2079
#File: E:\bishe\1\AbstractFeedDisplay.java
#Comment:
    /**
     * Returns displayable feed view component.
     *
     * @return displayable feed view component.
     */

#Code:
    public JComponent getComponent()
    {
        return this;
    }

#No. 2080
#File: E:\bishe\1\AbstractFeedDisplay.java
#Comment:
    /**
     * Adds listener.
     *
     * @param l listener.
     */

#Code:
    public void addListener(IFeedDisplayListener l)
    {
        if (!listeners.contains(l)) listeners.add(l);
    }

#No. 2081
#File: E:\bishe\1\AbstractFeedDisplay.java
#Comment:
    /**
     * Removes listener.
     *
     * @param l listener.
     */

#Code:
    public void removeListener(IFeedDisplayListener l)
    {
        listeners.remove(l);
    }

#No. 2082
#File: E:\bishe\1\AbstractFeedDisplay.java
#Comment:
    /**
     * Fire article selected event.
     *
     * @param lead              lead article.
     * @param selectedArticles  all selected articles.
     */

#Code:
    protected void fireArticleSelected(IArticle lead, IArticle[] selectedArticles)
    {
        for (IFeedDisplayListener l : listeners) l.articleSelected(lead, selectedArticles);
    }

#No. 2083
#File: E:\bishe\1\AbstractFeedDisplay.java
#Comment:
    /**
     * Fire link hovered event.
     *
     * @param link link.
     */

#Code:
    protected void fireLinkHovered(URL link)
    {
        for (IFeedDisplayListener l : listeners) l.linkHovered(link);
    }

#No. 2084
#File: E:\bishe\1\AbstractFeedDisplay.java
#Comment:
    /**
     * Fire link clicked event.
     *
     * @param link link.
     */

#Code:
    protected void fireLinkClicked(URL link)
    {
        for (IFeedDisplayListener l : listeners) l.linkClicked(link);
    }

#No. 2085
#File: E:\bishe\1\AbstractFeedDisplay.java
#Comment:
    /**
     * Fire feed jump link clicked event.
     *
     * @param feed feed.
     */

#Code:
    protected void fireFeedJumpLinkClicked(IFeed feed)
    {
        for (IFeedDisplayListener l : listeners) l.feedJumpLinkClicked(feed);
    }

#No. 2086
#File: E:\bishe\1\AbstractFeedDisplay.java
#Comment:
    /**
     * Fire the zoom-in event.
     */

#Code:
    protected void fireZoomIn()
    {
        for (IFeedDisplayListener l : listeners) l.onZoomIn();
    }

#No. 2087
#File: E:\bishe\1\AbstractFeedDisplay.java
#Comment:
    /**
     * Fire the zoom-out event.
     */

#Code:
    protected void fireZoomOut()
    {
        for (IFeedDisplayListener l : listeners) l.onZoomOut();
    }

#No. 2088
#File: E:\bishe\1\AbstractFeedDisplay.java
#Comment:
    /**
     * Get display configuration.
     *
     * @return configuration.
     */

#Code:
    public IFeedDisplayConfig getConfig()
    {
        return config;
    }

#No. 2089
#File: E:\bishe\1\AbstractFeedDisplay.java
#Comment:
    /**
     * Request focus for the list component.
     *
     * @return <code>FALSE</code> if focusing is guaranteed to fail.
     */

#Code:
    public boolean requestFocusInWindow()
    {
        boolean focused = true;

        if ((selectedDisplay == null && !this.selectFirstArticle(getConfig().getViewMode())) ||
            !selectedDisplay.focus())
        {
            focused = super.requestFocusInWindow();
        }

        return focused;
    }

#No. 2090
#File: E:\bishe\1\AbstractFeedDisplay.java
#Comment:
    /**
     * Finds the display to remove.
     *
     * @param aArticle      article displayed.
     * @param aGroup        group reported by a model.
     * @param aIndexInGroup index within the reported group.
     *
     * @return display or <code>NULL</code>.
     */

#Code:
    private IArticleDisplay findDisplay(IArticle aArticle, int aGroup, int aIndexInGroup)
    {
        IArticleDisplay display;

        int index = getDisplayIndex(aGroup, aIndexInGroup);
        Component cmp = index < getComponentCount() ? getComponent(index) : null;
        display = cmp == null || !(cmp instanceof IArticleDisplay) ? null : (IArticleDisplay)cmp;

        // Check if correct display is found
        if (display != null && display.getArticle() != aArticle)
        {
            getLogger().severe(MessageFormat.format(
                Strings.error("ui.wrong.article.has.been.found"),
                aGroup, aIndexInGroup));
            display = null;
        }

        // Plan B -- looking for an article display using direct iteration
        if (display == null)
        {
            getLogger().severe(MessageFormat.format(
                Strings.error("ui.missing.display"),
                index, aGroup, aIndexInGroup));

            display = findArticleDisplay(aArticle);
        }

        // If display is not found -- we are in trouble!
        if (display == null) getLogger().severe(Strings.error("ui.display.was.not.found"));

        return display;
    }

#No. 2091
#File: E:\bishe\1\AbstractFeedDisplay.java
#Comment:
    /**
     * Finds article display directly among all article components.
     *
     * @param aArticle article we are looking for.
     *
     * @return display component or <code>NULL</code>.
     */

#Code:
    protected IArticleDisplay findArticleDisplay(IArticle aArticle)
    {
        IArticleDisplay aDisplay = null;

        for (int i = 0; aDisplay == null && i < getComponentCount(); i++)
        {
            Component cmp = getComponent(i);
            if (cmp instanceof IArticleDisplay)
            {
                IArticleDisplay dsp = (IArticleDisplay)cmp;
                if (dsp.getArticle() == aArticle) aDisplay = dsp;
            }
        }

        return aDisplay;
    }

#No. 2092
#File: E:\bishe\1\AbstractFeedDisplay.java
#Comment:
    /**
     * Orders to select next article.
     *
     * @param mode mode of selection.
     *
     * @return <code>TRUE</code> if article has been selected.
     */

#Code:
    public boolean selectNextArticle(int mode)
    {
        return selectNextArticle(mode, selectedDisplay);
    }

#No. 2093
#File: E:\bishe\1\AbstractFeedDisplay.java
#Comment:
    /**
     * Orders to select next article.
     *
     * @param mode mode of selection.
     *
     * @return <code>TRUE</code> if article has been selected.
     */

#Code:
    public boolean selectFirstArticle(int mode)
    {
        boolean selected = selectNextArticle(mode, null);
        if (selected) ensureSelectedViewDisplayed();
        return selected;
    }

#No. 2094
#File: E:\bishe\1\AbstractFeedDisplay.java
#Comment:
    /**
     * Orders to select previous article.
     *
     * @param mode mode of selection.
     *
     * @return <code>TRUE</code> if article has been selected.
     */

#Code:
    public boolean selectPreviousArticle(int mode)
    {
        return selectPreviousArticle(selectedDisplay, mode);
    }

#No. 2095
#File: E:\bishe\1\AbstractFeedDisplay.java
#Comment:
    /**
     * Orders to select last article.
     *
     * @param mode mode of selection.
     *
     * @return <code>TRUE</code> if article has been selected.
     */

#Code:
    public boolean selectLastArticle(int mode)
    {
        boolean selected = selectPreviousArticle(null, mode);
        if (selected) ensureSelectedViewDisplayed();
        return selected;
    }

#No. 2096
#File: E:\bishe\1\AbstractFeedDisplay.java
#Comment:
    /**
     * Sets the feed which is required to be displayed.
     *
     * @param feed the feed.
     */

#Code:
    public void setFeed(IFeed feed)
    {
        selectDisplay(null, false, SelectionMode.SINGLE);
        model.setFeed(feed);
        updateSortingOrder();

        if (viewport != null)
        {
            if (viewport instanceof JumplessViewport) ((JumplessViewport)viewport).resetStoredPosition();
            scrollTo(new Rectangle(viewport.getWidth(), viewport.getHeight()));
        }
    }

#No. 2097
#File: E:\bishe\1\AbstractFeedDisplay.java
#Comment:
    /**
     * Returns currently selected text in currently selected article.
     *
     * @return text.
     */

#Code:
    public String getSelectedText()
    {
        return null;
    }

#No. 2098
#File: E:\bishe\1\AbstractFeedDisplay.java
#Comment:
    /**
     * Repaints all highlights in all visible articles.
     */

#Code:
    public void repaintHighlights()
    {
        Iterator it = new ArticleDisplayIterator();
        while (it.hasNext())
        {
            IArticleDisplay display = (IArticleDisplay)it.next();
            display.updateHighlights();
        }
    }

#No. 2099
#File: E:\bishe\1\AbstractFeedDisplay.java
#Comment:
    /**
     * Repaints all sentiments color codes.
     */

#Code:
    public void repaintSentimentsColorCodes()
    {
        Iterator it = new ArticleDisplayIterator();
        while (it.hasNext())
        {
            IArticleDisplay display = (IArticleDisplay)it.next();
            display.updateColorCode();
        }
    }

#No. 2100
#File: E:\bishe\1\AbstractFeedDisplay.java
#Comment:
    /**
     * Selects the next display after given.
     *
     * @param mode              mode of selection.
     * @param currentDisplay    currently selected display or <code>NULL</code>.
     *
     * @return <code>TRUE</code> if article has been selected.
     */

#Code:
    private boolean selectNextArticle(int mode, IArticleDisplay currentDisplay)
    {
        boolean selected = false;

        IArticleDisplay display = findNextDisplay(currentDisplay, mode);
        if (display != null)
        {
            selectDisplay(display, true, SelectionMode.SINGLE);
            selected = true;
        } else
        {
            // See if there are more pages
            int pages = model.getPagesCount();
            int page = model.getPage();
            if (page < pages - 1)
            {
                // Go to the next page and select the first article
                setPage(page + 1);
                selected = selectFirstArticle(mode);
            }
        }

        return selected;
    }

#No. 2101
#File: E:\bishe\1\AbstractFeedDisplay.java
#Comment:
    /**
     * Selects the previous display after given.
     *
     * @param mode              mode of selection.
     * @param currentDisplay    currently selected display or <code>NULL</code>.
     *
     * @return <code>TRUE</code> if article has been selected.
     */

#Code:
    private boolean selectPreviousArticle(IArticleDisplay currentDisplay, int mode)
    {
        boolean selected = false;

        IArticleDisplay display = findPrevDisplay(currentDisplay, mode);
        if (display != null)
        {
            selectDisplay(display, true, SelectionMode.SINGLE);
            selected = true;
        } else
        {
            // See if there are more pages before this one
            int page = model.getPage();
            if (page > 0)
            {
                // Go to the next page and select the first article
                setPage(page - 1);
                selected = selectLastArticle(mode);
            }
        }

        return selected;
    }

#No. 2102
#File: E:\bishe\1\AbstractFeedDisplay.java
#Comment:
    /**
     * Changes currently selected display. Depending on the mode of selection the result will
     * be different.
     * <p/>
     * For the {@link SelectionMode#RANGE} mode, articles between the {@link #selectedDisplay} and
     * this new display are selected inclusively and the {@link #selectedDisplay} is assigned
     * this new display.
     * <p/>
     * For the {@link SelectionMode#TOGGLE} mode, the article is toggled selected and makes it
     * in and out of the selected list. When the article is selected, it becomes the new
     * {@link #selectedDisplay}, when deselected the closest (if any) becomes.
     * <p/>
     * For the {@link SelectionMode#SINGLE} mode, the only article is selected and present in
     * the {@link #selectedDisplays} list.
     *
     * @param display       new display selection.
     * @param forceScroll   <code>TRUE</code> to force scrolling even when some link is hovered.
     * @param mode          mode of the article display selection.
     */

#Code:
    protected void selectDisplay(IArticleDisplay display, boolean forceScroll, SelectionMode mode)
    {
        boolean fireEvent = selectDisplayWithoutEvent(display, forceScroll, mode);

        if (fireEvent)
        {
            try
            {
                // Mark us as the source of the event
                articleSelectionSource = true;

                fireArticleSelected(getSelectedArticle(), getSelectedArticles());
            } finally
            {
                // Release the flag
                articleSelectionSource = false;
            }
        }
    }

#No. 2103
#File: E:\bishe\1\AbstractFeedDisplay.java
#Comment:
    /**
     * Returns all selected articles.
     *
     * @return articles.
     */

#Code:
    private IArticle[] getSelectedArticles()
    {
        IArticle[] articles = new IArticle[selectedDisplays.size()];

        int i = 0;
        for (IArticleDisplay display : selectedDisplays)
        {
            articles[i++] = display.getArticle();
        }

        return articles;
    }

#No. 2104
#File: E:\bishe\1\AbstractFeedDisplay.java
#Comment:
    /**
     * Finds index of the component.
     *
     * @param component component.
     *
     * @return index or <code>-1</code> if component wasn't found.
     */

#Code:
    private int indexOf(Component component)
    {
        int index = -1;

        Component[] components = getComponents();
        for (int i = 0; index == -1 && i < components.length; i++)
        {
            if (components[i] == component) index = i;
        }

        return index;
    }

#No. 2105
#File: E:\bishe\1\AbstractFeedDisplay.java
#Comment:
    /**
     * Finds next view with a properties fitting the mode.
     *
     * @param currentDisplay   current view.
     * @param aMode         mode.
     *
     * @return next view or <code>NULL</code>.
     *
     * @see com.salas.bb.views.INavigationModes#MODE_NORMAL
     * @see com.salas.bb.views.INavigationModes#MODE_UNREAD
     */

#Code:
    private IArticleDisplay findNextDisplay(IArticleDisplay currentDisplay, int aMode)
    {
        IArticleDisplay nextDisplay = null;

        int currentIndex = currentDisplay == null ? -1 : indexOf(currentDisplay.getComponent());
        for (int i = currentIndex + 1; nextDisplay == null && i < getComponentCount(); i++)
        {
            Component comp = getComponent(i);
            if (comp instanceof IArticleDisplay)
            {
                IArticleDisplay display = (IArticleDisplay)comp;
                if (display.getComponent().isVisible() &&
                    fitsMode(display.getArticle(), aMode))
                {
                    nextDisplay = display;
                }
            }
        }

        return nextDisplay;
    }

#No. 2106
#File: E:\bishe\1\AbstractFeedDisplay.java
#Comment:
    /**
     * Finds previous view with a properties fitting the mode.
     *
     * @param currentDisplay   current view.
     * @param aMode         mode.
     *
     * @return previous view or <code>NULL</code>.
     *
     * @see com.salas.bb.views.INavigationModes#MODE_NORMAL
     * @see com.salas.bb.views.INavigationModes#MODE_UNREAD
     */

#Code:
    private IArticleDisplay findPrevDisplay(IArticleDisplay currentDisplay, int aMode)
    {
        IArticleDisplay prevDisplay = null;

        int currentIndex = currentDisplay == null
            ? getComponentCount()
            : indexOf(currentDisplay.getComponent());

        for (int i = currentIndex - 1; prevDisplay == null && i >= 0; i--)
        {
            Component comp = getComponent(i);
            if (comp instanceof IArticleDisplay)
            {
                IArticleDisplay display = (IArticleDisplay)comp;
                if (display.getComponent().isVisible() &&
                    fitsMode(display.getArticle(), aMode))
                {
                    prevDisplay = (IArticleDisplay)comp;
                }
            }
        }

        return prevDisplay;
    }

#No. 2107
#File: E:\bishe\1\AbstractFeedDisplay.java
#Comment:
    /**
     * Called when model reports that there is no articles to display.
     */

#Code:
    private void onArticlesRemoved()
    {
        Component[] components = getComponents();
        for (Component component : components)
        {
            if (component instanceof ArticlesGroup)
            {
                ((ArticlesGroup)component).unregisterAll();
            } else if (component instanceof IArticleDisplay)
            {
                remove(component);

                IArticleDisplay display = ((IArticleDisplay)component);
                IArticle article = display.getArticle();
                article.removeListener(display.getArticleListener());
            }
        }
        updateNoContentPanel();

        // When page changes, we scroll to the top
        scrollToTop();
    }

#No. 2108
#File: E:\bishe\1\AbstractFeedDisplay.java
#Comment:
    /**
     * Called when model has another article added to some group.
     *
     * @param aArticle      added article.
     * @param aGroup        group the article was added to.
     * @param aIndexInGroup index in the group.
     */

#Code:
    private void onArticleAdded(IArticle aArticle, int aGroup, int aIndexInGroup)
    {
        updateNoContentPanel();

        IArticleDisplay display = createNewArticleDisplay(aArticle);
        display.addHyperlinkListener(new LinkListener());

        Component component = display.getComponent();
        component.setVisible(false);
        int index = getDisplayIndex(aGroup, aIndexInGroup);
        try
        {
            add(component, index);
            groups[aGroup].register(display);

            aArticle.addListener(display.getArticleListener());
        } catch (Exception e)
        {
            LOG.log(Level.SEVERE, "Failed to add article at: " + index +
                " (group=" + aGroup +
                ", ingroup=" + aIndexInGroup +
                ", groupIndex=" + indexOf(groups[aGroup]) +
                ", components=" + getComponentCount() + ")");
        }
    }

#No. 2109
#File: E:\bishe\1\AbstractFeedDisplay.java
#Comment:
    /**
     * Called when model has lost the article and it should no longer be displayed.
     *
     * @param aArticle      removed article.
     * @param aGroup        group it was.
     * @param aIndexInGroup index in group which was occupied with it.
     */

#Code:
    private void onArticleRemoved(IArticle aArticle, int aGroup, int aIndexInGroup)
    {
        IArticleDisplay display = findDisplay(aArticle, aGroup, aIndexInGroup);
        if (display == null) return;

        Component dispComponent = display.getComponent();
        boolean wasVisible = dispComponent.isVisible();
        dispComponent.setVisible(false);

        if (selectedDisplay != null)
        {
            if (selectedDisplay == display)
            {
                // TODO: we probably don't want to reset whole selection if the leading (or any other) display gets removed
                selectDisplay(null, false, SelectionMode.SINGLE);
            } else if (wasVisible)
            {
                Rectangle boundsDis = dispComponent.getBounds();
                Rectangle boundsView = viewport.getViewRect();

                int delta = boundsView.y - boundsDis.y;
                if (delta > 0)
                {
                    boundsView.y -= delta;
                    scrollTo(boundsView);
                }
            }
        }

        remove(dispComponent);
        groups[aGroup].unregister(display);

        aArticle.removeListener(display.getArticleListener());
        updateNoContentPanel();
    }

#No. 2110
#File: E:\bishe\1\AbstractFeedDisplay.java
#Comment:
    /**
     * Sets the hovered link.
     *
     * @param link link.
     */

#Code:
    private void setHoveredHyperLink(URL link)
    {
        if (hoveredLink == link) return;

        hoveredLink = link;
        fireLinkHovered(hoveredLink);
    }

#No. 2111
#File: E:\bishe\1\AbstractFeedDisplay.java
#Comment:
    /**
     * Sets the order of sorting. Default is descending (latest first).
     *
     * @param asc   <code>TRUE</code> for ascending order, <code>FALSE</code> for descending.
     */

#Code:
    public void setAscending(boolean asc)
    {
        model.setAscending(asc);

        // Change the name of groups after reverting the order
        for (int i = 0; i < groups.length; i++)
        {
            groups[i].setName(model.getGroupName(i));
        }
    }

#No. 2112
#File: E:\bishe\1\AbstractFeedDisplay.java
#Comment:
    /**
     * Scan through all displays and switch their collapse/expand statuses.
     *
     * @param aCollapsing collapse.
     */

#Code:
    protected void collapseAll(boolean aCollapsing)
    {
        if (model.getArticlesCount() > 0)
        {
            for (int i = 0; i < getComponentCount(); i++)
            {
                Component component = getComponent(i);
                if (component instanceof IArticleDisplay)
                {
                    IArticleDisplay display = (IArticleDisplay)component;
                    display.setCollapsed(aCollapsing);
                }
            }

            if (aCollapsing) requestFocus(); else requestFocusInWindow();
        }
    }

#No. 2113
#File: E:\bishe\1\AbstractFeedDisplay.java
#Comment:
    /**
     * Cycles view mode forward.
     */

#Code:
    public void cycleViewModeForward()
    {
        cycleViewMode(true, true);
    }

#No. 2114
#File: E:\bishe\1\AbstractFeedDisplay.java
#Comment:
    /**
     * Cycles view mode backward.
     */

#Code:
    public void cycleViewModeBackward()
    {
        cycleViewMode(true, false);
    }

#No. 2115
#File: E:\bishe\1\AbstractFeedDisplay.java
#Comment:
    /**
     * If there's display selected, collapses or expands it (switches).
     *
     * @param aCollapsing <code>TRUE</code> to collapse.
     */

#Code:
    protected void collapseSelected(boolean aCollapsing)
    {
        if (selectedDisplays.size() > 0)
        {
            for (IArticleDisplay display : selectedDisplays) display.setCollapsed(aCollapsing);
            if (aCollapsing) requestFocus(); else requestFocusInWindow();
        }
    }

#No. 2116
#File: E:\bishe\1\AbstractFeedDisplay.java
#Comment:
    /**
     * Updates settings of all groups.
     */

#Code:
    private void updateGroupsSettings()
    {
        for (ArticlesGroup group : groups)
        {
            group.setCanBeVisible(config.showGroups());
            group.setVisibleIfEmpty(config.showEmptyGroups());
        }

        updateNoContentPanel();
    }

#No. 2117
#File: E:\bishe\1\AbstractFeedDisplay.java
#Comment:
    /**
     * Scrolls to make rectangle visible.
     *
     * @param rect rectangle.
     */

#Code:
    private void scrollTo(final Rectangle rect)
    {
        Container parent = getParent();
        if (parent != null && parent instanceof IScrollContoller)
        {
            ((IScrollContoller)parent).scrollTo(rect);
        } else scrollRectToVisible(rect);
    }

#No. 2118
#File: E:\bishe\1\AbstractFeedDisplay.java
#Comment:
    /**
     * Returns index of article which is inside the group at specified index.
     *
     * @param aGroup        group index.
     * @param aIndexInGroup index within the group.
     *
     * @return article index.
     */

#Code:
    private int getDisplayIndex(int aGroup, int aIndexInGroup)
    {
        return indexOf(groups[aGroup]) + aIndexInGroup + 1;
    }

#No. 2119
#File: E:\bishe\1\AbstractFeedDisplay.java
#Comment:
    /**
     * Returns selected article.
     *
     * @return selected article or <code>NULL</code>.
     */

#Code:
    private IArticle getSelectedArticle()
    {
        return selectedDisplay == null ? null : selectedDisplay.getArticle();
    }

#No. 2120
#File: E:\bishe\1\AbstractFeedDisplay.java
#Comment:
    /**
     * Returns <code>TRUE</code> if article fits conditions of the mode.
     *
     * @param aArticle  article.
     * @param aMode     mode.
     *
     * @return <code>TRUE</code> if article fits conditions of the mode.
     *
     * @see com.salas.bb.views.INavigationModes#MODE_NORMAL
     * @see com.salas.bb.views.INavigationModes#MODE_UNREAD
     */

#Code:
    private boolean fitsMode(IArticle aArticle, int aMode)
    {
        return aMode == INavigationModes.MODE_NORMAL ||
            (aMode == INavigationModes.MODE_UNREAD && !aArticle.isRead());
    }

#No. 2121
#File: E:\bishe\1\AbstractFeedDisplay.java
#Comment:
    /**
     * Orders view to select and show article if it can be visible.
     *
     * @param article article to select.
     */

#Code:
    public void selectArticle(IArticle article)
    {
        int newPage = model.ensureArticleVisibility(article);
        if (newPage != -1) pageModel.setValue(newPage);
        
        final IArticleDisplay display = findArticleDisplay(article);
        if (display != null)
        {
            SwingUtilities.invokeLater(new Runnable()
            {
                public void run()
                {
                    selectDisplayWithoutEvent(display, true, SelectionMode.SINGLE);
                }
            });
        }
    }

#No. 2122
#File: E:\bishe\1\AbstractFeedDisplay.java
#Comment:
    /**
     * Repaints article text if is currently in the given mode.
     *
     * @param briefMode <code>TRUE</code> for brief mode, otherwise -- full mode.
     */

#Code:
    public void repaintIfInMode(boolean briefMode)
    {
        // Does nothing by default
    }

#No. 2123
#File: E:\bishe\1\AbstractFeedDisplay.java
#Comment:
    /**
     * Model listener.
     */

#Code:
    private class ModelListener implements IFeedDisplayModelListener
    {
        /** Invoked when all articles removed from the model as result of feeds change. */
        public void articlesRemoved()
        {
            onArticlesRemoved();
        }

        /**
         * Invoked when model receives the event about new article addition.
         *
         * @param article      new article.
         * @param group        group index this article was assigned to.
         * @param indexInGroup index inside the group.
         */
        public void articleAdded(IArticle article, int group, int indexInGroup)
        {
            onArticleAdded(article, group, indexInGroup);
        }

        /**
         * Invoked when model receives the event about article removal.
         *
         * @param article      deleted article.
         * @param group        group index this article was assigned to.
         * @param indexInGroup index inside the group.
         */
        public void articleRemoved(IArticle article, int group, int indexInGroup)
        {
            onArticleRemoved(article, group, indexInGroup);
        }
    }

#No. 2124
#File: E:\bishe\1\AbstractFeedDisplay.java
#Comment:
    /**
     * Returns the component the user clicked on.
     *
     * @param e event.
     *
     * @return component.
     */

#Code:
    protected Object getComponentForMouseEvent(MouseEvent e)
    {
        return e.getSource();
    }

#No. 2125
#File: E:\bishe\1\AbstractFeedFetcher.java
#Comment:
    /**
     * @return the User-Agent currently being sent to servers
     */

#Code:
    @Override
    public synchronized String getUserAgent() {
        return userAgent;
    }

#No. 2126
#File: E:\bishe\1\AbstractFeedFetcher.java
#Comment:
    /**
     * @param string The User-Agent to sent to servers
     */

#Code:
    @Override
    public synchronized void setUserAgent(final String string) {
        userAgent = string;
    }

#No. 2127
#File: E:\bishe\1\AbstractFeedFetcher.java
#Comment:
    /**
     * @param eventType The event type to fire
     * @param connection the current connection
     */

#Code:
    protected void fireEvent(final String eventType, final URLConnection connection) {
        fireEvent(eventType, connection.getURL().toExternalForm(), null);
    }

#No. 2128
#File: E:\bishe\1\AbstractFeedFetcher.java
#Comment:
    /**
     * @param eventType The event type to fire
     * @param connection the current connection
     * @param feed The feed to pass to the event
     */

#Code:
    protected void fireEvent(final String eventType, final URLConnection connection, final SyndFeed feed) {
        fireEvent(eventType, connection.getURL().toExternalForm(), feed);
    }

#No. 2129
#File: E:\bishe\1\AbstractFeedFetcher.java
#Comment:
    /**
     * @param eventType The event type to fire
     * @param urlStr the current url as a string
     */

#Code:
    protected void fireEvent(final String eventType, final String urlStr) {
        fireEvent(eventType, urlStr, null);
    }

#No. 2130
#File: E:\bishe\1\AbstractFeedFetcher.java
#Comment:
    /**
     * @param eventType The event type to fire
     * @param urlStr the current url as a string
     * @param feed The feed to pass to the event
     */

#Code:
    protected void fireEvent(final String eventType, final String urlStr, final SyndFeed feed) {
        final FetcherEvent fetcherEvent = new FetcherEvent(this, urlStr, eventType, feed);
        synchronized (listeners) {
            for (final FetcherListener fetcherEventListener : listeners) {
                fetcherEventListener.fetcherEvent(fetcherEvent);
            }
        }
    }

#No. 2131
#File: E:\bishe\1\AbstractFeedFetcher.java
#Comment:
    /**
     * @return Returns the useDeltaEncoding.
     */

#Code:
    @Override
    public synchronized boolean isUsingDeltaEncoding() {
        return usingDeltaEncoding;
    }

#No. 2132
#File: E:\bishe\1\AbstractFeedFetcher.java
#Comment:
    /**
     * @param useDeltaEncoding The useDeltaEncoding to set.
     */

#Code:
    @Override
    public synchronized void setUsingDeltaEncoding(final boolean useDeltaEncoding) {
        usingDeltaEncoding = useDeltaEncoding;
    }

#No. 2133
#File: E:\bishe\1\AbstractFeedFetcher.java
#Comment:
    /**
     * <p>
     * Handles HTTP error codes.
     * </p>
     *
     * @param responseCode the HTTP response code
     * @throws FetcherException if response code is in the range 400 to 599 inclusive
     */

#Code:
    protected void handleErrorCodes(final int responseCode) throws FetcherException {
        // Handle 2xx codes as OK, so ignore them here
        // 3xx codes are handled by the HttpURLConnection class
        if (responseCode == 403) {
            // Authentication is required
            throwAuthenticationError(responseCode);
        } else if (responseCode >= 400 && responseCode < 500) {
            throw4XXError(responseCode);
        } else if (responseCode >= 500 && responseCode < 600) {
            throw new FetcherException(responseCode, "The server encounted an error. HTTP Response code was:" + responseCode);
        }
    }

#No. 2134
#File: E:\bishe\1\AbstractFeedFetcher.java
#Comment:
    /**
     * <p>
     * Combine the entries in two feeds into a single feed.
     * </p>
     *
     * <p>
     * The returned feed will have the same data as the newFeed parameter, with the entries from
     * originalFeed appended to the end of its entries.
     * </p>
     *
     * @param originalFeed
     * @param newFeed
     * @return
     */

#Code:
    public static SyndFeed combineFeeds(final SyndFeed originalFeed, final SyndFeed newFeed) {
        try {
            final SyndFeed result = (SyndFeed) newFeed.clone();
            result.getEntries().addAll(result.getEntries().size(), originalFeed.getEntries());
            return result;
        } catch (final CloneNotSupportedException e) {
            final IllegalArgumentException iae = new IllegalArgumentException("Cannot clone feed");
            iae.initCause(e);
            throw iae;
        }
    }

#No. 2135
#File: E:\bishe\1\AbstractFeedProvider.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public String getType() {
        return TYPE;
    }

#No. 2136
#File: E:\bishe\1\AbstractFgInferencer.java
#Comment:
    /** @inheritDoc
     */

#Code:
    @Override
    public VarTensor getMarginals(Var var) {
        VarTensor marg = getVarBeliefs(var);
        marg = ensureRealSemiring(marg);
        return marg;
    }

#No. 2137
#File: E:\bishe\1\AbstractFgInferencer.java
#Comment:
    /** @inheritDoc
     */

#Code:
    @Override
    public VarTensor getMarginals(Factor factor) {
        VarTensor marg = getFactorBeliefs(factor);
        marg = ensureRealSemiring(marg);
        return marg;
    }    

#No. 2138
#File: E:\bishe\1\AbstractFgInferencer.java
#Comment:
    /** @inheritDoc
     */

#Code:
    @Override
    public VarTensor getLogMarginals(Var var) {
        VarTensor marg = getVarBeliefs(var);
        marg = ensureLogSemiring(marg);
        return marg;
    }

#No. 2139
#File: E:\bishe\1\AbstractFgInferencer.java
#Comment:
    /** @inheritDoc
     */

#Code:
    @Override
    public VarTensor getLogMarginals(Factor factor) {
        VarTensor marg = getFactorBeliefs(factor);
        marg = ensureLogSemiring(marg);
        return marg;
    }

#No. 2140
#File: E:\bishe\1\AbstractFibonacci.java
#Comment:
	/**
	 * @return the k'th Fibonacci number.
	 * @throws IllegalArgumentException if {@code k < 0}.
	 */

#Code:
	public int get(int k)
	{
		if (k < 0) throw new IllegalArgumentException("Invalid: "+k);

		switch (k)
		{
			//Base cases of Fibonacci sequence
			case 0 : return 0;
			case 1 : return 1;
			
			default: return get2p(k);
		}
	}

#No. 2141
#File: E:\bishe\1\AbstractFieldAndDescriptorMatcher.java
#Comment:
    /**
     * A map of field matchers, keyed by enums representing the field to match against.
     *
     * The enums need to have an ordinal number matching their field order position within
     * the frame in the AMQP spec, and should be named according to the spec.
     *
     * @return the map of matchers
     */

#Code:
    public Map<Enum<?>, Matcher<?>> getMatchers() {
        return fieldMatchers;
    }

#No. 2142
#File: E:\bishe\1\AbstractFieldAndDescriptorMatcher.java
#Comment:
    /**
     * Returns the received values, keyed by enums representing the field.
     *
     * The enums have an ordinal number matching their field order position within
     * the frame in the AMQP spec, and are named according to the spec.
     *
     * @return the map of received values
     */

#Code:
    protected Map<Enum<?>, Object> getReceivedFields() {
        return receivedFields;
    }

#No. 2143
#File: E:\bishe\1\AbstractFieldAndDescriptorMatcher.java
#Comment:
    /**
     * Verifies the fields of the provided list against any matchers registered.
     * @param described the list of fields from the described type.
     * @throws AssertionError if a registered matcher assertion is not met.
     */

#Code:
    public final void verifyFields(List<Object> described) throws AssertionError {
        int fieldNumber = 0;
        HashMap<Enum<?>, Object> valueMap = new LinkedHashMap<>();
        for (Object value : described) {
            valueMap.put(getField(fieldNumber++), value);
        }

        receivedFields = valueMap;

        _logger.debug("About to check the fields of the described type." + "\n  Received:" + valueMap + "\n  Expectations: " + fieldMatchers);
        for (Map.Entry<Enum<?>, Matcher<?>> entry : fieldMatchers.entrySet()) {
            @SuppressWarnings("unchecked")
            Matcher<Object> matcher = (Matcher<Object>) entry.getValue();
            Enum<?> field = entry.getKey();
            assertThat("Field " + field + " value should match", valueMap.get(field), matcher);
        }
    }

#No. 2144
#File: E:\bishe\1\AbstractFieldAndDescriptorMatcher.java
#Comment:
    /**
     * Intended to be overridden in most cases (but not necessarily all - hence not marked as abstract)
     */

#Code:
    protected Enum<?> getField(int fieldIndex) {
        throw new UnsupportedOperationException("getField is expected to be overridden by subclass if it is required");
    }

#No. 2145
#File: E:\bishe\1\AbstractFields.java
#Comment:
	/**
	 * Persists all Settable fields to the browser
	 */

#Code:
	public void persist() {
		for ( ISettable<?> field: fields ) {
			if ( field.hasValue() ) {
				field.setWebValue();
			}
		}
	}

#No. 2146
#File: E:\bishe\1\AbstractFile2Tmx.java
#Comment:
	/**
	 * Update by Yule 2013-8-23 添加进度参数
	 * @param file2TmxBean
	 * @param monitor
	 *         :monitor的开始 ，进度控制 ，结束都在方法内部完成。是一个子任务<br/>
	 *         ： 注意任务取消得情况
	 * @throws Exception ;
	 */

#Code:
	public abstract void doCovnerter(net.heartsome.cat.te.core.bean.File2TmxConvertBean file2TmxBean,IProgressMonitor monitor) throws Exception;
	
}
}

#No. 2147
#File: E:\bishe\1\AbstractFileComponent.java
#Comment:
	/**
	 * @return The {@link #contentHash} as a String.
	 */

#Code:
	@Override
	public final String getContentHash() {
		return contentHash;
	}

#No. 2148
#File: E:\bishe\1\AbstractFileComponent.java
#Comment:
	/**
	 * Sets the {@link #contentHash}. This is only public because it
	 * has to be used in the {@link org.peerbox.watchservice.filetree.
	 * persistency.LocalFileDao FileDao} class. Be aware that this method
	 * should not be used to set the {@link #contentHash} to arbitrary
	 * values.
	 */

#Code:
	protected final void setContentHash(final String contentHash) {
		this.contentHash = contentHash;
	}

#No. 2149
#File: E:\bishe\1\AbstractFileComponent.java
#Comment:
	/**
	 * Updates the {@link #contentHash} recursively, i.e. first on
	 * the object it is called, and then on ascending {@link org.
	 * peerbox.watchservice.filetree.composite.FolderComposite
	 * FolderComposite}s in case it changed. If there was no change,
	 * the handling concludes silently.
	 *
	 * @return True if the {@link #contentHash} changed.
	 */

#Code:
	@Override
	public final boolean updateContentHash() {
		boolean hasChanged = computeContentHash();
		if (hasChanged && getParent() != null) {
			getParent().updateContentHash();
		}
		return hasChanged;
	}

#No. 2150
#File: E:\bishe\1\AbstractFileComponent.java
#Comment:
	/**
	 * @return True if it is a folder {@link org.peerbox.watchservice.filetree.
	 * composite.FolderComposite FolderComposite)
	 */

#Code:
	@Override
	public final boolean isFolder() {
		return !isFile();
	}

#No. 2151
#File: E:\bishe\1\AbstractFileContentTransformerWorker.java
#Comment:
    /**
     * Creates a target content references using the targetContentReferenceHandler
     * 
     * @param mediaType
     * @return the target content reference
     */

#Code:
    protected ContentReference createTargetContentReference(String mediaType)
    {
        String filename = this.getClass().getSimpleName() + "-target-" + 
                UUID.randomUUID().toString() + "." + FileMediaType.SERVICE.getExtension(mediaType);
        
        return targetContentReferenceHandler.createContentReference(filename, mediaType);
    }

#No. 2152
#File: E:\bishe\1\AbstractFileContentTransformerWorker.java
#Comment:
    /**
     * Wrapper for a content reference and a {@link File}, useful
     * for passing around an already instantiated File object with
     * a related content reference.
     */

#Code:
    protected class FileContentReferencePair
    {
        private File file;
        private ContentReference contentReference;
        
        public FileContentReferencePair(File file, ContentReference contentReference)
        {
            super();
            this.file = file;
            this.contentReference = contentReference;
        }
        
        public File getFile()
        {
            return file;
        }
        public void setFile(File file)
        {
            this.file = file;
        }
        public ContentReference getContentReference()
        {
            return contentReference;
        }
        public void setContentReference(ContentReference contentReference)
        {
            this.contentReference = contentReference;
        }
    }

#No. 2153
#File: E:\bishe\1\AbstractFileDigester.java
#Comment:
/**
 * Base class for implementations of {@link FileDigester}.
 *
 * @author <a href="mailto:julien.nicoulaud@gmail.com">Julien Nicoulaud</a>
 * @since 1.0
 */

#Code:
public abstract class AbstractFileDigester
    implements FileDigester
{
    /**
     * The algorithm used to compute checksum digests.
     */
    protected final String algorithm;

    /**
     * Build a new instance of {@link AbstractFileDigester}.
     *
     * @param algorithm the algorithm used to compute checksum digests.
     */
    protected AbstractFileDigester( String algorithm )
    {
        this.algorithm = algorithm;
    }

    /**
     * {@inheritDoc}
     */
    public String getAlgorithm()
    {
        return algorithm;
    }

    /**
     * {@inheritDoc}
     */
    public String getFileExtension()
    {
        return "." + algorithm.toLowerCase().replace( "-", "" );
    }
}

#No. 2154
#File: E:\bishe\1\AbstractFileFormat.java
#Comment:
   /**
    * Generate an ordered set of column definitions from an ordered set of column names.
    *
    * @param columns column definitions
    * @param order column names
    * @return ordered set of column definitions
    */

#Code:
   private ColumnDefinition[] columnDefinitions(ColumnDefinition[] columns, String[] order)
   {
      Map<String, ColumnDefinition> map = makeColumnMap(columns);
      ColumnDefinition[] result = new ColumnDefinition[order.length];
      for (int index = 0; index < order.length; index++)
      {
         result[index] = map.get(order[index]);
      }
      return result;
   }

#No. 2155
#File: E:\bishe\1\AbstractFileFormat.java
#Comment:
   /**
    * Convert an array of column definitions into a map keyed by column name.
    *
    * @param columns array of column definitions
    * @return map of column definitions
    */

#Code:
   private Map<String, ColumnDefinition> makeColumnMap(ColumnDefinition[] columns)
   {
      Map<String, ColumnDefinition> map = new HashMap<String, ColumnDefinition>();
      for (ColumnDefinition def : columns)
      {
         map.put(def.getName(), def);
      }
      return map;
   }

#No. 2156
#File: E:\bishe\1\AbstractFileHeaderMojo.java
#Comment:
    /**
     * Checks the results of the mojo execution using the {@link #isFailOnMissingHeader()} and
     * {@link #isFailOnNotUptodateHeader()}.
     *
     * @param result processed files by their status
     * @throws MojoFailureException if check is not ok (some file with no header or to update)
     */

#Code:
    private void checkResults( EnumMap<FileState, Set<File>> result ) throws MojoFailureException
    {
        Set<FileState> states = result.keySet();

        StringBuilder builder = new StringBuilder();
        if ( isDryRun() && isFailOnMissingHeader() && states.contains( FileState.add ) )
        {
            List<File> files = FileUtil.orderFiles( result.get( FileState.add ) );

            builder.append( "There are " ).append( files.size() ).append( " file(s) with no header :" );
            for ( File file : files )
            {
                builder.append( "\n" ).append( file );
            }
        }

        if ( isDryRun() && isFailOnNotUptodateHeader() && states.contains( FileState.update ) )
        {
            List<File> files = FileUtil.orderFiles( result.get( FileState.update ) );

            builder.append( "\nThere are " ).append( files.size() ).append( " file(s) with header to update:" );
            for ( File file : files )
            {
                builder.append( "\n" ).append( file );
            }
        }
        String message = builder.toString();

        if ( StringUtils.isNotBlank( message ) )
        {
            throw new MojoFailureException( builder.toString() );
        }
    }

#No. 2157
#File: E:\bishe\1\AbstractFileHeaderMojo.java
#Comment:
    /**
     * Process a given comment style to all his detected files.
     *
     * @param commentStyle comment style to treat
     * @param filesToTreat files using this comment style to treat
     * @throws IOException if any IO error while processing files
     */

#Code:
    private void processCommentStyle( String commentStyle, List<File> filesToTreat ) throws IOException
    {

        // obtain license from definition
        License license = getLicense( getLicenseName(), true );

        if ( isVerbose() )
        {
            getLog().info( "Process header '" + commentStyle + "'" );
            getLog().info( " - using " + license.getDescription() );
        }

        // use header transformer according to comment style given in header
        FileHeaderTransformer transformer = getTransformer( transformers, commentStyle );
        FileHeaderProcessor processor = getFileHeaderProcessor( license, transformer );


        for ( File file : filesToTreat )
        {
            processFile( processor, file );
        }
        filesToTreat.clear();
    }

#No. 2158
#File: E:\bishe\1\AbstractFileHeaderMojo.java
#Comment:
    /**
     * Process the given file (will copy it, process the clone file and finally finalizeFile after process)...
     *
     * @param processor current file processor
     * @param file      original file to process
     * @throws IOException if any IO error while processing this file
     */

#Code:
    private void processFile( FileHeaderProcessor processor, File file ) throws IOException
    {

        if ( processedFiles.contains( file ) )
        {
            getLog().info( " - skip already processed file " + file );
            return;
        }

        // output file
        File processFile = new File( file.getAbsolutePath() + "_" + timestamp );
        boolean doFinalize = false;
        try
        {
            doFinalize = processFile( processor, file, processFile );
        }
        catch ( Exception e )
        {
            getLog().warn( "skip failed file : " + e.getMessage() +
                                   ( e.getCause() == null ? "" : " Cause : " + e.getCause().getMessage() ), e );
            FileState.fail.addFile( file, result );
            doFinalize = false;
        }
        finally
        {

            // whatever was the result, this file is treated.
            processedFiles.add( file );

            if ( doFinalize )
            {
                finalizeFile( file, processFile );
            }
            else
            {
                FileUtil.deleteFile( processFile );
            }
        }
    }

#No. 2159
#File: E:\bishe\1\AbstractFileName.java
#Comment:
    /**
     * Returns the base name of the file.
     * @return The base name of the file.
     */

#Code:
    @Override
    public String getBaseName()
    {
        if (baseName == null)
        {
            final int idx = getPath().lastIndexOf(SEPARATOR_CHAR);
            if (idx == -1)
            {
                baseName = getPath();
            }
            else
            {
                baseName = getPath().substring(idx + 1);
            }
        }

        return baseName;
    }

#No. 2160
#File: E:\bishe\1\AbstractFileName.java
#Comment:
    /**
     * Returns the absolute path of the file, relative to the root of the
     * file system that the file belongs to.
     * @return The path String.
     */

#Code:
    @Override
    public String getPath()
    {
        if (VFS.isUriStyle())
        {
            return absPath + getUriTrailer();
        }
        return absPath;
    }

#No. 2161
#File: E:\bishe\1\AbstractFileName.java
#Comment:
    /**
     * Returns the decoded path.
     * @return The decoded path String.
     * @throws FileSystemException If an error occurs.
     */

#Code:
    @Override
    public String getPathDecoded() throws FileSystemException
    {
        if (decodedAbsPath == null)
        {
            decodedAbsPath = UriParser.decode(getPath());
        }

        return decodedAbsPath;
    }

#No. 2162
#File: E:\bishe\1\AbstractFileName.java
#Comment:
    /**
     * Returns the name of the parent of the file.
     * @return the FileName of the parent.
     */

#Code:
    @Override
    public FileName getParent()
    {
        final String parentPath;
        final int idx = getPath().lastIndexOf(SEPARATOR_CHAR);
        if (idx == -1 || idx == getPath().length() - 1)
        {
            // No parent
            return null;
        }
        else if (idx == 0)
        {
            // Root is the parent
            parentPath = SEPARATOR;
        }
        else
        {
            parentPath = getPath().substring(0, idx);
        }
        return createName(parentPath, FileType.FOLDER);
    }

#No. 2163
#File: E:\bishe\1\AbstractFileName.java
#Comment:
    /**
     * find the root of the filesystem.
     * @return The root FileName.
     */

#Code:
    @Override
    public FileName getRoot()
    {
        FileName root = this;
        while (root.getParent() != null)
        {
            root = root.getParent();
        }

        return root;
    }

#No. 2164
#File: E:\bishe\1\AbstractFileName.java
#Comment:
    /**
     * Returns the URI scheme of this file.
     * @return The protocol used to access the file.
     */

#Code:
    @Override
    public String getScheme()
    {
        return scheme;
    }

#No. 2165
#File: E:\bishe\1\AbstractFileName.java
#Comment:
    /**
     * Returns the absolute URI of the file.
     * @return The absolute URI of the file.
     */

#Code:
    @Override
    public String getURI()
    {
        if (uri == null)
        {
            uri = createURI();
        }
        return uri;
    }

#No. 2166
#File: E:\bishe\1\AbstractFileName.java
#Comment:
    /**
     * Create a path that does not use the FileType since that field is not immutable.
     * @return The key.
     */

#Code:
    private String getKey()
    {
        if (key == null)
        {
            key = getURI();
        }
        return key;
    }

#No. 2167
#File: E:\bishe\1\AbstractFileName.java
#Comment:
    /**
     * Returns the URI without a password.
     *
     * @return Returns the URI without a password.
     */

#Code:
    @Override
    public String getFriendlyURI()
    {
        return createURI(false, false);
    }

#No. 2168
#File: E:\bishe\1\AbstractFileName.java
#Comment:
    /**
     * Returns the root URI of the file system this file belongs to.
     * @return The URI of the root.
     */

#Code:
    @Override
    public String getRootURI()
    {
        if (rootUri == null)
        {
            final StringBuilder buffer = new StringBuilder();
            appendRootUri(buffer, true);
            buffer.append(SEPARATOR_CHAR);
            rootUri = buffer.toString().intern();
        }
        return rootUri;
    }

#No. 2169
#File: E:\bishe\1\AbstractFileName.java
#Comment:
    /**
     * Returns the depth of this file name, within its file system.
     * @return The depth of the file name.
     */

#Code:
    @Override
    public int getDepth()
    {
        final int len = getPath().length();
        if (len == 0 || len == 1 && getPath().charAt(0) == SEPARATOR_CHAR)
        {
            return 0;
        }
        int depth = 1;
        for (int pos = 0; pos > -1 && pos < len; depth++)
        {
            pos = getPath().indexOf(SEPARATOR_CHAR, pos + 1);
        }
        return depth;
    }

#No. 2170
#File: E:\bishe\1\AbstractFileName.java
#Comment:
    /**
     * Returns the extension of this file name.
     * @return The file extension.
     */

#Code:
    @Override
    public String getExtension()
    {
        if (extension == null)
        {
            getBaseName();
            final int pos = baseName.lastIndexOf('.');
            // if ((pos == -1) || (pos == baseName.length() - 1))
            // imario@ops.co.at: Review of patch from adagoubard@chello.nl
            // do not treat filenames like
            // .bashrc c:\windows\.java c:\windows\.javaws c:\windows\.jedit c:\windows\.appletviewer
            // as extension
            if (pos < 1 || pos == baseName.length() - 1)
            {
                // No extension
                extension = "";
            }
            else
            {
                extension = baseName.substring(pos + 1).intern();
            }
        }
        return extension;
    }

#No. 2171
#File: E:\bishe\1\AbstractFileName.java
#Comment:
    /**
     * Determines if another file name is an ancestor of this file name.
     * @param ancestor The FileName to check.
     * @return true if the FileName is an ancestor, false otherwise.
     */

#Code:
    @Override
    public boolean isAncestor(final FileName ancestor)
    {
        if (!ancestor.getRootURI().equals(getRootURI()))
        {
            return false;
        }
        return checkName(ancestor.getPath(), getPath(), NameScope.DESCENDENT);
    }

#No. 2172
#File: E:\bishe\1\AbstractFileName.java
#Comment:
    /**
     * Determines if another file name is a descendent of this file name.
     * @param descendent The FileName to check.
     * @return true if the FileName is a descendent, false otherwise.
     */

#Code:
    @Override
    public boolean isDescendent(final FileName descendent)
    {
        return isDescendent(descendent, NameScope.DESCENDENT);
    }

#No. 2173
#File: E:\bishe\1\AbstractFileName.java
#Comment:
    /**
     * Determines if another file name is a descendent of this file name.
     * @param descendent The FileName to check.
     * @param scope The NameScope.
     * @return true if the FileName is a descendent, false otherwise.
     */

#Code:
    @Override
    public boolean isDescendent(final FileName descendent,
                                final NameScope scope)
    {
        if (!descendent.getRootURI().equals(getRootURI()))
        {
            return false;
        }
        return checkName(getPath(), descendent.getPath(), scope);
    }

#No. 2174
#File: E:\bishe\1\AbstractFileName.java
#Comment:
    /**
     * Checks if this file name is a name for a regular file by using its type.
     *
     * @return true if this file is a regular file.
     * @throws FileSystemException may be thrown by subclasses.
     * @see #getType()
     * @see FileType#FILE
     */

#Code:
    @Override
    public boolean isFile() throws FileSystemException
    {
        // Use equals instead of == to avoid any class loader worries.
        return FileType.FILE.equals(this.getType());
    }

#No. 2175
#File: E:\bishe\1\AbstractFileName.java
#Comment:
    /**
     * Returns the requested or current type of this name.
     * <p>
     * The "requested" type is the one determined during resolving the name.
     *  n this case the name is a {@link FileType#FOLDER} if it ends with an "/" else
     * it will be a {@link FileType#FILE}.
     * <p>
     * Once attached it will be changed to reflect the real type of this resource.
     *
     * @return {@link FileType#FOLDER} or {@link FileType#FILE}
     */

#Code:
    @Override
    public FileType getType()
    {
        return type;
    }

#No. 2176
#File: E:\bishe\1\AbstractFileName.java
#Comment:
    /**
     * Sets the type of this file e.g. when it will be attached.
     *
     * @param type {@link FileType#FOLDER} or {@link FileType#FILE}
     * @throws FileSystemException if an error occurs.
     */

#Code:
    void setType(final FileType type) throws FileSystemException
    {
        if (type != FileType.FOLDER && type != FileType.FILE && type != FileType.FILE_OR_FOLDER)
        {
            throw new FileSystemException("vfs.provider/filename-type.error");
        }

        this.type = type;
    }

#No. 2177
#File: E:\bishe\1\AbstractFileNameBuilder.java
#Comment:
    /**
     * @return built file name
     */

#Code:
    public abstract String build();

    /**
     * Clears a builder.
     *
     * @return this
     */
    public abstract AbstractFileNameBuilder clear();
}
#No. 2178
#File: E:\bishe\1\AbstractFileObject.java
#Comment:
    /**
     * Returns the last modified time of this file.  Is only called if
     * {@link #doGetType} does not return {@link FileType#IMAGINARY}.
     * <p>
     * This implementation throws an exception.
     *
     * @return The last modification time.
     * @throws Exception if an error occurs.
     */

#Code:
    protected long doGetLastModifiedTime() throws Exception
    {
        throw new FileSystemException("vfs.provider/get-last-modified-not-supported.error");
    }

#No. 2179
#File: E:\bishe\1\AbstractFileObject.java
#Comment:
    /**
     * Creates an output stream to write the file content to.  Is only
     * called if:
     * <ul>
     * <li>{@link #doIsWriteable} returns true.
     * <li>{@link #doGetType} returns {@link FileType#FILE}, or
     * {@link #doGetType} returns {@link FileType#IMAGINARY}, and the file's
     * parent exists and is a folder.
     * </ul>
     * It is guaranteed that there are no open stream (input or output) for
     * this file when this method is called.
     * <p>
     * The returned stream does not have to be buffered.
     * <p>
     * This implementation throws an exception.
     *
     * @param bAppend true if the file should be appended to, false if it should be overwritten.
     * @return An OutputStream to write to the file.
     * @throws Exception if an error occurs.
     */

#Code:
    protected OutputStream doGetOutputStream(final boolean bAppend) throws Exception
    {
        throw new FileSystemException("vfs.provider/write-not-supported.error");
    }

#No. 2180
#File: E:\bishe\1\AbstractFileObject.java
#Comment:
    /**
     * Creates access to the file for random i/o.  Is only called
     * if {@link #doGetType} returns {@link FileType#FILE}.
     * <p>
     * It is guaranteed that there are no open output streams for this file
     * when this method is called.
     *
     * @param mode The mode to access the file.
     * @return The RandomAccessContext.
     * @throws Exception if an error occurs.
     */

#Code:
    protected RandomAccessContent doGetRandomAccessContent(final RandomAccessMode mode) throws Exception
    {
        throw new FileSystemException("vfs.provider/random-access-not-supported.error");
    }

#No. 2181
#File: E:\bishe\1\AbstractFileObject.java
#Comment:
    /**
     * Determines if this file is executable.  Is only called if {@link #doGetType}
     * does not return {@link FileType#IMAGINARY}.
     * <p>
     * This implementation always returns false.
     *
     * @return true if the file is executable, false otherwise.
     * @throws Exception if an error occurs.
     */

#Code:
    protected boolean doIsExecutable() throws Exception
    {
        return false;
    }

#No. 2182
#File: E:\bishe\1\AbstractFileObject.java
#Comment:
    /**
     * Determines if this file is hidden.  Is only called if {@link #doGetType}
     * does not return {@link FileType#IMAGINARY}.
     * <p>
     * This implementation always returns false.
     *
     * @return true if the file is hidden, false otherwise.
     * @throws Exception if an error occurs.
     */

#Code:
    protected boolean doIsHidden() throws Exception
    {
        return false;
    }

#No. 2183
#File: E:\bishe\1\AbstractFileObject.java
#Comment:
    /**
     * Determines if this file can be read.  Is only called if {@link #doGetType}
     * does not return {@link FileType#IMAGINARY}.
     * <p>
     * This implementation always returns true.
     *
     * @return true if the file is readable, false otherwise.
     * @throws Exception if an error occurs.
     */

#Code:
    protected boolean doIsReadable() throws Exception
    {
        return true;
    }

#No. 2184
#File: E:\bishe\1\AbstractFileObject.java
#Comment:
    /**
     * Checks if this fileObject is the same file as {@code destFile} just with a different
     * name. E.g. for case insensitive filesystems like windows.
     *
     * @param destFile The file to compare to.
     * @return true if the FileObjects are the same.
     * @throws FileSystemException if an error occurs.
     */

#Code:
    protected boolean doIsSameFile(final FileObject destFile) throws FileSystemException
    {
        return false;
    }

#No. 2185
#File: E:\bishe\1\AbstractFileObject.java
#Comment:
    /**
     * Determines if this file can be written to.  Is only called if
     * {@link #doGetType} does not return {@link FileType#IMAGINARY}.
     * <p>
     * This implementation always returns true.
     *
     * @return true if the file is writable.
     * @throws Exception if an error occurs.
     */

#Code:
    protected boolean doIsWriteable() throws Exception
    {
        return true;
    }

#No. 2186
#File: E:\bishe\1\AbstractFileObject.java
#Comment:
    /**
     * Lists the children of this file.
     * <p>
     * Is only called if {@link #doGetType} returns {@link FileType#FOLDER}.
     * <p>
     * The return value of this method is cached, so the implementation can be expensive.<br>
     * Other than {@code doListChildren} you could return FileObject's to e.g. reinitialize the
     * type of the file.
     * <p>
     * (Introduced for Webdav: "permission denied on resource" during getType())
     *
     * @return The children of this FileObject.
     * @throws Exception if an error occurs.
     */

#Code:
    protected FileObject[] doListChildrenResolved() throws Exception
    {
        return null;
    }

#No. 2187
#File: E:\bishe\1\AbstractFileObject.java
#Comment:
    /**
     * Removes an attribute of this file.
     * <p>
     * Is only called if {@link #doGetType} does not return {@link FileType#IMAGINARY}.
     * <p>
     * This implementation throws an exception.
     *
     * @param attrName The name of the attribute to remove.
     * @throws Exception if an error occurs.
     * @since 2.0
     */

#Code:
    protected void doRemoveAttribute(final String attrName) throws Exception
    {
        throw new FileSystemException("vfs.provider/remove-attribute-not-supported.error");
    }

#No. 2188
#File: E:\bishe\1\AbstractFileObject.java
#Comment:
    /**
     * Renames the file.
     * <p>
     * Is only called when:
     * <ul>
     * <li>{@link #doIsWriteable} returns true.</li>
     * </ul>
     * <p>
     * This implementation throws an exception.
     *
     * @param newFile A FileObject with the new file name.
     * @throws Exception if an error occurs.
     */

#Code:
    protected void doRename(final FileObject newFile) throws Exception
    {
        throw new FileSystemException("vfs.provider/rename-not-supported.error");
    }

#No. 2189
#File: E:\bishe\1\AbstractFileObject.java
#Comment:
    /**
     * Sets an attribute of this file.
     * <p>
     * Is only called if {@link #doGetType} does not return {@link FileType#IMAGINARY}.
     * <p>
     * This implementation throws an exception.
     *
     * @param attrName The attribute name.
     * @param value The value to be associated with the attribute name.
     * @throws Exception if an error occurs.
     */

#Code:
    protected void doSetAttribute(final String attrName, final Object value) throws Exception
    {
        throw new FileSystemException("vfs.provider/set-attribute-not-supported.error");
    }

#No. 2190
#File: E:\bishe\1\AbstractFileObject.java
#Comment:
    /**
     * Make the file executable.
     * <p>
     * Only called if {@link #doGetType} does not return {@link FileType#IMAGINARY}.
     * <p>
     * This implementation returns false.
     *
     * @param executable True to allow access, false to disallow.
     * @param ownerOnly If {@code true}, the permission applies only to the owner; otherwise, it applies to everybody.
     * @return true if the operation succeeded.
     * @throws Exception Any Exception thrown is wrapped in FileSystemException.
     * @see #setExecutable(boolean, boolean)
     * @since 2.1
     */

#Code:
    protected boolean doSetExecutable(final boolean executable, final boolean ownerOnly) throws Exception
    {
        return false;
    }

#No. 2191
#File: E:\bishe\1\AbstractFileObject.java
#Comment:
    /**
     * Sets the last modified time of this file.
     * <p>
     * Is only called if {@link #doGetType} does not return {@link FileType#IMAGINARY}.
     * <p>
     * This implementation throws an exception.
     *
     * @param modtime The last modification time.
     * @return true if the time was set.
     * @throws Exception Any Exception thrown is wrapped in FileSystemException.
     */

#Code:
    protected boolean doSetLastModifiedTime(final long modtime) throws Exception
    {
        throw new FileSystemException("vfs.provider/set-last-modified-not-supported.error");
    }

#No. 2192
#File: E:\bishe\1\AbstractFileObject.java
#Comment:
    /**
     * Make the file or folder readable.
     * <p>
     * Only called if {@link #doGetType} does not return {@link FileType#IMAGINARY}.
     * <p>
     * This implementation returns false.
     *
     * @param readable
     *            True to allow access, false to disallow
     * @param ownerOnly
     *            If {@code true}, the permission applies only to the owner; otherwise, it applies to everybody.
     * @return true if the operation succeeded
     * @throws Exception Any Exception thrown is wrapped in FileSystemException.
     * @see #setReadable(boolean, boolean)
     * @since 2.1
     */

#Code:
    protected boolean doSetReadable(final boolean readable, final boolean ownerOnly) throws Exception
    {
        return false;
    }

#No. 2193
#File: E:\bishe\1\AbstractFileObject.java
#Comment:
    /**
     * Make the file or folder writeable.
     * <p>
     * Only called if {@link #doGetType} does not return {@link FileType#IMAGINARY}.
     *
     * @param writable True to allow access, false to disallow
     * @param ownerOnly If {@code true}, the permission applies only to the owner; otherwise, it applies to everybody.
     * @return true if the operation succeeded
     * @throws Exception Any Exception thrown is wrapped in FileSystemException.
     * @see #setWritable(boolean, boolean)
     * @since 2.1
     */

#Code:
    protected boolean doSetWritable(final boolean writable, final boolean ownerOnly) throws Exception
    {
        return false;
    }

#No. 2194
#File: E:\bishe\1\AbstractFileObject.java
#Comment:
    /**
     * Called when the output stream for this file is closed.
     * @throws Exception if an error occurs.
     */

#Code:
    protected void endOutput() throws Exception
    {
        if (getType() == FileType.IMAGINARY)
        {
            // File was created
            handleCreate(FileType.FILE);
        }
        else
        {
            // File has changed
            onChange();
        }
    }

#No. 2195
#File: E:\bishe\1\AbstractFileObject.java
#Comment:
    /**
     * Determines if the file exists.
     * @return true if the file exists, false otherwise,
     * @throws FileSystemException if an error occurs.
     */

#Code:
    @Override
    public boolean exists() throws FileSystemException
    {
        return getType() != FileType.IMAGINARY;
    }

#No. 2196
#File: E:\bishe\1\AbstractFileObject.java
#Comment:
    /**
     * Finds the set of matching descendants of this file, in depthwise
     * order.
     *
     * @param selector The FileSelector.
     * @return list of files or null if the base file (this object) do not exist
     * @throws FileSystemException if an error occurs.
     */

#Code:
    @Override
    public FileObject[] findFiles(final FileSelector selector) throws FileSystemException
    {
        final List<FileObject> list = this.listFiles(selector);
        return list == null ? null : list.toArray(new FileObject[list.size()]);
    }

#No. 2197
#File: E:\bishe\1\AbstractFileObject.java
#Comment:
    /**
     * Traverses the descendants of this file, and builds a list of selected
     * files.
     * @param selector The FileSelector.
     * @param depthwise if true files are added after their descendants, before otherwise.
     * @param selected A List of the located FileObjects.
     * @throws FileSystemException if an error occurs.
     */

#Code:
    @Override
    public void findFiles(final FileSelector selector,
                          final boolean depthwise,
                          final List<FileObject> selected) throws FileSystemException
    {
        try
        {
            if (exists())
            {
                // Traverse starting at this file
                final DefaultFileSelectorInfo info = new DefaultFileSelectorInfo();
                info.setBaseFolder(this);
                info.setDepth(0);
                info.setFile(this);
                traverse(info, selector, depthwise, selected);
            }
        }
        catch (final Exception e)
        {
            throw new FileSystemException("vfs.provider/find-files.error", fileName, e);
        }
    }

#No. 2198
#File: E:\bishe\1\AbstractFileObject.java
#Comment:
    /**
     * Returns the file system this file belongs to.
     * @return The FileSystem this file is associated with.
     */

#Code:
    protected AFS getAbstractFileSystem()
    {
        return fs;
    }

#No. 2199
#File: E:\bishe\1\AbstractFileObject.java
#Comment:
    /**
     * Returns a child of this file.
     * @param name The name of the child to locate.
     * @return The FileObject for the file or null if the child does not exist.
     * @throws FileSystemException if an error occurs.
     */

#Code:
    @Override
    public FileObject getChild(final String name) throws FileSystemException
    {
        // TODO - use a hashtable when there are a large number of children
        final FileObject[] children = getChildren();
        for (final FileObject element : children)
        {
            final FileName child = element.getName();
            // TODO - use a comparator to compare names
            if (child.getBaseName().equals(name))
            {
                return resolveFile(child);
            }
        }
        return null;
    }

#No. 2200
#File: E:\bishe\1\AbstractFileObject.java
#Comment:
    /**
     * Returns the file's content.
     * @return the FileContent for this FileObject.
     * @throws FileSystemException if an error occurs.
     */

#Code:
    @Override
    public FileContent getContent() throws FileSystemException
    {
        synchronized (fs)
        {
            attach();
            if (content == null)
            {
                content = doCreateFileContent();
            }
            return content;
        }
    }

#No. 2201
#File: E:\bishe\1\AbstractFileObject.java
#Comment:
    /**
     * create the filecontentinfo implementation.
     * @return The FileContentInfoFactory.
     */

#Code:
    protected FileContentInfoFactory getFileContentInfoFactory()
    {
        return fs.getFileSystemManager().getFileContentInfoFactory();
    }

#No. 2202
#File: E:\bishe\1\AbstractFileObject.java
#Comment:
    /**
     * @return FileOperations interface that provides access to the operations
     *         API.
     * @throws FileSystemException if an error occurs.
     */

#Code:
    @Override
    public FileOperations getFileOperations() throws FileSystemException
    {
        if (operations == null)
        {
            operations = new DefaultFileOperations(this);
        }

        return operations;
    }

#No. 2203
#File: E:\bishe\1\AbstractFileObject.java
#Comment:
    /**
     * Returns the file system this file belongs to.
     * @return The FileSystem this file is associated with.
     */

#Code:
    @Override
    public FileSystem getFileSystem()
    {
        return fs;
    }

#No. 2204
#File: E:\bishe\1\AbstractFileObject.java
#Comment:
    /**
     * Returns an input stream to use to read the content of the file.
     * @return The InputStream to access this file's content.
     * @throws FileSystemException if an error occurs.
     */

#Code:
    public InputStream getInputStream() throws FileSystemException
    {
        /* VFS-210
        if (!getType().hasContent())
        {
            throw new FileSystemException("vfs.provider/read-not-file.error", name);
        }
        if (!isReadable())
        {
            throw new FileSystemException("vfs.provider/read-not-readable.error", name);
        }
        */

        // Get the raw input stream
        try
        {
            return doGetInputStream();
        }
        catch (final org.apache.commons.vfs2.FileNotFoundException exc)
        {
            throw new org.apache.commons.vfs2.FileNotFoundException(fileName, exc);
        }
        catch (final FileNotFoundException exc)
        {
            throw new org.apache.commons.vfs2.FileNotFoundException(fileName, exc);
        }
        catch (final FileSystemException exc)
        {
            throw exc;
        }
        catch (final Exception exc)
        {
            throw new FileSystemException("vfs.provider/read.error", fileName, exc);
        }
    }

#No. 2205
#File: E:\bishe\1\AbstractFileObject.java
#Comment:
    /**
     * Returns the name of the file.
     *
     * @return The FileName, never {@code null}.
     */

#Code:
    @Override
    public FileName getName()
    {
        return fileName;
    }

#No. 2206
#File: E:\bishe\1\AbstractFileObject.java
#Comment:
    /**
     * Returns the receiver as a URI String for public display, like, without a
     * password.
     *
     * @return A URI String without a password, never {@code null}.
     */

#Code:
    @Override
    public String getPublicURIString()
    {
        return fileName.getFriendlyURI();
    }

#No. 2207
#File: E:\bishe\1\AbstractFileObject.java
#Comment:
    /**
     * Prepares this file for writing.  Makes sure it is either a file,
     * or its parent folder exists.  Returns an output stream to use to
     * write the content of the file to.
     * @return An OutputStream where the new contents of the file can be written.
     * @throws FileSystemException if an error occurs.
     */

#Code:
    public OutputStream getOutputStream() throws FileSystemException
    {
        return getOutputStream(false);
    }

#No. 2208
#File: E:\bishe\1\AbstractFileObject.java
#Comment:
    /**
     * Returns the parent of the file.
     * @return the parent FileObject.
     * @throws FileSystemException if an error occurs.
     */

#Code:
    @Override
    public FileObject getParent() throws FileSystemException
    {
        if (this.compareTo(fs.getRoot()) == 0) // equals is not implemented :-/
        {
            if (fs.getParentLayer() == null)
            {
                // Root file has no parent
                return null;
            }
            else
            {
                // Return the parent of the parent layer
                return fs.getParentLayer().getParent();
            }
        }

        synchronized (fs)
        {
            // Locate the parent of this file
            if (parent == null)
            {
                FileName name = fileName.getParent();
                if (name == null)
                {
                    return null;
                }
                parent = fs.resolveFile(name);
            }
            return parent;
        }
    }

#No. 2209
#File: E:\bishe\1\AbstractFileObject.java
#Comment:
    /**
     * Returns the file's type.
     * @return The FileType.
     * @throws FileSystemException if an error occurs.
     */

#Code:
    @Override
    public FileType getType() throws FileSystemException
    {
        synchronized (fs)
        {
            attach();

            // VFS-210: get the type only if requested for
            try
            {
                if (type == null)
                {
                    setFileType(doGetType());
                }
                if (type == null)
                {
                    setFileType(FileType.IMAGINARY);
                }
            }
            catch (final Exception e)
            {
                throw new FileSystemException("vfs.provider/get-type.error", e, fileName);
            }

            return type;
        }
    }

#No. 2210
#File: E:\bishe\1\AbstractFileObject.java
#Comment:
    /**
     * Returns a URL representation of the file.
     * @return The URL representation of the file.
     * @throws FileSystemException if an error occurs.
     */

#Code:
    @Override
    public URL getURL() throws FileSystemException
    {
        try
        {
            return AccessController.doPrivileged(new PrivilegedExceptionAction<URL>()
            {
                @Override
                public URL run() throws MalformedURLException
                {
                    final StringBuilder buf = new StringBuilder();
                    final String scheme = UriParser.extractScheme(fileName.getURI(), buf);
                    return new URL(scheme, "", -1,
                        buf.toString(), new DefaultURLStreamHandler(fs.getContext(), fs.getFileSystemOptions()));
                }
            });
        }
        catch (final PrivilegedActionException e)
        {
            throw new FileSystemException("vfs.provider/get-url.error", fileName, e.getException());
        }
    }

#No. 2211
#File: E:\bishe\1\AbstractFileObject.java
#Comment:
    /**
     * Called when this file is changed.
     * <p>
     * This will only happen if you monitor the file using {@link org.apache.commons.vfs2.FileMonitor}.
     *
     * @throws Exception if an error occurs.
     */

#Code:
    protected void handleChanged() throws Exception
    {
        // Notify the file system
        fs.fireFileChanged(this);
    }

#No. 2212
#File: E:\bishe\1\AbstractFileObject.java
#Comment:
    /**
     * Called when this file is created. Updates cached info and notifies
     * the parent and file system.
     *
     * @param newType The type of the file.
     * @throws Exception if an error occurs.
     */

#Code:
    protected void handleCreate(final FileType newType) throws Exception
    {
        synchronized (fs)
        {
            if (attached)
            {
                // Fix up state
                injectType(newType);

                removeChildrenCache();

                // Notify subclass
                onChange();
            }

            // Notify parent that its child list may no longer be valid
            notifyParent(this.getName(), newType);

            // Notify the file system
            fs.fireFileCreated(this);
        }
    }

#No. 2213
#File: E:\bishe\1\AbstractFileObject.java
#Comment:
    /**
     * Called when this file is deleted.  Updates cached info and notifies
     * subclasses, parent and file system.
     * @throws Exception if an error occurs.
     */

#Code:
    protected void handleDelete() throws Exception
    {
        synchronized (fs)
        {
            if (attached)
            {
                // Fix up state
                injectType(FileType.IMAGINARY);
                removeChildrenCache();

                // Notify subclass
                onChange();
            }

            // Notify parent that its child list may no longer be valid
            notifyParent(this.getName(), FileType.IMAGINARY);

            // Notify the file system
            fs.fireFileDeleted(this);
        }
    }

#No. 2214
#File: E:\bishe\1\AbstractFileObject.java
#Comment:
    /**
     * This method is meant to add an object where this object holds a strong reference then.
     * E.g. a archive-filesystem creates a list of all children and they shouldn't get
     * garbage collected until the container is garbage collected
     *
     * @param strongRef The Object to add.
     */

#Code:
    // TODO should this be a FileObject?
    public void holdObject(final Object strongRef)
    {
        if (objects == null)
        {
            objects = new ArrayList<>(INITIAL_LIST_SIZE);
        }
        objects.add(strongRef);
    }

#No. 2215
#File: E:\bishe\1\AbstractFileObject.java
#Comment:
    /**
     * Check if the internal state is "attached".
     *
     * @return true if this is the case
     */

#Code:
    @Override
    public boolean isAttached()
    {
        return attached;
    }

#No. 2216
#File: E:\bishe\1\AbstractFileObject.java
#Comment:
    /**
     * Check if the content stream is open.
     *
     * @return true if this is the case
     */

#Code:
    @Override
    public boolean isContentOpen()
    {
        if (content == null)
        {
            return false;
        }

        return content.isOpen();
    }

#No. 2217
#File: E:\bishe\1\AbstractFileObject.java
#Comment:
    /**
     * Determines if this file is executable.
     *
     * @return {@code true} if this file is executable, {@code false} if not.
     * @throws FileSystemException On error determining if this file exists.
     */

#Code:
    @Override
    public boolean isExecutable() throws FileSystemException
    {
        try
        {
            return exists() ? doIsExecutable() : false;
        }
        catch (final Exception exc)
        {
            throw new FileSystemException("vfs.provider/check-is-executable.error", fileName, exc);
        }
    }

#No. 2218
#File: E:\bishe\1\AbstractFileObject.java
#Comment:
    /**
     * Checks if this file is a regular file by using its file type.
     *
     * @return true if this file is a regular file.
     * @throws FileSystemException if an error occurs.
     * @see #getType()
     * @see FileType#FILE
     */

#Code:
    @Override
    public boolean isFile() throws FileSystemException
    {
        // Use equals instead of == to avoid any class loader worries.
        return FileType.FILE.equals(this.getType());
    }

#No. 2219
#File: E:\bishe\1\AbstractFileObject.java
#Comment:
    /**
     * Checks if this file is a folder by using its file type.
     *
     * @return true if this file is a regular file.
     * @throws FileSystemException if an error occurs.
     * @see #getType()
     * @see FileType#FOLDER
     */

#Code:
    @Override
    public boolean isFolder() throws FileSystemException
    {
        // Use equals instead of == to avoid any class loader worries.
        return FileType.FOLDER.equals(this.getType());
    }

#No. 2220
#File: E:\bishe\1\AbstractFileObject.java
#Comment:
    /**
     * Determines if this file can be read.
     * @return true if the file is a hidden file, false otherwise.
     * @throws FileSystemException if an error occurs.
     */

#Code:
    @Override
    public boolean isHidden() throws FileSystemException
    {
        try
        {
            return exists() ? doIsHidden() : false;
        }
        catch (final Exception exc)
        {
            throw new FileSystemException("vfs.provider/check-is-hidden.error", fileName, exc);
        }
    }

#No. 2221
#File: E:\bishe\1\AbstractFileObject.java
#Comment:
    /**
     * Determines if this file can be read.
     * @return true if the file can be read, false otherwise.
     * @throws FileSystemException if an error occurs.
     */

#Code:
    @Override
    public boolean isReadable() throws FileSystemException
    {
        try
        {
            return exists() ? doIsReadable() : false;
        }
        catch (final Exception exc)
        {
            throw new FileSystemException("vfs.provider/check-is-readable.error", fileName, exc);
        }
    }

#No. 2222
#File: E:\bishe\1\AbstractFileObject.java
#Comment:
    /**
     * Checks if this fileObject is the same file as {@code destFile} just with a different
     * name. E.g. for case insensitive filesystems like windows.
     *
     * @param destFile The file to compare to.
     * @return true if the FileObjects are the same.
     * @throws FileSystemException if an error occurs.
     */

#Code:
    protected boolean isSameFile(final FileObject destFile) throws FileSystemException
    {
        attach();
        return doIsSameFile(destFile);
    }

#No. 2223
#File: E:\bishe\1\AbstractFileObject.java
#Comment:
    /**
     * Determines if this file can be written to.
     * @return true if the file can be written to, false otherwise.
     * @throws FileSystemException if an error occurs.
     */

#Code:
    @Override
    public boolean isWriteable() throws FileSystemException
    {
        try
        {
            if (exists())
            {
                return doIsWriteable();
            }
            else
            {
                final FileObject parent = getParent();
                if (parent != null)
                {
                    return parent.isWriteable();
                }
                return true;
            }
        }
        catch (final Exception exc)
        {
            throw new FileSystemException("vfs.provider/check-is-writeable.error", fileName, exc);
        }
    }

#No. 2224
#File: E:\bishe\1\AbstractFileObject.java
#Comment:
    /**
     * Returns an iterator over a set of all FileObject in this file object.
     *
     * @return an Iterator.
     */

#Code:
    @Override
    public Iterator<FileObject> iterator()
    {
        try
        {
            return listFiles(Selectors.SELECT_ALL).iterator();
        }
        catch (final FileSystemException e)
        {
            throw new IllegalStateException(e);
        }
    }

#No. 2225
#File: E:\bishe\1\AbstractFileObject.java
#Comment:
    /**
     * Lists the set of matching descendants of this file, in depthwise
     * order.
     *
     * @param selector The FileSelector.
     * @return list of files or null if the base file (this object) do not exist or the {@code selector} is null
     * @throws FileSystemException if an error occurs.
     */

#Code:
    public List<FileObject> listFiles(final FileSelector selector) throws FileSystemException
    {
        if (!exists() || selector == null)
        {
            return null;
        }

        final ArrayList<FileObject> list = new ArrayList<>();
        this.findFiles(selector, true, list);
        return list;
    }

#No. 2226
#File: E:\bishe\1\AbstractFileObject.java
#Comment:
    /**
     * will be called after this file-object closed all its streams.
     */

#Code:
    protected void notifyAllStreamsClosed()
    {
    }

#No. 2227
#File: E:\bishe\1\AbstractFileObject.java
#Comment:
    /**
     * Notify the parent of a change to its children, when a child is created
     * or deleted.
     * @param childName The name of the child.
     * @param newType The type of the child.
     * @throws Exception if an error occurs.
     */

#Code:
    private void notifyParent(final FileName childName, final FileType newType) throws Exception
    {
        if (parent == null)
        {
            final FileName parentName = fileName.getParent();
            if (parentName != null)
            {
                // Locate the parent, if it is cached
                parent = fs.getFileFromCache(parentName);
            }
        }

        if (parent != null)
        {
            FileObjectUtils.getAbstractFileObject(parent).childrenChanged(childName, newType);
        }
    }

#No. 2228
#File: E:\bishe\1\AbstractFileObject.java
#Comment:
    /**
     * Called when the type or content of this file changes.
     * <p>
     * This implementation does nothing.
     *
     * @throws Exception if an error occurs.
     */

#Code:
    protected void onChange() throws Exception
    {
    }

#No. 2229
#File: E:\bishe\1\AbstractFileObject.java
#Comment:
    /**
     * Called when the children of this file change.  Allows subclasses to
     * refresh any cached information about the children of this file.
     * <p>
     * This implementation does nothing.
     *
     * @param child The name of the child that changed.
     * @param newType The type of the file.
     * @throws Exception if an error occurs.
     */

#Code:
    protected void onChildrenChanged(final FileName child, final FileType newType) throws Exception
    {
    }

#No. 2230
#File: E:\bishe\1\AbstractFileObject.java
#Comment:
    /**
     * This will prepare the fileObject to get resynchronized with the underlying filesystem if required.
     * @throws FileSystemException if an error occurs.
     */

#Code:
    @Override
    public void refresh() throws FileSystemException
    {
        // Detach from the file
        try
        {
            detach();
        }
        catch (final Exception e)
        {
            throw new FileSystemException("vfs.provider/resync.error", fileName, e);
        }
    }

#No. 2231
#File: E:\bishe\1\AbstractFileObject.java
#Comment:
    /**
     * Finds a file, relative to this file.
     *
     * @param path The path of the file to locate.  Can either be a relative
     *             path, which is resolved relative to this file, or an
     *             absolute path, which is resolved relative to the file system
     *             that contains this file.
     * @return The FileObject.
     * @throws FileSystemException if an error occurs.
     */

#Code:
    @Override
    public FileObject resolveFile(final String path) throws FileSystemException
    {
        final FileName otherName = fs.getFileSystemManager().resolveName(fileName, path);
        return fs.resolveFile(otherName);
    }

#No. 2232
#File: E:\bishe\1\AbstractFileObject.java
#Comment:
    /**
     * Returns a child by name.
     * @param name The name of the child to locate.
     * @param scope the NameScope.
     * @return The FileObject for the file or null if the child does not exist.
     * @throws FileSystemException if an error occurs.
     */

#Code:
    @Override
    public FileObject resolveFile(final String name, final NameScope scope)
        throws FileSystemException
    {
        // return fs.resolveFile(this.name.resolveName(name, scope));
        return fs.resolveFile(fs.getFileSystemManager().resolveName(this.fileName, name, scope));
    }

#No. 2233
#File: E:\bishe\1\AbstractFileObject.java
#Comment:
    /**
     * Returns the URI as a String.
     *
     * @return Returns the URI as a String.
     */

#Code:
    @Override
    public String toString()
    {
        return fileName.getURI();
    }

#No. 2234
#File: E:\bishe\1\AbstractFileOperationProvider.java
#Comment:
    /**
     * @param file
     *            the FileObject for which we need a operation.
     * @param operationClass
     *            the Class which instance we are needed.
     * @return the required operation instance.
     * @throws FileSystemException if operation cannot be retrieved.
     */

#Code:
    @Override
    public final FileOperation getOperation(final FileObject file, final Class<? extends FileOperation> operationClass)
            throws FileSystemException
    {
        final Class<? extends FileOperation> implementation = lookupOperation(operationClass);

        final FileOperation operationInstance = instantiateOperation(file, implementation);

        return operationInstance;
    }

#No. 2235
#File: E:\bishe\1\AbstractFileOperationProvider.java
#Comment:
    /**
     * Find class implementing a specific operation interface.
     *
     * @param operationClass the interface which is requested.
     * @return never returns null
     * @throws FileSystemException if operationClass is not a known FileOperation interface.
     */

#Code:
    protected final Class<? extends FileOperation> lookupOperation(final Class<? extends FileOperation> operationClass)
            throws FileSystemException
    {
        // check validity of passed class
        if (!FileOperation.class.isAssignableFrom(operationClass))
        {
            throw new FileSystemException("vfs.operation/wrong-type.error", operationClass);
        }

        // find appropriate class
        Class<? extends FileOperation> foundClass = null;
        final Iterator<Class<? extends FileOperation>> iterator = operations.iterator();
        while (iterator.hasNext())
        {
            final Class<? extends FileOperation> operation = iterator.next();
            if (operationClass.isAssignableFrom(operation))
            {
                foundClass = operation;
                break;
            }
        }

        if (foundClass == null)
        {
            throw new FileSystemException("vfs.operation/not-found.error", operationClass);
        }

        return foundClass;
    }

#No. 2236
#File: E:\bishe\1\AbstractFileOperationProvider.java
#Comment:
    /**
     * Add new FileOperation to list of known operations.
     *
     * @param operationClass a class implementing FileOperation.
     * @throws FileSystemException if instances of the class cannot be assigned to FileOperation.
     */

#Code:
    protected final void addOperation(final Class<? extends FileOperation> operationClass)
            throws FileSystemException
    {
        // check validity of passed class
        if (!FileOperation.class.isAssignableFrom(operationClass))
        {
            throw new FileSystemException("vfs.operation/cant-register.error", operationClass);
        }

        // ok, lets add it to the list
        operations.add(operationClass);
    }

#No. 2237
#File: E:\bishe\1\AbstractFileOutputBolt.java
#Comment:
	/**
	 * Writes the given tuple to disc (see {@link #tupleToString(Tuple)}.
	 * 
	 * @param input
	 *            The input tuple to be processed.
	 */

#Code:
	@Override
	public void execute(Tuple input) {
		if(this.writer != null) {
			try {
				this.writer.write(this.tupleToString(input));
			} catch(IOException e) {
				logger.error("Could not output tuple to output file: {}", input);
			}
		}
		this.collector.ack(input);
	}

#No. 2238
#File: E:\bishe\1\AbstractFileOutputBolt.java
#Comment:
	/**
	 * Same as {@link #execute(Tuple)}, but flushed the written output data to disc immediately.
	 * 
	 * @param input
	 *            The input tuple to be processed.
	 */

#Code:
	public void executeAndFlush(Tuple input) {
		if(this.writer != null) {
			try {
				this.writer.write(this.tupleToString(input));
				this.writer.flush();
			} catch(IOException e) {
				logger.error("Could not output tuple to output file: {}", input);
			}
		}
		this.collector.ack(input);
	}

#No. 2239
#File: E:\bishe\1\AbstractFilePreferenceSource.java
#Comment:
    /**
     * include version
     *
     * @param version
     * @return
     */

#Code:
    protected List<File> getLogFileListUntilVersion(long version) {
        if (version < 0) {
            return Collections.emptyList();
        }
        List<File> list = listLogFileNamesAndSorted();
        if (list.isEmpty()) {
            return Collections.emptyList();
        }
        final List<File> logFileList = new ArrayList<File>(list.size() - 1);

        for (File file : list) {
            long fileVersion = getLogFileVersion(file);
            if (fileVersion > version) {
                break;
            }
            logFileList.add(file);
        }
        return logFileList;
    }

#No. 2240
#File: E:\bishe\1\AbstractFileResourceManager.java
#Comment:
	/**
	 * The constructor
	 *
	 * @param storage       the storage
	 * @param clazz         manager type class
	 * @param directoryPath resource directory path
	 */

#Code:
	protected AbstractFileResourceManager(Storage storage, Class<T> clazz, String directoryPath) {
		super(storage, clazz);
		directory = new File(getStorage().getDirectory(), directoryPath);
	}

#No. 2241
#File: E:\bishe\1\AbstractFileResourceManager.java
#Comment:
	/**
	 * Gets resource directory
	 *
	 * @return the directory
	 */

#Code:
	protected File getDirectory() {
		return directory;
	}

#No. 2242
#File: E:\bishe\1\AbstractFileResourceManager.java
#Comment:
	/**
	 * Gets resource's file
	 *
	 * @param t instance
	 * @return the file
	 */

#Code:
	public abstract File getFile(T t);

	/**
	 * Gets all stored files
	 *
	 * @return list of files
	 */
	protected List<File> getFiles() {
		File[] files = getDirectory().listFiles();
		final List<File> list = new ArrayList<>();

		if(files != null) {
			list.addAll(Arrays.asList(files));
		}

		return list;
	}

#No. 2243
#File: E:\bishe\1\AbstractFileResourceManager.java
#Comment:
	/**
	 * Creates file if doesn't exist
	 *
	 * @param file the file
	 * @throws IOException if failed
	 */

#Code:
	private void createFileIfNotExists(File file) throws IOException {
		if(!file.exists()) {
			if(!file.createNewFile()) {
				throw new IOException("File creating failed (" + file.getPath() + ")");
			}
		}
	}

#No. 2244
#File: E:\bishe\1\AbstractFileResourceManager.java
#Comment:
	/**
	 * Trims extension from file's name
	 *
	 * @param file the file
	 * @return trimmed name
	 */

#Code:
	protected final String trimExtension(File file) {
		return StringUtils.substring(file.getName(), 0, StringUtils.lastIndexOf(file.getName(), '.'));
	}

#No. 2245
#File: E:\bishe\1\AbstractFileRouteLoader.java
#Comment:
    /**
     * Load Route
     *
     * @param inputStream route inputstream
     * @return return route list
     * @throws ParseException parse exception
     * @throws IOException    io exception
     */

#Code:
    private List<Route> load(InputStream inputStream) throws ParseException, IOException {
        int line = 0;
        List<Route> routes = new ArrayList<Route>();
        BufferedReader in = null;
        try {
            in = new BufferedReader(new InputStreamReader(inputStream));
            String input;
            while ((input = in.readLine()) != null) {
                line++;

                input = input.trim();

                if (!input.equals("") && !input.startsWith(".")) {
                    Route route = parse(input, line);
                    routes.add(route);
                }
            }
        } finally {
            IOKit.closeQuietly(in);
        }
        return routes;
    }

#No. 2246
#File: E:\bishe\1\AbstractFileRouteLoader.java
#Comment:
    /**
     * Verification controller method
     *
     * @param beanAndMethod controller and method, using.
     * @param line          line number
     * @return return a string that is verified after the verification.
     * @throws ParseException
     */

#Code:
    private String validateControllerAndMethod(String beanAndMethod, int line) throws ParseException {
        int hashPos = beanAndMethod.indexOf(".");
        if (hashPos == -1) {
            throw new ParseException("Unrecognized format for '" + beanAndMethod + "'", line);
        }

        return beanAndMethod;
    }

#No. 2247
#File: E:\bishe\1\AbstractFileRouteLoader.java
#Comment:
    /**
     * Construct a routing object
     *
     * @param httpMethod     request httpMethod
     * @param path           route path
     * @param controllerName controller name
     * @param methodName     method name
     * @return return route object
     * @throws RouteException
     */

#Code:
    private Route buildRoute(String httpMethod, String path, String controllerName, String methodName) throws RouteException {
        Object controller = controllerLoader.load(controllerName);
        Class<?> controllerType = controller.getClass();
        Method method = getMethod(controllerType, methodName);
        return new Route(HttpMethod.valueOf(httpMethod.toUpperCase()), path, controller, controllerType, method);
    }

#No. 2248
#File: E:\bishe\1\AbstractFileSelectionAction.java
#Comment:
    /**
     * The text field showing the user choice.
     */

#Code:
    private final JTextField textField;

    /**
     * The descriptor indicating the type of file chooser to be displayed.
     */
    private final FileSelectionDescriptor selectionDescriptor;

    /**
     *
     * @param textField the text field showing the user choice
     * @param selectionDescriptor the type of file chooser to be displayed
     */
    protected AbstractFileSelectionAction(@NotNull JTextField textField,
                                          @NotNull FileSelectionDescriptor selectionDescriptor)
    {
        this.textField = textField;
        this.selectionDescriptor = selectionDescriptor;
    }

#No. 2249
#File: E:\bishe\1\AbstractFileSelectionAction.java
#Comment:
    /**
     * Gets the selected files.
     *
     * @param actionEvent the underlying event
     * @param existingSelection the existing selection, if any
     * @return the selected virtual files
     */

#Code:
    protected abstract VirtualFile[] getFiles(@NotNull ActionEvent actionEvent,
                                              @Nullable VirtualFile existingSelection);
}
}

#No. 2250
#File: E:\bishe\1\AbstractFileStorage.java
#Comment:
	/**
	 * AbstractFileStorage constructor
	 *
	 * @param dataDirectory data directory
	 * @throws StorageConnectionFailedException when something goes wrong
	 */

#Code:
	public AbstractFileStorage(File dataDirectory) throws StorageConnectionFailedException {
		this.dataDirectory = dataDirectory;
		playersDirectory = new File(dataDirectory, "player/");
		guildsDirectory = new File(dataDirectory, "guild/");
		regionsDirectory = new File(dataDirectory, "region/");
		ranksDirectory = new File(dataDirectory, "rank/");

		if(!setUp()) {
			throw new StorageConnectionFailedException("Failed creating directories");
		}
	}

#No. 2251
#File: E:\bishe\1\AbstractFileStorage.java
#Comment:
	/**
	 * Gets data directory
	 *
	 * @return the directory
	 */

#Code:
	public final File getDirectory() {
		return dataDirectory;
	}

#No. 2252
#File: E:\bishe\1\AbstractFilesystemStorage.java
#Comment:
    /**
     * Implement to provide a File implementation (i.e. TFile)
     */

#Code:
    public abstract File createFile(String path);

    /**
     * Implement to provide a File implementation (i.e. TFile)
     */
    public abstract File createFile(File parent, String path);

    private File createFile(String parent, String path) {
        return createFile(createFile(parent), path);
    }

#No. 2253
#File: E:\bishe\1\AbstractFileTransferClient.java
#Comment:
    /**
     * Downloads a file from the specified directory and with the specified file name
     *
     * @param localFile the local file that will be created
     * @param remoteDir the remote directory to download from
     * @param remoteFile the remote file to download
     * @throws FileTransferException
     */

#Code:
    public void downloadFile(
                              String localFile,
                              String remoteDir,
                              String remoteFile ) throws FileTransferException {

        checkPausedTransferRunning( false );

        performDownloadFile( localFile, remoteDir, remoteFile );
    }

#No. 2254
#File: E:\bishe\1\AbstractFileTransferClient.java
#Comment:
    /**
     * Check if
     * @param expected the expected result: true if a running transfer is expected, false otherwise.
     * @throws FileTransferException
     */

#Code:
    protected void checkPausedTransferRunning(
                                               boolean expected ) throws FileTransferException {

        if( isTransferStartedAndPaused && !expected ) {
            throw new FileTransferException( "A transfer is already started and paused. It must be resumed before another one is initiated." );
        }
        if( !isTransferStartedAndPaused && expected ) {
            throw new FileTransferException( "A transfer is not started and paused. Cannot perform resume." );
        }
    }

#No. 2255
#File: E:\bishe\1\AbstractFileTransferClient.java
#Comment:
    /**
     * Enable or disable response gathering. If enabled the responses for each protocol command
     * will be gathered.
     * @param enable <b>true</b> to enable, <b>false</b> to disable response gathering.
     */

#Code:
    public void enableResponseCollection(
                                          boolean enable ) {

    }

#No. 2256
#File: E:\bishe\1\AbstractFileTransferClient.java
#Comment:
    /**
     * @return array of all the responses so far.
     */

#Code:
    public String[] getResponses() {

        if( this.listener == null ) {
            return new String[]{};
        }

        List<String> responses = this.listener.getResponses();

        return responses.toArray( new String[responses.size()] );
    }

#No. 2257
#File: E:\bishe\1\AbstractFileTransferClient.java
#Comment:
    /**
     * Add custom property for the specific client.
     * Default implementation throws {@link IllegalArgumentException} since it
     * does not support any parameters.
     * <p>Note: For implementations you should use the {@link #customProperties} Map</p>
     * @see IFileTransferClient
     * @param key property key name. About possible values check the protocol specific client implementations
     * @param value object with supported value
     * @throws IllegalArgumentException if the key or value is not supported
     */

#Code:
    public void addCustomProperty(
                                   String key,
                                   Object value ) throws IllegalArgumentException {

        throw new IllegalArgumentException( "Not supported" );

    }

#No. 2258
#File: E:\bishe\1\AbstractFileTransferClient.java
#Comment:
    /**
     * Method which is intended to be used to apply set/new properties on each connect()
     * if there are connection initialization parameters set.
     * Default implementation throws {@link IllegalArgumentException}
     * <p>Note: For implementations you should use the {@link #customProperties} Map</p>
     * @see IFileTransferClient
     * @throws IllegalArgumentException if the key or value is not supported
     */

#Code:
    public void applyCustomProperties() throws IllegalArgumentException {

        // do nothing
    }

#No. 2259
#File: E:\bishe\1\AbstractFileTransferClient.java
#Comment:
    /**
     * Breaks "prop1,prop2,prop3" into array of tokens.
     * It trims each token.
     * 
     * @param source string
     * @return result tokens
     */

#Code:
    protected String[] parseCustomProperties(
                                              String source ) {

        String[] result = source.split( "," );
        for( int i = 0; i < result.length; i++ ) {
            result[i] = result[i].trim();
        }

        return result;
    }

#No. 2260
#File: E:\bishe\1\AbstractFillWith.java
#Comment:
    /**
     * Check that the selected column parameter is correct : defined in the parameters and there's a matching column. If
     * the parameter is invalid, an exception is thrown.
     *
     * @param parameters where to look the parameter value.
     * @param rowMetadata the row metadata where to look for the column.
     */

#Code:
    private void checkParameters(Map<String, String> parameters, RowMetadata rowMetadata) {
        if (!parameters.containsKey(MODE_PARAMETER)) {
            throw new TalendRuntimeException(ActionErrorCodes.BAD_ACTION_PARAMETER,
                    ExceptionContext.build().put("paramName", MODE_PARAMETER));
        }

        if (parameters.get(MODE_PARAMETER).equals(CONSTANT_MODE) && !parameters.containsKey(DEFAULT_VALUE_PARAMETER)) {
            throw new TalendRuntimeException(ActionErrorCodes.BAD_ACTION_PARAMETER,
                    ExceptionContext.build().put("paramName", DEFAULT_VALUE_PARAMETER));
        } else if (!parameters.get(MODE_PARAMETER).equals(CONSTANT_MODE) && (!parameters.containsKey(SELECTED_COLUMN_PARAMETER)
                || rowMetadata.getById(parameters.get(SELECTED_COLUMN_PARAMETER)) == null)) {
            throw new TalendRuntimeException(ActionErrorCodes.BAD_ACTION_PARAMETER,
                    ExceptionContext.build().put("paramName", SELECTED_COLUMN_PARAMETER));
        }
    }

#No. 2261
#File: E:\bishe\1\AbstractFilterableNumberTableColumn.java
#Comment:
/**
 * You probably shouldn't ever extend this class.
 * It's only meant to be used by certain Java built-in classes which extend {@link Number}, 
 * almost all of which I've created sub-classes for.
 * 
 * @author JHS
 */

#Code:
public class AbstractFilterableNumberTableColumn<S, T extends Number>
extends AbstractFilterableTableColumn<S, T, NumberOperator<T>, NumberFilterEditor<T>>
{
    public AbstractFilterableNumberTableColumn(Class<T> klass)
    {
        this("", klass);
    }
    
    public AbstractFilterableNumberTableColumn(String text, Class<T> klass)
    {
        super(text, new NumberFilterEditor<>(text, klass));
    }
}

#No. 2262
#File: E:\bishe\1\AbstractFilterProviderAdapterFactoryBean.java
#Comment:
    /**
     * Helper method for basclasses that add an invoker to the lookup map. Performs validation that
     * no other invoker is bounded to the operation code.
     */

#Code:
    protected void addInvoker(Map<Integer, FilterOperationDelegateInvoker> invokerLookup, Method method, int operationCode) throws IllegalArgumentException {
        FilterOperationDelegateInvoker invoker = invokerLookup.get(operationCode);
        if (invoker != null) {
            throw new IllegalArgumentException("Filter adapter only allows for a single method for each operation. " +
                    "operation [" + operationCode + "] has method [" + invoker.getProcessMethod().getName() + "] and method [" +
                    method.getName() + "]");
        }
        // TODO add parameter validation
        invokerLookup.put(operationCode, new FilterOperationDelegateInvoker(operationCode, method));
    }

#No. 2263
#File: E:\bishe\1\AbstractFilterProviderFactoryBean.java
#Comment:
    /**
     * Sets if the filter will be active when the space is in <code>BACKUP</code> mode. Defaults to
     * <code>true<code>.
     */

#Code:
    public void setActiveWhenBackup(boolean activeWhenBackup) {
        this.activeWhenBackup = activeWhenBackup;
    }

#No. 2264
#File: E:\bishe\1\AbstractFilterProviderFactoryBean.java
#Comment:
    /**
     * Is the filter enabled. Defaults to <code>true</code>.
     */

#Code:
    public void setEnabled(boolean enabled) {
        this.enabled = enabled;
    }

#No. 2265
#File: E:\bishe\1\AbstractFilterProviderFactoryBean.java
#Comment:
    /**
     * Is this filter a security filter. Defaults to <code>false</code>.
     */

#Code:
    public void setSecurityFilter(boolean securityFilter) {
        this.securityFilter = securityFilter;
    }

#No. 2266
#File: E:\bishe\1\AbstractFilterProviderFactoryBean.java
#Comment:
    /**
     * Should the space shutdown in case the init method fails (throws an exception). Defaults to
     * <code>false</code>.
     */

#Code:
    public void setShutdownSpaceOnInitFailure(boolean shutdownSpaceOnInitFailure) {
        this.shutdownSpaceOnInitFailure = shutdownSpaceOnInitFailure;
    }

#No. 2267
#File: E:\bishe\1\AbstractFilterProviderFactoryBean.java
#Comment:
    /**
     * The filter priority. Defaults to <code>0</code>.
     */

#Code:
    public void setPriority(int priority) {
        this.priority = priority;
    }

#No. 2268
#File: E:\bishe\1\AbstractFilterProviderFactoryBean.java
#Comment:
    /**
     * Sets the bean name thanks to Spring {@link org.springframework.beans.factory.BeanNameAware}.
     * Used as the filter name.
     */

#Code:
    @Override
    public void setBeanName(String name) {
        this.beanName = name;
    }

#No. 2269
#File: E:\bishe\1\AbstractFilterProviderFactoryBean.java
#Comment:
    /**
     * <p>Constructs the filter provider and applies its different aspects. Delegates to {@link
     * #doGetFilterProvider()} for the actual filter provider creation.
     *
     * <p>Note, subclasses will need to initialize the filter provider with the relevant operation
     * codes it will listen on.
     */

#Code:
    @Override
    public void afterPropertiesSet() throws Exception {
        Assert.notNull(filter, "filter property is required");
        this.filterProvider = doGetFilterProvider();
        Assert.notNull(filterProvider.getOpCodes(), "At least one operation code is required for filter provider");
        Assert.isTrue(filterProvider.getOpCodes().length > 0, "At least one operation code is required for filter provider");

        filterProvider.setPriority(priority);
        filterProvider.setActiveWhenBackup(activeWhenBackup);
        filterProvider.setEnabled(enabled);
        filterProvider.setSecurityFilter(securityFilter);
        filterProvider.setShutdownSpaceOnInitFailure(shutdownSpaceOnInitFailure);
    }

#No. 2270
#File: E:\bishe\1\AbstractFirstMojo.java
#Comment:
/**
 * Touches a test file.
 *
 */

#Code:
public abstract class AbstractFirstMojo
    extends AbstractMojo
{

    /**
     * Project directory.
     */
    @Parameter( defaultValue = "${basedir}", readonly = true )
    protected File basedir;

    @Parameter( property = "first.touchFile", defaultValue = "${project.build.directory}/touch.txt",
                required = true )
    protected File touchFile;

    /**
     * Plexus compiler manager.
     */
    @Component
    protected CompilerManager compilerManager;

    /**
     *
     */
    @Component( role = ArtifactMetadataSource.class, hint = "maven" )
    protected ArtifactMetadataSource artifactMetadataSource;

}

#No. 2271
#File: E:\bishe\1\AbstractFlatGeneratorType.java
#Comment:
    /**
     * Gets the {@link FlatGeneratorSettings} for the given settings {@link DataView}.
     *
     * @param settings The settings
     * @return The flat generator settings
     */

#Code:
    private FlatGeneratorSettings getFlatGeneratorSettings(DataView settings) {
        return settings.getString(SETTINGS).map(FlatGeneratorSettingsParser::fromString).orElseGet(this::getDefaultSettings);
    }

#No. 2272
#File: E:\bishe\1\AbstractFlexProjectConfigurator.java
#Comment:
    /**
     * Configures the Flex SDK name and adds it to the library path of the project. Must be called before configuring
     * the library path.
     */

#Code:
    protected void configureFlexSDKName()
    {
        final String flexVersion = plugin.getFlexFramework().getVersion();
        final String flexSDKName = FlexFrameworkHelper.getFlexSDKName( flexVersion );
        settings.setFlexSDKName( flexSDKName );
    }

#No. 2273
#File: E:\bishe\1\AbstractFloatList.java
#Comment:
    /**
     * Returns the index of the first occurrence of the specified element.
     * Returns <code>-1</code> if the receiver does not contain this element.
     * 
     * @param element
     *            the element to be searched for.
     * @return the index of the first occurrence of the element in the receiver;
     *         returns <code>-1</code> if the element is not found.
     */

#Code:
    public int indexOf(float element) { // delta
        return indexOfFromTo(element, 0, size - 1);
    }

#No. 2274
#File: E:\bishe\1\AbstractFloatList.java
#Comment:
    /**
     * Returns the index of the first occurrence of the specified element.
     * Returns <code>-1</code> if the receiver does not contain this element.
     * Searches between <code>from</code>, inclusive and <code>to</code>,
     * inclusive. Tests for identity.
     * 
     * @param element
     *            element to search for.
     * @param from
     *            the leftmost search position, inclusive.
     * @param to
     *            the rightmost search position, inclusive.
     * @return the index of the first occurrence of the element in the receiver;
     *         returns <code>-1</code> if the element is not found.
     * @exception IndexOutOfBoundsException
     *                index is out of range (
     *                <tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>
     *                ).
     */

#Code:
    public int indexOfFromTo(float element, int from, int to) {
        checkRangeFromTo(from, to, size);

        for (int i = from; i <= to; i++) {
            if (element == getQuick(i))
                return i; // found
        }
        return -1; // not found
    }

#No. 2275
#File: E:\bishe\1\AbstractFloatList.java
#Comment:
    /**
     * Returns the index of the last occurrence of the specified element.
     * Returns <code>-1</code> if the receiver does not contain this element.
     * 
     * @param element
     *            the element to be searched for.
     * @return the index of the last occurrence of the element in the receiver;
     *         returns <code>-1</code> if the element is not found.
     */

#Code:
    public int lastIndexOf(float element) {
        return lastIndexOfFromTo(element, 0, size - 1);
    }

#No. 2276
#File: E:\bishe\1\AbstractFloatList.java
#Comment:
    /**
     * Returns the index of the last occurrence of the specified element.
     * Returns <code>-1</code> if the receiver does not contain this element.
     * Searches beginning at <code>to</code>, inclusive until <code>from</code>,
     * inclusive. Tests for identity.
     * 
     * @param element
     *            element to search for.
     * @param from
     *            the leftmost search position, inclusive.
     * @param to
     *            the rightmost search position, inclusive.
     * @return the index of the last occurrence of the element in the receiver;
     *         returns <code>-1</code> if the element is not found.
     * @exception IndexOutOfBoundsException
     *                index is out of range (
     *                <tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>
     *                ).
     */

#Code:
    public int lastIndexOfFromTo(float element, int from, int to) {
        checkRangeFromTo(from, to, size());

        for (int i = to; i >= from; i--) {
            if (element == getQuick(i))
                return i; // found
        }
        return -1; // not found
    }

#No. 2277
#File: E:\bishe\1\AbstractFloatList.java
#Comment:
    /**
     * Sorts the specified range of the receiver into ascending order.
     * 
     * The sorting algorithm is a modified mergesort (in which the merge is
     * omitted if the highest element in the low sublist is less than the lowest
     * element in the high sublist). This algorithm offers guaranteed n*log(n)
     * performance, and can approach linear performance on nearly sorted lists.
     * 
     * <p>
     * <b>You should never call this method unless you are sure that this
     * particular sorting algorithm is the right one for your data set.</b> It
     * is generally better to call <tt>sort()</tt> or <tt>sortFromTo(...)</tt>
     * instead, because those methods automatically choose the best sorting
     * algorithm.
     * 
     * @param from
     *            the index of the first element (inclusive) to be sorted.
     * @param to
     *            the index of the last element (inclusive) to be sorted.
     * @exception IndexOutOfBoundsException
     *                index is out of range (
     *                <tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>
     *                ).
     */

#Code:

    public void mergeSortFromTo(int from, int to) {
        int mySize = size();
        checkRangeFromTo(from, to, mySize);

        float[] myElements = elements();
        cern.colt.Sorting.mergeSort(myElements, from, to + 1);
        elements(myElements);
        setSizeRaw(mySize);
    }

#No. 2278
#File: E:\bishe\1\AbstractFloatList.java
#Comment:
    /**
     * Sorts the receiver according to the order induced by the specified
     * comparator. All elements in the range must be <i>mutually comparable</i>
     * by the specified comparator (that is, <tt>c.compare(e1, e2)</tt> must not
     * throw a <tt>ClassCastException</tt> for any elements <tt>e1</tt> and
     * <tt>e2</tt> in the range).
     * <p>
     * 
     * This sort is guaranteed to be <i>stable</i>: equal elements will not be
     * reordered as a result of the sort.
     * <p>
     * 
     * The sorting algorithm is a modified mergesort (in which the merge is
     * omitted if the highest element in the low sublist is less than the lowest
     * element in the high sublist). This algorithm offers guaranteed n*log(n)
     * performance, and can approach linear performance on nearly sorted lists.
     * 
     * @param from
     *            the index of the first element (inclusive) to be sorted.
     * @param to
     *            the index of the last element (inclusive) to be sorted.
     * @param c
     *            the comparator to determine the order of the receiver.
     * @throws ClassCastException
     *             if the array contains elements that are not <i>mutually
     *             comparable</i> using the specified comparator.
     * @throws IllegalArgumentException
     *             if <tt>fromIndex &gt; toIndex</tt>
     * @throws ArrayIndexOutOfBoundsException
     *             if <tt>fromIndex &lt; 0</tt> or
     *             <tt>toIndex &gt; a.length</tt>
     * @exception IndexOutOfBoundsException
     *                index is out of range (
     *                <tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>
     *                ).
     */

#Code:
    public void mergeSortFromTo(int from, int to, FloatComparator c) {
        int mySize = size();
        checkRangeFromTo(from, to, mySize);

        float[] myElements = elements();
        cern.colt.Sorting.mergeSort(myElements, from, to + 1, c);
        elements(myElements);
        setSizeRaw(mySize);
    }

#No. 2279
#File: E:\bishe\1\AbstractFloatList.java
#Comment:
    /**
     * Returns a new list of the part of the receiver between <code>from</code>,
     * inclusive, and <code>to</code>, inclusive.
     * 
     * @param from
     *            the index of the first element (inclusive).
     * @param to
     *            the index of the last element (inclusive).
     * @return a new list
     * @exception IndexOutOfBoundsException
     *                index is out of range (
     *                <tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>
     *                ).
     */

#Code:
    public AbstractFloatList partFromTo(int from, int to) {
        checkRangeFromTo(from, to, size);

        int length = to - from + 1;
        FloatArrayList part = new FloatArrayList(length);
        part.addAllOfFromTo(this, from, to);
        return part;
    }

#No. 2280
#File: E:\bishe\1\AbstractFloatList.java
#Comment:
    /**
     * Sorts the specified range of the receiver into ascending numerical order.
     * The sorting algorithm is a tuned quicksort, adapted from Jon L. Bentley
     * and M. Douglas McIlroy's "Engineering a Sort Function", Software-Practice
     * and Experience, Vol. 23(11) P. 1249-1265 (November 1993). This algorithm
     * offers n*log(n) performance on many data sets that cause other quicksorts
     * to degrade to quadratic performance.
     * 
     * <p>
     * <b>You should never call this method unless you are sure that this
     * particular sorting algorithm is the right one for your data set.</b> It
     * is generally better to call <tt>sort()</tt> or <tt>sortFromTo(...)</tt>
     * instead, because those methods automatically choose the best sorting
     * algorithm.
     * 
     * @param from
     *            the index of the first element (inclusive) to be sorted.
     * @param to
     *            the index of the last element (inclusive) to be sorted.
     * @exception IndexOutOfBoundsException
     *                index is out of range (
     *                <tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>
     *                ).
     */

#Code:

    public void quickSortFromTo(int from, int to) {
        int mySize = size();
        checkRangeFromTo(from, to, mySize);

        float[] myElements = elements();
        java.util.Arrays.sort(myElements, from, to + 1);
        //        cern.colt.Sorting.parallelQuickSort(myElements, from, to + 1, new FloatComparator() {
        //            public int compare(float a, float b) {
        //                return a < b ? -1 : (a == b ? 0 : 1);
        //            }
        //
        //        });
        elements(myElements);
        setSizeRaw(mySize);
    }

#No. 2281
#File: E:\bishe\1\AbstractFloatList.java
#Comment:
    /**
     * Sorts the receiver according to the order induced by the specified
     * comparator. All elements in the range must be <i>mutually comparable</i>
     * by the specified comparator (that is, <tt>c.compare(e1, e2)</tt> must not
     * throw a <tt>ClassCastException</tt> for any elements <tt>e1</tt> and
     * <tt>e2</tt> in the range).
     * <p>
     * 
     * The sorting algorithm is a tuned quicksort, adapted from Jon L. Bentley
     * and M. Douglas McIlroy's "Engineering a Sort Function", Software-Practice
     * and Experience, Vol. 23(11) P. 1249-1265 (November 1993). This algorithm
     * offers n*log(n) performance on many data sets that cause other quicksorts
     * to degrade to quadratic performance.
     * 
     * @param from
     *            the index of the first element (inclusive) to be sorted.
     * @param to
     *            the index of the last element (inclusive) to be sorted.
     * @param c
     *            the comparator to determine the order of the receiver.
     * @throws ClassCastException
     *             if the array contains elements that are not <i>mutually
     *             comparable</i> using the specified comparator.
     * @throws IllegalArgumentException
     *             if <tt>fromIndex &gt; toIndex</tt>
     * @throws ArrayIndexOutOfBoundsException
     *             if <tt>fromIndex &lt; 0</tt> or
     *             <tt>toIndex &gt; a.length</tt>
     * @exception IndexOutOfBoundsException
     *                index is out of range (
     *                <tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>
     *                ).
     */

#Code:
    public void quickSortFromTo(int from, int to, FloatComparator c) {
        int mySize = size();
        checkRangeFromTo(from, to, mySize);

        float[] myElements = elements();
        cern.colt.Sorting.quickSort(myElements, from, to + 1, c);
        elements(myElements);
        setSizeRaw(mySize);
    }

#No. 2282
#File: E:\bishe\1\AbstractFloatList.java
#Comment:
    /**
     * Removes from the receiver all elements that are contained in the
     * specified list. Tests for identity.
     * 
     * @param other
     *            the other list.
     * @return <code>true</code> if the receiver changed as a result of the
     *         call.
     */

#Code:
    public boolean removeAll(AbstractFloatList other) {
        if (other.size() == 0)
            return false; // nothing to do
        int limit = other.size() - 1;
        int j = 0;

        for (int i = 0; i < size; i++) {
            if (other.indexOfFromTo(getQuick(i), 0, limit) < 0)
                setQuick(j++, getQuick(i));
        }

        boolean modified = (j != size);
        setSize(j);
        return modified;
    }

#No. 2283
#File: E:\bishe\1\AbstractFloatList.java
#Comment:
    /**
     * Removes from the receiver all elements whose index is between
     * <code>from</code>, inclusive and <code>to</code>, inclusive. Shifts any
     * succeeding elements to the left (reduces their index). This call shortens
     * the list by <tt>(to - from + 1)</tt> elements.
     * 
     * @param from
     *            index of first element to be removed.
     * @param to
     *            index of last element to be removed.
     * @exception IndexOutOfBoundsException
     *                index is out of range (
     *                <tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>
     *                ).
     */

#Code:

    public void removeFromTo(int from, int to) {
        checkRangeFromTo(from, to, size);
        int numMoved = size - to - 1;
        if (numMoved > 0) {
            replaceFromToWithFrom(from, from - 1 + numMoved, this, to + 1);
            // fillFromToWith(from+numMoved, size-1, 0.0f); //delta
        }
        int width = to - from + 1;
        if (width > 0)
            setSizeRaw(size - width);
    }

#No. 2284
#File: E:\bishe\1\AbstractFloatList.java
#Comment:
    /**
     * Replaces a number of elements in the receiver with the same number of
     * elements of another list. Replaces elements in the receiver, between
     * <code>from</code> (inclusive) and <code>to</code> (inclusive), with
     * elements of <code>other</code>, starting from <code>otherFrom</code>
     * (inclusive).
     * 
     * @param from
     *            the position of the first element to be replaced in the
     *            receiver
     * @param to
     *            the position of the last element to be replaced in the
     *            receiver
     * @param other
     *            list holding elements to be copied into the receiver.
     * @param otherFrom
     *            position of first element within other list to be copied.
     */

#Code:
    public void replaceFromToWithFrom(int from, int to, AbstractFloatList other, int otherFrom) {
        int length = to - from + 1;
        if (length > 0) {
            checkRangeFromTo(from, to, size());
            checkRangeFromTo(otherFrom, otherFrom + length - 1, other.size());

            // unambiguous copy (it may hold other==this)
            if (from <= otherFrom) {
                for (; --length >= 0;)
                    setQuick(from++, other.getQuick(otherFrom++));
            } else {
                int otherTo = otherFrom + length - 1;
                for (; --length >= 0;)
                    setQuick(to--, other.getQuick(otherTo--));
            }

        }
    }

#No. 2285
#File: E:\bishe\1\AbstractFloatList.java
#Comment:
    /**
     * Replaces the part between <code>from</code> (inclusive) and
     * <code>to</code> (inclusive) with the other list's part between
     * <code>otherFrom</code> and <code>otherTo</code>. Powerful (and tricky)
     * method! Both parts need not be of the same size (part A can both be
     * smaller or larger than part B). Parts may overlap. Receiver and other
     * list may (but most not) be identical. If <code>from &gt; to</code>, then
     * inserts other part before <code>from</code>.
     * 
     * @param from
     *            the first element of the receiver (inclusive)
     * @param to
     *            the last element of the receiver (inclusive)
     * @param other
     *            the other list (may be identical with receiver)
     * @param otherFrom
     *            the first element of the other list (inclusive)
     * @param otherTo
     *            the last element of the other list (inclusive)
     * 
     *            <p>
     *            <b>Examples:</b>
     * 
     *            <pre>
     * a=[0, 1, 2, 3, 4, 5, 6, 7]
     * b=[50, 60, 70, 80, 90]
     * a.R(...)=a.replaceFromToWithFromTo(...)
     * 
     * a.R(3,5,b,0,4)--&gt;[0, 1, 2, 50, 60, 70, 80, 90, 6, 7]
     * a.R(1,6,b,0,4)--&gt;[0, 50, 60, 70, 80, 90, 7]
     * a.R(0,6,b,0,4)--&gt;[50, 60, 70, 80, 90, 7]
     * a.R(3,5,b,1,2)--&gt;[0, 1, 2, 60, 70, 6, 7]
     * a.R(1,6,b,1,2)--&gt;[0, 60, 70, 7]
     * a.R(0,6,b,1,2)--&gt;[60, 70, 7]
     * a.R(5,3,b,0,4)--&gt;[0, 1, 2, 3, 4, 50, 60, 70, 80, 90, 5, 6, 7]
     * a.R(5,0,b,0,4)--&gt;[0, 1, 2, 3, 4, 50, 60, 70, 80, 90, 5, 6, 7]
     * a.R(5,3,b,1,2)--&gt;[0, 1, 2, 3, 4, 60, 70, 5, 6, 7]
     * a.R(5,0,b,1,2)--&gt;[0, 1, 2, 3, 4, 60, 70, 5, 6, 7]
     * 
     * Extreme cases:
     * a.R(5,3,b,0,0)--&gt;[0, 1, 2, 3, 4, 50, 5, 6, 7]
     * a.R(5,3,b,4,4)--&gt;[0, 1, 2, 3, 4, 90, 5, 6, 7]
     * a.R(3,5,a,0,1)--&gt;[0, 1, 2, 0, 1, 6, 7]
     * a.R(3,5,a,3,5)--&gt;[0, 1, 2, 3, 4, 5, 6, 7]
     * a.R(3,5,a,4,4)--&gt;[0, 1, 2, 4, 6, 7]
     * a.R(5,3,a,0,4)--&gt;[0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 5, 6, 7]
     * a.R(0,-1,b,0,4)--&gt;[50, 60, 70, 80, 90, 0, 1, 2, 3, 4, 5, 6, 7]
     * a.R(0,-1,a,0,4)--&gt;[0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 5, 6, 7]
     * a.R(8,0,a,0,4)--&gt;[0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4]
     * </pre>
     */

#Code:
    public void replaceFromToWithFromTo(int from, int to, AbstractFloatList other, int otherFrom, int otherTo) {
        if (otherFrom > otherTo) {
            throw new IndexOutOfBoundsException("otherFrom: " + otherFrom + ", otherTo: " + otherTo);
        }

        if (this == other && to - from != otherTo - otherFrom) { // avoid
            // stumbling
            // over my
            // own feet
            replaceFromToWithFromTo(from, to, partFromTo(otherFrom, otherTo), 0, otherTo - otherFrom);
            return;
        }

        int length = otherTo - otherFrom + 1;
        int diff = length;
        int theLast = from - 1;

        if (to >= from) {
            diff -= (to - from + 1);
            theLast = to;
        }

        if (diff > 0) {
            beforeInsertDummies(theLast + 1, diff);
        } else {
            if (diff < 0) {
                removeFromTo(theLast + diff, theLast - 1);
            }
        }

        if (length > 0) {
            replaceFromToWithFrom(from, from + length - 1, other, otherFrom);
        }
    }

#No. 2286
#File: E:\bishe\1\AbstractFloatList.java
#Comment:
    /**
     * Replaces the part of the receiver starting at <code>from</code>
     * (inclusive) with all the elements of the specified collection. Does not
     * alter the size of the receiver. Replaces exactly
     * <tt>Math.max(0,Math.min(size()-from, other.size()))</tt> elements.
     * 
     * @param from
     *            the index at which to copy the first element from the
     *            specified collection.
     * @param other
     *            Collection to replace part of the receiver
     * @exception IndexOutOfBoundsException
     *                index is out of range (index &lt; 0 || index &gt;=
     *                size()).
     */

#Code:

    public void replaceFromWith(int from, java.util.Collection other) {
        checkRange(from, size());
        java.util.Iterator e = other.iterator();
        int index = from;
        int limit = Math.min(size() - from, other.size());
        for (int i = 0; i < limit; i++)
            set(index++, ((Number) e.next()).floatValue()); // delta
    }

#No. 2287
#File: E:\bishe\1\AbstractFloatList.java
#Comment:
    /**
     * Retains (keeps) only the elements in the receiver that are contained in
     * the specified other list. In other words, removes from the receiver all
     * of its elements that are not contained in the specified other list.
     * 
     * @param other
     *            the other list to test against.
     * @return <code>true</code> if the receiver changed as a result of the
     *         call.
     */

#Code:
    public boolean retainAll(AbstractFloatList other) {
        if (other.size() == 0) {
            if (size == 0)
                return false;
            setSize(0);
            return true;
        }

        int limit = other.size() - 1;
        int j = 0;
        for (int i = 0; i < size; i++) {
            if (other.indexOfFromTo(getQuick(i), 0, limit) >= 0)
                setQuick(j++, getQuick(i));
        }

        boolean modified = (j != size);
        setSize(j);
        return modified;
    }

#No. 2288
#File: E:\bishe\1\AbstractFloatList.java
#Comment:
    /**
     * Reverses the elements of the receiver. Last becomes first, second last
     * becomes second first, and so on.
     */

#Code:

    public void reverse() {
        float tmp;
        int limit = size() / 2;
        int j = size() - 1;

        for (int i = 0; i < limit;) { // swap
            tmp = getQuick(i);
            setQuick(i++, getQuick(j));
            setQuick(j--, tmp);
        }
    }

#No. 2289
#File: E:\bishe\1\AbstractFloatList.java
#Comment:
    /**
     * Replaces the element at the specified position in the receiver with the
     * specified element.
     * 
     * @param index
     *            index of element to replace.
     * @param element
     *            element to be stored at the specified position.
     * @throws IndexOutOfBoundsException
     *             if <tt>index &lt; 0 || index &gt;= size()</tt>.
     */

#Code:
    public void set(int index, float element) {
        if (index >= size || index < 0)
            throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size);
        setQuick(index, element);
    }

#No. 2290
#File: E:\bishe\1\AbstractFloatList.java
#Comment:
    /**
     * Sets the size of the receiver without modifying it otherwise. This method
     * should not release or allocate new memory but simply set some instance
     * variable like <tt>size</tt>.
     * 
     * If your subclass overrides and delegates size changing methods to some
     * other object, you must make sure that those overriding methods not only
     * update the size of the delegate but also of this class. For example:
     * public DatabaseList extends AbstractFloatList { ... public void
     * removeFromTo(int from,int to) { myDatabase.removeFromTo(from,to);
     * this.setSizeRaw(size-(to-from+1)); } }
     */

#Code:
    protected void setSizeRaw(int newSize) {
        size = newSize;
    }

#No. 2291
#File: E:\bishe\1\AbstractFloatList.java
#Comment:
    /**
     * Randomly permutes the part of the receiver between <code>from</code>
     * (inclusive) and <code>to</code> (inclusive).
     * 
     * @param from
     *            the index of the first element (inclusive) to be permuted.
     * @param to
     *            the index of the last element (inclusive) to be permuted.
     * @exception IndexOutOfBoundsException
     *                index is out of range (
     *                <tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>
     *                ).
     */

#Code:

    public void shuffleFromTo(int from, int to) {
        checkRangeFromTo(from, to, size());

        cern.jet.random.tfloat.FloatUniform gen = new cern.jet.random.tfloat.FloatUniform(AbstractFloatDistribution
                .makeDefaultGenerator());
        for (int i = from; i < to; i++) {
            int random = gen.nextIntFromTo(i, to);

            // swap(i, random)
            float tmpElement = getQuick(random);
            setQuick(random, getQuick(i));
            setQuick(i, tmpElement);
        }
    }

#No. 2292
#File: E:\bishe\1\AbstractFloatList.java
#Comment:
    /**
     * Returns the number of elements contained in the receiver.
     * 
     * @return the number of elements contained in the receiver.
     */

#Code:

    public int size() {
        return size;
    }

#No. 2293
#File: E:\bishe\1\AbstractFloatList.java
#Comment:
    /**
     * Returns a list which is a concatenation of <code>times</code> times the
     * receiver.
     * 
     * @param times
     *            the number of times the receiver shall be copied.
     */

#Code:
    public AbstractFloatList times(int times) {
        AbstractFloatList newList = new FloatArrayList(times * size());
        for (int i = times; --i >= 0;) {
            newList.addAllOfFromTo(this, 0, size() - 1);
        }
        return newList;
    }

#No. 2294
#File: E:\bishe\1\AbstractFloatList.java
#Comment:
    /**
     * Returns a <code>java.util.ArrayList</code> containing all the elements in
     * the receiver.
     */

#Code:

    public java.util.ArrayList toList() {
        int mySize = size();
        java.util.ArrayList list = new java.util.ArrayList(mySize);
        for (int i = 0; i < mySize; i++)
            list.add(new Float(get(i)));
        return list;
    }

#No. 2295
#File: E:\bishe\1\AbstractFloatList.java
#Comment:
    /**
     * Returns a string representation of the receiver, containing the String
     * representation of each element.
     */

#Code:

    public String toString() {
        return cern.colt.Arrays.toString(partFromTo(0, size() - 1).elements());
    }

#No. 2296
#File: E:\bishe\1\AbstractFolder.java
#Comment:
    /**
     * Remove an action.
     * Note: calls to {@link #getAllActions()} that happen before calls to this method may not see the update.
     * Note: this method does not affect transient actions contributed by a {@link TransientActionFactory}
     *
     * @param a an action to remove (if {@code null} then this will be a no-op)
     * @return {@code true} if this actions changed as a result of the call
     * @since FIXME
     */

#Code:
    // TODO remove once baseline has JENKINS-39404
    @SuppressWarnings("deprecation")
    public boolean removeAction(@Nullable Action a) {
        if (a == null) {
            return false;
        }

#No. 2297
#File: E:\bishe\1\AbstractFolder.java
#Comment:
    /**
     * Removes any actions of the specified type.
     * Note: calls to {@link #getAllActions()} that happen before calls to this method may not see the update.
     * Note: this method does not affect transient actions contributed by a {@link TransientActionFactory}
     *
     * @param clazz the type of actions to remove
     * @return {@code true} if this actions changed as a result of the call
     * @since FIXME
     */

#Code:
    // TODO remove once baseline has JENKINS-39404
    @SuppressWarnings({"ConstantConditions", "deprecation"})
    @SuppressFBWarnings("RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE")
    public boolean removeActions(@Nonnull Class<? extends Action> clazz) {
        if (clazz == null) {
            throw new IllegalArgumentException("Action type must be non-null");
        }

#No. 2298
#File: E:\bishe\1\AbstractFolder.java
#Comment:
    /**
     * Replaces any actions of the specified type by the supplied action.
     * Note: calls to {@link #getAllActions()} that happen before calls to this method may not see the update.
     * Note: this method does not affect transient actions contributed by a {@link TransientActionFactory}
     *
     * @param clazz the type of actions to replace (note that the action you are replacing this with need not extend
     *              this class)
     * @param a     the action to replace with
     * @return {@code true} if this actions changed as a result of the call
     * @since FIXME
     */

#Code:
    // TODO remove once baseline has JENKINS-39404
    @SuppressWarnings({"ConstantConditions", "deprecation"})
    @SuppressFBWarnings("RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE")
    public boolean replaceActions(@Nonnull Class<? extends Action> clazz, Action a) {
        if (clazz == null) {
            throw new IllegalArgumentException("Action type must be non-null");
        }

#No. 2299
#File: E:\bishe\1\AbstractFolder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public AbstractFolderDescriptor getDescriptor() {
        return (AbstractFolderDescriptor) Jenkins.getActiveInstance().getDescriptorOrDie(getClass());
    }

#No. 2300
#File: E:\bishe\1\AbstractFolder.java
#Comment:
    /**
     * May be used to enumerate or remove properties.
     * To add properties, use {@link #addProperty}.
     */

#Code:
    public DescribableList<AbstractFolderProperty<?>,AbstractFolderPropertyDescriptor> getProperties() {
        return properties;
    }

#No. 2301
#File: E:\bishe\1\AbstractFolder.java
#Comment:
    /**
     * It is unwise to override this, lest links to children from nondefault {@link View}s break.
     * TODO remove this warning if and when JENKINS-35243 is fixed in the baseline.
     * {@inheritDoc}
     */

#Code:
    @Override
    public String getUrlChildPrefix() {
        return "job";
    }

#No. 2302
#File: E:\bishe\1\AbstractFolder.java
#Comment:
    /**
     * For URL binding.
     * @see #getUrlChildPrefix
     */

#Code:
    public I getJob(String name) {
        return getItem(name);
    }

#No. 2303
#File: E:\bishe\1\AbstractFolder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public String getPronoun() {
        return AlternativeUiTextProvider.get(PRONOUN, this, getDescriptor().getDisplayName());
    }

#No. 2304
#File: E:\bishe\1\AbstractFolder.java
#Comment:
    /**
     * Overrides from job properties.
     */

#Code:
    @Override
    public Collection<?> getOverrides() {
        List<Object> r = new ArrayList<Object>();
        for (AbstractFolderProperty<?> p : properties) {
            r.addAll(p.getItemContainerOverrides());
        }
        return r;
    }

#No. 2305
#File: E:\bishe\1\AbstractFolder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public void addView(View v) throws IOException {
        viewGroupMixIn.addView(v);
    }

#No. 2306
#File: E:\bishe\1\AbstractFolder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public boolean canDelete(View view) {
        return viewGroupMixIn.canDelete(view);
    }

#No. 2307
#File: E:\bishe\1\AbstractFolder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public void deleteView(View view) throws IOException {
        viewGroupMixIn.deleteView(view);
    }

#No. 2308
#File: E:\bishe\1\AbstractFolder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public View getView(String name) {
        return viewGroupMixIn.getView(name);
    }

#No. 2309
#File: E:\bishe\1\AbstractFolder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Exported
    @Override
    public Collection<View> getViews() {
        return viewGroupMixIn.getViews();
    }

#No. 2310
#File: E:\bishe\1\AbstractFolder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Exported
    @Override
    public View getPrimaryView() {
        return viewGroupMixIn.getPrimaryView();
    }

#No. 2311
#File: E:\bishe\1\AbstractFolder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public void onViewRenamed(View view, String oldName, String newName) {
        viewGroupMixIn.onViewRenamed(view, oldName, newName);
    }

#No. 2312
#File: E:\bishe\1\AbstractFolder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public ViewsTabBar getViewsTabBar() {
        return folderViews.getTabBar();
    }

#No. 2313
#File: E:\bishe\1\AbstractFolder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public ItemGroup<? extends TopLevelItem> getItemGroup() {
        return this;
    }

#No. 2314
#File: E:\bishe\1\AbstractFolder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public List<Action> getViewActions() {
        return Collections.emptyList();
    }

#No. 2315
#File: E:\bishe\1\AbstractFolder.java
#Comment:
    /**
     * Fallback to the primary view.
     */

#Code:
    @Override
    public View getStaplerFallback() {
        return getPrimaryView();
    }

#No. 2316
#File: E:\bishe\1\AbstractFolder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    protected SearchIndexBuilder makeSearchIndex() {
        return super.makeSearchIndex().add(new CollectionSearchIndex<TopLevelItem>() {
            /**
             * {@inheritDoc}
             */
            @Override
            protected SearchItem get(String key) {
                return Jenkins.getActiveInstance().getItem(key, grp());
            }

            /**
             * {@inheritDoc}
             */
            @Override
            protected Collection<TopLevelItem> all() {
                return Items.getAllItems(grp(), TopLevelItem.class);
            }

            /**
             * {@inheritDoc}
             */
            @Override
            protected String getName(TopLevelItem j) {
                return j.getRelativeNameFrom(grp());
            }
            /** Disambiguates calls that otherwise would match {@link Item} too. */
            private ItemGroup<?> grp() {
                return AbstractFolder.this;
            }
        });
    }

#No. 2317
#File: E:\bishe\1\AbstractFolder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public ContextMenu doChildrenContextMenu(StaplerRequest request, StaplerResponse response) {
        ContextMenu menu = new ContextMenu();
        for (View view : getViews()) {
            menu.add(view.getAbsoluteUrl(),view.getDisplayName());
        }
        return menu;
    }

#No. 2318
#File: E:\bishe\1\AbstractFolder.java
#Comment:
    /**
     * Checks if a top-level view with the given name exists.
     */

#Code:
    public FormValidation doViewExistsCheck(@QueryParameter String value) {
        checkPermission(View.CREATE);

        String view = fixEmpty(value);
        if (view == null) {
            return FormValidation.ok();
        }

#No. 2319
#File: E:\bishe\1\AbstractFolder.java
#Comment:
    /**
     * Get the current health report for a folder.
     *
     * @return the health report. Never returns null
     */

#Code:
    public HealthReport getBuildHealth() {
        List<HealthReport> reports = getBuildHealthReports();
        return reports.isEmpty() ? new HealthReport() : reports.get(0);
    }

#No. 2320
#File: E:\bishe\1\AbstractFolder.java
#Comment:
    /**
     * Invalidates the cache of build health reports.
     *
     * @since FIXME
     */

#Code:
    public void invalidateBuildHealthReports() {
        healthReports = null;
    }

#No. 2321
#File: E:\bishe\1\AbstractFolder.java
#Comment:
    /**
     * Gets the icon used for this folder.
     */

#Code:
    public FolderIcon getIcon() {
        return icon;
    }

#No. 2322
#File: E:\bishe\1\AbstractFolder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public Collection<? extends Job> getAllJobs() {
        Set<Job> jobs = new HashSet<Job>();
        for (Item i : getItems()) {
            jobs.addAll(i.getAllJobs());
        }
        return jobs;
    }

#No. 2323
#File: E:\bishe\1\AbstractFolder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Exported(name="jobs")
    @Override
    public Collection<I> getItems() {
        List<I> viewableItems = new ArrayList<I>();
        for (I item : items.values()) {
            if (item.hasPermission(Item.READ)) {
                viewableItems.add(item);
            }
        }
        return viewableItems;
    }

#No. 2324
#File: E:\bishe\1\AbstractFolder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public I getItem(String name) throws AccessDeniedException {
        if (items == null) {
            return null;
        }
        I item = items.get(name);
        if (item == null) {
            return null;
        }
        if (!item.hasPermission(Item.READ)) {
            if (item.hasPermission(Item.DISCOVER)) {
                throw new AccessDeniedException("Please log in to access " + name);
            }
            return null;
        }
        return item;
    }

#No. 2325
#File: E:\bishe\1\AbstractFolder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @SuppressWarnings("deprecation")
    @Override
    public void onRenamed(I item, String oldName, String newName) throws IOException {
        items.remove(oldName);
        items.put(newName, item);
        // For compatibility with old views:
        for (View v : folderViews.getViews()) {
            v.onJobRenamed(item, oldName, newName);
        }
        save();
    }

#No. 2326
#File: E:\bishe\1\AbstractFolder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @SuppressWarnings("deprecation")
    @Override
    public void onDeleted(I item) throws IOException {
        ItemListener.fireOnDeleted(item);
        items.remove(item.getName());
        // For compatibility with old views:
        for (View v : folderViews.getViews()) {
            v.onJobRenamed(item, item.getName(), null);
        }
        save();
    }

#No. 2327
#File: E:\bishe\1\AbstractFolder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public synchronized void save() throws IOException {
        if (folderViews != null) {
            folderViews.invalidateCaches();
        }
        if (BulkChange.contains(this)) {
            return;
        }
        super.save();
        // TODO should this not just be done in AbstractItem?
        ItemListener.fireOnUpdated(this);
    }

#No. 2328
#File: E:\bishe\1\AbstractFolder.java
#Comment:
    /**
     * Renames this item container.
     */

#Code:
    @Override
    public void renameTo(String newName) throws IOException {
        super.renameTo(newName);
    }

#No. 2329
#File: E:\bishe\1\AbstractFolder.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public synchronized void doSubmitDescription(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {
        getPrimaryView().doSubmitDescription(req, rsp);
    }

#No. 2330
#File: E:\bishe\1\AbstractFolder.java
#Comment:
    /**
     * Where user will be redirected after creating or reconfiguring a {@code AbstractFolder}.
     *
     * @return A string that represents the redirect location URL.
     *
     * @see javax.servlet.http.HttpServletResponse#sendRedirect(String)
     */

#Code:
    @Restricted(NoExternalUse.class)
    @Nonnull
    protected String getSuccessfulDestination() {
        return ".";
    }

#No. 2331
#File: E:\bishe\1\AbstractFolder.java
#Comment:
    /**
     * Allows a subclass to block renames under dynamic conditions.
     * @return a message if rename should currently be prohibited, or null to allow
     */

#Code:
    @CheckForNull
    protected String renameBlocker() {
        for (Job<?,?> job : getAllJobs()) {
            if (job.isBuilding()) {
                return "Unable to rename a folder while a job inside it is building.";
            }
        }
        return null;
    }

#No. 2332
#File: E:\bishe\1\AbstractFolderIdWrapper.java
#Comment:
	/**
	 * Validates folderId against specified version.
	 * 
	 * @param version
	 *            the version
	 * @throws ServiceVersionException
	 *             the service version exception
	 */

#Code:
	protected void validate(ExchangeVersion version)
			throws ServiceVersionException {
	}

#No. 2333
#File: E:\bishe\1\AbstractFolderProperty.java
#Comment:
/**
 * Property potentially applicable to any {@link AbstractFolder}.
 * @since 4.11-beta-1
 */

#Code:
public abstract class AbstractFolderProperty<C extends AbstractFolder<?>> extends AbstractDescribableImpl<AbstractFolderProperty<?>> implements ExtensionPoint, ReconfigurableDescribable<AbstractFolderProperty<?>> {

    /**
     * The {@link AbstractFolder} object that owns this property.
     * This value will be set by the folder.
     * Derived classes can expect this value to be always set.
     */
    protected transient C owner;

    /**
     * Hook for performing post-initialization action.
     */
    protected void setOwner(@NonNull C owner) {
        this.owner = owner;
    }

#No. 2334
#File: E:\bishe\1\AbstractFolderProperty.java
#Comment:
    /**
     * Gets an owner of the property.
     * @return Owner of the property.
     *         It should be always non-null if the property initialized correctly.
     */

#Code:
    @NonNull
    @Restricted(NoExternalUse.class)
    public C getOwner() {
        return owner;
    }

#No. 2335
#File: E:\bishe\1\AbstractFolderProperty.java
#Comment:
    /**
     * Provides stapler override objects to {@link Folder} so that its URL space can be partially
     * overridden by properties.
     *
     * @see StaplerOverridable
     */

#Code:
    public Collection<?> getItemContainerOverrides() {
        return Collections.emptyList();
    }

#No. 2336
#File: E:\bishe\1\AbstractFolderProperty.java
#Comment:
    /**
     * Folder properties can optionally contribute health reports for the folder. These should be reports of the folder
     * directly, where a report requires iteration of the items in the folder use the {@link #getHealthMetrics()}
     * in order to prevent multiple iterations of the items in the folder.
     *
     * @return the list of health reports.
     */

#Code:
    @NonNull
    public List<HealthReport> getHealthReports() {
        return Collections.emptyList();
    }

#No. 2337
#File: E:\bishe\1\AbstractFolderProperty.java
#Comment:
    /**
     * Returns the health metrics contributed by this property.
     *
     * @return the health metrics contributed by this property.
     */

#Code:
    @NonNull
    public List<FolderHealthMetric> getHealthMetrics() {
        return Collections.emptyList();
    }

#No. 2338
#File: E:\bishe\1\AbstractFolderTest.java
#Comment:
    /**
     *
     * This test create one child under root assert size, child list then delete
     */

#Code:
    @Test
    public void create_child_then_remove() throws Exception {

        // create /foo
        long sizeBefore = getFolderRepository().size();
        final Folder foo = getFolderRepository().addFolder(homeFolderId, "/foo");
        long sizeAfter = getFolderRepository().size();
        assertThat(sizeAfter).isEqualTo(sizeBefore + 1);

        // make sure /foo is listed as children
        Iterable<Folder> iterable = getFolderRepository().children(homeFolderId);
        List<Folder> folders = Lists.newArrayList(iterable);
        assertThat(folders).isNotNull().isNotEmpty().hasSize(1);

        // remove /foo
        getFolderRepository().removeFolder(foo.getId());
        sizeAfter = getFolderRepository().size();
        assertThat(sizeAfter).isEqualTo(sizeBefore);

        // make sure it's removed
        iterable = getFolderRepository().children(homeFolderId);
        folders = Lists.newArrayList(iterable);
        assertThat(folders).isNotNull().isEmpty();
    }

#No. 2339
#File: E:\bishe\1\AbstractFolderTest.java
#Comment:
    /**
     *
     * This test create two folders and a folder entry then copy it to the other folder
     */

#Code:
    @Test
    public void create_entry_then_copy() throws Exception {

        // 2 folders /foo & /bar
        long sizeBefore = getFolderRepository().size();
        Folder foo = getFolderRepository().addFolder(homeFolderId, "foo");
        Folder bar = getFolderRepository().addFolder(homeFolderId, "bar");
        long sizeAfter = getFolderRepository().size();
        assertThat(sizeAfter).isEqualTo(sizeBefore + 2);
        assertChildrenSize(homeFolderId, 2);

        //  bordeaux in /foo
        FolderEntry wineEntry = new FolderEntry(DATASET, "bordeaux");
        getFolderRepository().addFolderEntry(wineEntry, foo.getId());
        Iterable<FolderEntry> folderEntries = getFolderRepository().entries(foo.getId(), DATASET);
        List<FolderEntry> entries = Lists.newArrayList(folderEntries);
        assertThat(entries).isNotNull().isNotEmpty().hasSize(1).contains(wineEntry);

        // copy bordeaux in /bar
        getFolderRepository().copyFolderEntry(wineEntry, bar.getId());
        folderEntries = getFolderRepository().entries(bar.getId(), DATASET);
        entries = Lists.newArrayList(folderEntries);
        assertThat(entries).isNotNull().isNotEmpty().hasSize(1);
        assertFolderEntry(entries.get(0), "bordeaux", DATASET);

        // still in foo as it's a copy
        folderEntries = getFolderRepository().entries(foo.getId(), DATASET);
        entries = Lists.newArrayList(folderEntries);
        assertThat(entries).isNotNull().isNotEmpty().hasSize(1).contains(wineEntry);

    }

#No. 2340
#File: E:\bishe\1\AbstractFolderTest.java
#Comment:
    /**
     *
     * This test create two folders and a folder entry then move it to the other folder
     */

#Code:
    @Test
    public void create_entry_then_move() throws Exception {

        // 2 folders /foo & /bar
        long sizeBefore = getFolderRepository().size();
        Folder foo = getFolderRepository().addFolder(homeFolderId, "foo");
        Folder bar = getFolderRepository().addFolder(homeFolderId, "bar");
        long sizeAfter = getFolderRepository().size();
        assertThat(sizeAfter).isEqualTo(sizeBefore + 2);
        assertChildrenSize(homeFolderId, 2);

        // bordeaux in /foo
        FolderEntry wineEntry = new FolderEntry(DATASET, "bordeaux");
        getFolderRepository().addFolderEntry(wineEntry, foo.getId());
        Iterable<FolderEntry> folderEntries = getFolderRepository().entries(foo.getId(), DATASET);
        List<FolderEntry> entries = Lists.newArrayList(folderEntries);
        assertThat(entries).isNotNull().isNotEmpty().hasSize(1).contains(wineEntry);

        // move bordeaux to /bar
        getFolderRepository().moveFolderEntry(wineEntry, foo.getId(), bar.getId());
        folderEntries = getFolderRepository().entries(bar.getId(), DATASET);
        entries = Lists.newArrayList(folderEntries);
        assertThat(entries).isNotNull().isNotEmpty().hasSize(1);
        assertFolderEntry(entries.get(0), "bordeaux", DATASET);

        // not in foo as it's a move
        folderEntries = getFolderRepository().entries(foo.getId(), DATASET);
        entries = Lists.newArrayList(folderEntries);
        assertThat(entries).isNotNull().isEmpty();

    }

#No. 2341
#File: E:\bishe\1\AbstractFolderTest.java
#Comment:
    /**
     *
     * This test create folders and search in names
     */

#Code:
    @Test
    public void create_folders_then_search() throws Exception {
        // given
        long sizeBefore = getFolderRepository().size();
        final Folder foo = getFolderRepository().addFolder(homeFolderId, "foo");
        getFolderRepository().addFolder(homeFolderId, "bar");
        long sizeAfter = getFolderRepository().size();
        assertThat(sizeAfter).isEqualTo(sizeBefore + 2);

        assertChildrenSize(homeFolderId, 2);

        getFolderRepository().addFolder(foo.getId(), "beer");
        Folder wine = getFolderRepository().addFolder(foo.getId(), "wine");
        getFolderRepository().addFolder(wine.getId(), "toto");
        getFolderRepository().addFolder(wine.getId(), "titi");
        getFolderRepository().addFolder(wine.getId(), "thetiti");
        getFolderRepository().addFolder(wine.getId(), "yupTITI");
        getFolderRepository().addFolder(wine.getId(), "yeahTITI");
        getFolderRepository().addFolder(wine.getId(), "goodwine");
        getFolderRepository().addFolder(wine.getId(), "verygoodWInE");

        sizeAfter = getFolderRepository().size();
        assertThat(sizeAfter).isEqualTo(sizeBefore + 2 + 9);

        // when / then
        assertOnSearch("foo", false, 1);
        assertOnSearch("wine", false, 3);
        assertOnSearch("tIti", false, 4);
        assertOnSearch("titi", true, 1); // strict

    }

#No. 2342
#File: E:\bishe\1\AbstractFontContainer.java
#Comment:
  /**
   * PDFBox object which contains the Font Dictionary
   */

#Code:
  protected PDFont font = null;

  protected Map<Integer, GlyphDetail> cidKnownByFont = new HashMap<Integer, GlyphDetail>();

  /**
   * Boolean used to know if the Font Program is embedded.
   */
  protected boolean isFontProgramEmbedded = true;

  /**
   * Errors which occurs during the Font Validation
   */
  protected List<ValidationError> errors = new ArrayList<ValidationError>(0);

  /**
   * The FontContainer Constructor. The type attribute is initialized according
   * to the given PDFont object.
   * 
   * @param fd
   *          Font object of the PDFBox API. (Mandatory)
   * @throws NullPointerException
   *           If the fd is null.
   */
  public AbstractFontContainer(PDFont fd) {
    this.font = fd;
  }

#No. 2343
#File: E:\bishe\1\AbstractFontContainer.java
#Comment:
  /**
   * Return the PDFont object
   * 
   * @return
   */

#Code:
  public PDFont getFont() {
    return font;
  }

#No. 2344
#File: E:\bishe\1\AbstractFontContainer.java
#Comment:
  /**
   * @return the isFontProgramEmbedded
   */

#Code:
  public boolean isFontProgramEmbedded() {
    return isFontProgramEmbedded;
  }

#No. 2345
#File: E:\bishe\1\AbstractFontContainer.java
#Comment:
  /**
   * @param isFontProgramEmbedded
   *          the isFontProgramEmbedded to set
   */

#Code:
  public void setFontProgramEmbedded(boolean isFontProgramEmbedded) {
    this.isFontProgramEmbedded = isFontProgramEmbedded;
  }

#No. 2346
#File: E:\bishe\1\AbstractFontContainer.java
#Comment:
  /**
   * Addition of a validation error.
   * 
   * @param error
   */

#Code:
  public void addError(ValidationError error) {
    this.errors.add(error);
  }

#No. 2347
#File: E:\bishe\1\AbstractFontContainer.java
#Comment:
  /**
   * This method returns the validation state of the font.
   * 
   * If the list of errors is empty, the validation is successful (State :
   * VALID). If the size of the list is 1 and if the error is about EmbeddedFont,
   * the state is "MAYBE" because the font can be valid if
   * it isn't used (for Width error) or if the rendering mode is 3 (For not
   * embedded font). Otherwise, the validation failed (State : INVALID)
   * 
   * @return
   */

#Code:
  public State isValid() {
    if (this.errors.isEmpty()) {
      return State.VALID;
    }

    if ((this.errors.size() == 1)
        && !this.isFontProgramEmbedded) {
      return State.MAYBE;
    }

    // else more than one error, the validation failed
    return State.INVALID;
  }

#No. 2348
#File: E:\bishe\1\AbstractFontContainer.java
#Comment:
  /**
   * @return the errors
   */

#Code:
  public List<ValidationError> getErrors() {
    return errors;
  }

#No. 2349
#File: E:\bishe\1\AbstractFontContainer.java
#Comment:
  /**
   * Check if the cid is present and consistent in the contained font.
   * @param cid the cid
   * @return true if cid is present and consistent, false otherwise
   */

#Code:
  public abstract void checkCID (int cid) throws GlyphException;

  
  void addKnownCidElement(GlyphDetail glyphDetail) {
    this.cidKnownByFont.put(glyphDetail.getCID(), glyphDetail);
  }

#No. 2350
#File: E:\bishe\1\AbstractForm.java
#Comment:
    /**
     * Number of layout columns.<br>
     * Form fields will fill columns in the order they have been specified
     * in {@link #setFields(org.jboss.ballroom.client.widgets.forms.FormItem[])}.
     *
     * @param columns
     */

#Code:
    public void setNumColumns(int columns)
    {
        this.numColumns = columns;
    }

#No. 2351
#File: E:\bishe\1\AbstractForm.java
#Comment:
    /**
     * Specify the form fields.
     * Needs to be called before {@link #asWidget()}.
     *
     * @param items
     */

#Code:
    public void setFields(FormItem... items) {
        setFieldsInGroup(Form.DEFAULT_GROUP, items);
    }

#No. 2352
#File: E:\bishe\1\AbstractForm.java
#Comment:
    /**
     * Enable/disable this form.
     *
     * @param isEnabled
     */

#Code:
    public void setEnabled(boolean isEnabled) {

        this.isEnabled = isEnabled;

        if(deck!=null)  // might no be created yet (backwards compatibility)
            toggleViews();
    }

#No. 2353
#File: E:\bishe\1\AbstractForm.java
#Comment:
    /**
     * Binds a default single selection model to the table
     * that displays selected rows in a form.
     *
     * @param table
     */

#Code:
    public void bind(CellTable<T> table) {
        SingleSelectionModel<T> selectionModel = (SingleSelectionModel<T>)table.getSelectionModel();
        if (selectionModel == null) {
            selectionModel = new SingleSelectionModel<T>();
        }

        final SingleSelectionModel<T> finalSelectionModel = selectionModel;

        selectionModel.addSelectionChangeHandler(new SelectionChangeEvent.Handler() {

            public void onSelectionChange(SelectionChangeEvent event) {

                Scheduler.get().scheduleDeferred(new Scheduler.ScheduledCommand() {

                    public void execute() {
                        T selectedObject = finalSelectionModel.getSelectedObject();
                        if(selectedObject!=null)
                            edit(selectedObject);
                        else
                        {
                            clearValues();

                        }
                    }
                });
            }
        });

        table.setSelectionModel(finalSelectionModel);

        table.addRowCountChangeHandler(new RowCountChangeEvent.Handler() {

            public void onRowCountChange(RowCountChangeEvent event) {
                if(event.getNewRowCount()==0 && event.isNewRowCountExact())
                    clearValues();

            }
        });

    }

#No. 2354
#File: E:\bishe\1\AbstractFormat.java
#Comment:
    /**
     * Create a default number format.  The default number format is based on {@link
     * NumberFormat#getNumberInstance(java.util.Locale)} with the only customizing is the maximum
     * number of BigFraction digits, which is set to 0.
     *
     * @param locale the specific locale used by the format.
     * @return the default number format specific to the given locale.
     */

#Code:
    protected static NumberFormat getDefaultNumberFormat(final Locale locale) {
        final NumberFormat nf = NumberFormat.getNumberInstance(locale);
        nf.setMaximumFractionDigits(0);
        nf.setParseIntegerOnly(true);
        return nf;
    }

#No. 2355
#File: E:\bishe\1\AbstractFormat.java
#Comment:
    /**
     * Access the denominator format.
     *
     * @return the denominator format.
     */

#Code:
    public NumberFormat getDenominatorFormat() {
        return denominatorFormat;
    }

#No. 2356
#File: E:\bishe\1\AbstractFormat.java
#Comment:
    /**
     * Access the numerator format.
     *
     * @return the numerator format.
     */

#Code:
    public NumberFormat getNumeratorFormat() {
        return numeratorFormat;
    }

#No. 2357
#File: E:\bishe\1\AbstractFormat.java
#Comment:
    /**
     * Modify the denominator format.
     *
     * @param format the new denominator format value.
     * @throws IllegalArgumentException if <code>format</code> is <code>null</code>.
     */

#Code:
    public void setDenominatorFormat(final NumberFormat format) {
        if (format == null) {
            throw MathRuntimeException.createIllegalArgumentException(
                    "denominator format can not be null");
        }
        this.denominatorFormat = format;
    }

#No. 2358
#File: E:\bishe\1\AbstractFormat.java
#Comment:
    /**
     * Modify the numerator format.
     *
     * @param format the new numerator format value.
     * @throws IllegalArgumentException if <code>format</code> is <code>null</code>.
     */

#Code:
    public void setNumeratorFormat(final NumberFormat format) {
        if (format == null) {
            throw MathRuntimeException.createIllegalArgumentException(
                    "numerator format can not be null");
        }
        this.numeratorFormat = format;
    }

#No. 2359
#File: E:\bishe\1\AbstractFormat.java
#Comment:
    /**
     * Parses <code>source</code> until a non-whitespace character is found.
     *
     * @param source the string to parse
     * @param pos    input/ouput parsing parameter.  On output, <code>pos</code> holds the index of
     *               the next non-whitespace character.
     */

#Code:
    protected static void parseAndIgnoreWhitespace(final String source,
                                                   final ParsePosition pos) {
        parseNextCharacter(source, pos);
        pos.setIndex(pos.getIndex() - 1);
    }

#No. 2360
#File: E:\bishe\1\AbstractFormat.java
#Comment:
    /**
     * Parses <code>source</code> until a non-whitespace character is found.
     *
     * @param source the string to parse
     * @param pos    input/ouput parsing parameter.
     * @return the first non-whitespace character.
     */

#Code:
    protected static char parseNextCharacter(final String source,
                                             final ParsePosition pos) {
        int index = pos.getIndex();
        final int n = source.length();
        char ret = 0;

        if (index < n) {
            char c;
            do {
                c = source.charAt(index++);
            } while (Character.isWhitespace(c) && index < n);
            pos.setIndex(index);

            if (index < n) {
                ret = c;
            }
        }

        return ret;
    }

#No. 2361
#File: E:\bishe\1\AbstractFormat.java
#Comment:
    /**
     * Formats a double value as a fraction and appends the result to a StringBuffer.
     *
     * @param value    the double value to format
     * @param buffer   StringBuffer to append to
     * @param position On input: an alignment field, if desired. On output: the offsets of the
     *                 alignment field
     * @return a reference to the appended buffer
     * @see #format(Object, StringBuffer, FieldPosition)
     */

#Code:
    @Override
    public StringBuffer format(final double value,
                               final StringBuffer buffer, final FieldPosition position) {
        return format(Double.valueOf(value), buffer, position);
    }

#No. 2362
#File: E:\bishe\1\AbstractFormat.java
#Comment:
    /**
     * Formats a long value as a fraction and appends the result to a StringBuffer.
     *
     * @param value    the long value to format
     * @param buffer   StringBuffer to append to
     * @param position On input: an alignment field, if desired. On output: the offsets of the
     *                 alignment field
     * @return a reference to the appended buffer
     * @see #format(Object, StringBuffer, FieldPosition)
     */

#Code:
    @Override
    public StringBuffer format(final long value,
                               final StringBuffer buffer, final FieldPosition position) {
        return format(Long.valueOf(value), buffer, position);
    }

#No. 2363
#File: E:\bishe\1\AbstractFormattedDisk.java
#Comment:
    /*
     * All formatted disks will have empty and/or used sectors, so set them
     * here, and let the actual subclass add its sector types later. This list
     * is used to hold one of each sector type so that the DiskLayoutPanel can
     * draw its grid and key correctly. Every additional type that the instance
     * creates should be added here too.
     */

#Code:
    sectorTypesList.add (emptySector);
    sectorTypesList.add (usedSector);
    /*
     * Hopefully every used sector will be changed by the subclass to something
     * sensible, but deleted files will always leave the sector as used/unknown
     * as it contains data.
     */
    setSectorTypes ();
    setGridLayout ();
    /*
     * Create the disk name as the root for the catalog tree. Subclasses will
     * have to append their catalog entries to this node.
     */
    DefaultAppleFileSource afs =
        new DefaultAppleFileSource (getName (), disk.toString (), this);
    DefaultMutableTreeNode root = new DefaultMutableTreeNode (afs);
    DefaultTreeModel treeModel = new DefaultTreeModel (root);
    catalogTree = new JTree (treeModel);
    treeModel.setAsksAllowsChildren (true); // allows empty nodes to appear as folders
    /*
     * Add an ActionListener to the disk in case the interleave or blocksize
     * changes
     */
    disk.addActionListener (new ActionListener ()
    {
      @Override
      public void actionPerformed (ActionEvent e)
      {
        setSectorTypes ();
      }
    });

#No. 2364
#File: E:\bishe\1\AbstractFormattedDisk.java
#Comment:
  /*
   * Catalog Tree routines
   */

#Code:
  @Override
  public JTree getCatalogTree ()
  {
    return catalogTree;
  }

#No. 2365
#File: E:\bishe\1\AbstractFormattedDisk.java
#Comment:
  /*
   * These routines just hand back the information that was created above, and
   * added to by the subclass.
   */

#Code:
  @Override
  public SectorType getSectorType (int block)
  {
    return getSectorType (disk.getDiskAddress (block));
  }

#No. 2366
#File: E:\bishe\1\AbstractFormattedDisk.java
#Comment:
  /*
   * Override this with something useful
   */

#Code:
  @Override
  public AppleFileSource getCatalog ()
  {
    return new DefaultAppleFileSource (disk.toString (), this);
  }

#No. 2367
#File: E:\bishe\1\AbstractForwardHeadersUsingTest.java
#Comment:
/**
 * The base class for testing to use {@code X-Forwarded-*} headers.
 */

#Code:
@RunWith(SpringRunner.class)
@SpringBootTest(
        value = {
                "server.useForwardHeaders=true",
                "logback.access.config=classpath:logback-access.queue.xml",
        },

#No. 2368
#File: E:\bishe\1\AbstractForwardHeadersUsingTest.java
#Comment:
    /**
     * The REST template.
     */

#Code:
    @Autowired
    protected TestRestTemplate rest;

    /**
     * Creates a test rule.
     *
     * @return a test rule.
     */
    @Rule
    public TestRule rule() {
        return RuleChain
                .outerRule(new LogbackAccessEventQueuingAppenderRule())
                .around(new LogbackAccessEventQueuingListenerRule());
    }

#No. 2369
#File: E:\bishe\1\AbstractFreeTextExtension.java
#Comment:
	  /**
	   * Creates a tag and initializes its content.
	   *
	   * @param content
	   */

#Code:
	  protected AbstractFreeTextExtension(String content) {
	    this.content = content;
	  }

#No. 2370
#File: E:\bishe\1\AbstractFrontendMojo.java
#Comment:
    /**
     * Determines if the current execution is during a testing phase (e.g., "test" or "integration-test").
     */

#Code:
    private boolean isTestingPhase() {
        String phase = execution.getLifecyclePhase();
        return "test".equals(phase) || "integration-test".equals(phase);
    }

#No. 2371
#File: E:\bishe\1\AbstractFrontendMojo.java
#Comment:
    /**
     * Whether to raise an error or a failure if the execution fails. If unset, execution will fail if not in a testing
     * phase.
     *
     * @since 1.4
     * @see #isTestingPhase()
     */

#Code:
    @Parameter(property = "failOnError")
    protected Boolean failOnError;

    /**
     * @since 1.4
     * @see #failOnError
     */
    protected boolean isFailOnError() {
        if (failOnError == null) {
            failOnError = !isTestingPhase();
        }
        return failOnError;
    }

#No. 2372
#File: E:\bishe\1\AbstractFullTransactionPolicy.java
#Comment:
    /**
     * 把event加入ds
     *
     * @param ds       ChangeDataSet
     * @param provider TabbleDataProvider
     */

#Code:
    private void addEvent2DataSet(ChangeDataSet ds, TableDataProvider provider) {
        String tableName = provider.getTableName();
        final TableSizeEntry entry;
        if (tableDataSize.containsKey(tableName)) {
            entry = tableDataSize.get(tableName);
        } else {
            entry = new TableSizeEntry(tableName);
        }
        // 首先记录原始大小
        tableDataSize.put(tableName, entry);
        entry.dataLen += provider.getDataLen();

        if (!isCanAddEvent(ds, provider, entry)) {
            return;
        }
        // 不需要丢弃的数据需要加入到ChangeDataSet
        if (!ds.getTableDef().containsKey(tableName)) {
            ds.getTableDef().put(tableName, provider.getColumnMeta());
        }
        List<RowData> dataRowList = null;
        if (!ds.getTableData().containsKey(tableName)) {
            dataRowList = new LinkedList<RowData>();
            ds.getTableData().put(tableName, dataRowList);
        } else {
            dataRowList = ds.getTableData().get(tableName);
        }
        dataRowList.addAll(provider.getRowData());
        ds.setGtId(provider.getGTId());
    }

#No. 2373
#File: E:\bishe\1\AbstractFunctionHandler.java
#Comment:
	/**
	 * Return true if this Handler handles the function;
	 *
	 * @param func
	 * @return
	 * @throws SQLException
	 */

#Code:
	abstract public Expr handle(Function func, AliasInfo alias)
			throws SQLException;

	protected Expr handleExpr0(final Class<? extends ExprFunction0> clazz,
			final Function func, final int type, final AliasInfo alias)
					throws SQLException {
		final ExpressionList l = func.getParameters();
		if (l != null) {
			throw getToManyArgumentEx(func, "zero");
		}
		try {
			final ExprFunction0 expr = clazz.newInstance();
			// stack.push(expr);
			// final ColumnName colName = tblName.getColumnName(func.getName());
			final ColumnName colName = tblName.getColumnName(alias.getAlias());
			builder.registerFunction(colName, type);
			return ExprInfoFactory.getInstance(expr, colName);
		} catch (final InstantiationException e) {
			throw new IllegalStateException(e.getMessage(), e);
		} catch (final IllegalAccessException e) {
			throw new IllegalStateException(e.getMessage(), e);
		}
	}

#No. 2374
#File: E:\bishe\1\AbstractFuture.java
#Comment:
    /**
     * Throws CancellationException if the future was canceled.
     */

#Code:
    private void checkState() {
        if (isCancelled())
            throw new CancellationException("task was cancelled");
    }

#No. 2375
#File: E:\bishe\1\AbstractGameStrategy.java
#Comment:
	/**
	 * 动作类型优先级倒序，先低后高，不在列表里的为最低。<br>
	 * 进行比较时反过来用index比较，不在列表里的为-1。
	 */

#Code:
	private static final List<ActionType> ACTION_TYPE_PRIORITY_LIST = Arrays
			.asList(CHI, PENG, ZHIGANG, WIN);

	/**
	 * 和>杠>碰>吃>其他，相同的比较与上次动作的玩家位置关系。
	 * 
	 * @see com.github.blovemaple.mj.rule.GameStrategy#getActionPriorityComparator()
	 */
	@Override
	public Comparator<ActionTypeAndLocation> getActionPriorityComparator() {
		Comparator<ActionTypeAndLocation> c = Comparator.comparing(
				atl -> ACTION_TYPE_PRIORITY_LIST.indexOf(atl.getActionType()));
		c = c.reversed();
		c = c.thenComparing(a -> {
			PlayerLocation lastLocation = a.getContext()
					.getLastActionLocation();
			return lastLocation == null ? Relation.SELF
					: lastLocation.getRelationOf(a.getLocation());
		});
		return c;
	}

#No. 2376
#File: E:\bishe\1\AbstractGatewayProvider.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public String getType() {
        return GatewayProvider.TYPE;
    }

#No. 2377
#File: E:\bishe\1\AbstractGcloudMojo.java
#Comment:
  /**
   * The entry point to Aether, i.e. the component doing all the work.
   *
   * @component
   */

#Code:

  protected RepositorySystem repoSystem;

  /**
   * The current repository/network configuration of Maven.
   *
   * @parameter default-value="${repositorySystemSession}"
   * @readonly
   */
  protected RepositorySystemSession repoSession;

  /**
   * The project's remote repositories to use for the resolution of project dependencies.
   *
   * @parameter default-value="${project.remoteProjectRepositories}"
   * @readonly
   */
  protected List<RemoteRepository> projectRepos;

  /**
   * The project's remote repositories to use for the resolution of plugins and their dependencies.
   *
   * @parameter default-value="${project.remotePluginRepositories}"
   * @readonly
   */
  protected List<RemoteRepository> pluginRepos;

  protected void resolveAndSetSdkRoot() throws MojoExecutionException {

    File sdkBaseDir = SdkResolver
        .getSdk(maven_project, repoSystem, repoSession, pluginRepos, projectRepos);

    try {
      System.setProperty("appengine.sdk.root", sdkBaseDir.getCanonicalPath());
    } catch (IOException e) {
      throw new MojoExecutionException("Could not open SDK zip archive.", e);
    }
  }

#No. 2378
#File: E:\bishe\1\AbstractGcloudMojo.java
#Comment:
  /**
   * @return the java version used the pom (target) and 1.7 if not present.
   */

#Code:
  protected String getJavaVersion() {
    String javaVersion = "1.7";
    Plugin p = maven_project.getPlugin("org.apache.maven.plugins:maven-compiler-plugin");
    if (p != null) {
      Xpp3Dom config = (Xpp3Dom) p.getConfiguration();
      if (config == null) {
        return javaVersion;
      }
      Xpp3Dom domVersion = config.getChild("target");
      if (domVersion != null) {
        javaVersion = domVersion.getValue();
      }
    }
    return javaVersion;
  }

#No. 2379
#File: E:\bishe\1\AbstractGcloudMojo.java
#Comment:
    /* Complicated matrix...
    vm:true java7 in pom ok   ->runtime:java7
    vm:false java8 in pom  ok   ->error for now (unless override in runtime flag)
    vm:true java8 in pm , generate a dockerfile and runtime:custom 
    env:2 java 7in pom ->ok, runtime is java
    env:2 java8 in pom ->ok runtime is java  
    */

#Code:
    boolean isVm = appengineWeb.getUseVm();
    boolean isStandard = ("1".equals(appengineWeb.getEnv())
        || "std".equals(appengineWeb.getEnv())) && isVm == false;
    boolean isFlex = "2".equals(appengineWeb.getEnv())
        || "flex".equals(appengineWeb.getEnv())
        || "flexible".equals(appengineWeb.getEnv());

    // config error: vm false
    if (isStandard && getJavaVersion().equals("1.8")) {
      throw new MojoExecutionException(
          "For now, Standard GAE runtime only works with Java7, but the pom.xml is targetting 1.8");
    }

#No. 2380
#File: E:\bishe\1\AbstractGcloudMojo.java
#Comment:
  /**
   * Executes the gcloud components update app-engine-java command to install the extra component
   * needed for the Maven plugin.
   */

#Code:
  private void installJavaAppEngineComponent(String pythonLocation) throws MojoExecutionException {
    ArrayList<String> installCommand = new ArrayList<>();
    installCommand.add(pythonLocation);
    if (Utils.canDisableImportOfPythonModuleSite()) {
      installCommand.add("-S");
    }
    installCommand.add(gcloud_directory + "/lib/gcloud.py");
    installCommand.add("components");
    installCommand.add("update");
    installCommand.add("app-engine-java");
    installCommand.add("--quiet");
    ProcessBuilder pb = new ProcessBuilder(installCommand);
    getLog().info("Installing the Cloud SDK app-engine-java component");
    getLog().info("Please, be patient, it takes a while on slow network...");

    try {
      Process process = pb.start();
      final Scanner stdOut = new Scanner(process.getInputStream());
      new Thread("standard-out-redirection") {
        @Override
        public void run() {
          while (stdOut.hasNextLine() && !Thread.interrupted()) {
            getLog().info(stdOut.nextLine());
          }
        }
      };
      process.waitFor();
      getLog().info("Cloud SDK app-engine-java component installed.");

    } catch (IOException | InterruptedException ex) {
      throw new MojoExecutionException("Error: cannot execute gcloud command " + ex);
    }
  }

#No. 2381
#File: E:\bishe\1\AbstractGelfAppender.java
#Comment:
    /**
     * IP or hostname of graylog server.
     */

#Code:
    private String graylogHost;

    /**
     * Port of graylog server. Default: 12201.
     */
    private int graylogPort = DEFAULT_GELF_PORT;

    private GelfLayout layout;

    public String getGraylogHost() {
        return graylogHost;
    }

#No. 2382
#File: E:\bishe\1\AbstractGelfTransport.java
#Comment:
    /**
     * {@inheritDoc}
     * <p>This implementation is backed by a {@link java.util.concurrent.BlockingQueue}. When this method returns the
     * message has been added to the {@link java.util.concurrent.BlockingQueue} but has not been sent to the remote
     * host yet.</p>
     *
     * @param message message to send to the remote host
     * @throws InterruptedException
     */

#Code:
    @Override
    public void send(final GelfMessage message) throws InterruptedException {
        LOG.debug("Sending message: {}", message.toString());
        queue.put(message);
    }

#No. 2383
#File: E:\bishe\1\AbstractGelfTransport.java
#Comment:
    /**
     * {@inheritDoc}
     * <p>This implementation is backed by a {@link java.util.concurrent.BlockingQueue}. When this method returns the
     * message has been added to the {@link java.util.concurrent.BlockingQueue} but has not been sent to the remote
     * host yet.</p>
     *
     * @param message message to send to the remote host
     * @return true if the message could be dispatched, false otherwise
     */

#Code:
    @Override
    public boolean trySend(final GelfMessage message) {
        LOG.debug("Trying to send message: {}", message.toString());
        return queue.offer(message);
    }

#No. 2384
#File: E:\bishe\1\AbstractGelfTransport.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public void stop() {
        workerGroup.shutdownGracefully().awaitUninterruptibly();
    }

#No. 2385
#File: E:\bishe\1\AbstractGenerateComponentDescriptionTest.java
#Comment:
	/**
	 * <p>
	 * </p>
	 * 
	 * @param testCase
	 */

#Code:
	public AbstractGenerateComponentDescriptionTest(String testCase) {
		this._testCase = testCase;
	}

#No. 2386
#File: E:\bishe\1\AbstractGenerateComponentDescriptionTest.java
#Comment:
	/**
	 * <p>
	 * </p>
	 * 
	 * @return
	 */

#Code:
	public String getTestCase() {
		return _testCase;
	}

#No. 2387
#File: E:\bishe\1\AbstractGenerateComponentDescriptionTest.java
#Comment:
	/**
	 * @see com.wuetherich.osgi.ds.annotations.test.util.AbstractDsAnnotationsTest#createSourceFile()
	 */

#Code:
	@Override
	protected SourceFile createSourceFile() {
		return new SourceFile.Default(JAVA_TEST_FILE, fromStream(getClass()
				.getResourceAsStream(_testCase + ".input")));
	}

#No. 2388
#File: E:\bishe\1\AbstractGenerator.java
#Comment:
    /**
     * Converts a given date to an explicit timestamp string in local time zone.
     *
     * @param date a timestamp to convert.
     * @return a string representing a timestamp.
     */

#Code:
    private String dateToExplicitTimestamp( Date date )
    {
        DateFormat df = new SimpleDateFormat( "yyyy-MM-dd HH:mm:ssZ" );
        return "TS: " + df.format( date );
    }

#No. 2389
#File: E:\bishe\1\AbstractGenerator.java
#Comment:
    /**
     * Converts a given date to an explicit timestamp string in UTC time zone.
     *
     * @param date a timestamp to convert.
     * @return a string representing a timestamp.
     */

#Code:
    private String dateToExplicitTimestampUTC( Date date )
    {
        DateFormat df = new SimpleDateFormat( "yyyy-MM-dd HH:mm:ss" );
        df.setTimeZone( TimeZone.getTimeZone( "UTC" ) );
        return "TS: " + df.format( date ) + "Z";
    }

#No. 2390
#File: E:\bishe\1\AbstractGenerator.java
#Comment:
    /**
     * Add {@code level} space caracteres at the begin of each lines of the
     * given {@code text}.
     *
     * @param level the number of space caracteres to add
     * @param text  the text to prefix
     * @return the indented text
     */

#Code:
    protected String indentText( int level, String text )
    {
        StringBuilder buffer = new StringBuilder();
        String[] lines = text.split( "\n" );
        String prefix = StringUtils.leftPad( "", level );
        for ( String line : lines )
        {
            buffer.append( prefix ).append( line ).append( EOL );
        }
        return buffer.toString();
    }

#No. 2391
#File: E:\bishe\1\AbstractGeneratorCLI.java
#Comment:
    /**
     * Spring injected tenant service.
     *
     * @param tenantService The tenant service.
     */

#Code:
    public void setTenantService(TenantService tenantService) {
        this.tenantService = tenantService;
    }

#No. 2392
#File: E:\bishe\1\AbstractGeneratorTest.java
#Comment:
	/**
	 * Process all recorded events and generates code, ignoring all future events
	 * to compute generated code.
	 */

#Code:
	public void flushEvents() {
		this.display.syncExec(new Runnable() {
			@Override
			public void run() {
				AbstractGeneratorTest.this.recorderDialog.getRecorder().flushGenerationRules();
			}
		});
	}

#No. 2393
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Get the messagingType.
     *
     * @return the messagingType.
     */

#Code:
    public String getMessagingType() {
        assertUnknownOrMessageDrivenBean();
        return messagingType;
    }

#No. 2394
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Is this JMS
     *
     * @return true for jms
     */

#Code:
    public boolean isJMS() {
        assertUnknownOrMessageDrivenBean();
        String messagingType = getMessagingType();
        return messagingType == null || "javax.jms.MessageListener".equals(messagingType);
    }

#No. 2395
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Set the messagingType.
     *
     * @param messagingType the messagingType.
     * @throws IllegalArgumentException for a null messagingType
     */

#Code:
    public void setMessagingType(String messagingType) {
        assertUnknownOrMessageDrivenBean();
        if (messagingType == null)
            throw new IllegalArgumentException("Null messagingType");
        this.messagingType = messagingType;
    }

#No. 2396
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Get the messageDestinationType.
     *
     * @return the messageDestinationType.
     */

#Code:
    public String getMessageDestinationType() {
        assertUnknownOrMessageDrivenBean();
        return messageDestinationType;
    }

#No. 2397
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Set the messageDestinationType.
     *
     * @param messageDestinationType the messageDestinationType.
     * @throws IllegalArgumentException for a null messageDestinationType
     */

#Code:
    public void setMessageDestinationType(String messageDestinationType) {
        assertUnknownOrMessageDrivenBean();
        if (messageDestinationType == null)
            throw new IllegalArgumentException("Null messageDestinationType");
        this.messageDestinationType = messageDestinationType;
    }

#No. 2398
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Get the messageDestinationLink.
     *
     * @return the messageDestinationLink.
     */

#Code:
    public String getMessageDestinationLink() {
        assertUnknownOrMessageDrivenBean();
        return messageDestinationLink;
    }

#No. 2399
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Set the messageDestinationLink.
     *
     * @param messageDestinationLink the messageDestinationLink.
     * @throws IllegalArgumentException for a null messageDestinationLink
     */

#Code:
    public void setMessageDestinationLink(String messageDestinationLink) {
        assertUnknownOrMessageDrivenBean();
        if (messageDestinationLink == null)
            throw new IllegalArgumentException("Null messageDestinationLink");
        this.messageDestinationLink = messageDestinationLink;
    }

#No. 2400
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Get the activationConfig.
     *
     * @return the activationConfig.
     */

#Code:
    public ActivationConfigMetaData getActivationConfig() {
        assertUnknownOrMessageDrivenBean();
        return activationConfig;
    }

#No. 2401
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Set the activationConfig.
     *
     * @param activationConfig the activationConfig.
     * @throws IllegalArgumentException for a null activationConfig
     */

#Code:
    public void setActivationConfig(ActivationConfigMetaData activationConfig) {
        assertUnknownOrMessageDrivenBean();
        if (activationConfig == null)
            throw new IllegalArgumentException("Null activationConfig");
        this.activationConfig = activationConfig;
    }

#No. 2402
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Get the messageSelector.
     *
     * @return the messageSelector.
     */

#Code:
    public String getMessageSelector() {
        assertUnknownOrMessageDrivenBean();
        return messageSelector;
    }

#No. 2403
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Set the messageSelector.
     *
     * @param messageSelector the messageSelector.
     * @throws IllegalArgumentException for a null messageSelector
     */

#Code:
    public void setMessageSelector(String messageSelector) {
        assertUnknownOrMessageDrivenBean();
        if (messageSelector == null)
            throw new IllegalArgumentException("Null messageSelector");
        this.messageSelector = messageSelector;
    }

#No. 2404
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Get the acknowledgeMode.
     *
     * @return the acknowledgeMode.
     */

#Code:
    public String getAcknowledgeMode() {
        assertUnknownOrMessageDrivenBean();
        return acknowledgeMode;
    }

#No. 2405
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Set the acknowledgeMode.
     *
     * @param acknowledgeMode the acknowledgeMode.
     * @throws IllegalArgumentException for a null acknowledgeMode
     */

#Code:
    public void setAcknowledgeMode(String acknowledgeMode) {
        assertUnknownOrMessageDrivenBean();
        if (acknowledgeMode == null)
            throw new IllegalArgumentException("Null acknowledgeMode");
        this.acknowledgeMode = acknowledgeMode;
    }

#No. 2406
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Get the subscriptionDurability.
     *
     * @return the subscriptionDurability.
     */

#Code:
    public SubscriptionDurability getSubscriptionDurability() {
        assertUnknownOrMessageDrivenBean();
        return subscriptionDurability;
    }

#No. 2407
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Set the subscriptionDurability.
     *
     * @param subscriptionDurability the subscriptionDurability.
     * @throws IllegalArgumentException for a null subscriptionDurability
     */

#Code:
    public void setSubscriptionDurability(SubscriptionDurability subscriptionDurability) {
        assertUnknownOrMessageDrivenBean();
        if (subscriptionDurability == null)
            throw new IllegalArgumentException("Null subscriptionDurability");
        this.subscriptionDurability = subscriptionDurability;
    }

#No. 2408
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Get the home.
     *
     * @return the home.
     */

#Code:
    public String getHome() {
        assertUnknownEntityOrSessionBean();
        return home;
    }

#No. 2409
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Set the home.
     *
     * @param home the home.
     * @throws IllegalArgumentException for a null home
     */

#Code:
    public void setHome(String home) {
        assertUnknownEntityOrSessionBean();
        if (home == null)
            throw new IllegalArgumentException("Null home");
        this.home = home;
    }

#No. 2410
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Get the remote.
     *
     * @return the remote.
     */

#Code:
    public String getRemote() {
        assertUnknownEntityOrSessionBean();
        return remote;
    }

#No. 2411
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Set the remote.
     *
     * @param remote the remote.
     * @throws IllegalArgumentException for a null remote
     */

#Code:
    public void setRemote(String remote) {
        assertUnknownEntityOrSessionBean();
        if (remote == null)
            throw new IllegalArgumentException("Null remote");
        this.remote = remote;
    }

#No. 2412
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Get the localHome.
     *
     * @return the localHome.
     */

#Code:
    public String getLocalHome() {
        assertUnknownEntityOrSessionBean();
        return localHome;
    }

#No. 2413
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Set the localHome.
     *
     * @param localHome the localHome.
     * @throws IllegalArgumentException for a null localHome
     */

#Code:
    public void setLocalHome(String localHome) {
        assertUnknownEntityOrSessionBean();
        if (localHome == null)
            throw new IllegalArgumentException("Null localHome");
        this.localHome = localHome;
    }

#No. 2414
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Get the local.
     *
     * @return the local.
     */

#Code:
    public String getLocal() {
        assertUnknownEntityOrSessionBean();
        return local;
    }

#No. 2415
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Set the local.
     *
     * @param local the local.
     * @throws IllegalArgumentException for a null local
     */

#Code:
    public void setLocal(String local) {
        assertUnknownEntityOrSessionBean();
        if (local == null)
            throw new IllegalArgumentException("Null local");
        this.local = local;
    }

#No. 2416
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Get the businessLocals.
     *
     * @return the businessLocals.
     */

#Code:
    public BusinessLocalsMetaData getBusinessLocals() {
        assertUnknownOrSessionBean();
        return businessLocals;
    }

#No. 2417
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Set the businessLocals.
     *
     * @param businessLocals the businessLocals.
     * @throws IllegalArgumentException for a null businessLocasl
     */

#Code:
    public void setBusinessLocals(BusinessLocalsMetaData businessLocals) {
        assertUnknownOrSessionBean();
        if (businessLocals == null)
            throw new IllegalArgumentException("Null businessLocals");
        this.businessLocals = businessLocals;
    }

#No. 2418
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Get the businessRemotes.
     *
     * @return the businessRemotes.
     */

#Code:
    public BusinessRemotesMetaData getBusinessRemotes() {
        assertUnknownOrSessionBean();
        return businessRemotes;
    }

#No. 2419
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Set the businessRemotes.
     *
     * @param businessRemotes the businessRemotes.
     * @throws IllegalArgumentException for a null businessRemotes
     */

#Code:
    public void setBusinessRemotes(BusinessRemotesMetaData businessRemotes) {
        assertUnknownOrSessionBean();
        if (businessRemotes == null)
            throw new IllegalArgumentException("Null businessRemotes");
        this.businessRemotes = businessRemotes;
    }

#No. 2420
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Get the serviceEndpoint.
     *
     * @return the serviceEndpoint.
     */

#Code:
    public String getServiceEndpoint() {
        assertUnknownOrSessionBean();
        return serviceEndpoint;
    }

#No. 2421
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Set the serviceEndpoint.
     *
     * @param serviceEndpoint the serviceEndpoint.
     * @throws IllegalArgumentException for a null serviceEndpoint
     */

#Code:
    public void setServiceEndpoint(String serviceEndpoint) {
        assertUnknownOrSessionBean();
        if (serviceEndpoint == null)
            throw new IllegalArgumentException("Null serviceEndpoint");
        this.serviceEndpoint = serviceEndpoint;
    }

#No. 2422
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Get the sessionType.
     *
     * @return the sessionType.
     */

#Code:
    public SessionType getSessionType() {
        assertUnknownOrSessionBean();
        return sessionType;
    }

#No. 2423
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Set the sessionType.
     *
     * @param sessionType the sessionType.
     * @throws IllegalArgumentException for a null sessionType
     */

#Code:
    public void setSessionType(SessionType sessionType) {
        assertUnknownOrSessionBean();
        if (sessionType == null)
            throw new IllegalArgumentException("Null sessionType");
        this.sessionType = sessionType;
    }

#No. 2424
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Is this stateful
     *
     * @return true for stateful
     */

#Code:
    public boolean isStateful() {
        assertUnknownOrSessionBean();
        if (sessionType == null)
            return false;
        return sessionType == SessionType.Stateful;
    }

#No. 2425
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Is this stateless
     *
     * @return true for stateless
     */

#Code:
    public boolean isStateless() {
        assertUnknownOrSessionBean();
        if (sessionType == null)
            return false;
        return sessionType == SessionType.Stateless;
    }

#No. 2426
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Set the timeoutMethod.
     *
     * @param timeoutMethod the timeoutMethod.
     * @throws IllegalArgumentException for a null timeoutMethod
     */

#Code:
    public void setTimeoutMethod(NamedMethodMetaData timeoutMethod) {
        if (getEjbType() != EjbType.MESSAGE_DRIVEN && getSessionType() != null
                && getSessionType() != SessionType.Stateless && getSessionType() != SessionType.Singleton )
            throw new IllegalStateException("EJB 3.1 FR 4.3.8: Only stateless or singleton beans can have timeouts: " + this);
        super.setTimeoutMethod(timeoutMethod);
    }

#No. 2427
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Get the initMethods.
     *
     * @return the initMethods.
     */

#Code:
    public InitMethodsMetaData getInitMethods() {
        assertUnknownOrSessionBean();
        return initMethods;
    }

#No. 2428
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Set the initMethods.
     *
     * @param initMethods the initMethods.
     * @throws IllegalArgumentException for a null initMethods
     */

#Code:
    public void setInitMethods(InitMethodsMetaData initMethods) {
        assertUnknownOrSessionBean();
        if (initMethods == null)
            throw new IllegalArgumentException("Null initMethods");
        this.initMethods = initMethods;
    }

#No. 2429
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Get the removeMethods.
     *
     * @return the removeMethods.
     */

#Code:
    public RemoveMethodsMetaData getRemoveMethods() {
        assertUnknownOrSessionBean();
        return removeMethods;
    }

#No. 2430
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Set the removeMethods.
     *
     * @param removeMethods the removeMethods.
     * @throws IllegalArgumentException for a null removeMethods
     */

#Code:
    public void setRemoveMethods(RemoveMethodsMetaData removeMethods) {
        assertUnknownOrSessionBean();
        if (removeMethods == null)
            throw new IllegalArgumentException("Null removeMethods");
        this.removeMethods = removeMethods;
    }

#No. 2431
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Get the postActivates.
     *
     * @return the postActivates.
     */

#Code:
    public LifecycleCallbacksMetaData getPostActivates() {
        assertUnknownOrSessionBean();
        return postActivates;
    }

#No. 2432
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Set the postActivates.
     *
     * @param postActivates the postActivates.
     * @throws IllegalArgumentException for a null postActivates
     */

#Code:
    public void setPostActivates(LifecycleCallbacksMetaData postActivates) {
        assertUnknownOrSessionBean();
        if (postActivates == null)
            throw new IllegalArgumentException("Null postActivates");
        this.postActivates = postActivates;
    }

#No. 2433
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Get the prePassivates.
     *
     * @return the prePassivates.
     */

#Code:
    public LifecycleCallbacksMetaData getPrePassivates() {
        assertUnknownOrSessionBean();
        return prePassivates;
    }

#No. 2434
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Set the prePassivates.
     *
     * @param prePassivates the prePassivates.
     * @throws IllegalArgumentException for a null prePassivates
     */

#Code:
    public void setPrePassivates(LifecycleCallbacksMetaData prePassivates) {
        assertUnknownOrSessionBean();
        if (prePassivates == null)
            throw new IllegalArgumentException("Null prePassivates");
        this.prePassivates = prePassivates;
    }

#No. 2435
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Returns the init-on-startup value of the session bean metadata.
     * Returns null if none is defined.
     *
     * @return
     */

#Code:
    public Boolean isInitOnStartup() {
        assertUnknownOrSessionBean();
        return initOnStartup;
    }

#No. 2436
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * @return Returns {@link EmptyMetaData} if the bean represents a no-interface
     *         bean. Else returns null.
     *         Use the {@link #isNoInterfaceBean()} API which is more intuitive.
     * @see SessionBean31MetaData#isNoInterfaceBean()
     */

#Code:
    public EmptyMetaData getLocalBean() {
        assertUnknownOrSessionBean();
        return this.localBean;
    }

#No. 2437
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Set the metadata to represent whether this bean
     * exposes an no-interface view
     *
     * @param isNoInterfaceBean True if the bean exposes a no-interface
     *                          view. Else set to false.
     */

#Code:
    public void setLocalBean(EmptyMetaData localBean) {
        assertUnknownOrSessionBean31();
        this.localBean = localBean;
    }

#No. 2438
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * @return Returns true if this bean exposes a no-interface view.
     *         Else returns false. This is similar to {@link #getLocalBean()}, but
     *         is more intuitive
     */

#Code:
    public boolean isNoInterfaceBean() {
        assertUnknownOrSessionBean();
        return this.localBean == null ? false : true;
    }

#No. 2439
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Sets the no-interface information in the metadata
     *
     * @param isNoInterfaceBean True if this is a no-interface bean, false otherwise
     */

#Code:
    public void setNoInterfaceBean(boolean isNoInterfaceBean) {
        assertUnknownOrSessionBean31();
        this.localBean = isNoInterfaceBean ? new EmptyMetaData() : null;
    }

#No. 2440
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Returns true if this is a singleton session bean. Else returns false
     */

#Code:
    public boolean isSingleton() {
        assertUnknownOrSessionBean();
        if (this.getSessionType() == null)
            return false;
        return this.getSessionType() == SessionType.Singleton;
    }

#No. 2441
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Sets the concurrency management type of this bean
     *
     * @param concurrencyManagementType The concurrency management type
     * @throws If the passed <code>concurrencyManagementType</code> is null
     */

#Code:
    public void setConcurrencyManagementType(ConcurrencyManagementType concurrencyManagementType) {
        assertUnknownOrSessionBean31();
        if (concurrencyManagementType == null) {
            throw new IllegalArgumentException("Concurrency management type cannot be null");
        }
        this.concurrencyManagementType = concurrencyManagementType;
    }

#No. 2442
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Returns the concurrency management type of this bean
     *
     * @return
     */

#Code:
    public ConcurrencyManagementType getConcurrencyManagementType() {
        assertUnknownOrSessionBean();
        return this.concurrencyManagementType;
    }

#No. 2443
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Sets the concurrent methods of this bean
     *
     * @param concurrentMethods
     * @throws IllegalArgumentException If the passed <code>concurrentMethods</code> is null
     */

#Code:
    public void setConcurrentMethods(ConcurrentMethodsMetaData concurrentMethods) {
        assertUnknownOrSessionBean31();
        this.concurrentMethods = concurrentMethods;
    }

#No. 2444
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Returns a {@link java.util.Map} whose key represents a {@link NamedMethodMetaData} and whose value
     * represents {@link ConcurrentMethodMetaData} of this bean. Returns an empty {@link java.util.Map} if
     * there are no concurrent methods for this bean
     *
     * @return
     */

#Code:
    public ConcurrentMethodsMetaData getConcurrentMethods() {
        assertUnknownOrSessionBean();
        return this.concurrentMethods;
    }

#No. 2445
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Sets the lock type applicable at the bean level
     *
     * @param lockType {@link LockType}
     */

#Code:
    public void setLockType(LockType lockType) {
        assertUnknownOrSessionBean31();
        this.beanLevelLockType = lockType;
    }

#No. 2446
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Returns the lock type applicable at the bean level
     *
     * @return
     */

#Code:
    public LockType getLockType() {
        assertUnknownOrSessionBean();
        return this.beanLevelLockType;
    }

#No. 2447
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Sets the bean level access timeout metadata
     *
     * @param accessTimeout {@link AccessTimeoutMetaData}
     */

#Code:
    public void setAccessTimeout(AccessTimeoutMetaData accessTimeout) {
        assertUnknownOrSessionBean31();
        this.beanLevelAccessTimeout = accessTimeout;
    }

#No. 2448
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Returns the access timeout metadata applicable at bean level
     *
     * @return
     */

#Code:
    public AccessTimeoutMetaData getAccessTimeout() {
        assertUnknownOrSessionBean();
        return this.beanLevelAccessTimeout;
    }

#No. 2449
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Returns the names of one or more Singleton beans in the same application
     * as the referring Singleton.
     *
     * @return
     */

#Code:
    public String[] getDependsOn() {
        if (this.dependsOn == null || this.dependsOn.getEjbNames() == null) {
            return null;
        }
        List<String> ejbNames = this.dependsOn.getEjbNames();
        return ejbNames.toArray(new String[ejbNames.size()]);
    }

#No. 2450
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Sets the names of one or more singleton beans, each of which must be initialized before
     * the referring bean. Each dependent bean is expressed using ejb-link syntax.
     *
     * @param dependsOn The singleton bean dependencies
     */

#Code:
    public void setDependsOn(String[] dependsOn) {
        assertUnknownOrSessionBean31();
        this.dependsOn = new DependsOnMetaData(dependsOn);
    }

#No. 2451
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Sets the names of one or more singleton beans, each of which must be initialized before
     * the referring bean. Each dependent bean is expressed using ejb-link syntax.
     *
     * @param dependsOn The singleton bean dependencies
     */

#Code:
    public void setDependsOnMetaData(DependsOnMetaData dependsOnMetaData) {
        assertUnknownOrSessionBean31();
        this.dependsOn = dependsOnMetaData;
    }

#No. 2452
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Sets the names of one or more singleton beans, each of which must be initialized before
     * the referring bean. Each dependent bean is expressed using ejb-link syntax.
     *
     * @param dependsOn The singleton bean dependencies
     */

#Code:
    public void setDependsOn(Collection<String> dependsOn) {
        assertUnknownOrSessionBean31();
        if (dependsOn == null) {
            return;
        }
        this.setDependsOn(dependsOn.toArray(new String[dependsOn.size()]));
    }

#No. 2453
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Is this container managed persistence
     *
     * @return true for cmp
     */

#Code:
    public boolean isCMP() {
        assertUnknownOrEntityBean();
        if (persistenceType == null)
            return true;
        return persistenceType == PersistenceType.Container;
    }

#No. 2454
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Is this bean managed persistence
     *
     * @return true for bmp
     */

#Code:
    public boolean isBMP() {
        assertUnknownOrEntityBean();
        return isCMP() == false;
    }

#No. 2455
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Get the persistenceType.
     *
     * @return the persistenceType.
     */

#Code:
    public PersistenceType getPersistenceType() {
        assertUnknownOrEntityBean();
        return persistenceType;
    }

#No. 2456
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Set the persistenceType.
     *
     * @param persistenceType the persistenceType.
     * @throws IllegalArgumentException for a null persistenceType
     */

#Code:
    public void setPersistenceType(PersistenceType persistenceType) {
        assertUnknownOrEntityBean();
        if (persistenceType == null)
            throw new IllegalArgumentException("Null persistenceType");
        this.persistenceType = persistenceType;
    }

#No. 2457
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Get the primKeyClass.
     *
     * @return the primKeyClass.
     */

#Code:
    public String getPrimKeyClass() {
        assertUnknownOrEntityBean();
        return primKeyClass;
    }

#No. 2458
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Set the primKeyClass.
     *
     * @param primKeyClass the primKeyClass.
     * @throws IllegalArgumentException for a null primKeyClass
     */

#Code:
    public void setPrimKeyClass(String primKeyClass) {
        assertUnknownOrEntityBean();
        if (primKeyClass == null)
            throw new IllegalArgumentException("Null primKeyClass");
        this.primKeyClass = primKeyClass;
    }

#No. 2459
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Get the reentrant.
     *
     * @return the reentrant.
     */

#Code:
    public boolean isReentrant() {
        assertUnknownOrEntityBean();
        return reentrant == null ? false : reentrant;
    }

#No. 2460
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Set the reentrant.
     *
     * @param reentrant the reentrant.
     */

#Code:
    public void setReentrant(boolean reentrant) {
        assertUnknownOrEntityBean();
        this.reentrant = reentrant;
    }

#No. 2461
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Whether it is CMP1x
     *
     * @return true for cmp1x
     */

#Code:
    public boolean isCMP1x() {
        assertUnknownOrEntityBean();
        if (cmpVersion == null) {
            if (getEjbJarMetaData().isEJB2x() || getEjbJarMetaData().isEJB3x())
                return false;
            else
                return true;
        }
        return "1.x".equals(cmpVersion);
    }

#No. 2462
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Get the cmpVersion.
     *
     * @return the cmpVersion.
     */

#Code:
    public String getCmpVersion() {
        assertUnknownOrEntityBean();
        return cmpVersion;
    }

#No. 2463
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Set the cmpVersion.
     *
     * @param cmpVersion the cmpVersion.
     * @throws IllegalArgumentException for a null cmpVersion
     */

#Code:
    public void setCmpVersion(String cmpVersion) {
        assertUnknownOrEntityBean();
        if (cmpVersion == null)
            throw new IllegalArgumentException("Null cmpVersion");
        this.cmpVersion = cmpVersion;
    }

#No. 2464
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Get the abstractSchemaName.
     *
     * @return the abstractSchemaName.
     */

#Code:
    public String getAbstractSchemaName() {
        assertUnknownOrEntityBean();
        return abstractSchemaName;
    }

#No. 2465
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Set the abstractSchemaName.
     *
     * @param abstractSchemaName the abstractSchemaName.
     * @throws IllegalArgumentException for a null abstractSchemaName
     */

#Code:
    public void setAbstractSchemaName(String abstractSchemaName) {
        assertUnknownOrEntityBean();
        if (abstractSchemaName == null)
            throw new IllegalArgumentException("Null abstractSchemaName");
        this.abstractSchemaName = abstractSchemaName;
    }

#No. 2466
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Get the primKeyField.
     *
     * @return the primKeyField.
     */

#Code:
    public String getPrimKeyField() {
        assertUnknownOrEntityBean();
        return primKeyField;
    }

#No. 2467
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Set the primKeyField.
     *
     * @param primKeyField the primKeyField.
     * @throws IllegalArgumentException for a null primKeyField
     */

#Code:
    public void setPrimKeyField(String primKeyField) {
        assertUnknownOrEntityBean();
        if (primKeyField == null)
            throw new IllegalArgumentException("Null primKeyField");
        this.primKeyField = primKeyField;
    }

#No. 2468
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Get the cmpFields.
     *
     * @return the cmpFields.
     */

#Code:
    public CMPFieldsMetaData getCmpFields() {
        assertUnknownOrEntityBean();
        return cmpFields;
    }

#No. 2469
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Set the cmpFields.
     *
     * @param cmpFields the cmpFields.
     * @throws IllegalArgumentException for a null cmpFields
     */

#Code:
    public void setCmpFields(CMPFieldsMetaData cmpFields) {
        assertUnknownOrEntityBean();
        if (cmpFields == null)
            throw new IllegalArgumentException("Null cmpFields");
        this.cmpFields = cmpFields;
    }

#No. 2470
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Get the queries.
     *
     * @return the queries.
     */

#Code:
    public QueriesMetaData getQueries() {
        assertUnknownOrEntityBean();
        return queries;
    }

#No. 2471
#File: E:\bishe\1\AbstractGenericBeanMetaData.java
#Comment:
    /**
     * Set the queries.
     *
     * @param queries the queries.
     * @throws IllegalArgumentException for a null queries
     */

#Code:
    public void setQueries(QueriesMetaData queries) {
        assertUnknownOrEntityBean();
        if (queries == null)
            throw new IllegalArgumentException("Null queries");
        this.queries = queries;
    }

#No. 2472
#File: E:\bishe\1\AbstractGenericHandler.java
#Comment:
    /**
     * Helper method which creates the metrics for the current response and publishes them if enabled.
     *
     * @param response the response which is needed as context.
     */

#Code:
    private void writeMetrics(final CouchbaseResponse response) {
        if (currentRequest != null && currentOpTime >= 0 && env() != null
            && env().networkLatencyMetricsCollector().isEnabled()) {

            try {
                Class<? extends CouchbaseRequest> requestClass = currentRequest.getClass();
                String simpleName = classNameCache.get(requestClass);
                if (simpleName == null) {
                    simpleName = requestClass.getSimpleName();
                    classNameCache.put(requestClass, simpleName);
                }

                NetworkLatencyMetricsIdentifier identifier = new NetworkLatencyMetricsIdentifier(
                        remoteHostname,
                        serviceType().toString(),
                        simpleName,
                        response.status().toString()
                );
                env().networkLatencyMetricsCollector().record(identifier, currentOpTime);
            } catch (Throwable e) {
                LOGGER.warn("Could not collect latency metric for request + "
                    + currentRequest + "(" + currentOpTime + ")", e);
            }
        }
    }

#No. 2473
#File: E:\bishe\1\AbstractGenericHandler.java
#Comment:
    /**
     * Helper method which performs the initial decoding process.
     *
     * @param ctx the channel handler context for logging purposes.
     */

#Code:
    private void initialDecodeTasks(final ChannelHandlerContext ctx) {
        currentRequest = sentRequestQueue.poll();
        currentDecodingState = DecodingState.STARTED;

        if (currentRequest != null) {
            Long st = sentRequestTimings.poll();
            if (st != null) {
                currentOpTime = System.nanoTime() - st;
            } else {
                currentOpTime = -1;
            }
        }

        if (traceEnabled) {
            LOGGER.trace("{}Started decoding of {}", logIdent(ctx, endpoint), currentRequest);
        }
    }

#No. 2474
#File: E:\bishe\1\AbstractGenericHandler.java
#Comment:
    /**
     * Publishes a response with the attached observable.
     *
     * @param response the response to publish.
     * @param observable pushing into the event sink.
     */

#Code:
    protected void publishResponse(final CouchbaseResponse response,
        final Subject<CouchbaseResponse, CouchbaseResponse> observable) {
        if (response.status() != ResponseStatus.RETRY && observable != null) {
            if (moveResponseOut) {
                Scheduler scheduler = env().scheduler();
                if (scheduler instanceof CoreScheduler) {
                    scheduleDirect((CoreScheduler) scheduler, response, observable);
                } else {
                    scheduleWorker(scheduler, response, observable);
                }
            } else {
                completeResponse(response, observable);
            }
        } else {
            responseBuffer.publishEvent(ResponseHandler.RESPONSE_TRANSLATOR, response, observable);
        }
    }

#No. 2475
#File: E:\bishe\1\AbstractGenericHandler.java
#Comment:
    /**
     * Fulfill and complete the response observable.
     *
     * When called directly, this method completes on the event loop, but it can also be used in a callback (see
     * {@link #scheduleDirect(CoreScheduler, CouchbaseResponse, Subject)} for example.
     */

#Code:
    private static void completeResponse(final CouchbaseResponse response,
        final Subject<CouchbaseResponse, CouchbaseResponse> observable) {
        try {
            observable.onNext(response);
            observable.onCompleted();
        } catch (Exception ex) {
            LOGGER.warn("Caught exception while onNext on observable", ex);
            observable.onError(ex);
        }
    }

#No. 2476
#File: E:\bishe\1\AbstractGenericHandler.java
#Comment:
    /**
     * Optimized version of dispatching onto the core scheduler through direct scheduling.
     *
     * This method has less GC overhead compared to {@link #scheduleWorker(Scheduler, CouchbaseResponse, Subject)}
     * since no worker needs to be generated explicitly (but is not part of the public Scheduler interface).
     */

#Code:
    private static void scheduleDirect(CoreScheduler scheduler, final CouchbaseResponse response,
        final Subject<CouchbaseResponse, CouchbaseResponse> observable) {
        scheduler.scheduleDirect(new Action0() {
            @Override
            public void call() {
                completeResponse(response, observable);
            }
        });
    }

#No. 2477
#File: E:\bishe\1\AbstractGenericHandler.java
#Comment:
    /**
     * Dispatches the response on a generic scheduler through creating a worker.
     */

#Code:
    private static void scheduleWorker(Scheduler scheduler, final CouchbaseResponse response,
        final Subject<CouchbaseResponse, CouchbaseResponse> observable) {
        final Scheduler.Worker worker = scheduler.createWorker();
        worker.schedule(new Action0() {
            @Override
            public void call() {
                try {
                    observable.onNext(response);
                    observable.onCompleted();
                } catch (Exception ex) {
                    LOGGER.warn("Caught exception while onNext on observable", ex);
                    observable.onError(ex);
                } finally {
                    worker.unsubscribe();
                }
            }
        });
    }

#No. 2478
#File: E:\bishe\1\AbstractGenericHandler.java
#Comment:
    /**
     * Notify that decoding is finished. This needs to be called by the child handlers in order to
     * signal that operations are done.
     */

#Code:
    protected void finishedDecoding() {
        this.currentDecodingState = DecodingState.FINISHED;
        if (isTransient) {
            endpoint.disconnect();
        }
    }

#No. 2479
#File: E:\bishe\1\AbstractGenericHandler.java
#Comment:
    /**
     * Cancells any outstanding operations which are currently on the wire.
     *
     * @param ctx the handler context.
     */

#Code:
    private void handleOutstandingOperations(final ChannelHandlerContext ctx) {
        if (sentRequestQueue.isEmpty()) {
            LOGGER.trace(logIdent(ctx, endpoint) + "Not cancelling operations - sent queue is empty.");
            return;
        }

        LOGGER.debug(logIdent(ctx, endpoint) + "Cancelling " + sentRequestQueue.size() + " outstanding requests.");
        while (!sentRequestQueue.isEmpty()) {
            REQUEST req = sentRequestQueue.poll();
            try {
                sideEffectRequestToCancel(req);
                failSafe(env().scheduler(), moveResponseOut, req.observable(),
                        new RequestCancelledException("Request cancelled in-flight."));
            } catch (Exception ex) {
                LOGGER.info("Exception thrown while cancelling outstanding operation: " + req, ex);
            }
        }

        sentRequestTimings.clear();
    }

#No. 2480
#File: E:\bishe\1\AbstractGenericHandler.java
#Comment:
    /**
     * This method can be overridden as it is called every time an operation is cancelled.
     *
     * Overriding implementations may do some custom logic with them, for example freeing resources they know of
     * to avoid leaking.
     *
     * @param request the request to side effect on.
     */

#Code:
    protected void sideEffectRequestToCancel(final REQUEST request) {
        // Nothing to do in the generic implementation.
    }

#No. 2481
#File: E:\bishe\1\AbstractGenericHandler.java
#Comment:
    /**
     * Helper method to check if conditions are met to send a keepalive right now.
     *
     * @return true if keepalive can be sent, false otherwise.
     */

#Code:
    private boolean shouldSendKeepAlive() {
        if (pipeline) {
            return true; // always send if pipelining is enabled
        }

        // if pipelining is disabled, only send if the request queue is empty and no response
        // is currently being decoded.
        return sentRequestQueue.isEmpty() && currentDecodingState == DecodingState.INITIAL;
    }

#No. 2482
#File: E:\bishe\1\AbstractGenericHandler.java
#Comment:
    /**
     * Override to return a non-null request to be fired in the pipeline in case a keep alive is triggered.
     *
     * @return a CouchbaseRequest to be fired in case of keep alive (null by default).
     */

#Code:
    protected CouchbaseRequest createKeepAliveRequest() {
        return null;
    }

#No. 2483
#File: E:\bishe\1\AbstractGenericHandler.java
#Comment:
    /**
     * Override to customize the behavior when a keep alive has been triggered and a keep alive request sent.
     *
     * The default behavior is to log the event at debug level.
     *
     * @param ctx the channel context.
     * @param keepAliveRequest the keep alive request that was sent when keep alive was triggered
     */

#Code:
    protected void onKeepAliveFired(ChannelHandlerContext ctx, CouchbaseRequest keepAliveRequest) {
        if (LOGGER.isDebugEnabled()) {
            LOGGER.debug(logIdent(ctx, endpoint) + "KeepAlive fired");
        }
    }

#No. 2484
#File: E:\bishe\1\AbstractGenericHandler.java
#Comment:
    /**
     * Override to customize the behavior when a keep alive has been responded to.
     *
     * The default behavior is to log the event and the response status at trace level.
     *
     * @param ctx the channel context.
     * @param keepAliveResponse the keep alive request that was sent when keep alive was triggered
     */

#Code:
    protected void onKeepAliveResponse(ChannelHandlerContext ctx, CouchbaseResponse keepAliveResponse) {
        if (traceEnabled) {
            LOGGER.trace(logIdent(ctx, endpoint) + "keepAlive was answered, status "
                    + keepAliveResponse.status());
        }
    }

#No. 2485
#File: E:\bishe\1\AbstractGenericHandler.java
#Comment:
    /**
     * Returns the current request if set.
     *
     * @return the current request.
     */

#Code:
    protected REQUEST currentRequest() {
        return currentRequest;
    }

#No. 2486
#File: E:\bishe\1\AbstractGenericHandler.java
#Comment:
    /**
     * Sets current request.
     *
     * FIXME this is temporary solution for {@link com.couchbase.client.core.endpoint.dcp.DCPHandler}
     * @param request request to become the current one
     */

#Code:
    protected void currentRequest(REQUEST request) {
        currentRequest = request;
    }

#No. 2487
#File: E:\bishe\1\AbstractGenericHandler.java
#Comment:
    /**
     * @return stringified version of the remote node's hostname
     */

#Code:
    protected String remoteHostname() {
        return remoteHostname;
    }

#No. 2488
#File: E:\bishe\1\AbstractGenericHandler.java
#Comment:
    /**
     * Returns environment.
     *
     * @return the environment
     */

#Code:
    protected CoreEnvironment env() {
        return endpoint.environment();
    }

#No. 2489
#File: E:\bishe\1\AbstractGenericHandler.java
#Comment:
    /**
     * The parent endpoint.
     */

#Code:
    protected AbstractEndpoint endpoint() {
        return endpoint;
    }

#No. 2490
#File: E:\bishe\1\AbstractGenericHandler.java
#Comment:
    /**
     * Simple log helper to give logs a common prefix.
     *
     * @param ctx the context.
     * @param endpoint the endpoint.
     * @return a prefix string for logs.
     */

#Code:
    protected static String logIdent(final ChannelHandlerContext ctx, final Endpoint endpoint) {
        return "[" + ctx.channel().remoteAddress() + "][" + endpoint.getClass().getSimpleName() + "]: ";
    }

#No. 2491
#File: E:\bishe\1\AbstractGenericHandler.java
#Comment:
    /**
     * Add basic authentication headers to a {@link HttpRequest}.
     *
     * The given information is Base64 encoded and the authorization header is set appropriately. Since this needs
     * to be done for every request, it is refactored out.
     *
     * @param ctx the handler context.
     * @param request the request where the header should be added.
     * @param user the username for auth.
     * @param password the password for auth.
     */

#Code:
    public static void addHttpBasicAuth(final ChannelHandlerContext ctx, final HttpRequest request, final String user,
        final String password) {
        final String pw = password == null ? "" : password;

        ByteBuf raw = ctx.alloc().buffer(user.length() + pw.length() + 1);
        raw.writeBytes((user + ":" + pw).getBytes(CHARSET));
        ByteBuf encoded = Base64.encode(raw, false);
        request.headers().add(HttpHeaders.Names.AUTHORIZATION, "Basic " + encoded.toString(CHARSET));
        encoded.release();
        raw.release();
    }

#No. 2492
#File: E:\bishe\1\AbstractGenericHandler.java
#Comment:
    /**
     * Helper method to return the remote http host, cached.
     *
     * @param ctx the handler context.
     * @return the remote http host.
     */

#Code:
    protected String remoteHttpHost(ChannelHandlerContext ctx) {
        if (remoteHttpHost == null) {
            SocketAddress addr = ctx.channel().remoteAddress();
            if (addr instanceof InetSocketAddress) {
                InetSocketAddress inetAddr = (InetSocketAddress) addr;
                remoteHttpHost = inetAddr.getAddress().getHostAddress() + ":" + inetAddr.getPort();
            } else {
                remoteHttpHost = addr.toString();
            }
        }
        return remoteHttpHost;
    }

#No. 2493
#File: E:\bishe\1\AbstractGet.java
#Comment:
    /**
     * Obtain data root according to filter from operation element.
     *
     * @param operationElement operation element
     * @return if filter is present and not empty returns Optional of the InstanceIdentifier to the read location
     *      in datastore. Empty filter returns Optional.absent() which should equal an empty &lt;data/&gt;
     *      container in the response. If filter is not present we want to read the entire datastore - return ROOT.
     * @throws DocumentedException if not possible to get identifier from filter
     */

#Code:
    protected Optional<YangInstanceIdentifier> getDataRootFromFilter(final XmlElement operationElement)
            throws DocumentedException {
        final Optional<XmlElement> filterElement = operationElement.getOnlyChildElementOptionally(FILTER);
        if (filterElement.isPresent()) {
            if (filterElement.get().getChildElements().size() == 0) {
                return Optional.absent();
            }
            return Optional.of(getInstanceIdentifierFromFilter(filterElement.get()));
        }

        return Optional.of(ROOT);
    }

#No. 2494
#File: E:\bishe\1\AbstractGetStatusRequester.java
#Comment:
	/**
	 * Returns a list containing all the remote consumers' status.
	 * @return a list containing all the remote consumers' status.
	 */

#Code:
	@Req("REQ034")
	protected ArrayList<ConsumerInfo> getRemoteConsumersStatus() {
		Map<String,ConsumerInfo> consumersMap = CommonUtils.createSerializableMap();

		List<AllocableWorker> allocableWorkers = PeerDAOFactory.getInstance().getAllocationDAO().getLocalAllocableWorkers();
		
		for (AllocableWorker allocableWorker : allocableWorkers) {

			Consumer consumer = allocableWorker.getConsumer();
			if (consumer == null || consumer.isLocal()) {
				continue;
			}

			String consumerAddress = consumer.getConsumerAddress();
			if (consumerAddress == null) {
				continue;
			}
			
			ConsumerInfo consumerInfo = consumersMap.get(consumerAddress);
			
			if (consumerInfo == null) {
				consumerInfo = new ConsumerInfo(0, consumerAddress);
				consumersMap.put(consumerAddress, consumerInfo);
			}
			
			consumerInfo.setNumberOfLocalWorkers(consumerInfo.getNumberOfLocalWorkers() + 1);
		}
		
		
		ArrayList<ConsumerInfo> result = new ArrayList<ConsumerInfo>(consumersMap.values());
		Collections.sort(result, new ConsumerInfoComparator());
		return result;
	}

#No. 2495
#File: E:\bishe\1\AbstractGettableByIndexData.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public boolean isNull(int i) {
        return getValue(i) == null;
    }

#No. 2496
#File: E:\bishe\1\AbstractGettableByIndexData.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public boolean getBool(int i) {
        checkType(i, DataType.Name.BOOLEAN);

        ByteBuffer value = getValue(i);
        if (value == null || value.remaining() == 0)
            return false;

        return TypeCodec.BooleanCodec.instance.deserializeNoBoxing(value);
    }

#No. 2497
#File: E:\bishe\1\AbstractGettableByIndexData.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public int getInt(int i) {
        checkType(i, DataType.Name.INT);

        ByteBuffer value = getValue(i);
        if (value == null || value.remaining() == 0)
            return 0;

        return TypeCodec.IntCodec.instance.deserializeNoBoxing(value);
    }

#No. 2498
#File: E:\bishe\1\AbstractGettableByIndexData.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public long getLong(int i) {
        checkType(i, DataType.Name.BIGINT, DataType.Name.COUNTER);

        ByteBuffer value = getValue(i);
        if (value == null || value.remaining() == 0)
            return 0L;

        return TypeCodec.LongCodec.instance.deserializeNoBoxing(value);
    }

#No. 2499
#File: E:\bishe\1\AbstractGettableByIndexData.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public Date getDate(int i) {
        checkType(i, DataType.Name.TIMESTAMP);

        ByteBuffer value = getValue(i);
        if (value == null || value.remaining() == 0)
            return null;

        return TypeCodec.DateCodec.instance.deserialize(value);
    }

#No. 2500
#File: E:\bishe\1\AbstractGettableByIndexData.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public float getFloat(int i) {
        checkType(i, DataType.Name.FLOAT);

        ByteBuffer value = getValue(i);
        if (value == null || value.remaining() == 0)
            return 0.0f;

        return TypeCodec.FloatCodec.instance.deserializeNoBoxing(value);
    }

#No. 2501
#File: E:\bishe\1\AbstractGettableByIndexData.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public double getDouble(int i) {
        checkType(i, DataType.Name.DOUBLE);

        ByteBuffer value = getValue(i);
        if (value == null || value.remaining() == 0)
            return 0.0;

        return TypeCodec.DoubleCodec.instance.deserializeNoBoxing(value);
    }

#No. 2502
#File: E:\bishe\1\AbstractGettableByIndexData.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public ByteBuffer getBytesUnsafe(int i) {
        ByteBuffer value = getValue(i);
        if (value == null)
            return null;

        return value.duplicate();
    }

#No. 2503
#File: E:\bishe\1\AbstractGettableByIndexData.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public ByteBuffer getBytes(int i) {
        checkType(i, DataType.Name.BLOB);
        return getBytesUnsafe(i);
    }

#No. 2504
#File: E:\bishe\1\AbstractGettableByIndexData.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public String getString(int i) {
        DataType.Name type = checkType(i, DataType.Name.VARCHAR,
                                          DataType.Name.TEXT,
                                          DataType.Name.ASCII);

        ByteBuffer value = getValue(i);
        if (value == null)
            return null;

        return type == DataType.Name.ASCII
             ? TypeCodec.StringCodec.asciiInstance.deserialize(value)
             : TypeCodec.StringCodec.utf8Instance.deserialize(value);
    }

#No. 2505
#File: E:\bishe\1\AbstractGettableByIndexData.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public BigInteger getVarint(int i) {
        checkType(i, DataType.Name.VARINT);

        ByteBuffer value = getValue(i);
        if (value == null || value.remaining() == 0)
            return null;

        return TypeCodec.BigIntegerCodec.instance.deserialize(value);
    }

#No. 2506
#File: E:\bishe\1\AbstractGettableByIndexData.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public BigDecimal getDecimal(int i) {
        checkType(i, DataType.Name.DECIMAL);

        ByteBuffer value = getValue(i);
        if (value == null || value.remaining() == 0)
            return null;

        return TypeCodec.DecimalCodec.instance.deserialize(value);
    }

#No. 2507
#File: E:\bishe\1\AbstractGettableByIndexData.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public UUID getUUID(int i) {
        DataType.Name type = checkType(i, DataType.Name.UUID, DataType.Name.TIMEUUID);

        ByteBuffer value = getValue(i);
        if (value == null || value.remaining() == 0)
            return null;

        return type == DataType.Name.UUID
             ? TypeCodec.UUIDCodec.instance.deserialize(value)
             : TypeCodec.TimeUUIDCodec.instance.deserialize(value);
    }

#No. 2508
#File: E:\bishe\1\AbstractGettableByIndexData.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public InetAddress getInet(int i) {
        checkType(i, DataType.Name.INET);

        ByteBuffer value = getValue(i);
        if (value == null || value.remaining() == 0)
            return null;

        return TypeCodec.InetCodec.instance.deserialize(value);
    }

#No. 2509
#File: E:\bishe\1\AbstractGettableByIndexData.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    @SuppressWarnings("unchecked")
    public <T> List<T> getList(int i, Class<T> elementsClass) {
        DataType type = getType(i);
        if (type.getName() != DataType.Name.LIST)
            throw new InvalidTypeException(String.format("Column %s is not of list type", getName(i)));

        Class<?> expectedClass = type.getTypeArguments().get(0).getName().javaType;
        if (!elementsClass.isAssignableFrom(expectedClass))
            throw new InvalidTypeException(String.format("Column %s is a list of %s (CQL type %s), cannot be retrieved as a list of %s", getName(i), expectedClass, type, elementsClass));

        ByteBuffer value = getValue(i);
        if (value == null)
            return Collections.<T>emptyList();

        return Collections.unmodifiableList((List<T>)type.codec(protocolVersion).deserialize(value));
    }

#No. 2510
#File: E:\bishe\1\AbstractGettableByIndexData.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    @SuppressWarnings("unchecked")
    public <T> List<T> getList(int i, TypeToken<T> elementsType) {
        DataType type = getType(i);
        if (type.getName() != DataType.Name.LIST)
            throw new InvalidTypeException(String.format("Column %s is not of list type", getName(i)));

        DataType expectedType = type.getTypeArguments().get(0);
        if (!expectedType.canBeDeserializedAs(elementsType))
            throw new InvalidTypeException(String.format("Column %s has CQL type %s, cannot be retrieved as a list of %s", getName(i), type, elementsType));

        ByteBuffer value = getValue(i);
        if (value == null)
            return Collections.<T>emptyList();

        return Collections.unmodifiableList((List<T>)type.codec(protocolVersion).deserialize(value));
    }

#No. 2511
#File: E:\bishe\1\AbstractGettableByIndexData.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    @SuppressWarnings("unchecked")
    public <T> Set<T> getSet(int i, Class<T> elementsClass) {
        DataType type = getType(i);
        if (type.getName() != DataType.Name.SET)
            throw new InvalidTypeException(String.format("Column %s is not of set type", getName(i)));

        Class<?> expectedClass = type.getTypeArguments().get(0).getName().javaType;
        if (!elementsClass.isAssignableFrom(expectedClass))
            throw new InvalidTypeException(String.format("Column %s is a set of %s (CQL type %s), cannot be retrieved as a set of %s", getName(i), expectedClass, type, elementsClass));

        ByteBuffer value = getValue(i);
        if (value == null)
            return Collections.<T>emptySet();

        return Collections.unmodifiableSet((Set<T>)type.codec(protocolVersion).deserialize(value));
    }

#No. 2512
#File: E:\bishe\1\AbstractGettableByIndexData.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    @SuppressWarnings("unchecked")
    public <T> Set<T> getSet(int i, TypeToken<T> elementsType) {
        DataType type = getType(i);
        if (type.getName() != DataType.Name.SET)
            throw new InvalidTypeException(String.format("Column %s is not of set type", getName(i)));

        DataType expectedType = type.getTypeArguments().get(0);
        if (!expectedType.canBeDeserializedAs(elementsType))
            throw new InvalidTypeException(String.format("Column %s has CQL type %s, cannot be retrieved as a set of %s", getName(i), type, elementsType));

        ByteBuffer value = getValue(i);
        if (value == null)
            return Collections.<T>emptySet();

        return Collections.unmodifiableSet((Set<T>)type.codec(protocolVersion).deserialize(value));
    }

#No. 2513
#File: E:\bishe\1\AbstractGettableByIndexData.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    @SuppressWarnings("unchecked")
    public <K, V> Map<K, V> getMap(int i, Class<K> keysClass, Class<V> valuesClass) {
        DataType type = getType(i);
        if (type.getName() != DataType.Name.MAP)
            throw new InvalidTypeException(String.format("Column %s is not of map type", getName(i)));

        Class<?> expectedKeysClass = type.getTypeArguments().get(0).getName().javaType;
        Class<?> expectedValuesClass = type.getTypeArguments().get(1).getName().javaType;
        if (!keysClass.isAssignableFrom(expectedKeysClass) || !valuesClass.isAssignableFrom(expectedValuesClass))
            throw new InvalidTypeException(String.format("Column %s is a map of %s->%s (CQL type %s), cannot be retrieved as a map of %s->%s", getName(i), expectedKeysClass, expectedValuesClass, type, keysClass, valuesClass));

        ByteBuffer value = getValue(i);
        if (value == null)
            return Collections.<K, V>emptyMap();

        return Collections.unmodifiableMap((Map<K, V>)type.codec(protocolVersion).deserialize(value));
    }

#No. 2514
#File: E:\bishe\1\AbstractGettableByIndexData.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    @SuppressWarnings("unchecked")
    public <K, V> Map<K, V> getMap(int i, TypeToken<K> keysType, TypeToken<V> valuesType) {
        DataType type = getType(i);
        if (type.getName() != DataType.Name.MAP)
            throw new InvalidTypeException(String.format("Column %s is not of map type", getName(i)));

        DataType expectedKeysType = type.getTypeArguments().get(0);
        DataType expectedValuesType = type.getTypeArguments().get(1);
        if (!expectedKeysType.canBeDeserializedAs(keysType) || !expectedValuesType.canBeDeserializedAs(valuesType))
            throw new InvalidTypeException(String.format("Column %s has CQL type %s, cannot be retrieved as a map of %s->%s", getName(i), type, keysType, valuesType));

        ByteBuffer value = getValue(i);
        if (value == null)
            return Collections.<K, V>emptyMap();

        return Collections.unmodifiableMap((Map<K, V>)type.codec(protocolVersion).deserialize(value));
    }

#No. 2515
#File: E:\bishe\1\AbstractGettableByIndexData.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    @SuppressWarnings("unchecked")
    public UDTValue getUDTValue(int i) {
        DataType type = getType(i);
        if (type.getName() != DataType.Name.UDT)
            throw new InvalidTypeException(String.format("Column %s is not a UDT", getName(i)));

        ByteBuffer value = getValue(i);
        if (value == null || value.remaining() == 0)
            return null;

        // UDT always use the protocol V3 to encode values
        return (UDTValue)type.codec(ProtocolVersion.V3).deserialize(value);
    }

#No. 2516
#File: E:\bishe\1\AbstractGettableByIndexData.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    @SuppressWarnings("unchecked")
    public TupleValue getTupleValue(int i) {
        DataType type = getType(i);
        if (type.getName() != DataType.Name.TUPLE)
            throw new InvalidTypeException(String.format("Column %s is not a tuple", getName(i)));

        ByteBuffer value = getValue(i);
        if (value == null || value.remaining() == 0)
            return null;

        // tuples always use the protocol V3 to encode values
        return (TupleValue)type.codec(ProtocolVersion.V3).deserialize(value);
    }

#No. 2517
#File: E:\bishe\1\AbstractGettableByIndexData.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public Object getObject(int i) {
        ByteBuffer raw = getValue(i);
        DataType type = getType(i);
        if (raw == null)
            switch (type.getName()) {
                case LIST:
                    return Collections.emptyList();
                case SET:
                    return Collections.emptySet();
                case MAP:
                    return Collections.emptyMap();
                default:
                    return null;
            }
        else
            return type.deserialize(raw, protocolVersion);
    }

#No. 2518
#File: E:\bishe\1\AbstractGettableData.java
#Comment:
    /**
     * Creates a new AbstractGettableData object.
     *
     * @param protocolVersion the protocol version in which values returned
     * by {@link #getValue} will be returned. This must be a protocol version
     * supported by this driver. In general, the correct value will be the
     * value returned by {@link ProtocolOptions#getProtocolVersion}.
     *
     * @throws IllegalArgumentException if {@code protocolVersion} is not a valid protocol version.
     */

#Code:
    protected AbstractGettableData(ProtocolVersion protocolVersion) {
        super(protocolVersion);
    }

#No. 2519
#File: E:\bishe\1\AbstractGettableData.java
#Comment:
    /**
     * @throws IllegalArgumentException if {@code protocolVersion} does not correspond to any known version.
     *
     * @deprecated This constructor is provided for backward compatibility, use {@link #AbstractGettableData(ProtocolVersion)} instead.
     */

#Code:
    @Deprecated
    protected AbstractGettableData(int protocolVersion) {
        this(ProtocolVersion.fromInt(protocolVersion));
    }

#No. 2520
#File: E:\bishe\1\AbstractGettableData.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public boolean isNull(String name) {
        return isNull(getIndexOf(name));
    }

#No. 2521
#File: E:\bishe\1\AbstractGettableData.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public boolean getBool(String name) {
        return getBool(getIndexOf(name));
    }

#No. 2522
#File: E:\bishe\1\AbstractGettableData.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public int getInt(String name) {
        return getInt(getIndexOf(name));
    }

#No. 2523
#File: E:\bishe\1\AbstractGettableData.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public long getLong(String name) {
        return getLong(getIndexOf(name));
    }

#No. 2524
#File: E:\bishe\1\AbstractGettableData.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public Date getDate(String name) {
        return getDate(getIndexOf(name));
    }

#No. 2525
#File: E:\bishe\1\AbstractGettableData.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public float getFloat(String name) {
        return getFloat(getIndexOf(name));
    }

#No. 2526
#File: E:\bishe\1\AbstractGettableData.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public double getDouble(String name) {
        return getDouble(getIndexOf(name));
    }

#No. 2527
#File: E:\bishe\1\AbstractGettableData.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public ByteBuffer getBytesUnsafe(String name) {
        return getBytesUnsafe(getIndexOf(name));
    }

#No. 2528
#File: E:\bishe\1\AbstractGettableData.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public ByteBuffer getBytes(String name) {
        return getBytes(getIndexOf(name));
    }

#No. 2529
#File: E:\bishe\1\AbstractGettableData.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public String getString(String name) {
        return getString(getIndexOf(name));
    }

#No. 2530
#File: E:\bishe\1\AbstractGettableData.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public BigInteger getVarint(String name) {
        return getVarint(getIndexOf(name));
    }

#No. 2531
#File: E:\bishe\1\AbstractGettableData.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public BigDecimal getDecimal(String name) {
        return getDecimal(getIndexOf(name));
    }

#No. 2532
#File: E:\bishe\1\AbstractGettableData.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public UUID getUUID(String name) {
        return getUUID(getIndexOf(name));
    }

#No. 2533
#File: E:\bishe\1\AbstractGettableData.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public InetAddress getInet(String name) {
        return getInet(getIndexOf(name));
    }

#No. 2534
#File: E:\bishe\1\AbstractGettableData.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public <T> List<T> getList(String name, Class<T> elementsClass) {
        return getList(getIndexOf(name), elementsClass);
    }

#No. 2535
#File: E:\bishe\1\AbstractGettableData.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public <T> List<T> getList(String name, TypeToken<T> elementsType) {
        return getList(getIndexOf(name), elementsType);
    }

#No. 2536
#File: E:\bishe\1\AbstractGettableData.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public <T> Set<T> getSet(String name, Class<T> elementsClass) {
        return getSet(getIndexOf(name), elementsClass);
    }

#No. 2537
#File: E:\bishe\1\AbstractGettableData.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public <T> Set<T> getSet(String name, TypeToken<T> elementsType) {
        return getSet(getIndexOf(name), elementsType);
    }

#No. 2538
#File: E:\bishe\1\AbstractGettableData.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public <K, V> Map<K, V> getMap(String name, Class<K> keysClass, Class<V> valuesClass) {
        return getMap(getIndexOf(name), keysClass, valuesClass);
    }

#No. 2539
#File: E:\bishe\1\AbstractGettableData.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public <K, V> Map<K, V> getMap(String name, TypeToken<K> keysType, TypeToken<V> valuesType) {
        return getMap(getIndexOf(name), keysType, valuesType);
    }

#No. 2540
#File: E:\bishe\1\AbstractGettableData.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public UDTValue getUDTValue(String name) {
        return getUDTValue(getIndexOf(name));
    }

#No. 2541
#File: E:\bishe\1\AbstractGettableData.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public TupleValue getTupleValue(String name) {
        return getTupleValue(getIndexOf(name));
    }

#No. 2542
#File: E:\bishe\1\AbstractGettableData.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public Object getObject(String name) {
        return getObject(getIndexOf(name));
    }

#No. 2543
#File: E:\bishe\1\AbstractGitflowBranchMojo.java
#Comment:
    /**
     * Method exposing Property Resolving for subclasses.
     *
     * @param expression
     * @return
     */

#Code:
    protected String resolveExpression(final String expression) {
        return resolver.resolveValue(expression, project.getProperties(), systemEnvVars);
    }

#No. 2544
#File: E:\bishe\1\AbstractGitflowBranchMojo.java
#Comment:
            /*
             * (/origin/)?master goes to the maven 'release' repo.
             * (/origin/)?release/(.*) , (/origin/)?hotfix/(.*) , and (/origin/)?bugfix/(.*) go to the maven 'stage' repo.
             * (/origin/)?develop goes to the 'snapshot' repo.
             * All other builds will use the default semantics for 'deploy'.
             */

#Code:
            if (gitBranch.matches(masterBranchPattern)) {
                logExecute(GitBranchType.MASTER, gitBranch, masterBranchPattern);
            } else if (gitBranch.matches(supportBranchPattern)) {
                logExecute(GitBranchType.SUPPORT, gitBranch, supportBranchPattern);
            } else if (gitBranch.matches(releaseBranchPattern)) {
                logExecute(GitBranchType.RELEASE, gitBranch, releaseBranchPattern);
            } else if (gitBranch.matches(hotfixBranchPattern)) {
                logExecute(GitBranchType.HOTFIX, gitBranch, hotfixBranchPattern);
            } else if (gitBranch.matches(developmentBranchPattern)) {
                logExecute(GitBranchType.DEVELOPMENT, gitBranch, developmentBranchPattern);
            } else {
                logExecute(GitBranchType.OTHER, gitBranch, null);
            }

#No. 2545
#File: E:\bishe\1\AbstractGolangMojo.java
#Comment:
  /**
   * set of flags to be ignored among build and extra build flags, for inside use
   */

#Code:
  protected final Set<String> buildFlagsToIgnore = new HashSet<String>();
  
  private static final String[] BANNER = new String[]{"______  ___             _________     ______",
    "___   |/  /__   __________  ____/________  / ______ ______________ _",
    "__  /|_/ /__ | / /_  __ \\  / __ _  __ \\_  /  _  __ `/_  __ \\_  __ `/",
    "_  /  / / __ |/ /_  / / / /_/ / / /_/ /  /___/ /_/ /_  / / /  /_/ / ",
    "/_/  /_/  _____/ /_/ /_/\\____/  \\____//_____/\\__,_/ /_/ /_/_\\__, /",
    "                                                           /____/",
    "                  https://github.com/raydac/mvn-golang",
    ""
  };

#No. 2546
#File: E:\bishe\1\AbstractGPlusProvider.java
#Comment:
  /**
   * Set and overwrite the default before date that was read from the configuration file.
   * @param defaultBeforeDate defaultBeforeDate
   */

#Code:
  public void setDefaultBeforeDate(DateTime defaultBeforeDate) {
    this.config.setDefaultBeforeDate(defaultBeforeDate);
  }

#No. 2547
#File: E:\bishe\1\AbstractGPlusProvider.java
#Comment:
  /**
   * Set and overwrite the default after date that was read from teh configuration file.
   * @param defaultAfterDate defaultAfterDate
   */

#Code:
  public void setDefaultAfterDate(DateTime defaultAfterDate) {
    this.config.setDefaultAfterDate(defaultAfterDate);
  }

#No. 2548
#File: E:\bishe\1\AbstractGPlusProvider.java
#Comment:
  /**
   * Sets and overwrite the user info from the configuaration file.  Uses the defaults before and after dates.
   * @param userIds userIds
   */

#Code:
  public void setUserInfoWithDefaultDates(Set<String> userIds) {
    List<UserInfo> gplusUsers = new LinkedList<>();
    for (String userId : userIds) {
      UserInfo user = new UserInfo();
      user.setUserId(userId);
      user.setAfterDate(this.config.getDefaultAfterDate());
      user.setBeforeDate(this.config.getDefaultBeforeDate());
      gplusUsers.add(user);
    }
    this.config.setGooglePlusUsers(gplusUsers);
  }

#No. 2549
#File: E:\bishe\1\AbstractGPlusProvider.java
#Comment:
  /**
   * Set and overwrite user into from the configuration file. Only sets after date.
   * @param usersAndAfterDates usersAndAfterDates
   */

#Code:
  public void setUserInfoWithAfterDate(Map<String, DateTime> usersAndAfterDates) {
    List<UserInfo> gplusUsers = new LinkedList<>();
    for (String userId : usersAndAfterDates.keySet()) {
      UserInfo user = new UserInfo();
      user.setUserId(userId);
      user.setAfterDate(usersAndAfterDates.get(userId));
      gplusUsers.add(user);
    }
    this.config.setGooglePlusUsers(gplusUsers);
  }

#No. 2550
#File: E:\bishe\1\AbstractGradientPaint.java
#Comment:
	/**
     * Returns the transparency mode for this <code>GradientPaint</code>.
     * @return an integer value representing this <code>GradientPaint</code>
     * object's transparency mode.
     * @see Transparency
     */

#Code:
	public int getTransparency()
	{
		return (((color1.getAlpha() & color2.getAlpha()) == 0xff) ? OPAQUE : TRANSLUCENT);
	}

#No. 2551
#File: E:\bishe\1\AbstractGraphGenerator.java
#Comment:
	/**
	 * limits for highlighting node - find interval into which count fits and highlight with color
	 */

#Code:
	protected List<ColorInterval> highlightColorIntervalList;

	public AbstractGraphGenerator() {
		super();
	}

#No. 2552
#File: E:\bishe\1\AbstractGraphicsState.java
#Comment:
	/**
	 *  Calculated from the buffered-image
	 */

#Code:
	protected transient WritableRaster raster;

	protected BufferedImage image;
	protected Rectangle clip;

	// __________________________________________________________________________

	public Graphics create(int x, int y, int w, int h)
	{
		BufferedImage image = (BufferedImage) createImage(x, y, w, h);
		if (image == null)
			return null;

		Graphics g = image.createGraphics();
		g.translate(x > 0 ? 0 : x, y > 0 ? 0 : y);
		g.setClip(0, 0, w, h);
		return g;
	}

#No. 2553
#File: E:\bishe\1\AbstractGraphicsState.java
#Comment:
	/**
	 *  Creates a sub-raster of the master image if it is apropriate otherwise
	 *  it will have to create a brand-new raster image.
	 */

#Code:
	protected WritableRaster createRaster(int x, int y, int w, int h)
	{
		// should not be passed in null graphics
		if (w < 1 || h < 1)
			return null;

		// should not be passed in elements outside of the raser
		if (x >= clip.x + clip.width || y >= clip.y + clip.height)
			return null;

		// calculate where to generate the raster
		int xPos = x < 0 ? clip.x : x;
		int yPos = y < 0 ? clip.y : y;

		int width = x < 0 ? x + w : w;
		width = Math.min(width, clip.width -xPos);

		int height =  y < 0 ? y + h : h;
		height = Math.min(height, clip.height -yPos);

		if (height < 1 || width < 1)
			return null;

		if (TRACE)
		{
			System.out.println("x="+x+"y="+y+"w="+w+"h="+h);
			System.out.println("xpos=" +xPos + " yPos=" +yPos + "width=" +width + "height=" + height);
			System.out.println(clip.toString());
			System.out.println();
		}
		return (WritableRaster) raster.createChild(xPos, yPos, width, height, 0, 0, null);
	}

#No. 2554
#File: E:\bishe\1\AbstractGraphTooltip.java
#Comment:
    /**
     * @return FlowPage
     */

#Code:
    protected FlowPage createFlowPage() {
        final FlowPage page = new FlowPage();
        final ConstrainedPageFlowLayout pageLayout =
                new ConstrainedPageFlowLayout(page);
        page.setLayoutManager(pageLayout);
        pageLayout.setMaxFlowWidth(TOOLTIP_WIDTH);
        page.setBorder(new SectionBorder());
        page.setFont(Application.getInstance().getFont(Application.TOOLTIP_FONT));
        add(page);
        return page;
    }

#No. 2555
#File: E:\bishe\1\AbstractGridPageAction.java
#Comment:
	/**
	 * 根据请求的条件查找列表对象
	 *
	 * @return
	 */

#Code:
	protected List<T> findList() {
		return this.getQuery().condition(this.getGridCondition()).list();
	}

#No. 2556
#File: E:\bishe\1\AbstractGridPageAction.java
#Comment:
	/**
	 * 根据请求的条件查找分页信息对象
	 *
	 * @return
	 */

#Code:
	protected Page<T> findPage() {
		return this.getQuery().condition(this.getGridCondition())
				.page(page.getPageNo(), page.getPageSize());
	}

#No. 2557
#File: E:\bishe\1\AbstractGridPageAction.java
#Comment:
	/**
	 * 是否启用兼容模式
	 * <p>子类不想使用兼容模式时，推荐在属性配置文件中添加 quirksMode=false 配置。
	 * 也可以复写此方法返回 false。新增此方法是为了使旧代码不需要修改也可以正常使用。
	 * </p>
	 *
	 * @return 如果子类没有复写、属性文件有没有配置quirksMode则默认返回true
	 */

#Code:
	protected boolean isQuirksMode() {
		return !"false".equals(getText("quirksMode"));
	}

#No. 2558
#File: E:\bishe\1\AbstractGridPageAction.java
#Comment:
	/**
	 * 初始化默认Action的Url
	 *
	 * @deprecated 使用getHtmlPageNamespace()的默认行为代替：[namespace]/create|open|edit|delete
	 */

#Code:
	protected void initDefaultActionUrl(ListPage listPage) {
		listPage.setCreateUrl(getCreateUrl()).setDeleteUrl(getDeleteUrl())
				.setEditUrl(this.getEditUrl()).setOpenUrl(this.getOpenUrl());
	}

#No. 2559
#File: E:\bishe\1\AbstractGridPageAction.java
#Comment:
	/**
	 * 附加头部信息
	 */

#Code:
	protected Component getHtmlPageHeader() {
		// 默认为工具条
		return getHtmlPageToolbar();
	}

#No. 2560
#File: E:\bishe\1\AbstractGridPageAction.java
#Comment:
	/**
	 * 附加中间信息
	 */

#Code:
	protected Component getHtmlPageCenter() {
		// 默认为Grid
		return getHtmlPageGrid();
	}

#No. 2561
#File: E:\bishe\1\AbstractGridPageAction.java
#Comment:
	/**
	 * 附加页脚信息
	 */

#Code:
	protected Component getHtmlPageFooter() {
		return null;
	}

#No. 2562
#File: E:\bishe\1\AbstractGridPageAction.java
#Comment:
	/**
	 * 获取视图action的简易名称
	 *
	 * @deprecated 使用getHtmlPageNamespace()的默认行为代替：[namespace]/page|list|data
	 */

#Code:
	protected String getViewActionName() {
		return getFormActionName() + "s";
	}

#No. 2563
#File: E:\bishe\1\AbstractGridPageAction.java
#Comment:
	/**
	 * 获取表单action的简易名称
	 *
	 * @deprecated 使用getHtmlPageNamespace()的默认行为代替：[namespace]/create|open|edit|delete
	 */

#Code:
	protected String getFormActionName() {
		// 从类名解析出domain名
		return org.springframework.util.StringUtils.uncapitalize(this.getClass().getSimpleName()
				.replaceAll("Action|sAction|ViewAction|FormAction", ""));
	}

#No. 2564
#File: E:\bishe\1\AbstractGridPageAction.java
#Comment:
	/**
	 * 模块所在上下文路径
	 *
	 * @deprecated 使用getHtmlPageNamespace()的默认行为代替
	 */

#Code:
	protected String getModuleContextPath() {
		return null;
	}

#No. 2565
#File: E:\bishe\1\AbstractGridPageAction.java
#Comment:
	/**
	 * 默认使用此命名空间构建CRUD的Action路径
	 *
	 * @return
	 */

#Code:
	@Override
	protected String getHtmlPageNamespace() {
		return isQuirksMode() ? this.getModuleContextPath() + "/" + getViewActionName() : getActionNamespace();
	}

#No. 2566
#File: E:\bishe\1\AbstractGridPageAction.java
#Comment:
	/**
	 * 编辑的url
	 *
	 * @deprecated 使用getHtmlPageNamespace()的默认行为代替：[namespace]/edit
	 */

#Code:
	protected String getEditUrl() {
		return this.getModuleContextPath() + "/" + getFormActionName() + "/edit";
	}

#No. 2567
#File: E:\bishe\1\AbstractGridPageAction.java
#Comment:
	/**
	 * 查看的url
	 *
	 * @deprecated 使用getHtmlPageNamespace()的默认行为代替：[namespace]/open
	 */

#Code:
	protected String getOpenUrl() {
		return getModuleContextPath() + "/" + getFormActionName() + "/open";
	}

#No. 2568
#File: E:\bishe\1\AbstractGridPageAction.java
#Comment:
	/**
	 * 删除的url
	 *
	 * @deprecated 使用getHtmlPageNamespace()的默认行为代替：[namespace]/delete
	 */

#Code:
	protected String getDeleteUrl() {
		return this.getModuleContextPath() + "/" + getFormActionName() + "/delete";
	}

#No. 2569
#File: E:\bishe\1\AbstractGridPageAction.java
#Comment:
	/**
	 * 新建的url
	 *
	 * @deprecated 使用getHtmlPageNamespace()的默认行为代替：[namespace]/create
	 */

#Code:
	protected String getCreateUrl() {
		return this.getModuleContextPath() + "/" + getFormActionName() + "/create";
	}

#No. 2570
#File: E:\bishe\1\AbstractGridPageAction.java
#Comment:
	/**
	 * 获取表格数据的额外请求参数
	 */

#Code:
	protected JSONObject getGridExtrasData() {
		JSONObject json = new JSONObject();
		try {
			this.extendGridExtrasData(json);
		} catch (JSONException e) {
			throw new CoreException(e);
		}
		return json.length() == 0 ? null : json;
	}

#No. 2571
#File: E:\bishe\1\AbstractGridPageAction.java
#Comment:
	/**
	 * 扩展表格数据的额外请求参数
	 *
	 * @param json 已经初始化好的Json对象
	 */

#Code:
	protected void extendGridExtrasData(JSONObject json) throws JSONException {
		// 注意put入到json的key要与action的字段名一致
	}

#No. 2572
#File: E:\bishe\1\AbstractGridPageAction.java
#Comment:
	/**
	 * 获取表格双击行的js处理函数名
	 */

#Code:
	protected String getGridDblRowMethod() {
		return this.isReadonly() ? "bc.page.open" : "bc.page.edit";
	}

#No. 2573
#File: E:\bishe\1\AbstractGridPageAction.java
#Comment:
	/**
	 * 构建表格列头
	 *
	 * @return
	 */

#Code:
	protected GridHeader getGridHeader(List<Column> columns) {
		GridHeader header = new GridHeader();
		header.setColumns(columns);
		header.setToggleSelectTitle(getText("title.toggleSelect"));
		return header;
	}

#No. 2574
#File: E:\bishe\1\AbstractGridPageAction.java
#Comment:
	/**
	 * 构建数据部分的html
	 *
	 * @return
	 */

#Code:
	protected GridData getGridData(List<Column> columns) {
		GridData data = new GridData() {
			public String getRowClass(List<? extends Object> data,
			                          Object rowData, int index, int type) {
				return getGridRowClass(data, rowData, index, type);
			}
		};
		if (this.page != null) {
			data.setPageNo(page.getPageNo());
			data.setPageCount(page.getPageCount());
			data.setTotalCount(page.getTotalCount());
		}
		data.setData(this.rebuildGridData(this.es));
		data.setColumns(columns);
		data.setRowLabelExpression(getGridRowLabelExpression());
		// data.setName(getText(StringUtils.uncapitalize(getEntityConfigName())));
		return data;
	}

#No. 2575
#File: E:\bishe\1\AbstractGridPageAction.java
#Comment:
	/**
	 * 对视图的数据执行特殊的处理，默认不作任何处理
	 *
	 * @param data 视图的数据
	 * @return 处理后的数据
	 */

#Code:
	protected List<T> rebuildGridData(List<T> data) {
		return data;
	}

#No. 2576
#File: E:\bishe\1\AbstractGridPageAction.java
#Comment:
	/**
	 * 获取数据行需要附加的特殊样式
	 *
	 * @param data    整个grid的数据
	 * @param rowData 此行包含的数据
	 * @param index   行的索引号
	 * @param type    0-左侧固定列的行,1-右侧数据列的行
	 * @return 返回空将不附加特殊样式
	 */

#Code:
	protected String getGridRowClass(List<? extends Object> data,
	                                 Object rowData, int index, int type) {
		return null;
	}

#No. 2577
#File: E:\bishe\1\AbstractGridPageAction.java
#Comment:
	/**
	 * 构建视图页面表格底部的工具条
	 */

#Code:
	protected GridFooter getGridFooter(Grid grid) {
		GridFooter footer = new GridFooter();

		// 刷新按钮
		footer.addButton(GridFooter
				.getDefaultRefreshButton(getText("label.refresh")));

		// 本地或远程排序方式切换按钮
		footer.addButton(GridFooter.getDefaultSortButton(grid.isRemoteSort(),
				getText("title.click2remoteSort"),
				getText("title.click2localSort")));

		// 分页按钮
		if (this.page != null) {
			footer.addButton(new SeekGroupButton().setPageNo(page.getPageNo())
					.setPageCount(page.getPageCount())
					.setTotalCount(page.getTotalCount()));
			footer.addButton(new PageSizeGroupButton().setActiveValue(25)
					.setValues(new int[]{25, 50, 100})
					.setTitle(getText("label.pageSize")));
		}

		// 添加自定义的按钮
		this.extendGridFooterButton(footer);

		return footer;
	}

#No. 2578
#File: E:\bishe\1\AbstractGridPageAction.java
#Comment:
	/**
	 * 添加自定义的Grid底部工具条按钮
	 *
	 * @param gridFooter 已初始化好的GridFooter
	 */

#Code:
	protected void extendGridFooterButton(GridFooter gridFooter) {

	}

#No. 2579
#File: E:\bishe\1\AbstractGridPageAction.java
#Comment:
	/**
	 * grid数据的查询条件
	 */

#Code:
	protected Condition getGridCondition() {
		return new AndCondition().add(getGridSpecalCondition())
				.add(getGridSearchCondition()).add(getGridOrderCondition());
	}

#No. 2580
#File: E:\bishe\1\AbstractGridPageAction.java
#Comment:
	/**
	 * 构建排序条件
	 *
	 * @return
	 */

#Code:
	protected OrderCondition getGridOrderCondition() {
		if (this.sort == null || this.sort.length() == 0)
			return getGridDefaultOrderCondition();

		// sort为grid的排序配置，格式为"filed1 asc,filed2 desc,..."
		String[] cfgs = this.sort.split(",");
		String[] cfg = cfgs[0].split(" ");

		OrderCondition oc = new OrderCondition(cfg[0],
				cfg.length > 1 ? (Direction.Desc.toSymbol().equalsIgnoreCase(
						cfg[1]) ? Direction.Desc : Direction.Asc)
						: Direction.Asc
		);

		for (int i = 1; i < cfgs.length; i++) {
			cfg = cfgs[i].split(" ");
			oc.add(cfg[0], cfg.length > 1 ? (Direction.Desc.toSymbol()
					.equalsIgnoreCase(cfg[1]) ? Direction.Desc : Direction.Asc)
					: Direction.Asc);
		}

		return oc;
	}

#No. 2581
#File: E:\bishe\1\AbstractGridPageAction.java
#Comment:
	/**
	 * 构建默认的排序条件，通常用于子类复写
	 *
	 * @return
	 */

#Code:
	protected OrderCondition getGridDefaultOrderCondition() {
		return null;
	}

#No. 2582
#File: E:\bishe\1\AbstractGridPageAction.java
#Comment:
	/**
	 * 构建特殊的条件，通常用于子类复写
	 *
	 * @return
	 */

#Code:
	protected Condition getGridSpecalCondition() {
		return null;
	}

#No. 2583
#File: E:\bishe\1\AbstractGridPageAction.java
#Comment:
	/**
	 * 构建简易+高级的查询条件
	 *
	 * @return
	 */

#Code:
	protected MixCondition getGridSearchCondition() {
		return ConditionUtils.mix2AndCondition(
				this.getGridSearchCondition4Simple(),
				this.getGridSearchCondition4Advance());
	}

#No. 2584
#File: E:\bishe\1\AbstractGridPageAction.java
#Comment:
	/**
	 * 构建单个查询条件的方法
	 *
	 * @param field
	 * @param value
	 * @return
	 */

#Code:
	protected Condition getGridSearchCondition4OneField(String field,
	                                                    String value) {
		return buildDefaultLikeCondition(field, value);
	}

#No. 2585
#File: E:\bishe\1\AbstractGridPageAction.java
#Comment:
	/**
	 * 自动根据值是否在首末包含%符号来生成相应的Like条件
	 *
	 * @param field
	 * @param value
	 * @return
	 */

#Code:
	protected Condition buildDefaultLikeCondition(String field, String value) {
		if (value == null || value.length() == 0)
			return null;
		boolean s = value.startsWith("%");
		boolean e = value.endsWith("%");
		if (s && !e) {
			return new LikeRightCondition(field, "%" + value);
		} else if (!s && e) {
			return new LikeLeftCondition(field, value + "%");
		} else {
			return new LikeCondition(field, value);
		}
	}

#No. 2586
#File: E:\bishe\1\AbstractGridPageAction.java
#Comment:
	/**
	 * 获取高级搜索条件框输入值
	 *
	 * @param key 在data-condition中配置的name属性值
	 * @return 返回的值是根据值类型转换后的值
	 */

#Code:
	protected Object getGridSearchCondition4AdvanceValue(String key) {
		return getGridSearchCondition4AdvanceValue(key, false);
	}

#No. 2587
#File: E:\bishe\1\AbstractGridPageAction.java
#Comment:
	/**
	 * 获取高级搜索条件框输入值
	 *
	 * @param key    在data-condition中配置的name属性值
	 * @param origin 是否返回原值还是根据值类型转换后的值
	 * @return
	 */

#Code:
	protected Object getGridSearchCondition4AdvanceValue(String key,
	                                                     boolean origin) {
		JSONArray jsons = getSearch4advanceJsonArray();
		if (jsons == null)
			return null;
		JSONObject json;
		try {
			for (int i = 0; i < jsons.length(); i++) {
				json = jsons.getJSONObject(i);
				if (json.has("name") && key.equals(json.getString("name"))) {
					if (origin) {
						return json.get("value");
					} else {
						return StringUtils
								.convertValueByType(json.getString("type"),
										json.getString("value"));
					}
				}
			}
			return null;
		} catch (JSONException e) {
			throw new CoreException(e);
		}
	}

#No. 2588
#File: E:\bishe\1\AbstractGridPageAction.java
#Comment:
	/**
	 * @param useDisabledReplaceDelete 控制是使用删除按钮还是禁用按钮
	 * @return
	 */

#Code:
	protected Toolbar getHtmlPageToolbar(boolean useDisabledReplaceDelete) {
		Toolbar tb = new Toolbar();

		if (this.isReadonly()) {
			// 查看按钮
			tb.addButton(getDefaultOpenToolbarButton());
		} else {
			// 新建按钮
			tb.addButton(getDefaultCreateToolbarButton());

			// 编辑按钮
			tb.addButton(getDefaultEditToolbarButton());

			if (useDisabledReplaceDelete) {
				// 禁用按钮
				tb.addButton(getDefaultDisabledToolbarButton());
			} else {
				// 删除按钮
				tb.addButton(getDefaultDeleteToolbarButton());
			}
		}

		// 搜索按钮
		tb.addButton(getDefaultSearchToolbarButton());

		return tb;
	}

#No. 2589
#File: E:\bishe\1\AbstractGridPageAction.java
#Comment:
	/**
	 * 创建默认的删除按钮
	 *
	 * @return
	 */

#Code:
	protected Button getDefaultDeleteToolbarButton() {
		return Toolbar.getDefaultDeleteToolbarButton(getText("label.delete"));
	}

#No. 2590
#File: E:\bishe\1\AbstractGridPageAction.java
#Comment:
	/**
	 * 创建默认的禁用按钮
	 *
	 * @return
	 */

#Code:
	protected Button getDefaultDisabledToolbarButton() {
		return Toolbar
				.getDefaultDisabledToolbarButton(getText("label.disabled"));
	}

#No. 2591
#File: E:\bishe\1\AbstractGridPageAction.java
#Comment:
	/**
	 * 创建默认的编辑按钮
	 *
	 * @return
	 */

#Code:
	protected Button getDefaultEditToolbarButton() {
		return Toolbar.getDefaultEditToolbarButton(getText("label.edit"));
	}

#No. 2592
#File: E:\bishe\1\AbstractGridPageAction.java
#Comment:
	/**
	 * 创建默认的新建按钮
	 *
	 * @return
	 */

#Code:
	protected Button getDefaultCreateToolbarButton() {
		return Toolbar.getDefaultCreateToolbarButton(getText("label.create"));
	}

#No. 2593
#File: E:\bishe\1\AbstractGridPageAction.java
#Comment:
	/**
	 * 创建默认的查看按钮
	 *
	 * @return
	 */

#Code:
	protected Button getDefaultOpenToolbarButton() {
		return Toolbar.getDefaultOpenToolbarButton(getText("label.read"));
	}

#No. 2594
#File: E:\bishe\1\AbstractGridPageAction.java
#Comment:
	/**
	 * 创建默认的搜索按钮
	 *
	 * @return
	 */

#Code:
	protected Button getDefaultSearchToolbarButton() {
		if (this.useAdvanceSearch()) {
			return Toolbar.getDefaultAdvanceSearchToolbarButton(
					getText("title.click2search"),
					getText("title.click2advanceSearch"),
					this.getAdvanceSearchConditionsActionPath());
		} else {
			return Toolbar
					.getDefaultSearchToolbarButton(getText("title.click2search"));
		}
	}

#No. 2595
#File: E:\bishe\1\AbstractGridPageAction.java
#Comment:
	/**
	 * 获取Entity的状态值转换列表
	 *
	 * @return
	 */

#Code:
	protected Map<String, String> getEntityStatuses() {
		Map<String, String> statuses = new HashMap<String, String>();
		statuses.put(String.valueOf(BCConstants.STATUS_DISABLED),
				getText("entity.status.disabled"));
		statuses.put(String.valueOf(BCConstants.STATUS_ENABLED),
				getText("entity.status.enabled"));
		statuses.put(String.valueOf(BCConstants.STATUS_DELETED),
				getText("entity.status.deleted"));
		return statuses;
	}

#No. 2596
#File: E:\bishe\1\AbstractGridPageAction.java
#Comment:
	/**
	 * 获取高级搜索条件框的action路径，默认为“[上下文路径]/[子系统路径]/[domain类名的小写]/conditions”
	 *
	 * @return
	 */

#Code:
	protected String getAdvanceSearchConditionsActionPath() {
		return this.getModuleContextPath() + "/" + this.getViewActionName() + "/conditions";
	}

#No. 2597
#File: E:\bishe\1\AbstractGridPageAction.java
#Comment:
	/**
	 * 是否使用高级搜索，默认为false
	 *
	 * @return
	 */

#Code:
	protected boolean useAdvanceSearch() {
		return false;
	}

#No. 2598
#File: E:\bishe\1\AbstractGridPageAction.java
#Comment:
	/**
	 * 高级搜索条件窗口
	 */

#Code:
	public String conditions() throws Exception {
		// 加载条件窗口的可选项列表信息
		this.initConditionsFrom();

		return SUCCESS;
	}

#No. 2599
#File: E:\bishe\1\AbstractGridPageAction.java
#Comment:
	/**
	 * 初始化高级及搜索条件窗口的可选项列表信息
	 */

#Code:
	protected void initConditionsFrom() throws Exception {

	}

#No. 2600
#File: E:\bishe\1\AbstractGridRenderer.java
#Comment:
    /**
     * @param facesContext
     * @param child
     */

#Code:
    protected void renderChild(FacesContext facesContext, UIComponent child) throws IOException {
        ResponseWriter responseWriter = facesContext.getResponseWriter();

        responseWriter.startElement("div", child);
        child.encodeAll(facesContext);
        responseWriter.endElement("div");
    }

#No. 2601
#File: E:\bishe\1\AbstractGROOVEControl.java
#Comment:
	/**
	 * @param item
	 */

#Code:
	private void addChilds(NodeItem item) {
		Iterator<NodeItem> i = item.children();
		while( i.hasNext()) {
			NodeItem iChild = i.next();
			iChild.setHighlighted(true);
			selectedItems.add(iChild);
			addChilds(iChild);
		}		
	}

#No. 2602
#File: E:\bishe\1\AbstractGROOVEControl.java
#Comment:
	/**
	 * @param toRoot
	 */

#Code:
	private void clear(Visualization v,TemporalObject toRoot) {
		v.getVisualItem("GROOVE", toRoot).setHighlighted(false);
		for(TemporalObject to : toRoot.childObjects())
			clear(v,to);
	}

#No. 2603
#File: E:\bishe\1\AbstractGROOVEControl.java
#Comment:
	/**
	 * @param root
	 * @param pattern
	 * @param patternRoot
	 */

#Code:
	private void searchPattern(Visualization v,TemporalObject dataNode,TemporalObject patternNode) {
//		Granularity granularity = new Granularity(JavaDateCalendarManager.getSingleton().getDefaultCalendar(),
//				dataNode.getTemporalElement().asGeneric().getGranularityId(),
//				dataNode.getTemporalElement().asGeneric().getGranularityContextId());
//		Granularity patternGranularity = new Granularity(JavaDateCalendarManager.getSingleton().getDefaultCalendar(),
//				patternNode.getTemporalElement().asGeneric().getGranularityId(),
//				patternNode.getTemporalElement().asGeneric().getGranularityContextId());
//		if (granularity.getIdentifier() == patternGranularity.getIdentifier() &&
//				granularity.getGranularityContextIdentifier() == patternGranularity.getGranularityContextIdentifier()) {
//		}
//	} else {
//		for(TemporalObject ipo : patternNode.childObjects())
//			searchPatternRecurse(v,dataNode,ipo,baseValue);
//	}

#No. 2604
#File: E:\bishe\1\AbstractGROOVEControl.java
#Comment:
	/**
	 * @param root
	 * @param patternRoot
	 */

#Code:
	private boolean buildPattern(Node data, TemporalDataset pattern, TemporalObject current) {
		boolean result = false;
		Iterator<Node> i = data.children();
		while(i.hasNext()) {
			Node iChild = i.next();
			TemporalElement el = ((TemporalObject)((TableNodeItem)iChild).getSourceTuple()).getTemporalElement();
			try {
				TemporalElement newel = pattern.addInstant(el.getGranule());
				TemporalObject newObj = pattern.addTemporalObject(newel);
				boolean keep = buildPattern(iChild,pattern,newObj);
				if (((VisualItem)iChild).isHighlighted()) {				
					newObj.setDouble("value",iChild.getDouble("value"));			
					current.linkWithChild(newObj);
					result = true;
				} else if(keep) {
					newObj.setDouble("value",Double.NaN);
					current.linkWithChild(newObj);
					result = true;
				} else {
					pattern.removeNode(newObj);
				}
			} catch (TemporalDataException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} 
		}
		
		return result;
	}

#No. 2605
#File: E:\bishe\1\AbstractGroupLight.java
#Comment:
	/**
	 * Translate actor in a direction of speed without stopping. Actor moves
	 * in constants speed set without acceleration 
     * 
     * @param speedX axis-X speed
	 * @param speedY axis-Y speed
     * @param delta the delta time for accurate speed
	 * */

#Code:
	public void translateWithoutAcc(float speedX, float speedY, float delta){
		setPosition(getX() + (speedX * delta), getY() + (speedY * delta));
	}

#No. 2606
#File: E:\bishe\1\AbstractGroupLight.java
#Comment:
	/**
	 * Get textureRegion of the actor
     * 
     * @return TextureRegion
	 * 
	 * */

#Code:
	public TextureRegion getTextureRegion() {
		return textureRegion;
	}

#No. 2607
#File: E:\bishe\1\AbstractGroupLight.java
#Comment:
	/**
	 * Set texture region for the actor, it will be drawn only if texture region is set and active
     * 
     * @param textureRegion texture region of the actor
	 * @param isTextureRegionActive set texture region active to be drawn or not
	 * */

#Code:
	public void setTextureRegion(TextureRegion textureRegion, boolean isTextureRegionActive) {
		this.textureRegion = textureRegion;
		this.isTextureRegionActive = isTextureRegionActive;
	}

#No. 2608
#File: E:\bishe\1\AbstractGuiComponent.java
#Comment:
	/**
	 * <p>Constructor for AbstractGuiComponent.</p>
	 *
	 * @param parent a {@link lupos.gui.operatorgraph.visualeditor.guielements.VisualGraph} object.
	 * @param gw a {@link lupos.gui.operatorgraph.graphwrapper.GraphWrapper} object.
	 * @param operator a T object.
	 * @param movable a boolean.
	 */

#Code:
	protected AbstractGuiComponent(final VisualGraph<T> parent, final GraphWrapper gw, final T operator, final boolean movable) {
		super(parent, gw, movable);

		this.parent = parent;
		this.operator = operator;
	}

#No. 2609
#File: E:\bishe\1\AbstractGuiComponent.java
#Comment:
	/**
	 * <p>delete.</p>
	 */

#Code:
	public void delete() {
		if(this.isAnnotation()) {
			this.getBox().deleteLineAnnotation(this.parent.createGraphWrapper(this.child));
		}
		else {
			this.getBox().removeAnnotations();

			// remove line annotations to this element...
			for(final GraphWrapper preGW : this.getBox().getOp().getPrecedingElements()) {
				this.parent.getBoxes().get(preGW).removeAnnotationsTo(this.gw);
			}

			// remove box from QueryGraph...
			this.parent.getBoxes().remove(this.gw);
		}

		// removing operator from OperatorContainer if he was in one...
		final AbstractGuiComponent<T> outerRef = this.parent.outerReference;

		if(outerRef != null && outerRef.getParentOp() instanceof OperatorContainer && !this.isAnnotation()) {
			((OperatorContainer) outerRef.getParentOp()).removeOperator((Operator) this.operator);
		}

		// remove this graphical component...
		this.parent.remove(this);
		this.parent.removeFromRootList(this.parent.createGraphWrapper(this.operator));

		this.parent.repaint();
	}

#No. 2610
#File: E:\bishe\1\AbstractGuiComponent.java
#Comment:
	/**
	 * <p>getVisualEditor.</p>
	 *
	 * @return a {@link lupos.gui.operatorgraph.visualeditor.VisualEditor} object.
	 */

#Code:
	public VisualEditor<T> getVisualEditor() {
		return this.parent.visualEditor;
	}

#No. 2611
#File: E:\bishe\1\AbstractGuiComponent.java
#Comment:
	/**
	 * <p>getParentQG.</p>
	 *
	 * @return a {@link lupos.gui.operatorgraph.visualeditor.guielements.VisualGraph} object.
	 */

#Code:
	public VisualGraph<T> getParentQG() {
		return this.parent;
	}

#No. 2612
#File: E:\bishe\1\AbstractGuiComponent.java
#Comment:
	/**
	 * <p>Getter for the field <code>parentOp</code>.</p>
	 *
	 * @return a T object.
	 */

#Code:
	public T getParentOp() {
		if(this.isAnnotation()) {
			return this.parentOp;
		}
		else {
			return this.operator;
		}
	}

#No. 2613
#File: E:\bishe\1\AbstractGuiComponent.java
#Comment:
	/**
	 * <p>Getter for the field <code>child</code>.</p>
	 *
	 * @return a T object.
	 */

#Code:
	public T getChild() {
		return this.child;
	}

#No. 2614
#File: E:\bishe\1\AbstractGuiComponent.java
#Comment:
	/**
	 * <p>Getter for the field <code>operator</code>.</p>
	 *
	 * @return a T object.
	 */

#Code:
	public T getOperator() {
		return this.operator;
	}

#No. 2615
#File: E:\bishe\1\AbstractGuiComponent.java
#Comment:
	/**
	 * <p>makeSuggestions.</p>
	 */

#Code:
	protected void makeSuggestions() {
		this.parent.visualEditor.getStatusBar().clear();

		((Suggester<T>) this.parent.visualEditor).makeSuggestions(this.operator);
	}

#No. 2616
#File: E:\bishe\1\AbstractGuiComponent.java
#Comment:
	/**
	 * <p>handleConnectionMode.</p>
	 *
	 * @return a boolean.
	 */

#Code:
	public boolean handleConnectionMode() {
		// get the connection mode...
		final Connection<T> connectionMode = this.parent.visualEditor.connectionMode;

		if(connectionMode != null) { // create a connection...
			connectionMode.addOperator(this.operator);

			return true;
		}

		return false;
	}

#No. 2617
#File: E:\bishe\1\AbstractGuiComponent.java
#Comment:
	/**
	 * <p>inConnectionMode.</p>
	 *
	 * @return a boolean.
	 */

#Code:
	public boolean inConnectionMode() {
		return this.parent.visualEditor.connectionMode != null;
	}

#No. 2618
#File: E:\bishe\1\AbstractGuiComponent.java
#Comment:
	/**
	 * <p>validateOperatorPanel.</p>
	 *
	 * @param showErrors a boolean.
	 * @param data a {@link java.lang.Object} object.
	 * @return a boolean.
	 */

#Code:
	public abstract boolean validateOperatorPanel(boolean showErrors, Object data);
}
}

#No. 2619
#File: E:\bishe\1\AbstractGUIInventory.java
#Comment:
	/**
	 * The constructor
	 *
	 * @param size  inventory size (multiply of 9)
	 * @param title title message
	 */

#Code:
	public AbstractGUIInventory(int size, MessageWrapper title) {
		inventory = ChestGUIUtils.createInventory(size, title);
	}

#No. 2620
#File: E:\bishe\1\AbstractGUIInventory.java
#Comment:
	/**
	 * Adds an item to the inventory
	 *
	 * @param executor executor instance
	 */

#Code:
	protected void add(GUIInventory.Executor executor) {
		if(!getExecutors().contains(executor)) {
			throw new IllegalArgumentException("Trying to add not registered executor to the inventory");
		}

		getInventory().addItem(executor.getItem());
	}

#No. 2621
#File: E:\bishe\1\AbstractGUIInventory.java
#Comment:
	/**
	 * Register an executor
	 * and add it to the inventory
	 *
	 * @param executor executor
	 */

#Code:
	protected void registerAndAdd(GUIInventory.Executor executor) {
		registerExecutor(executor);
		add(executor);
	}

#No. 2622
#File: E:\bishe\1\AbstractGUIInventory.java
#Comment:
	/**
	 * Reopens the GUI
	 */

#Code:
	protected void reopen() {
		close();
		open(getViewer());
	}

#No. 2623
#File: E:\bishe\1\AbstractGUIInventory.java
#Comment:
	/**
	 * Regenerates GUI content
	 */

#Code:
	protected void regenerate() {
		inventory.clear();
		getExecutors().clear();
		generateContent();
		ChestGUIUtils.addBackItem(this);
	}

#No. 2624
#File: E:\bishe\1\AbstractGUIInventory.java
#Comment:
		/**
		 * The constructor
		 *
		 * @param itemStack icon item
		 */

#Code:
		public Executor(ItemStack itemStack) {
			this.itemStack = itemStack;
		}

#No. 2625
#File: E:\bishe\1\AbstractGUIInventory.java
#Comment:
		/**
		 * The constructor
		 * ItemStack is generated from message
		 *
		 * @param messageWrapper message wrapper
		 */

#Code:
		public Executor(MessageWrapper messageWrapper) {
			this(messageWrapper.getItemStack());
		}

#No. 2626
#File: E:\bishe\1\AbstractGUIInventory.java
#Comment:
		/**
		 * The constructor
		 *
		 * @param itemStack icon item
		 */

#Code:
		public EmptyExecutor(ItemStack itemStack) {
			super(itemStack);
		}

#No. 2627
#File: E:\bishe\1\AbstractGUIInventory.java
#Comment:
		/**
		 * The constructor
		 * ItemStack is generated from message
		 *
		 * @param messageWrapper message wrapper
		 */

#Code:
		public EmptyExecutor(MessageWrapper messageWrapper) {
			super(messageWrapper);
		}

#No. 2628
#File: E:\bishe\1\AbstractGUIInventory.java
#Comment:
		/**
		 * The constructor
		 *
		 * @param itemStack item
		 * @param command   command string
		 * @param close     close flag
		 */

#Code:
		public CommandExecutor(ItemStack itemStack, String command, boolean close) {
			super(itemStack);
			this.command = command;
			this.close = close;
		}

#No. 2629
#File: E:\bishe\1\AbstractGUIInventory.java
#Comment:
		/**
		 * The constructor
		 *
		 * @param messageWrapper message wrapper
		 * @param command        command string
		 * @param close          close flag
		 */

#Code:
		public CommandExecutor(MessageWrapper messageWrapper, String command, boolean close) {
			this(messageWrapper.getItemStack(), command, close);
		}

#No. 2630
#File: E:\bishe\1\AbstractH2Mojo.java
#Comment:
  /**
   * Installs a {@link List} of {@link Service}s that this {@link
   * AbstractH2Mojo} is capable of {@linkplain #spawnServer()
   * spawning}.
   *
   * @param services a {@link List} of {@link Service}s; may be {@code
   * null}
   */

#Code:
  public void setServices(final List<Service> services) {
    if (services == null || services.isEmpty()) {
      this.services = Collections.emptyList();
    } else {
      this.services = services;
    }
  }

#No. 2631
#File: E:\bishe\1\AbstractH2Mojo.java
#Comment:
  /**
   * Returns {@code true} if a shutdown operation should shut down all
   * H2 TCP servers running on the host in question.
   *
   * @return {@code true} if a shutdown operation should shut down all
   * H2 TCP servers running on the host in question; {@code false} otherwise
   */

#Code:
  public boolean getShutdownAllServers() {
    return this.shutdownAllServers;
  }

#No. 2632
#File: E:\bishe\1\AbstractH2Mojo.java
#Comment:
  /**
   * Sets whether a shutdown operation should shut down all H2 TCP
   * servers running on the host in question.
   *
   * @param shutdownAllServers if a shutdown operation should shut
   * down all H2 TCP servers running on the host in question
   */

#Code:
  public void setShutdownAllServers(final boolean shutdownAllServers) {
    this.shutdownAllServers = shutdownAllServers;
  }

#No. 2633
#File: E:\bishe\1\AbstractH2Mojo.java
#Comment:
  /**
   * Returns the password necessary to shut down spawned H2 TCP
   * servers.
   *
   * <p>This method may return {@code null}.</p>
   *
   * @return the shutdown password, or {@code null}
   */

#Code:
  public String getShutdownPassword() {
    return this.shutdownPassword;
  }

#No. 2634
#File: E:\bishe\1\AbstractH2Mojo.java
#Comment:
  /**
   * Sets the password necessary to shut down spawned H2 TCP servers.
   *
   * @param pw the new password; may be {@code null}
   */

#Code:
  public void setShutdownPassword(final String pw) {
    this.shutdownPassword = pw;
  }

#No. 2635
#File: E:\bishe\1\AbstractH2Mojo.java
#Comment:
  /**
   * Returns the hostname to which shutdown requests will be routed.
   *
   * <p>This method may return {@code null}.  Consumers of this method
   * should interpret such return values as being equal to {@code
   * localhost}.</p>
   *
   * @return the hostname to which shutdown requests will be routed,
   * or {@code null}
   */

#Code:
  public String getShutdownHost() {
    return this.shutdownHost;
  }

#No. 2636
#File: E:\bishe\1\AbstractH2Mojo.java
#Comment:
  /**
   * Sets the hostname to which shutdown requests will be routed.
   * Passing a {@code null} parameter to this method will result in
   * "{@code localhost}" being used.
   *
   * @param shutdownHost the hostname to which shutdown requests will
   * be routed; may be {@code null}
   */

#Code:
  public void setShutdownHost(final String shutdownHost) {
    this.shutdownHost = shutdownHost;
  }

#No. 2637
#File: E:\bishe\1\AbstractH2Mojo.java
#Comment:
  /**
   * Returns whether shutdown should be forced (if shutdown has been
   * requested).  See <a
   * href="http://www.h2database.com/javadoc/org/h2/tools/Server.html#main_String...">the
   * documentation for the {@code Server} class</a> for more details.
   *
   * @return {@code true} if shutdown should be forced
   */

#Code:
  public boolean getForceShutdown() {
    return this.forceShutdown;
  }

#No. 2638
#File: E:\bishe\1\AbstractH2Mojo.java
#Comment:
  /**
   * Sets whether shutdown should be forced (if shutdown has been
   * requested).  See <a
   * href="http://www.h2database.com/javadoc/org/h2/tools/Server.html#main_String...">the
   * documentation for the {@code Server} class</a> for more details.
   *
   * @param shutdown if {@code true}, then shutdown operations will be
   * forced
   */

#Code:
  public void setForceShutdown(final boolean shutdown) {
    this.forceShutdown = shutdown;
  }

#No. 2639
#File: E:\bishe\1\AbstractH2Mojo.java
#Comment:
  /**
   * Returns the {@link File} representing the path to the H2 jar file
   * that is on the classpath.  This method never returns {@code
   * null}.
   *
   * @return the {@link File} representing the path to the H2 jar
   * file; never {@code null}
   */

#Code:
  public final File getH2() {
    final ProtectionDomain pd = Server.class.getProtectionDomain();
    assert pd != null;
    final CodeSource cs = pd.getCodeSource();
    assert cs != null;
    final URL location = cs.getLocation();
    assert location != null;
    try {
      return new File(location.toURI());
    } catch (final URISyntaxException wontHappen) {
      throw (InternalError)new InternalError().initCause(wontHappen);
    }
  }

#No. 2640
#File: E:\bishe\1\AbstractH2Mojo.java
#Comment:
  /**
   * Returns the {@link File} representing the path to the Java
   * executable used to spawn H2 TCP servers.  This method may return
   * {@code null}.
   *
   * @return the {@link File} representing the path to the Java
   * executable, or {@code null}
   */

#Code:
  public File getJava() {
    return this.java;
  }

#No. 2641
#File: E:\bishe\1\AbstractH2Mojo.java
#Comment:
  /**
   * Sets the {@link File} representing the path to the Java
   * executable used to spawn H2 TCP servers.
   *
   * @param java the {@link File} to use; may be {@code null}
   */

#Code:
  public void setJava(final File java) {
    this.java = java;
  }

#No. 2642
#File: E:\bishe\1\AbstractH2Mojo.java
#Comment:
  /**
   * Returns any Java options passed to the spawned H2 process.  This
   * method may return {@code null}.
   *
   * @return any Java options passed to the spawned H2 process, or
   * {@code null}
   */

#Code:
  public String[] getJavaOptions() {
    return this.javaOptions;
  }

#No. 2643
#File: E:\bishe\1\AbstractH2Mojo.java
#Comment:
  /**
   * Sets any command-line options to be passed to the Java runtime
   * when spawning a new H2 TCP server.
   *
   * @param javaOptions the options; may be {@code null}
   */

#Code:
  public void setJavaOptions(final String... javaOptions) {
    this.javaOptions = javaOptions;
  }

#No. 2644
#File: E:\bishe\1\AbstractH2Mojo.java
#Comment:
  /**
   * Returns {@code true} if the {@code -trace} option will be
   * supplied to the spawned H2 TCP server.  See <a
   * href="http://www.h2database.com/javadoc/org/h2/tools/Server.html#main_String...">the
   * documentation for the {@code Server} class</a> for more details.
   *
   * @return {@code true} if the {@code -trace} option will be
   * supplied to the spawned H2 TCP server
   */

#Code:
  public boolean getTrace() {
    return this.trace;
  }

#No. 2645
#File: E:\bishe\1\AbstractH2Mojo.java
#Comment:
  /**
   * Sets whether the {@code -trace} option will be supplied to new H2
   * TCP servers.  See <a
   * href="http://www.h2database.com/javadoc/org/h2/tools/Server.html#main_String...">the
   * documentation for the {@code Server} class</a> for more details.
   *
   * @param trace whether the {@code -trace} option will be supplied
   * to new H2 TCP servers
   */

#Code:
  public void setTrace(final boolean trace) {
    this.trace = trace;
  }

#No. 2646
#File: E:\bishe\1\AbstractH2Mojo.java
#Comment:
  /**
   * Returns {@code true} if the {@code -ifExists} option will be
   * supplied to the spawned H2 TCP server.  See <a
   * href="http://www.h2database.com/javadoc/org/h2/tools/Server.html#main_String...">the
   * documentation for the {@code Server} class</a> for more details.
   *
   * @return {@code true} if the {@code -ifExists} option will be
   * supplied to the spawned H2 TCP server
   */

#Code:
  public boolean getIfExists() {
    return this.ifExists;
  }

#No. 2647
#File: E:\bishe\1\AbstractH2Mojo.java
#Comment:
  /**
   * Sets whether the {@code -ifExists} option will be supplied to the
   * spawned H2 TCP server.  See <a
   * href="http://www.h2database.com/javadoc/org/h2/tools/Server.html#main_String...">the
   * documentation for the {@code Server} class</a> for more details.
   *
   * @param ifExists whether the {@code -ifExists} option will be
   * supplied to new H2 TCP servers
   */

#Code:
  public void setIfExists(final boolean ifExists) {
    this.ifExists = ifExists;
  }

#No. 2648
#File: E:\bishe\1\AbstractH2Mojo.java
#Comment:
  /**
   * Returns {@code true} if the {@code -tcpAllowOthers} option will
   * be supplied to the spawned H2 TCP server.  See <a
   * href="http://www.h2database.com/javadoc/org/h2/tools/Server.html#main_String...">the
   * documentation for the {@code Server} class</a> for more details.
   *
   * @return {@code true} if the {@code -tcpAllowOthers} option will
   * be supplied to the spawned H2 TCP server
   *
   * @deprecated Use the correct {@link Service} instead.
   */

#Code:
  @Deprecated
  public boolean getAllowOthers() {
    return this.allowOthers;
  }

#No. 2649
#File: E:\bishe\1\AbstractH2Mojo.java
#Comment:
  /**
   * Sets whether the {@code -tcpAllowOthers} option will be supplied
   * to the spawned H2 TCP server.  See <a
   * href="http://www.h2database.com/javadoc/org/h2/tools/Server.html#main_String...">the
   * documentation for the {@code Server} class</a> for more details.
   *
   * @param allowOthers whether the {@code -tcpAllowOthers} option
   * will be supplied to new H2 TCP servers
   *
   * @deprecated Use the correct {@link Service} instead.
   */

#Code:
  @Deprecated
  public void setAllowOthers(final boolean allowOthers) {
    this.allowOthers = allowOthers;
    final Service tcpService = this.getService("tcp");
    if (tcpService != null) {
      tcpService.setAllowOthers(this.getAllowOthers());
    }
  }

#No. 2650
#File: E:\bishe\1\AbstractH2Mojo.java
#Comment:
  /**
   * Returns {@code true} if the {@code -tcpSSL} option will
   * be supplied to the spawned H2 TCP server.  See <a
   * href="http://www.h2database.com/javadoc/org/h2/tools/Server.html#main_String...">the
   * documentation for the {@code Server} class</a> for more details.
   *
   * @return {@code true} if the {@code -tcpSSL} option will
   * be supplied to the spawned H2 TCP server
   *
   * @deprecated Use the correct {@link Service} instead.
   */

#Code:
  @Deprecated
  public boolean getUseSSL() {
    return this.useSSL;
  }

#No. 2651
#File: E:\bishe\1\AbstractH2Mojo.java
#Comment:
  /**
   * Sets whether the {@code -tcpSSL} option will be supplied
   * to the spawned H2 TCP server.  See <a
   * href="http://www.h2database.com/javadoc/org/h2/tools/Server.html#main_String...">the
   * documentation for the {@code Server} class</a> for more details.
   *
   * @param useSSL whether the {@code -tcpSSL} option
   * will be supplied to new H2 TCP servers
   *
   * @deprecated Use the correct {@link Service} instead.
   */

#Code:
  @Deprecated
  public void setUseSSL(final boolean useSSL) {
    this.useSSL = useSSL;
    final Service tcpService = this.getService("tcp");
    if (tcpService != null) {
      tcpService.setSSL(this.getUseSSL());
    }
  }

#No. 2652
#File: E:\bishe\1\AbstractH2Mojo.java
#Comment:
  /**
   * Returns the {@link File} representing the base directory from
   * which H2 TCP servers will be spawned.  
   *
   * <p>This property corresponds to the {@code -baseDir} option
   * supplied to spawned H2 TCP servers.  See <a
   * href="http://www.h2database.com/javadoc/org/h2/tools/Server.html#main_String...">the
   * documentation for the {@code Server} class</a> for more
   * details.</p>
   *
   * <p>This method may return {@code null}.</p>
   *
   * @return the {@link File} representing the base directory, or
   * {@code null}
   */

#Code:
  public File getBaseDirectory() {
    return this.baseDirectory;
  }

#No. 2653
#File: E:\bishe\1\AbstractH2Mojo.java
#Comment:
  /**
   * Sets the base directory from which H2 TCP servers will be
   * spawned.
   *
   * <p>This property corresponds to the {@code -baseDir} option
   * supplied to spawned H2 TCP servers.  See <a
   * href="http://www.h2database.com/javadoc/org/h2/tools/Server.html#main_String...">the
   * documentation for the {@code Server} class</a> for more
   * details.</p>
   *
   * @param baseDirectory a {@link File} representing the new base
   * directory; may be {@code null}
   */

#Code:
  public void setBaseDirectory(final File baseDirectory) {
    this.baseDirectory = baseDirectory;
  }

#No. 2654
#File: E:\bishe\1\AbstractH2Mojo.java
#Comment:
  /**
   * Returns the port on which new H2 TCP servers spawned by this
   * class will listen.  H2's default port is 9092.
   *
   * @return the port on which new H2 TCP servers spawned by this
   * class will listen; this will be a number between {@code 0} and
   * {@code 65535}, inclusive
   *
   * @deprecated Use the correct {@link Service} instead.
   */

#Code:
  @Deprecated
  public int getPort() {
    return this.port;
  }

#No. 2655
#File: E:\bishe\1\AbstractH2Mojo.java
#Comment:
  /**
   * Sets the port on which new H2 TCP servers spawned by this class
   * will listen.  H2's default port is 9092.
   *
   * @param port the new port; will be constrained to be between
   * {@code 0} and {@code 65535}, inclusive
   *
   * @deprecated Use the correct {@link Service} instead.
   */

#Code:
  @Deprecated
  public void setPort(final int port) {
    this.port = Math.min(65535, Math.max(0, port));
    final Service tcpService = this.getService("tcp");
    if (tcpService != null) {
      tcpService.setPort(this.getPort());
    }
  }

#No. 2656
#File: E:\bishe\1\AbstractH2Mojo.java
#Comment:
  /**
   * Creates a new {@link Server} using H2's {@link
   * Server#createTcpServer(String[])}, {@link
   * Server#createPgServer(String[])} or {@link
   * Server#createWebServer(String[])} method.  This method must never
   * return {@code null}.
   *
   * <p><strong>Note:</strong> This method is experimental.</p>
   *
   * @return a new {@link Server} as produced by the {@link
   * Server#createTcpServer(String[])} method; never {@code null}
   *
   * @exception SQLException if an error occurs
   */

#Code:
  protected Server createServer() throws SQLException {
    Server server = null;
    final List<String> args = this.getServerArguments();
    if (args == null || args.isEmpty()) {
      throw new SQLException("Cannot create server; no arguments");
    } else if (args.contains("-tcp")) {
      server = Server.createTcpServer(args.toArray(new String[args.size()]));
    } else if (args.contains("-pg")) {
      server = Server.createPgServer(args.toArray(new String[args.size()]));
    } else if (args.contains("-web")) {
      server = Server.createWebServer(args.toArray(new String[args.size()]));
    } else {
      throw new SQLException("Unknown service");
    }
    return server;
  }

#No. 2657
#File: E:\bishe\1\AbstractH2Mojo.java
#Comment:
  /**
   * Returns a {@link ProcessBuilder} that can be used and reused to
   * spawn new fully configured H2 TCP servers.
   *
   * <p>This method never returns {@code null}.</p>
   *
   * <h2>Design Notes</h2>
   *
   * <p>At the moment, the implementation of this method returns a new
   * {@link ProcessBuilder} in all cases, but this behavior should not
   * be relied upon.</p>
   *
   * @return a {@link ProcessBuilder}; never {@code null}
   */

#Code:
  protected ProcessBuilder getServerSpawner() {
    final List<String> args = this.getServerArguments();
    assert args != null;

    // A spawned server should never run as a daemon.
    args.remove("-tcpDaemon");
    args.remove("-pgDaemon");
    args.remove("-webDaemon");

    int argumentIndex = 0;

    File java = this.getJava();
    if (java == null) {
      java = new File(new File(new File(System.getProperty("java.home")), "bin"), "java");
    }
    args.add(argumentIndex++, java.getAbsolutePath());

    final String[] javaOptions = this.getJavaOptions();
    if (javaOptions != null && javaOptions.length > 0) {
      for (final String option : javaOptions) {
        if (option != null && !option.trim().isEmpty()) {
          args.add(argumentIndex++, option);
        }
      }
    }

    args.add(argumentIndex++, "-cp");
    final File fileLocation = this.getH2();
    assert fileLocation != null;
    args.add(argumentIndex++, fileLocation.getAbsolutePath());

    args.add(argumentIndex++, Server.class.getName());

    final Log log = this.getLog();
    if (log != null && log.isDebugEnabled()) {
      log.debug("Process arguments: " + args);
    }
    return new ProcessBuilder(args);
  }

#No. 2658
#File: E:\bishe\1\AbstractH2Mojo.java
#Comment:
  /**
   * Returns a {@link Process} representing an H2 TCP server that has
   * been started.  The returned {@link Process} is guaranteed not to
   * be {@code null} and will not have been {@linkplain
   * Process#destroy() destroyed}.
   *
   * @return a non-{@code null} {@link Process}
   *
   * @exception IOException if an error occurred during {@link
   * Process} creation, usually because of a {@link
   * ProcessBuilder#start()} failure
   */

#Code:
  protected Process spawnServer() throws IOException {
    return this.getServerSpawner().start();
  }

#No. 2659
#File: E:\bishe\1\AbstractH2Mojo.java
#Comment:
  /**
   * Shuts down a server spawned earlier by the {@link #spawnServer()} method.
   *
   * @exception SQLException if the server could not be shut down
   */

#Code:
  protected void shutdownServer() throws SQLException {
    String password = this.getShutdownPassword();
    if (password == null) {
      password = "";
    }
    final int port = this.getPort();
    String host = this.getShutdownHost();
    if (host == null) {
      host = "";
    } else {
      host = host.trim();
    }
    if (host.isEmpty()) {
      host = "localhost";
    }
    TcpServer.shutdown(String.format("tcp://%s:%d", host, port), password, this.getForceShutdown(), this.getShutdownAllServers());
  }

#No. 2660
#File: E:\bishe\1\AbstractHADatasource.java
#Comment:
    /**
     * 检查备选数据源是否为空，如果为空则抛出异常
     */

#Code:
    protected void checkDataSourceListEmpty() throws DataSourceInvalidException {
        if (CollectionUtils.isEmpty(mysqlDataSourceList)) {
            throw new DataSourceInvalidException("mysqlDataSourceList is empty");
        }
    }

#No. 2661
#File: E:\bishe\1\AbstractHADatasource.java
#Comment:
    /**
     * 从备选数据源列表中选中可用的数据源源，具体的选择会被委托到{@link DatasourceChoosePolicy DatasourceChoosePolicy}
     * 中， 选中的数据源需要使用{@link DatasourceChooseCallbackHandler
     * DatasourceChooseCallbackHandler}来回调做一些初始化操作。
     *
     * @throws IOException
     * @throws NoSuchAlgorithmException
     */

#Code:
    protected void chooseMysqlDataSource() throws IOException, NoSuchAlgorithmException {
        T bak = currentDataSource;
        safeCloseCurrent();
        currentDataSource = recconectCurrent(bak);

        if (currentDataSource != null) {
            return;
        }

        // 使用匿名类，保证能够使用当前类中的一些基础方法
        currentDataSource =
                datasourceChoosePolicy.choose(mysqlDataSourceList, new DatasourceChooseCallbackHandler<T>() {

                    @Override
                    public void doCallback(T choosedDattasource) throws IOException, NoSuchAlgorithmException,
                            TimeoutException {
                        if (!choosedDattasource.isOpen()) {
                            StringBuffer sb =
                                    new StringBuffer("Choose new dataSource, [ip, port] is [")
                                            .append(choosedDattasource.getIpAddress()).append(", ")
                                            .append(choosedDattasource.getPort()).append("]");
                            getLogger().info(sb.toString());
                            prepareChoosedDatasouce(choosedDattasource);
                        }
                    }

                    @Override
                    public void logError(Exception e) {
                        getLogger().error(null, e);
                    }

                });
    }

#No. 2662
#File: E:\bishe\1\AbstractHADatasource.java
#Comment:
    /**
     * 重新连接一下当前的数据源。
     * <p>
     * 当从socket读取数据失败或者超时时，在切换数据源之前先重新连接一下当前的数据，如果不成功 再试图切换数据源，这是因为数据读取失败往往不是挂了，而是网络抖动。
     * </p>
     *
     * @param ds 需要重连的数据源
     *
     * @return 重连成功的数据源，null表示重连失败或者当前没有数据源
     */

#Code:
    private T recconectCurrent(T ds) {
        if (ds == null) {
            return ds;
        }

        getLogger().info("Reconnect current datasource {}:{}", ds.getIpAddress(), ds.getPort());

        try {
            prepareChoosedDatasouce(ds);
            return ds;
        } catch (NoSuchAlgorithmException e) {
            getLogger().error(null, e);
        } catch (IOException e) {
            getLogger().error(null, e);

        } catch (TimeoutException e) {
            getLogger().error(null, e);
        }
        return null;
    }

#No. 2663
#File: E:\bishe\1\AbstractHADatasource.java
#Comment:
    /**
     * 安全的关闭数据源，并记录日志
     */

#Code:
    protected void safeCloseCurrent() {
        // 关闭当前数据源
        if (currentDataSource != null) {
            StringBuffer sb =
                    new StringBuffer("DataSource is invalid and try to close, [ip, port] is [")
                            .append(currentDataSource.getIpAddress()).append(", ").append(currentDataSource.getPort())
                            .append("]");
            getLogger().warn(sb.toString());

            currentDataSource.close();
            currentDataSource = null;
        } else {
            getLogger().info("CurrentMysqlDataSource is null, pass closing");
        }
    }

#No. 2664
#File: E:\bishe\1\AbstractHandlerPlugin.java
#Comment:
/**
 * Abstract base class for {@link HandlerPlugin} implementations.
 * 
 * @author Curtis Rueden
 */

#Code:
public abstract class AbstractHandlerPlugin<D> extends AbstractTypedPlugin<D>
	implements HandlerPlugin<D>
{
	// NB: No implementation needed.
}

#No. 2665
#File: E:\bishe\1\AbstractHandlerService.java
#Comment:
/**
 * Abstract base class for {@link HandlerService}s.
 * 
 * @author Curtis Rueden
 * @param <DT> Base data type handled by the handlers.
 * @param <PT> Plugin type of the handlers.
 */

#Code:
public abstract class AbstractHandlerService<DT, PT extends HandlerPlugin<DT>>
	extends AbstractSingletonService<PT> implements HandlerService<DT, PT>
{
	// NB: No implementation needed.
}

#No. 2666
#File: E:\bishe\1\AbstractHandlerTest.java
#Comment:
    /**
     * Validates that at least one line of the GZIP'd file contains the expected text.
     *
     * @param path             the path to the GZIP file
     * @param expectedContains the expected text
     *
     * @throws IOException if an error occurs while reading the GZIP file
     */

#Code:
    static void validateGzipContents(final Path path, final String expectedContains) throws IOException {
        try (BufferedReader reader = new BufferedReader(new InputStreamReader(new GZIPInputStream(Files.newInputStream(path))))) {
            String line;
            while ((line = reader.readLine()) != null) {
                if (line.contains(expectedContains)) {
                    return;
                }
            }
        }
        Assert.fail(String.format("GZIP file %s missing contents: %s", path, expectedContains));
    }

#No. 2667
#File: E:\bishe\1\AbstractHandlerTest.java
#Comment:
    /**
     * Validates that the ZIP file contains the expected file, the expected file is not empty and that the first line
     * contains the expected text.
     *
     * @param path             the path to the zip file
     * @param expectedFileName the name of the file inside the zip file
     * @param expectedContains the expected text
     *
     * @throws IOException if an error occurs reading the zip file
     */

#Code:
    static void validateZipContents(final Path path, final String expectedFileName, final String expectedContains) throws IOException {
        try (final FileSystem zipFs = FileSystems.newFileSystem(URI.create("jar:" +  path.toUri().toASCIIString()), Collections.singletonMap("create", "true"))) {
            final Path file = zipFs.getPath(zipFs.getSeparator(), expectedFileName);
            Assert.assertTrue(String.format("Expected file %s not found.", expectedFileName), Files.exists(file));
            final List<String> lines = Files.readAllLines(file, StandardCharsets.UTF_8);
            Assert.assertFalse(String.format("File %s appears to be empty in zip file %s.", expectedFileName, path), lines.isEmpty());
            Assert.assertTrue(String.format("ZIP file %s missing contents: %s", path, expectedContains), lines.get(0).contains(expectedContains));
        }
    }

#No. 2668
#File: E:\bishe\1\AbstractHanoi.java
#Comment:
	/**
	 * @param n the total number of rings.
	 * @param source the source tower.
	 * @param intermediate the intermediate tower.
	 * @param destination the destination tower.
	 * @return a list of steps to move all rings in the source tower to the destination tower.
	 */

#Code:
	public abstract List<String> solve(int n, char source, char intermediate, char destination);
	
	protected String getKey(int n, char source, char destination)
	{
		return n+":"+source+"->"+destination;
	}

#No. 2669
#File: E:\bishe\1\AbstractHardwareWalletState.java
#Comment:
  /**
   * <p>Provide standard handling for an unexpected message so the downstream consumer can react appropriately</p>
   *
   * @param context The current context providing parameters for decisions
   * @param event   The event driving the transition
   */

#Code:
  protected void handleUnexpectedMessageEvent(HardwareWalletContext context, MessageEvent event) {

    log.warn("Unexpected message event '{}'", event.getEventType().name());
    if (event.getMessage().isPresent()) {
      HardwareWalletEvents.fireHardwareWalletEvent(HardwareWalletEventType.SHOW_OPERATION_FAILED, event.getMessage().get(), context.getClient().name());
    } else {
      HardwareWalletEvents.fireHardwareWalletEvent(HardwareWalletEventType.SHOW_OPERATION_FAILED, context.getClient().name());
    }
    context.resetToConnected();

  }

#No. 2670
#File: E:\bishe\1\AbstractHashProvider.java
#Comment:
    /**
     * Called by implementations that support caching of stateless hash
     * functions when a cached instance is desired. If a cached instance is not
     * available, this method calls {@link #createCacheable} to create one,
     * which is then cached (if caching is available).
     * 
     * @param params the hash algorithm parameters
     * @param required the required hash support flags
     * @return a hash function
     * @throws UnsupportedOperationException if this provider cannot support the
     *             given parameters
     */

#Code:
    protected final Hash getCacheable(final P params, final EnumSet<HashSupport> required) {
        if (HashCacheLoader.hasCache()) {
            final HashCache cache = HashCacheLoader.getCache();
            try {
                return cache.get(params, required, new Callable<Hash>() {
                    @Override
                    public Hash call() throws Exception {
                        return createCacheable(params, required);
                    }
                });
            } catch (ExecutionException e) {
                final Throwable cause = e.getCause();
                if (cause instanceof RuntimeException)
                    throw (RuntimeException) cause;
                throw new UnsupportedOperationException(e);
            }
        }
        return createCacheable(params, required);
    }

#No. 2671
#File: E:\bishe\1\AbstractHashProvider.java
#Comment:
    /**
     * Called by {@link #getCacheable} to create new cacheable stateless hash
     * functions. The default implementation simply throws
     * {@link UnsupportedOperationException}.
     * 
     * @param params the hash algorithm parameters
     * @param required the required hash support flags
     * @return a stateless hash function
     * @throws UnsupportedOperationException if this provider cannot support the
     *             given parameters
     */

#Code:
    protected StatelessHash createCacheable(P params, EnumSet<HashSupport> required) {
        throw new UnsupportedOperationException();
    }

#No. 2672
#File: E:\bishe\1\AbstractHBaseMiniClusterTest.java
#Comment:
	/**
	 * Transfer given strings into a array of <code>byte[]</code>.
	 * @param strings
	 * @return
	 */

#Code:
	protected static byte[][] transfer2BytesArray(String[] strings) {
		List<byte[]> bytesList = new ArrayList<byte[]>();
		if (null != strings && strings.length > 0) {
			for (int a = 0; a < strings.length; a++) {
				bytesList.add(Bytes.toBytes(strings[a]));
			}
		}

		return bytesList.toArray(new byte[][] {});
	}

#No. 2673
#File: E:\bishe\1\AbstractHBaseMiniClusterTest.java
#Comment:
	/**
	 * Import local file to table.
	 * @param conf
	 * @param args
	 * @param TABLE_NAME
	 * @param INPUT_FILE
	 * @throws IOException
	 * @throws InterruptedException
	 * @throws ClassNotFoundException
	 */

#Code:
	protected static void importLocalFile2Table(
			final Configuration conf, final String[] args, final String TABLE_NAME, 
			final String INPUT_FILE)
			throws IOException, InterruptedException, ClassNotFoundException {
		Validate.notEmpty(INPUT_FILE, "INPUT_FILE shall not be empty or null");
		
		InputStream ips = ClassLoader.getSystemResourceAsStream(INPUT_FILE);
		assertNotNull(ips);

		FileSystem fs = FileSystem.get(conf);
		FSDataOutputStream op = fs.create(new Path(INPUT_FILE), true);
		IOUtils.write(IOUtils.toString(ips), op, HConstants.UTF8_ENCODING);
		IOUtils.closeQuietly(op);
		IOUtils.closeQuietly(ips);
		
		int length = args.length + 2;
		String[] newArgs = new String[length];
		System.arraycopy(args, 0, newArgs, 0, args.length);
		newArgs[length - 2] = TABLE_NAME;
//		newArgs[length - 1] = INPUT_FILE_PATH + INPUT_FILE;
		newArgs[length - 1] = INPUT_FILE;

		Job job = ImportTsv.createSubmittableJob(conf, newArgs);
		job.waitForCompletion(true);
		assertTrue(job.isSuccessful());
	}

#No. 2674
#File: E:\bishe\1\AbstractHBaseMiniClusterTest.java
#Comment:
	/**
	 * Create table and corresponding columnFamilies.
	 * @param conf
	 * @param tableName
	 * @param columnFamilyNames
	 * @throws Exception
	 */

#Code:
	protected static void createTable(Configuration conf, byte[] tableName, byte[][] columnFamilyNames) throws Exception {
		HTableDescriptor desc = new HTableDescriptor(tableName);
		for (byte[] family : columnFamilyNames) {
			desc.addFamily(new HColumnDescriptor(family));
		}
		new HBaseAdmin(conf).createTable(desc);
	}

#No. 2675
#File: E:\bishe\1\AbstractHBaseMiniClusterTest.java
#Comment:
	/**
	 * encoding to UTF-8 string.
	 * @param bytes
	 * @return
	 * @throws UnsupportedEncodingException
	 */

#Code:
	protected static String toU8Str(byte[] bytes)
			throws UnsupportedEncodingException {
		return new String(bytes, HConstants.UTF8_ENCODING);
	}

#No. 2676
#File: E:\bishe\1\AbstractHBaseMiniClusterTest.java
#Comment:
	/**
	 * Print table content.
	 * @param tableName
	 * @return return key/value count.
	 * @throws IOException
	 */

#Code:
	protected static long printTable(String tableName) throws IOException {
		MiniHBaseCluster cluster = TEST_UTIL.getHBaseCluster();
		Configuration conf = cluster.getConfiguration();
		HTable hTable = new HTable(new Configuration(conf), tableName);
		long kvCount = 0;
		
		System.out.println("print content for table:" + Bytes.toString(hTable.getTableName()));
		Scan scan = new Scan();
		hTable.getScanner(scan);
		ResultScanner resScanner = hTable.getScanner(scan);
		KeyValue[] kvs = null;
		
		for (Result res : resScanner) {
			System.out.println("\nrowKey = " + Bytes.toString(res.getRow()));
			kvs = res.raw();
			for(KeyValue kv : kvs) {
				kvCount++;
				System.out.println(kv + ", " + Bytes.toString(kv.getValue()));
			}
		}
		return kvCount;
	}

#No. 2677
#File: E:\bishe\1\AbstractHBaseMiniClusterTest.java
#Comment:
	/**
	 * import local data to mini-cluster.
	 * @param args arguments for <code>ImportTsv</code> use.
	 * @param tableName <code>HTable</code> name
	 * @param columnFamilies HTable column families
	 * @param inputFileName file name
	 * @throws Exception
	 */

#Code:
	protected static void importData(String[] args, String tableName, String[] columnFamilies,
			String inputFileName) throws Exception {
				// Cluster
				MiniHBaseCluster cluster = TEST_UTIL.getHBaseCluster();
			
				GenericOptionsParser opts = new GenericOptionsParser(
						cluster.getConfiguration(), args);
				Configuration conf = opts.getConfiguration();
				args = opts.getRemainingArgs();
			
				final byte[][] FAMS = transfer2BytesArray(columnFamilies);
				final byte[] TAB = Bytes.toBytes(tableName);
				
				createTable(conf, TAB, FAMS);
				
				importLocalFile2Table(conf, args, tableName, inputFileName);
			}

#No. 2678
#File: E:\bishe\1\AbstractHBaseTool.java
#Comment:
  /**
   * Parse a number and enforce a range.
   */

#Code:
  public static long parseLong(String s, long minValue, long maxValue) {
    long l = Long.parseLong(s);
    if (l < minValue || l > maxValue) {
      throw new IllegalArgumentException("The value " + l
          + " is out of range [" + minValue + ", " + maxValue + "]");
    }
    return l;
  }

#No. 2679
#File: E:\bishe\1\AbstractHDFSWriter.java
#Comment:
  /**
   * Contract for subclasses: Call registerCurrentStream() on open,
   * unregisterCurrentStream() on close, and the base class takes care of the
   * rest.
   * @return
   */

#Code:
  @Override
  public boolean isUnderReplicated() {
    try {
      int numBlocks = getNumCurrentReplicas();
      if (numBlocks == -1) {
        return false;
      }
      int desiredBlocks;
      if (configuredMinReplicas != null) {
        desiredBlocks = configuredMinReplicas;
      } else {
        desiredBlocks = getFsDesiredReplication();
      }
      return numBlocks < desiredBlocks;
    } catch (IllegalAccessException e) {
      LOGGER.error(UNEXPECTED_ERROR, e);
    } catch (InvocationTargetException e) {
      LOGGER.error(UNEXPECTED_ERROR, e);
    } catch (IllegalArgumentException e) {
      LOGGER.error(UNEXPECTED_ERROR, e);
    }
    return false;
  }

#No. 2680
#File: E:\bishe\1\AbstractHDFSWriter.java
#Comment:
  /**
   * This method gets the datanode replication count for the current open file.
   *
   * If the pipeline isn't started yet or is empty, you will get the default
   * replication factor.
   *
   * <p/>If this function returns -1, it means you
   * are not properly running with the HDFS-826 patch.
   * @throws java.lang.reflect.InvocationTargetException
   * @throws IllegalAccessException
   * @throws IllegalArgumentException
   */

#Code:
  @SuppressWarnings("squid:S1160")
  public int getNumCurrentReplicas()
      throws IllegalArgumentException, IllegalAccessException,
          InvocationTargetException {
    if (refGetNumCurrentReplicas != null && outputStream != null) {
      OutputStream dfsOutputStream = outputStream.getWrappedStream();
      if (dfsOutputStream != null) {
        Object repl = refGetNumCurrentReplicas.invoke(dfsOutputStream, NO_ARGS);
        if (repl instanceof Integer) {
          return ((Integer)repl).intValue();
        }
      }
    }
    return -1;
  }

#No. 2681
#File: E:\bishe\1\AbstractHDFSWriter.java
#Comment:
  /**
   * Find the 'getNumCurrentReplicas' on the passed <code>os</code> stream.
   * @return Method or null.
   */

#Code:
  private Method reflectGetNumCurrentReplicas(FSDataOutputStream os) {
    Method m = null;
    if (os != null) {
      Class<? extends OutputStream> wrappedStreamClass = os.getWrappedStream()
          .getClass();
      try {
        m = wrappedStreamClass.getDeclaredMethod("getNumCurrentReplicas",
            new Class<?>[] {});
        m.setAccessible(true);
      } catch (NoSuchMethodException e) {
        LOGGER.info("FileSystem's output stream doesn't support"
            + " getNumCurrentReplicas; --HDFS-826 not available; fsOut="
            + wrappedStreamClass.getName() + "; err=" + e);
      } catch (SecurityException e) {
        LOGGER.info("Doesn't have access to getNumCurrentReplicas on "
            + "FileSystems's output stream --HDFS-826 not available; fsOut="
            + wrappedStreamClass.getName(), e);
        m = null; // could happen on setAccessible()
      }
    }
    if (m != null) {
      LOGGER.debug("Using getNumCurrentReplicas--HDFS-826");
    }
    return m;
  }

#No. 2682
#File: E:\bishe\1\AbstractHDFSWriter.java
#Comment:
  /**
   * Find the 'getDefaultReplication' method on the passed <code>fs</code>
   * FileSystem that takes a Path argument.
   * @return Method or null.
   */

#Code:
  private Method reflectGetDefaultReplication(FileSystem fileSystem) {
    Method m = null;
    if (fileSystem != null) {
      Class<?> fsClass = fileSystem.getClass();
      try {
        m = fsClass.getMethod("getDefaultReplication",
            new Class<?>[] { Path.class });
      } catch (NoSuchMethodException e) {
        LOGGER.debug("FileSystem implementation doesn't support"
            + " getDefaultReplication(Path); -- HADOOP-8014 not available; " +
            "className = " + fsClass.getName() + "; err = " + e);
      } catch (SecurityException e) {
        LOGGER.debug("No access to getDefaultReplication(Path) on "
            + "FileSystem implementation -- HADOOP-8014 not available; " +
            "className = " + fsClass.getName() + "; err = " + e);
      }
    }
    if (m != null) {
      LOGGER.debug("Using FileSystem.getDefaultReplication(Path) from " +
          "HADOOP-8014");
    }
    return m;
  }

#No. 2683
#File: E:\bishe\1\AbstractHDFSWriter.java
#Comment:
  /**
   * If hflush is available in this version of HDFS, then this method calls
   * hflush, else it calls sync.
   * @param os - The stream to flush/sync
   * @throws java.io.IOException
   */

#Code:
  protected void hflushOrSync(FSDataOutputStream os) throws IOException {
    try {
      // At this point the refHflushOrSync cannot be null,
      // since register method would have thrown if it was.
      this.refHflushOrSync.invoke(os);
    } catch (InvocationTargetException e) {
      String msg = "Error while trying to hflushOrSync!";
      LOGGER.error(msg);
      Throwable cause = e.getCause();
      if(cause != null && cause instanceof IOException) {
        throw (IOException)cause;
      }
      throw new FlumeException(msg, e);
    } catch (Exception e) {
      String msg = "Error while trying to hflushOrSync!";
      LOGGER.error(msg);
      throw new FlumeException(msg, e);
    }
  }

#No. 2684
#File: E:\bishe\1\AbstractHeaderFooterWrapperAdapter.java
#Comment:
    /**
     * Returns a newly created adapter for header items.
     *
     * @return Adapter for header items
     */

#Code:
    @NonNull
    protected RecyclerView.Adapter onCreateHeaderAdapter() {
        return new BaseHeaderAdapter(this);
    }

#No. 2685
#File: E:\bishe\1\AbstractHeaderFooterWrapperAdapter.java
#Comment:
    /**
     * Returns a newly created adapter for the footer items.
     *
     * @return Adapter for the footer items
     */

#Code:
    @NonNull
    protected RecyclerView.Adapter onCreateFooterAdapter() {
        return new BaseFooterAdapter(this);
    }

#No. 2686
#File: E:\bishe\1\AbstractHeaderFooterWrapperAdapter.java
#Comment:
    /**
     * Returns the adapter for the header items.
     *
     * @return Adapter for the header items
     */

#Code:
    public RecyclerView.Adapter getHeaderAdapter() {
        return mHeaderAdapter;
    }

#No. 2687
#File: E:\bishe\1\AbstractHeaderFooterWrapperAdapter.java
#Comment:
    /**
     * Returns the adapter for the footer items.
     *
     * @return Adapter for the footer items
     */

#Code:
    public RecyclerView.Adapter getFooterAdapter() {
        return mFooterAdapter;
    }

#No. 2688
#File: E:\bishe\1\AbstractHeaderFooterWrapperAdapter.java
#Comment:
    /**
     * Returns underlying adapter.
     * @return The underlying adapter instance
     */

#Code:
    public RecyclerView.Adapter getWrappedAdapter() {
        return mWrappedAdapter;
    }

#No. 2689
#File: E:\bishe\1\AbstractHeaderFooterWrapperAdapter.java
#Comment:
    /**
     * Returns the path segment for the underlying adapter.
     *
     * @return AdapterPathSegment for the wrapped adapter
     */

#Code:
    public AdapterPathSegment getWrappedAdapterSegment() {
      return new AdapterPathSegment(mWrappedAdapter, mWrappedAdapterTag);
    }

#No. 2690
#File: E:\bishe\1\AbstractHeaderFooterWrapperAdapter.java
#Comment:
    /**
     * Returns the path segment for the header adapter.
     *
     * @return AdapterPathSegment for the header adapter
     */

#Code:
    public AdapterPathSegment getHeaderSegment() {
      return new AdapterPathSegment(mHeaderAdapter, mHeaderAdapterTag);
    }

#No. 2691
#File: E:\bishe\1\AbstractHeaderFooterWrapperAdapter.java
#Comment:
    /**
     * Returns the path segment for the footer adapter.
     *
     * @return AdapterPathSegment for the footer adapter
     */

#Code:
    public AdapterPathSegment getFooterSegment() {
      return new AdapterPathSegment(mFooterAdapter, mFooterAdapterTag);
    }

#No. 2692
#File: E:\bishe\1\AbstractHeaderFooterWrapperAdapter.java
#Comment:
    /**
     * Called by RecyclerView to display the data at the specified position. This method should
     * update the contents of the {@link RecyclerView.ViewHolder#itemView} to reflect the footer item
     * at the given position.
     *
     * @param holder The ViewHolder which should be updated to represent the contents of the
     *        item at the given position in the data set.
     * @param localPosition The position of the item within the footer adapter's data set.
     * @param payloads A non-null list of merged payloads. Can be empty list if requires full
     *                 update.
     * @see {@link RecyclerView.Adapter#onBindViewHolder(RecyclerView.ViewHolder, int, List)}
     */

#Code:
    public void onBindFooterItemViewHolder(FooterVH holder, int localPosition, List<Object> payloads) {
        onBindFooterItemViewHolder(holder, localPosition);
    }

#No. 2693
#File: E:\bishe\1\AbstractHeaderFooterWrapperAdapter.java
#Comment:
     /**
     * Returns the total number of items in the data set hold by the header adapter.
     *
     * @return The total number of items in the header adapter.
     * @see {@link RecyclerView.Adapter#getItemCount()}
     */

#Code:
    public abstract int getHeaderItemCount();

    /**
     * Returns the total number of items in the data set hold by the footer adapter.
     *
     * @return The total number of items in the footer adapter.
     * @see {@link RecyclerView.Adapter#getItemCount()}
     */
    public abstract int getFooterItemCount();

    /**
     * Return the stable ID for the item at <code>localPosition</code>. If {@link #hasStableIds()}
     * would return false this method should return {@link RecyclerView#NO_ID}.
     *
     * @param localPosition Header adapter position to query
     * @return the stable ID of the item at position
     * @see {@link RecyclerView.Adapter#getItemId(int)}
     */
    @IntRange(from = ItemIdComposer.MIN_WRAPPED_ID, to = ItemIdComposer.MAX_WRAPPED_ID)
    public long getHeaderItemId(int localPosition) {
        if (hasStableIds()) {
            return RecyclerView.NO_ID;
        }
        return localPosition; // This works for simple header items without structural changes
    }

#No. 2694
#File: E:\bishe\1\AbstractHeaderFooterWrapperAdapter.java
#Comment:
    /**
     * Return the stable ID for the item at <code>localPosition</code>. If {@link #hasStableIds()}
     * would return false this method should return {@link RecyclerView#NO_ID}.
     *
     * @param localPosition Foote adapter position to query
     * @return the stable ID of the item at position
     * @see {@link RecyclerView.Adapter#getItemId(int)}
     */

#Code:
    @IntRange(from = ItemIdComposer.MIN_WRAPPED_ID, to = ItemIdComposer.MAX_WRAPPED_ID)
    public long getFooterItemId(int localPosition) {
        if (hasStableIds()) {
            return RecyclerView.NO_ID;
        }
        return localPosition; // This works for simple footer items without structural changes
    }

#No. 2695
#File: E:\bishe\1\AbstractHeaderFooterWrapperAdapter.java
#Comment:
    /**
     * Return the view type of the header item at <code>localPosition</code> for the purposes
     * of view recycling.
     *
     * <p>The default implementation of this method returns 0, making the assumption of
     * a single view type for the adapter. Unlike ListView adapters, types need not
     * be contiguous.</p>
     *
     * @param localPosition The header adapter local position to query
     * @return integer value identifying the type of the view needed to represent the item at
     *                 <code>localPosition</code>. Type codes need not be contiguous.
     */

#Code:
    @IntRange(from = ItemViewTypeComposer.MIN_WRAPPED_VIEW_TYPE, to = ItemViewTypeComposer.MAX_WRAPPED_VIEW_TYPE)
    public int getHeaderItemViewType(int localPosition) {
        return 0;
    }

#No. 2696
#File: E:\bishe\1\AbstractHeaderFooterWrapperAdapter.java
#Comment:
    /**
     * Return the view type of the footer item at <code>localPosition</code> for the purposes
     * of view recycling.
     *
     * <p>The default implementation of this method returns 0, making the assumption of
     * a single view type for the adapter. Unlike ListView adapters, types need not
     * be contiguous.</p>
     *
     * @param localPosition The footer adapter local position to query
     * @return integer value identifying the type of the view needed to represent the item at
     *                 <code>localPosition</code>. Type codes need not be contiguous.
     */

#Code:
    @IntRange(from = ItemViewTypeComposer.MIN_WRAPPED_VIEW_TYPE, to = ItemViewTypeComposer.MAX_WRAPPED_VIEW_TYPE)
    public int getFooterItemViewType(int localPosition) {
        return 0;
    }

#No. 2697
#File: E:\bishe\1\AbstractHeaderItem.java
#Comment:
/**
 * Generic implementation of {@link IHeader} interface. By default this item is hidden and not
 * selectable.
 * <p>This abstract class extends {@link AbstractFlexibleItem}.</p>
 * The ViewHolder must be of type {@link FlexibleViewHolder} to assure correct StickyHeader
 * behaviours.
 *
 * @param <VH> {@link FlexibleViewHolder}
 * @author Davide Steduto
 * @since 17/01/2016 Created
 * <br/>18/06/2016 Changed signature with FlexibleViewHolder
 */

#Code:
public abstract class AbstractHeaderItem<VH extends FlexibleViewHolder>
		extends AbstractFlexibleItem<VH>
		implements IHeader<VH> {

	/**
	 * By default, header is hidden and not selectable
	 */
	public AbstractHeaderItem() {
		setHidden(true);
		setSelectable(false);
	}

}
#No. 2698
#File: E:\bishe\1\AbstractHealthDescriptor.java
#Comment:
    /**
     * Determines whether a threshold has been defined.
     *
     * @return <code>true</code> if a threshold has been defined
     */

#Code:
    public boolean isThresholdEnabled() {
        return thresholds.isValid();
    }

#No. 2699
#File: E:\bishe\1\AbstractHealthDescriptor.java
#Comment:
    /**
     * Returns a lower bound of warnings that will guarantee that a build
     * neither is unstable or failed.
     *
     * @return the number of warnings
     */

#Code:
    public int getLowerBoundOfThresholds() {
        return thresholds.getLowerBound();
    }

#No. 2700
#File: E:\bishe\1\AbstractHealthDescriptor.java
#Comment:
    /**
     * Determines whether a health report should be created.
     *
     * @return <code>true</code> if a health report should be created
     */

#Code:
    public boolean isHealthyReportEnabled() {
        if (isValid(healthy) && isValid(unHealthy)) {
            int healthyNumber = convert(healthy);
            int unHealthyNumber = convert(unHealthy);

            return unHealthyNumber > healthyNumber;
        }
        return false;
    }

#No. 2701
#File: E:\bishe\1\AbstractHealthDescriptor.java
#Comment:
    /**
     * Returns the healthy threshold for annotations, i.e. when health is reported as 100%.
     *
     * @return the 100% healthiness
     * @throws IllegalArgumentException if the healthy values are not valid
     * @see #isHealthyReportEnabled()
     */

#Code:
    public int getHealthyAnnotations() {
        if (isHealthyReportEnabled()) {
            return convert(healthy);
        }
        throw createException();
    }

#No. 2702
#File: E:\bishe\1\AbstractHealthDescriptor.java
#Comment:
    /**
     * Creates a new {@link IllegalArgumentException}.
     *
     * @return a new {@link IllegalArgumentException}
     */

#Code:
    private IllegalArgumentException createException() {
        return new IllegalArgumentException("Healthy values are not valid: " + healthy + ", " + unHealthy);
    }

#No. 2703
#File: E:\bishe\1\AbstractHealthDescriptor.java
#Comment:
    /**
     * Returns the unhealthy threshold of annotations, i.e. when health is reported as 0%.
     *
     * @return the 0% unhealthiness
     * @throws IllegalArgumentException if the healthy values are not valid
     * @see #isHealthyReportEnabled()
     */

#Code:
    public int getUnHealthyAnnotations() {
        if (isHealthyReportEnabled()) {
            return convert(unHealthy);
        }
        throw createException();
    }

#No. 2704
#File: E:\bishe\1\AbstractHealthDescriptor.java
#Comment:
    /**
     * Initializes new fields that are not serialized yet.
     *
     * @return the object
     */

#Code:
    @SuppressWarnings("deprecation")
    protected Object readResolve() {
        if (thresholds == null) {
            thresholds = new Thresholds();

            if (threshold != null) {
                thresholds.unstableTotalAll = threshold;
                threshold = null; // NOPMD
            }
            if (newThreshold != null) {
                thresholds.unstableNewAll = newThreshold;
                newThreshold = null; // NOPMD
            }
            if (failureThreshold != null) {
                thresholds.failedTotalAll = failureThreshold;
                failureThreshold = null; //NOPMD
            }
            if (newFailureThreshold != null) {
                thresholds.failedNewAll = newFailureThreshold;
                newFailureThreshold = null; // NOPMD
            }
        }
        return this;
    }

#No. 2705
#File: E:\bishe\1\AbstractHessianConnectionFactory.java
#Comment:
/**
 * Internal factory for creating connections to the server.  The default
 * factory is java.net
 */

#Code:
abstract public class AbstractHessianConnectionFactory
  implements HessianConnectionFactory
{
  private HessianProxyFactory _factory;
  
  /**
   * The HessianProxyFactory contains some common network
   * configuration like timeouts.
   */
  public void setHessianProxyFactory(HessianProxyFactory factory)
  {
    _factory = factory;
  }
  
  /**
   * The HessianProxyFactory contains some common network
   * configuration like timeouts.
   */
  public HessianProxyFactory getHessianProxyFactory()
  {
    return _factory;
  }
  
  /**
   * Opens a new or recycled connection to the HTTP server.
   */
  abstract public HessianConnection open(URL url)
    throws IOException;
}

#No. 2706
#File: E:\bishe\1\AbstractHibernateSpaceDataSource.java
#Comment:
    /**
     * Returns if the given entity name is part of the {@link #getManagedEntries()} list.
     */

#Code:
    protected boolean isManagedEntry(String entityName) {
        return sessionManager.isManagedEntry(entityName);
    }

#No. 2707
#File: E:\bishe\1\AbstractHierarchicalGraphModel.java
#Comment:
	/**
	 * Performs various verification to be done after construction:
	 * <ul>
	 * <li>Ensure all node have non negative degree.
	 * </ul>
	 */

#Code:
	public void verify() throws Exception {
		for (IBoundedItem child : getChildren()) {
			if (getNodeDegree(child) == -1)
				throw new Exception(
						"at least one child has no degree information: "
								+ child);
			if (child.getParent() != this)
				throw new Exception("parent not set: " + child);
			/*
			 * if(child instanceof AbstractHierarchicalGraphModel){
			 * ((AbstractHierarchicalGraphModel)child).verify(); }
			 */
		}
	}

#No. 2708
#File: E:\bishe\1\AbstractHierarchicalGraphModel.java
#Comment:
	/**
	 * Create (N*N-N) repulsors
	 */

#Code:
	public void createAllMutualRepulsors() {
		for (IBoundedItem b1 : getChildren())
			for (IBoundedItem b2 : getChildren())
				if (b1 != b2)
					addRepulsor(b1, b2);
	}

#No. 2709
#File: E:\bishe\1\AbstractHierarchicalGraphModel.java
#Comment:
	/**
	 * Create (N*N/2 - N) instead of N repulsors
	 */

#Code:
	public void createAllMutualRepulsorsNoSymetry() {
		int n = getChildren().size();
		// int t = (n*n)/2;
		// int k = 0;

		for (int i = 0; i < n; i++) {
			// System.out.println((k++) + "/" + n);
			IBoundedItem b1 = children.get(i);
			for (int j = i + 1; j < n; j++) {
				IBoundedItem b2 = children.get(j);
				addRepulsor(b1, b2);
			}
		}
	}

#No. 2710
#File: E:\bishe\1\AbstractHierarchicalGraphModel.java
#Comment:
	/**
	 * Create (N*N-N) attractors
	 */

#Code:
	public void createAllMutualAttractors() {
		for (IBoundedItem b1 : getChildren())
			for (IBoundedItem b2 : getChildren())
				if (b1 != b2) {
					addAttractionEdgeForce(b1, b2);
				}
	}

#No. 2711
#File: E:\bishe\1\AbstractHierarchicalModel.java
#Comment:
    /** Warning: calling getRoot() for the first time will cache the root.
     * If needing to have
     */

#Code:
    @Override
    public IHierarchicalNodeModel getRoot(){
        if(cache.getRoot()==null){
            if(parent==null)
                cache.setRoot(this);
            else
                cache.setRoot(computeRoot());
        }
        return cache.getRoot();
    }

#No. 2712
#File: E:\bishe\1\AbstractHierarchicalModel.java
#Comment:
    /**
     * Return the number of level between this model and its farest leaf in the hierarchy.
     * If no other child than raw IBoundedItem, then leaf level is 0.
     */

#Code:
    @Override
    public int getMaxLeafLevel(){
        int max = 0;
        for(IBoundedItem i: children){
            if(i instanceof IHierarchicalNodeModel){
                int level = 1 + ((IHierarchicalNodeModel)i).getMaxLeafLevel();
                if(level>max)
                    max = level;
            }
        }
        return max;
    }

#No. 2713
#File: E:\bishe\1\AbstractHierarchicalModel.java
#Comment:
    /**
     * A shortcut for {@link addChild(item, true)}
     */

#Code:
    public boolean addChild(IBoundedItem item){
        return addChild(item, true);
    }

#No. 2714
#File: E:\bishe\1\AbstractHierarchicalModel.java
#Comment:
    /**
     * Add an item to the child list, and set the input item parent to this.
     * If set to true, bounds of this model are updated recursively.
     */

#Code:
    public boolean addChild(IBoundedItem item, boolean refreshBounds){
        boolean s = children.add(item);
        if(s){
            item.setParent(this);
            if(refreshBounds)
                refreshBounds(true);
        }
        return s;
    }

#No. 2715
#File: E:\bishe\1\AbstractHierarchicalModel.java
#Comment:
    /** 
     * Returns false if at least one item wasn't added properly to the children list.
     */

#Code:
    public boolean addChildren(Collection<IBoundedItem> items, boolean refreshBounds){
        boolean s = true;
        for(IBoundedItem item: items)
            s = s && addChild(item, false);        
        if(refreshBounds)
            refreshBounds(true);
        return s;
    }

#No. 2716
#File: E:\bishe\1\AbstractHierarchicalModel.java
#Comment:
    /** 
     * Map an input data to its representation. If the child is not referenced yet, it is
     * added to the children list through {@link addChild()}.
     */

#Code:
    public void registerChild(Object data, IBoundedItem representation){
        if(!hasChild(representation))
            addChild(representation);
        this.dataToModel.put(data, representation);
    }

#No. 2717
#File: E:\bishe\1\AbstractHierarchicalModel.java
#Comment:
    /** 
     * Map a representation to the object that it is currently holding.
     */

#Code:
    public void registerChild(IBoundedItem representation){
        registerChild(representation.getObject(), representation);
    }

#No. 2718
#File: E:\bishe\1\AbstractHierarchicalModel.java
#Comment:
        /*if(parentDirty){
            computeAbsolutePosition(absolutePosition);
            //parentDirty = false;
        }
        return absolutePosition;*/

#Code:
        return handler.getOrUpdateAbsolutePosition();

    }
    
    /*protected void computeAbsolutePosition(Coord2d abs){
        if(parent==null)
            abs.set(getPosition());
        else{
            //abs.set(getPosition());
            //abs.addSelf(getParent().getAbsolutePosition());
            abs.set(getParent().getAbsolutePosition().add(getPosition()));
        }
    }

#No. 2719
#File: E:\bishe\1\AbstractHierarchicalModel.java
#Comment:
    /**
     * Change position by copying input coordinate values into self coordinate values.
     * Parent is set dirty
     */

#Code:
    @Override
    public void changePosition(float x, float y){
        position.x = x;
        position.y = y;        
        notifyPositionChanged();
    }

#No. 2720
#File: E:\bishe\1\AbstractHierarchicalModel.java
#Comment:
    /**
     * Change position by adding input coordinate values to self coordinate values.
     */

#Code:
    @Override
    public void shiftPosition(float x, float y){
        position.addSelf(x, y);
        notifyPositionChanged();
    }

#No. 2721
#File: E:\bishe\1\AbstractHierarchicalModel.java
#Comment:
    /** Tells children that parent position changed and that there absolute position
     * is not accurate anymore*/

#Code:
    public void fireParentPositionChanged(){
        for(IBoundedItem item: children)
            item.notifyParentPositionDirty();
    }

#No. 2722
#File: E:\bishe\1\AbstractHierarchicalModel.java
#Comment:
        /*for(IBoundedItem i: getChildren()){
            if(i instanceof AbstractHierarchicalModel){
                ((AbstractHierarchicalModel)i).updateBoundsCache();
            }
        }*/

#Code:
        handler.updateRawRectangleBounds();
        handler.updateRadialBounds();
        //flags.dirtyChildrenPosition = false;        
        fireItemBoundsChanged();
    }
    
    /******** MULTI REPRESENTATION (COLLAPSED) *********/
    
    @Override
    public CollapsedModelItem getCollapsedModel(){
        return collapsedModel;
    }

#No. 2723
#File: E:\bishe\1\AbstractHierarchicalModel.java
#Comment:
    /*public boolean equals(Object o){
        if(o instanceof IBoundedItem){
            Object data = getObject();
            Object data2 = ((IBoundedItem)o).getObject();
            if(data!=null && data2!=null){
                return data.equals(data2);
            }
            else
                return super.equals(o);
        }
        else
            return super.equals(o);
    }
    
    public int hashCode(){
        Object data = getObject();
        if(data!=null)
            return data.hashCode();
        return super.hashCode();
    }*/

#Code:
    
    /********* SLOTS *********/
    
    @Override
    public Coord2d getSlotableCenter() {
        return getAbsolutePosition();
    }

#No. 2724
#File: E:\bishe\1\AbstractHierarchicalRenderer.java
#Comment:
    /*public RectangleBounds getBoundsForRendering(IHierarchicalModel model){
        //RectangleBounds bounds = model.getRectangleBounds().shiftCenterTo(model.getAbsolutePosition());
        //RectangleBounds bounds = AbstractHierarchicalModel.getAbsoluteBounds(model);
        //RectangleBounds bounds = model.getRelativeRectangleBounds();
        return model.getAbsoluteRectangleBounds();
    }*/

#Code:
    
    /**************************/
    
    public void addChild(IHierarchicalRenderer renderer){
        children.add(renderer);
    }

#No. 2725
#File: E:\bishe\1\AbstractHistogramExecutor.java
#Comment:
	/**
	 * Must be overridden to implement that the request (for histogram or min/max computations) is transmitted over network
	 *
	 * @param request the request for histograms or min/max computations serialized as json string
	 * @param triplePattern can be used for determining the key of the node holding data relevant to this triple pattern
	 * @return the result strings (serialized as json string) from the queried nodes
	 */

#Code:
	public abstract String[] sendJSONRequests(String request, TriplePattern triplePattern);

	/**
	 * just for creating the json request string for rebuilding the statistics to be sent over network
	 *
	 * @return the json request string for rebuilding the statistics
	 */
	public static String createRebuildStatisticsRequestString(){
		final JSONObject json = new JSONObject();
		try {
			json.put("rebuild_statistics_request", "now");
		} catch (final JSONException e) {
			System.err.println(e);
			e.printStackTrace();
		}
		return json.toString();
	}

#No. 2726
#File: E:\bishe\1\AbstractHistoryAction.java
#Comment:
    /**
     * Sets the extended view path. The extended view path will be removed from file paths in the event. The extended view path is for example the view root +
     * view name; and this path shows up in the history and can be confusing for users.
     * 
     * @param path
     *            the new extended view path.
     */

#Code:
    public void setExtendedViewPath(String path) {
        this.extendedViewPath = path;
    }

#No. 2727
#File: E:\bishe\1\AbstractHistoryDataView.java
#Comment:
    /**
     * Obtains the SQL needed for obtaining the historical data of the selected view.
     *
     * @param listOfDevices with the list of devices needed for retrieving the historical data.
     * @return {@link java.lang.String} with the SQL sentence.
     */

#Code:
    public String getHistoryDataSql(@NonNull final List<String> listOfDevices) {
        final StringBuilder listOfDevicesSql = new StringBuilder();
        listOfDevicesSql.append('(');
        for (int i = listOfDevices.size() - 1; i >= 0; i--) {
            listOfDevicesSql.append(convertToSqlString(listOfDevices.get(i)));
            if (i > 0) {
                listOfDevicesSql.append(", ");
            }
        }

#No. 2728
#File: E:\bishe\1\AbstractHistoryDataView.java
#Comment:
    /**
     * Obtains the SQL needed for obtaining the addresses of the devices available in the selected interval.
     *
     * @return {@link java.lang.String} with the SQL sentence.
     */

#Code:
    public String getListOfDevicesSql() {
        return String.format("SELECT DISTINCT %s FROM %s;", HistoryDataTable.COLUMN_DEVICE_ADDRESS, getName());
    }

#No. 2729
#File: E:\bishe\1\AbstractHistoryDataView.java
#Comment:
    /**
     * Obtains the maximum number of milliseconds of a view.
     *
     * @return <code>int</code> with the number of milliseconds.
     */

#Code:
    public abstract int getNumberMilliseconds();

    /**
     * Returns the view resolution.
     *
     * @return <code>int</code> with the view resolution in milliseconds.
     */
    @SuppressWarnings("unused")
    public abstract int getResolution();
}
#No. 2730
#File: E:\bishe\1\AbstractHostnameToCertificateChecker.java
#Comment:
	/**
	 * This method is called whenever there is an error when processing the peer's certificate
	 * and hostname. Generally it should never happen, and the implementation should simply 
	 * close the socket and report the error. The default implementation simply throws an 
	 * {@link IllegalStateException}. 
	 * @param hce the original event object
	 * @param e error
	 */

#Code:
	protected void processingError(HandshakeCompletedEvent hce, Exception e)
	{
		throw new IllegalStateException("Error occured when verifying if the SSL peer's " +
				"hostname matches its certificate", e);
	}

#No. 2731
#File: E:\bishe\1\AbstractHostPartitionConnectionPool.java
#Comment:
    /**
     * Called every time a host is added, removed or is marked as down
     */

#Code:
    protected void rebuildPartitions() {
        topology.refresh();
    }

#No. 2732
#File: E:\bishe\1\AbstractHostPartitionConnectionPool.java
#Comment:
    /**
     * @return {@link Topology}
     */

#Code:
    public Topology<CL> getTopology() {
        return topology;
    }

#No. 2733
#File: E:\bishe\1\AbstractHostPartitionConnectionPool.java
#Comment:
    /**
     * @return {@link Partitioner}
     */

#Code:
    public Partitioner getPartitioner() {
        return this.partitioner;
    }

#No. 2734
#File: E:\bishe\1\AbstractHtmlDriver.java
#Comment:
    /**
     * <b>NOTE:</b> This method should not be used directly into the test scripts. 
     * The implementation may be changed by the Automation Framework Team without notice.
     * @return Internal Object
     */

#Code:
    public abstract Object getInternalObject(
                                              String objectName );
}
}

#No. 2735
#File: E:\bishe\1\AbstractHtmlPageAction.java
#Comment:
	/**
	 * 访问页面的命名空间，默认与 struts 配置文件中的 namespace 值保持一致
	 */

#Code:
	protected String getHtmlPageNamespace(){
		return getActionNamespace();
	}

#No. 2736
#File: E:\bishe\1\AbstractHtmlPageAction.java
#Comment:
	/**
	 * 构建页面的html代码
	 */

#Code:
	protected HtmlPage buildHtmlPage() {
		HtmlPage htmlPage = new HtmlPage();

		// 设置页面参数
		htmlPage.setNamespace(getHtmlPageNamespace())
				.setTitle(this.getHtmlPageTitle())
				.setInitMethod(getHtmlPageInitMethod())
				.setOption(getHtmlPageOption().toString()).setBeautiful(true)
				.addClazz("bc-page");

		// 引用额外的js、css文件
		htmlPage.addJs(getHtmlPageJs());// 兼容旧的代码
		List<String> container = new ArrayList<>();
		addJsCss(container);
		if (!container.isEmpty()) htmlPage.setAttr("data-js", new JSONArray(container).toString());

		// 附加工具条
		htmlPage.addChild(getHtmlPageToolbar());

		return htmlPage;
	}

#No. 2737
#File: E:\bishe\1\AbstractHtmlPageAction.java
#Comment:
	/**
	 * 页面配置参数
	 */

#Code:
	protected PageOption getHtmlPageOption() {
		return new PageOption().setMinWidth(250).setMinHeight(120)
				.setModal(false).setMinimizable(true).setMaximizable(true);
	}

#No. 2738
#File: E:\bishe\1\AbstractHtmlPageAction.java
#Comment:
	/**
	 * 页面加载后调用的js初始化方法
	 */

#Code:
	protected String getHtmlPageInitMethod() {
		return null;
	}

#No. 2739
#File: E:\bishe\1\AbstractHtmlPageAction.java
#Comment:
	/**
	 * 向页面添加额外的js、css文件
	 * <p>调用此方法生成的data-js属性为json数组格式，页面将使用requireJs加载这些js、css文件</p>
	 *
	 * @param container 已初始化好的容器
	 */

#Code:
	protected void addJsCss(List<String> container) {
		// Do nothing
	}

#No. 2740
#File: E:\bishe\1\AbstractHtmlPageAction.java
#Comment:
	/**
	 * 页面需要另外加载的js、css文件，逗号连接多个文件
	 * <p>此方式为旧的加载js、css文件的方法，新模块不要继续使用</p>
	 *
	 * @deprecated use addJsCss(List<String>)
	 */

#Code:
	protected String getHtmlPageJs() {
		Collection<String> jscss = new ArrayList<String>();
		addHtmlPageJsCss(jscss, getContextPath());
		return StringUtils.collectionToCommaDelimitedString(jscss);
	}

#No. 2741
#File: E:\bishe\1\AbstractHtmlPageAction.java
#Comment:
	/**
	 * 向页面添加额外的js文件
	 *
	 * @param jscss       已初始化好的集合
	 * @param contextPath 上下文路径
	 * @deprecated use addJsCss(List<String>)
	 */

#Code:
	protected void addHtmlPageJsCss(Collection<String> jscss, String contextPath) {
		// Do nothing
	}

#No. 2742
#File: E:\bishe\1\AbstractHtmlPageAction.java
#Comment:
	/**
	 * 获取访问该ation的上下文路径
	 */

#Code:
	protected String getContextPath() {
		return ServletActionContext.getRequest().getContextPath();
	}

#No. 2743
#File: E:\bishe\1\AbstractHtmlReporter.java
#Comment:
	/**
	 * If no execution exists. Meaning, we are not appending to an older
	 * execution; A new execution would be created. If the execution is new,
	 * will add a new reported machine instance. If we are appending to an older
	 * execution, and the machine is the same as the machine the execution were
	 * executed on, will append the results to the last machine and will not
	 * create a new one.
	 * 
	 */

#Code:
	private void addMachineToExecution() {
		MachineNode currentMachine = new MachineNode(getMachineName());
		if (null == execution) {
			execution = new Execution();
			execution.addMachine(currentMachine);
			return;
		}
		// We are going to append to existing execution
		MachineNode lastMachine = execution.getLastMachine();
		if (null == lastMachine || null == lastMachine.getName()) {
			// Something is wrong. We don't have machine in the existing
			// execution. We need to add a new one
			execution.addMachine(currentMachine);
			return;
		}
		if (!lastMachine.getName().equals(currentMachine.getName())) {
			// The execution happened on machine different from the current
			// machine, so we will create a new machine
			execution.addMachine(currentMachine);
		}

	}

#No. 2744
#File: E:\bishe\1\AbstractHtmlReporter.java
#Comment:
	/**
	 * This method is meant to be override. It is called at the start of the run
	 */

#Code:
	public void startRun() {
		execution.getLastMachine().setPlannedTests(calculateNumberOfPlannedTests());
	}

#No. 2745
#File: E:\bishe\1\AbstractHtmlReporter.java
#Comment:
	/**
	 * Adding the scenario properties to the newly created scenario. <br>
	 * Override this method if you would your reporter to add additional
	 * properties to the scenario.
	 * 
	 * @param scenario
	 *            Newly created scenario.
	 */

#Code:
	protected void addScenarioProperties(ScenarioNode scenario) {
		// Adding the summary properties. Those also include the run properties
		// that have a 'summary' prefix
		final Properties summaryProperties = Summary.getInstance().getProperties();
		for (Object key : summaryProperties.keySet()) {
			final String value = summaryProperties.getProperty(key + "");
			if (!StringUtils.isEmpty(value)) {
				scenario.addScenarioProperty(key.toString(), value);
			}
		}
		// We are adding some additional information that we may find
		// interesting
		final String sutFile = JSystemProperties.getInstance().getPreference(FrameworkOptions.USED_SUT_FILE);
		if (!StringUtils.isEmpty(sutFile)) {
			scenario.addScenarioProperty("sutFile", sutFile);
		}
		final String testDir = JSystemProperties.getInstance().getPreference(FrameworkOptions.TESTS_CLASS_FOLDER);
		if (!StringUtils.isEmpty(testDir)) {
			scenario.addScenarioProperty("testDir", testDir);
		}
	}

#No. 2746
#File: E:\bishe\1\AbstractHttpApi.java
#Comment:
    /**
     * execute() an httpRequest catching exceptions and returning null instead.
     *
     * @param httpRequest
     * @return
     * @throws IOException
     */

#Code:
    public HttpResponse executeHttpRequest(HttpRequestBase httpRequest) throws IOException {
        if (DEBUG) LOG.log(Level.FINE, "executing HttpRequest for: "
                + httpRequest.getURI().toString());
        try {
            mHttpClient.getConnectionManager().closeExpiredConnections();
            return mHttpClient.execute(httpRequest);
        } catch (IOException e) {
            httpRequest.abort();
            throw e;
        }
    }

#No. 2747
#File: E:\bishe\1\AbstractHttpApi.java
#Comment:
    /**
     * Create a thread-safe client. This client does not do redirecting, to allow us to capture
     * correct "error" codes.
     *
     * @return HttpClient
     */

#Code:
    public static final DefaultHttpClient createHttpClient() {
        // Sets up the http part of the service.
        final SchemeRegistry supportedSchemes = new SchemeRegistry();

        // Register the "http" protocol scheme, it is required
        // by the default operator to look up socket factories.
        final SocketFactory sf = PlainSocketFactory.getSocketFactory();
        supportedSchemes.register(new Scheme("http", sf, 80));
        supportedSchemes.register(new Scheme("https", SSLSocketFactory.getSocketFactory(), 443));
        
        // Set some client http client parameter defaults.
        final HttpParams httpParams = createHttpParams();
        HttpClientParams.setRedirecting(httpParams, false);

        final ClientConnectionManager ccm = new ThreadSafeClientConnManager(httpParams,
                supportedSchemes);
        return new DefaultHttpClient(ccm, httpParams);
    }

#No. 2748
#File: E:\bishe\1\AbstractHttpApi.java
#Comment:
    /**
     * Create the default HTTP protocol parameters.
     */

#Code:
    private static final HttpParams createHttpParams() {
        final HttpParams params = new BasicHttpParams();

        // Turn off stale checking. Our connections break all the time anyway,
        // and it's not worth it to pay the penalty of checking every time.
        HttpConnectionParams.setStaleCheckingEnabled(params, false);

        HttpConnectionParams.setConnectionTimeout(params, TIMEOUT * 1000);
        HttpConnectionParams.setSoTimeout(params, TIMEOUT * 1000);
        HttpConnectionParams.setSocketBufferSize(params, 8192);

        return params;
    }

#No. 2749
#File: E:\bishe\1\AbstractHttpClient.java
#Comment:
    /**
     * Replaces the parameters.
     * The implementation here does not update parameters of dependent objects.
     *
     * @param params    the new default parameters
     */

#Code:
    public synchronized void setParams(HttpParams params) {
        defaultParams = params;
    }

#No. 2750
#File: E:\bishe\1\AbstractHttpClient.java
#Comment:
    /**
     * @since 4.1
     */

#Code:
    public synchronized final RedirectStrategy getRedirectStrategy() {
        if (redirectStrategy == null) {
            redirectStrategy = new DefaultRedirectStrategy();
        }
        return redirectStrategy;
    }

#No. 2751
#File: E:\bishe\1\AbstractHttpClient.java
#Comment:
    /**
     * @since 4.1
     */

#Code:
    public synchronized void setRedirectStrategy(final RedirectStrategy redirectStrategy) {
        this.redirectStrategy = redirectStrategy;
    }

#No. 2752
#File: E:\bishe\1\AbstractHttpClient.java
#Comment:
    /**
     * Maps to {@link HttpClient#execute(HttpHost,HttpRequest,HttpContext)
     *                           execute(target, request, context)}.
     * The target is determined from the URI of the request.
     *
     * @param request   the request to execute
     * @param context   the request-specific execution context,
     *                  or <code>null</code> to use a default context
     */

#Code:
    public final HttpResponse execute(HttpUriRequest request,
                                      HttpContext context)
        throws IOException, ClientProtocolException {

        if (request == null) {
            throw new IllegalArgumentException
                ("Request must not be null.");
        }

        return execute(determineTarget(request), request, context);
    }

#No. 2753
#File: E:\bishe\1\AbstractHttpClient.java
#Comment:
    /**
     * @since 4.1
     */

#Code:
    protected RequestDirector createClientRequestDirector(
            final HttpRequestExecutor requestExec,
            final ClientConnectionManager conman,
            final ConnectionReuseStrategy reustrat,
            final ConnectionKeepAliveStrategy kastrat,
            final HttpRoutePlanner rouplan,
            final HttpProcessor httpProcessor,
            final HttpRequestRetryHandler retryHandler,
            final RedirectStrategy redirectStrategy,
            final AuthenticationHandler targetAuthHandler,
            final AuthenticationHandler proxyAuthHandler,
            final UserTokenHandler stateHandler,
            final HttpParams params) {
        return new DefaultRequestDirector(
                log,
                requestExec,
                conman,
                reustrat,
                kastrat,
                rouplan,
                httpProcessor,
                retryHandler,
                redirectStrategy,
                targetAuthHandler,
                proxyAuthHandler,
                stateHandler,
                params);
    }

#No. 2754
#File: E:\bishe\1\AbstractHttpClient.java
#Comment:
    /**
     * Obtains parameters for executing a request.
     * The default implementation in this class creates a new
     * {@link ClientParamsStack} from the request parameters
     * and the client parameters.
     * <br/>
     * This method is called by the default implementation of
     * {@link #execute(HttpHost,HttpRequest,HttpContext)}
     * to obtain the parameters for the
     * {@link DefaultRequestDirector}.
     *
     * @param req    the request that will be executed
     *
     * @return  the parameters to use
     */

#Code:
    protected HttpParams determineParams(HttpRequest req) {
        return new ClientParamsStack
            (null, getParams(), req.getParams(), null);
    }

#No. 2755
#File: E:\bishe\1\AbstractHttpClientConnection.java
#Comment:
    /**
     * Creates an instance of {@link EntityDeserializer} with the
     * {@link LaxContentLengthStrategy} implementation to be used for
     * de-serializing entities received over this connection.
     * <p>
     * This method can be overridden in a super class in order to create
     * instances of {@link EntityDeserializer} using a custom
     * {@link ContentLengthStrategy}.
     *
     * @return HTTP entity deserializer
     */

#Code:
    protected EntityDeserializer createEntityDeserializer() {
        return new EntityDeserializer(new LaxContentLengthStrategy());
    }

#No. 2756
#File: E:\bishe\1\AbstractHttpClientConnection.java
#Comment:
    /**
     * Creates an instance of {@link EntitySerializer} with the
     * {@link StrictContentLengthStrategy} implementation to be used for
     * serializing HTTP entities sent over this connection.
     * <p>
     * This method can be overridden in a super class in order to create
     * instances of {@link EntitySerializer} using a custom
     * {@link ContentLengthStrategy}.
     *
     * @return HTTP entity serialzier.
     */

#Code:
    protected EntitySerializer createEntitySerializer() {
        return new EntitySerializer(new StrictContentLengthStrategy());
    }

#No. 2757
#File: E:\bishe\1\AbstractHttpClientConnection.java
#Comment:
    /**
     * Creates an instance of {@link DefaultHttpResponseFactory} to be used
     * for creating {@link HttpResponse} objects received by over this
     * connection.
     * <p>
     * This method can be overridden in a super class in order to provide
     * a different implementation of the {@link HttpResponseFactory} interface.
     *
     * @return HTTP response factory.
     */

#Code:
    protected HttpResponseFactory createHttpResponseFactory() {
        return new DefaultHttpResponseFactory();
    }

#No. 2758
#File: E:\bishe\1\AbstractHttpClientConnection.java
#Comment:
    /**
     * Creates an instance of {@link HttpMessageParser} to be used for parsing
     * HTTP responses received over this connection.
     * <p>
     * This method can be overridden in a super class in order to provide
     * a different implementation of the {@link HttpMessageParser} interface or
     * to pass a different implementation of {@link LineParser} to the
     * the default implementation {@link HttpResponseParser}.
     *
     * @param buffer the session input buffer.
     * @param responseFactory the HTTP response factory.
     * @param params HTTP parameters.
     * @return HTTP message parser.
     */

#Code:
    protected HttpMessageParser createResponseParser(
            final SessionInputBuffer buffer,
            final HttpResponseFactory responseFactory,
            final HttpParams params) {
        return new HttpResponseParser(buffer, null, responseFactory, params);
    }

#No. 2759
#File: E:\bishe\1\AbstractHttpClientConnection.java
#Comment:
    /**
     * Creates an instance of {@link HttpMessageWriter} to be used for
     * writing out HTTP requests sent over this connection.
     * <p>
     * This method can be overridden in a super class in order to provide
     * a different implementation of the {@link HttpMessageWriter} interface or
     * to pass a different implementation of {@link LineFormatter} to the
     * the default implementation {@link HttpRequestWriter}.
     *
     * @param buffer the session output buffer
     * @param params HTTP parameters
     * @return HTTP message writer
     */

#Code:
    protected HttpMessageWriter createRequestWriter(
            final SessionOutputBuffer buffer,
            final HttpParams params) {
        return new HttpRequestWriter(buffer, null, params);
    }

#No. 2760
#File: E:\bishe\1\AbstractHttpClientConnection.java
#Comment:
    /**
     * @since 4.1
     */

#Code:
    protected HttpConnectionMetricsImpl createConnectionMetrics(
            final HttpTransportMetrics inTransportMetric,
            final HttpTransportMetrics outTransportMetric) {
        return new HttpConnectionMetricsImpl(inTransportMetric, outTransportMetric);
    }

#No. 2761
#File: E:\bishe\1\AbstractHttpClientConnection.java
#Comment:
    /**
     * Initializes this connection object with {@link SessionInputBuffer} and
     * {@link SessionOutputBuffer} instances to be used for sending and
     * receiving data. These session buffers can be bound to any arbitrary
     * physical output medium.
     * <p>
     * This method will invoke {@link #createHttpResponseFactory()},
     * {@link #createRequestWriter(SessionOutputBuffer, HttpParams)}
     * and {@link #createResponseParser(SessionInputBuffer, HttpResponseFactory, HttpParams)}
     * methods to initialize HTTP request writer and response parser for this
     * connection.
     *
     * @param inbuffer the session input buffer.
     * @param outbuffer the session output buffer.
     * @param params HTTP parameters.
     */

#Code:
    protected void init(
            final SessionInputBuffer inbuffer,
            final SessionOutputBuffer outbuffer,
            final HttpParams params) {
        if (inbuffer == null) {
            throw new IllegalArgumentException("Input session buffer may not be null");
        }
        if (outbuffer == null) {
            throw new IllegalArgumentException("Output session buffer may not be null");
        }
        this.inbuffer = inbuffer;
        this.outbuffer = outbuffer;
        if (inbuffer instanceof EofSensor) {
            this.eofSensor = (EofSensor) inbuffer;
        }
        this.responseParser = createResponseParser(
                inbuffer,
                createHttpResponseFactory(),
                params);
        this.requestWriter = createRequestWriter(
                outbuffer, params);
        this.metrics = createConnectionMetrics(
                inbuffer.getMetrics(),
                outbuffer.getMetrics());
    }

#No. 2762
#File: E:\bishe\1\AbstractHttpClientSSLTest.java
#Comment:
    /**
     * Frascati engine
     */

#Code:
    protected FraSCAti frascati;

    /**
     * The SCA composite to test
     */
    protected Component scaComposite;    
    
    /**
     * Start FraSCAti and load the composite
     * @param compositeName The composite to load
     * @throws FrascatiException 
     */
    public void startFraSCAtiAndLoadComposite(String compositeName) throws FrascatiException{
        System.out.println("Loading SCA composite '" + compositeName + "'...");
        // Start FraSCAti
        frascati = FraSCAti.newFraSCAti();
        // Load the composite
        scaComposite = frascati.processComposite(compositeName, new ProcessingContextImpl());
    }

#No. 2763
#File: E:\bishe\1\AbstractHttpClientSSLTest.java
#Comment:
    /**
     * Close the SCA domain
     * @throws IllegalLifeCycleException if the domain cannot be closed
     * @throws NoSuchInterfaceException if the lifecycle controller of the component is not found
     */

#Code:
    @After
    public final void close() throws FrascatiException {
        if (scaComposite != null) {
            frascati.close(scaComposite);
        }
        frascati.close();
    }    

#No. 2764
#File: E:\bishe\1\AbstractHttpClientSSLTest.java
#Comment:
    /**
     * This test do nothing, just wait for a user action to stop the test.
     * 
     * @throws ClientException
     * @throws SOAPException
     * @throws IOException
     */

#Code:
    @Test
    @Ignore
    public final void testWaitUntilRead() throws Exception {
        System.out.println("Http Discovery Proxy started, wait for user action to stop !");
        // Just push a key in the console window to stop the test
        System.in.read();
        System.out.println("Http Discovery Proxy stopped !");
    }

#No. 2765
#File: E:\bishe\1\AbstractHttpClientSSLTest.java
#Comment:
    /**
     * Return the composite name used for the test
     * @return The composite name
     */

#Code:
    public abstract String getComposite();    
    
}
}

#No. 2766
#File: E:\bishe\1\AbstractHttpConnection.java
#Comment:
	/**
	 * Creates a new instance of AbstractHttpConnection
	 *
	 * @param eventloop eventloop which will handle its I/O operations
	 */

#Code:
	public AbstractHttpConnection(Eventloop eventloop, AsyncTcpSocket asyncTcpSocket, char[] headerChars, int maxHttpMessageSize) {
		this.eventloop = eventloop;
		this.headerChars = headerChars;
		assert headerChars.length >= MAX_HEADER_LINE_SIZE;
		this.maxHttpMessageSize = maxHttpMessageSize;
		this.asyncTcpSocket = asyncTcpSocket;
		reset();
	}

#No. 2767
#File: E:\bishe\1\AbstractHttpContentSession.java
#Comment:
	/**
	 * Provide an HTTP response, depending of which redirect strategy is used:
	 * it could a redirect (HTTP 307, Temporary Redirect), or a tunneled
	 * response using the Streaming Proxy.
	 * 
	 * @param url
	 *            Content URL
	 * @throws ContentException
	 *             Exception in the media server
	 */

#Code:
	private void answerActivateMediaRequest4SimpleHttpConfigurationWithRedirect(
			String url) {
		try {
			HttpServletResponse response = (HttpServletResponse) initialAsyncCtx
					.getResponse();
			getLogger().info("Sending redirect to " + url);
			response.setStatus(HttpServletResponse.SC_TEMPORARY_REDIRECT);
			response.setHeader("Location", url);

		} catch (Throwable t) {
			throw new KurentoMediaFrameworkException(t.getMessage(), t, 20013);
		} finally {
			initialAsyncCtx.complete();
			initialAsyncCtx = null;
		}
	}

#No. 2768
#File: E:\bishe\1\AbstractHttpContentSession.java
#Comment:
	/**
	 * Provide an HTTP response, when a JSON signaling protocol strategy is
	 * used.
	 * 
	 * @param url
	 *            Content URL
	 * @throws ContentException
	 *             Exception in the media server
	 */

#Code:
	private void answerActivateMediaRequest4JsonControlProtocolConfiguration(
			String url) {
		protocolManager.sendJsonAnswer(initialAsyncCtx,
				JsonRpcResponse.newStartUrlResponse(url, sessionId,
						initialJsonRequest.getId()));
		initialAsyncCtx = null;
		initialJsonRequest = null;
	}

#No. 2769
#File: E:\bishe\1\AbstractHttpContentSession.java
#Comment:
	/**
	 * Control protocol accessor (getter).
	 * 
	 * @return Control protocol strategy
	 */

#Code:
	@Override
	public boolean useControlProtocol() {
		return useControlProtocol;
	}

#No. 2770
#File: E:\bishe\1\AbstractHttpContentSession.java
#Comment:
	/**
	 * Release Streaming proxy.
	 */

#Code:
	@Override
	protected synchronized void destroy() {
		super.destroy();

		if (repositoryHttpEndpoint != null) {
			repositoryHttpEndpoint.stop();
			repositoryHttpEndpoint = null;
		}

		Future<?> localTunnelingProxyFuture = tunnellingProxyFuture;
		if (localTunnelingProxyFuture != null) {
			localTunnelingProxyFuture.cancel(true);
			tunnellingProxyFuture = null;
		}
	}

#No. 2771
#File: E:\bishe\1\AbstractHttpInputStream.java
#Comment:
  /**
   * Closes the cache entry and makes the socket available for reuse. This
   * should be invoked when the end of the body has been reached.
   */

#Code:
  protected final void endOfInput(boolean streamCancelled) throws IOException {
    if (cacheRequest != null) {
      cacheBody.close();
    }
    httpEngine.release(streamCancelled);
  }

#No. 2772
#File: E:\bishe\1\AbstractHttpInputStream.java
#Comment:
  /**
   * Calls abort on the cache entry and disconnects the socket. This
   * should be invoked when the connection is closed unexpectedly to
   * invalidate the cache entry and to prevent the HTTP connection from
   * being reused. HTTP messages are sent in serial so whenever a message
   * cannot be read to completion, subsequent messages cannot be read
   * either and the connection must be discarded.
   *
   * <p>An earlier implementation skipped the remaining bytes, but this
   * requires that the entire transfer be completed. If the intention was
   * to cancel the transfer, closing the connection is the only solution.
   */

#Code:
  protected final void unexpectedEndOfInput() {
    if (cacheRequest != null) {
      cacheRequest.abort();
    }
    httpEngine.release(true);
  }

#No. 2773
#File: E:\bishe\1\AbstractHttpServerConnection.java
#Comment:
    /**
     * Creates an instance of {@link EntityDeserializer} with the
     * {@link LaxContentLengthStrategy} implementation to be used for
     * de-serializing entities received over this connection.
     * <p>
     * This method can be overridden in a super class in order to create
     * instances of {@link EntityDeserializer} using a custom
     * {@link ContentLengthStrategy}.
     *
     * @return HTTP entity deserializer
     */

#Code:
    protected EntityDeserializer createEntityDeserializer() {
        return new EntityDeserializer(new LaxContentLengthStrategy());
    }

#No. 2774
#File: E:\bishe\1\AbstractHttpServerConnection.java
#Comment:
    /**
     * Creates an instance of {@link EntitySerializer} with the
     * {@link StrictContentLengthStrategy} implementation to be used for
     * serializing HTTP entities sent over this connection.
     * <p>
     * This method can be overridden in a super class in order to create
     * instances of {@link EntitySerializer} using a custom
     * {@link ContentLengthStrategy}.
     *
     * @return HTTP entity serialzier.
     */

#Code:
    protected EntitySerializer createEntitySerializer() {
        return new EntitySerializer(new StrictContentLengthStrategy());
    }

#No. 2775
#File: E:\bishe\1\AbstractHttpServerConnection.java
#Comment:
    /**
     * Creates an instance of {@link DefaultHttpRequestFactory} to be used
     * for creating {@link HttpRequest} objects received by over this
     * connection.
     * <p>
     * This method can be overridden in a super class in order to provide
     * a different implementation of the {@link HttpRequestFactory} interface.
     *
     * @return HTTP request factory.
     */

#Code:
    protected HttpRequestFactory createHttpRequestFactory() {
        return new DefaultHttpRequestFactory();
    }

#No. 2776
#File: E:\bishe\1\AbstractHttpServerConnection.java
#Comment:
    /**
     * Creates an instance of {@link HttpMessageParser} to be used for parsing
     * HTTP requests received over this connection.
     * <p>
     * This method can be overridden in a super class in order to provide
     * a different implementation of the {@link HttpMessageParser} interface or
     * to pass a different implementation of {@link LineParser} to the
     * the default implementation {@link HttpRequestParser}.
     *
     * @param buffer the session input buffer.
     * @param requestFactory the HTTP request factory.
     * @param params HTTP parameters.
     * @return HTTP message parser.
     */

#Code:
    protected HttpMessageParser createRequestParser(
            final SessionInputBuffer buffer,
            final HttpRequestFactory requestFactory,
            final HttpParams params) {
        return new HttpRequestParser(buffer, null, requestFactory, params);
    }

#No. 2777
#File: E:\bishe\1\AbstractHttpServerConnection.java
#Comment:
    /**
     * Creates an instance of {@link HttpMessageWriter} to be used for
     * writing out HTTP responses sent over this connection.
     * <p>
     * This method can be overridden in a super class in order to provide
     * a different implementation of the {@link HttpMessageWriter} interface or
     * to pass a different implementation of {@link LineFormatter} to the
     * the default implementation {@link HttpResponseWriter}.
     *
     * @param buffer the session output buffer
     * @param params HTTP parameters
     * @return HTTP message writer
     */

#Code:
    protected HttpMessageWriter createResponseWriter(
            final SessionOutputBuffer buffer,
            final HttpParams params) {
        return new HttpResponseWriter(buffer, null, params);
    }

#No. 2778
#File: E:\bishe\1\AbstractHttpServerConnection.java
#Comment:
    /**
     * @since 4.1
     */

#Code:
    protected HttpConnectionMetricsImpl createConnectionMetrics(
            final HttpTransportMetrics inTransportMetric,
            final HttpTransportMetrics outTransportMetric) {
        return new HttpConnectionMetricsImpl(inTransportMetric, outTransportMetric);
    }

#No. 2779
#File: E:\bishe\1\AbstractHttpServerConnection.java
#Comment:
    /**
     * Initializes this connection object with {@link SessionInputBuffer} and
     * {@link SessionOutputBuffer} instances to be used for sending and
     * receiving data. These session buffers can be bound to any arbitrary
     * physical output medium.
     * <p>
     * This method will invoke {@link #createHttpRequestFactory},
     * {@link #createRequestParser(SessionInputBuffer, HttpRequestFactory, HttpParams)}
     * and {@link #createResponseWriter(SessionOutputBuffer, HttpParams)}
     * methods to initialize HTTP request parser and response writer for this
     * connection.
     *
     * @param inbuffer the session input buffer.
     * @param outbuffer the session output buffer.
     * @param params HTTP parameters.
     */

#Code:
    protected void init(
            final SessionInputBuffer inbuffer,
            final SessionOutputBuffer outbuffer,
            final HttpParams params) {
        if (inbuffer == null) {
            throw new IllegalArgumentException("Input session buffer may not be null");
        }
        if (outbuffer == null) {
            throw new IllegalArgumentException("Output session buffer may not be null");
        }
        this.inbuffer = inbuffer;
        this.outbuffer = outbuffer;
        if (inbuffer instanceof EofSensor) {
            this.eofSensor = (EofSensor) inbuffer;
        }
        this.requestParser = createRequestParser(
                inbuffer,
                createHttpRequestFactory(),
                params);
        this.responseWriter = createResponseWriter(
                outbuffer, params);
        this.metrics = createConnectionMetrics(
                inbuffer.getMetrics(),
                outbuffer.getMetrics());
    }

#No. 2780
#File: E:\bishe\1\AbstractHttpSmsSender.java
#Comment:
    /**
     * 异步处理
     *
     * @param smsMessage
     * @return
     */

#Code:
    @Override
    public Future<DataTransferObject> asyncSend(SmsMessage smsMessage) throws URISyntaxException, UnsupportedEncodingException {
        return smsSendThreadPool.sumitTask(smsMessage, this.buildPostParam(smsMessage), config);
    }

#No. 2781
#File: E:\bishe\1\AbstractHttpSmsSender.java
#Comment:
    /**
     * 创建URI
     *
     * @return
     */

#Code:
    public URI buildURIByConfig() throws URISyntaxException {
        URIBuilder builder = new URIBuilder();
        builder.setHost(config.getHost());
        builder.setPort(config.getPort());
        builder.setPath(config.getPath());
        builder.setScheme(config.getProtocol());
        builder.setCharset(Charset.forName(config.getCharset()));
        return builder.build();
    }

#No. 2782
#File: E:\bishe\1\AbstractHystrixCommand.java
#Comment:
    /**
     * {@inheritDoc}.
     */

#Code:
    @Override
    protected T getFallback() {
        throw new RuntimeException("No fallback available.", getExecutionException());
    }

#No. 2783
#File: E:\bishe\1\AbstractHystrixCommand.java
#Comment:
    /**
     * Clears cache for the specified hystrix command.
     */

#Code:
    protected void flushCache() {
        if (cacheRemoveInvocationContext != null) {
            HystrixRequestCacheManager.getInstance().clearCache(cacheRemoveInvocationContext);
        }
    }

#No. 2784
#File: E:\bishe\1\AbstractHystrixStreamController.java
#Comment:
	/**
	 * Maintain an open connection with the client. On initial connection send latest data of each requested event type and subsequently send all changes for each requested event type.
	 * 
	 * @return JAX-RS Response - Serialization will be handled by {@link HystrixStreamingOutputProvider}
	 */

#Code:
	protected Response handleRequest() {
		ResponseBuilder builder = null;
		/* ensure we aren't allowing more connections than we want */
		int numberConnections = getCurrentConnections().get();
		int maxNumberConnectionsAllowed = getMaxNumberConcurrentConnectionsAllowed(); // may change at runtime, so look this up for each request
		if (numberConnections >= maxNumberConnectionsAllowed) {
			builder = Response.status(Status.SERVICE_UNAVAILABLE).entity("MaxConcurrentConnections reached: " + maxNumberConnectionsAllowed);
		} else {
			/* initialize response */
			builder = Response.status(Status.OK);
			builder.header(HttpHeaders.CONTENT_TYPE, "text/event-stream;charset=UTF-8");
			builder.header(HttpHeaders.CACHE_CONTROL, "no-cache, no-store, max-age=0, must-revalidate");
			builder.header("Pragma", "no-cache");
			getCurrentConnections().incrementAndGet();
			builder.entity(new HystrixStream(sampleStream, pausePollerThreadDelayInMs, getCurrentConnections()));
		}
		return builder.build();

	}

#No. 2785
#File: E:\bishe\1\AbstractIdentityAssertionBase.java
#Comment:
  /**
   * Retrieve the principal to represent the asserted identity from
   * the provided Subject.
   * @param subject
   * @return principalName
   */

#Code:
  protected String getPrincipalName(Subject subject) {
    return SubjectUtils.getPrimaryPrincipalName(subject);
  }

#No. 2786
#File: E:\bishe\1\AbstractIdentityAssertionFilter.java
#Comment:
  /**
   * 
   */

#Code:
  public AbstractIdentityAssertionFilter() {
    super();
  }

#No. 2787
#File: E:\bishe\1\AbstractIdentityTest.java
#Comment:
    /**
     * The output files generated by this class are text files,
     * independent of the kind of module being tested.
     *
     * @return The String "txt".
     */

#Code:
    protected String outputExtension()
    {
        return "txt";
    }

#No. 2788
#File: E:\bishe\1\AbstractIdentityTest.java
#Comment:
    /**
     * Set to true if the identity transformation should actually be asserted,
     * by default only the expected and actual results are written to a file, but not compared.
     * This should be called during setUp().
     *
     * @param doAssert True to actually execute the test.
     */

#Code:
    protected void assertIdentity( boolean doAssert )
    {
        this.assertIdentity = doAssert;
    }

#No. 2789
#File: E:\bishe\1\AbstractIdentityTest.java
#Comment:
    /**
     * @return the expected identity string
     */

#Code:
    protected String getExpected()
    {
        return expected;
    }

#No. 2790
#File: E:\bishe\1\AbstractIdleService.java
#Comment:
  /**
   * Returns the {@link Executor} that will be used to run this service.
   * Subclasses may override this method to use a custom {@link Executor}, which
   * may configure its worker thread with a specific name, thread group or
   * priority. The returned executor's {@link Executor#execute(Runnable)
   * execute()} method is called when this service is started and stopped,
   * and should return promptly.
   */

#Code:
  protected Executor executor() {
    return new Executor() {
      @Override public void execute(Runnable command) {
        MoreExecutors.newThread(threadNameSupplier.get(), command).start();
      }
    };

#No. 2791
#File: E:\bishe\1\AbstractImage.java
#Comment:
    /**
     * Load the texture for the square
     */

#Code:
    protected int loadGLTexture(Bitmap bitmap) {

        if(bitmap == null || mGL == null){
            return 0;
        }

        removeTexture();

        // generate one texture pointer
        mGL.glGenTextures(1, textures, 0);
        // ...and bind it to our array
        mGL.glBindTexture(GL10.GL_TEXTURE_2D, textures[0]);

        // create nearest filtered texture
        mGL.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_MIN_FILTER, GL10.GL_LINEAR);
        mGL.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_MAG_FILTER, GL10.GL_NEAREST);

        //Different possible texture parameters, e.g. GL10.GL_CLAMP_TO_EDGE
        mGL.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_WRAP_S, GL10.GL_REPEAT);
        mGL.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_WRAP_T, GL10.GL_REPEAT);

        // Use Android GLUtils to specify a two-dimensional texture image from our bitmap
        GLUtils.texImage2D(GL10.GL_TEXTURE_2D, 0, bitmap, 0);

        // Clean up
        bitmap.recycle();
        if(loadedBitmap !=null){
            loadedBitmap = null;
        }

        initBuffers();

        return textures[0];
    }

#No. 2792
#File: E:\bishe\1\AbstractImageDeletionMessage.java
#Comment:
    /**
     * List of images which were removed with this action.
     *
     * @return Array of URLs of removed images as string
     */

#Code:
    public String[] getRemovedImageUrls() {
        return removedImageUrls;
    }

#No. 2793
#File: E:\bishe\1\AbstractImageSupport.java
#Comment:
    /**
     * Executes an actual image capture of a virtual machine. The default implementation throws an {@link OperationNotSupportedException}
     * indicating this is not supported.
     * @param options the options used for creating the virtual machine
     * @param task the task for tracking image creation (or null if not interested/not asynchronous)
     * @return a newly created image
     * @throws CloudException an error occurred with the cloud provider while capturing the virtual machine as an image
     * @throws InternalException an error occurred locally while attempting to capture the virtual machine as an image
     */

#Code:
    protected MachineImage capture(@Nonnull ImageCreateOptions options, @Nullable AsynchronousTask<MachineImage> task) throws CloudException, InternalException {
        throw new OperationNotSupportedException("Image capture is not currently implemented in " + getProvider().getCloudName());
    }

    @Override
    public final @Nonnull MachineImage captureImage(@Nonnull ImageCreateOptions options) throws CloudException, InternalException {
        boolean supported = false;

        for( MachineImageType type : MachineImageType.values() ) {
            if( getCapabilities().supportsImageCapture(type) ) {
                supported = true;
            }
        }

#No. 2794
#File: E:\bishe\1\AbstractImageSupport.java
#Comment:
    /**
     * Compares a machine image to the specified set of criteria to see if there is a match.
     * @param image the image to be checked
     * @param keyword a keyword on which to compare against name, description, or meta-data (or <code>null</code> if not part of the search criteria)
     * @param platform the platform to match against or <code>null</code> if any platform is acceptable
     * @param architecture the architecture to match against or <code>null</code> if any architecture is acceptable
     * @param classes the image classes to filter against or <code>null</code> if any image class is acceptable
     * @return true if the image matches the specified criteria
     */

#Code:
    protected boolean matches(@Nonnull MachineImage image, @Nullable String keyword, @Nullable Platform platform, @Nullable Architecture architecture, @Nullable ImageClass ... classes) {
        if( architecture != null && !architecture.equals(image.getArchitecture()) ) {
            return false;
        }

#No. 2795
#File: E:\bishe\1\AbstractImporterComponent.java
#Comment:
    /**
     * Stop the Importer component, iPOJO Invalidate instance callback.
     * Must be override !
     */

#Code:
    protected void stop() {
        declarationBindManager.unbindAll();
    }

#No. 2796
#File: E:\bishe\1\AbstractImporterComponent.java
#Comment:
    /**
     * Start the endpoint-creator component, iPOJO Validate instance callback.
     * Must be override !
     */

#Code:
    protected void start() {
        //
    }

#No. 2797
#File: E:\bishe\1\AbstractImporterComponent.java
#Comment:
    /**
     * @param importDeclaration The {@link ImportDeclaration} of the service to be imported.
     * @throws org.ow2.chameleon.fuchsia.core.exceptions.BinderException
     */

#Code:
    public void addDeclaration(final ImportDeclaration importDeclaration) throws BinderException {
        declarationBindManager.addDeclaration(importDeclaration);
    }

#No. 2798
#File: E:\bishe\1\AbstractImporterComponent.java
#Comment:
    /**
     * @param importDeclaration The {@link ImportDeclaration} of the service to stop to be imported.
     * @throws org.ow2.chameleon.fuchsia.core.exceptions.BinderException
     */

#Code:
    public void removeDeclaration(final ImportDeclaration importDeclaration) throws BinderException {
        declarationBindManager.removeDeclaration(importDeclaration);
    }

#No. 2799
#File: E:\bishe\1\AbstractImportTask.java
#Comment:
	/**
	 * Creates new folder and starts appending puzzles to this folder.
	 *
	 * @param name
	 */

#Code:
	protected void importFolder(String name) {
		importFolder(name, System.currentTimeMillis());
	}

#No. 2800
#File: E:\bishe\1\AbstractImportTask.java
#Comment:
	/**
	 * Creates new folder and starts appending puzzles to this folder.
	 *
	 * @param name
	 * @param created
	 */

#Code:
	protected void importFolder(String name, long created) {
		if (mDatabase == null) {
			throw new IllegalStateException("Database is not opened.");
		}

		mFolderCount++;

		mFolder = mDatabase.insertFolder(name, created);
	}

#No. 2801
#File: E:\bishe\1\AbstractImportTask.java
#Comment:
	/**
	 * Starts appending puzzles to the folder with given <code>name</code>. If such folder does
	 * not exist, this method creates new one.
	 *
	 * @param name
	 */

#Code:
	protected void appendToFolder(String name) {
		if (mDatabase == null) {
			throw new IllegalStateException("Database is not opened.");
		}

		mFolderCount++;

		mFolder = null;
		mFolder = mDatabase.findFolder(name);
		if (mFolder == null) {
			mFolder = mDatabase.insertFolder(name, System.currentTimeMillis());
		}
	}

#No. 2802
#File: E:\bishe\1\AbstractImportTask.java
#Comment:
	/**
	 * Imports game. Game will be stored in folder, which was set by
	 * {@link #importFolder(String, boolean)} or {@link #appendToFolder(String)}.
	 *
	 * @param game
	 * @throws SudokuInvalidFormatException
	 */

#Code:
	protected void importGame(String data) throws SudokuInvalidFormatException {
		mImportParams.clear();
		mImportParams.data = data;
		importGame(mImportParams);
	}

#No. 2803
#File: E:\bishe\1\AbstractImportTask.java
#Comment:
	/**
	 * Imports game with all its fields.
	 *
	 * @param game Fields to import (state of game, created, etc.)
	 * @param data Data to import.
	 */

#Code:
	protected void importGame(SudokuImportParams pars) throws SudokuInvalidFormatException {
		if (mDatabase == null) {
			throw new IllegalStateException("Database is not opened.");
		}

		mDatabase.importSudoku(mFolder.id, pars);
	}

#No. 2804
#File: E:\bishe\1\AbstractImportTask.java
#Comment:
		/**
		 * Occurs when import is finished.
		 *
		 * @param importSuccessful Indicates whether import was successful.
		 * @param folderId         Contains id of imported folder, or -1 if multiple folders were imported.
		 */

#Code:
		void onImportFinished(boolean importSuccessful, long folderId);
	}

}
}

#No. 2805
#File: E:\bishe\1\AbstractInclude.java
#Comment:
        /**
         *  Put method also stores values in local scope
         *
         *  @param key name of item to set
         *  @param value object to set to key
         *  @return old stored object
         */

#Code:
        public Object put(String key, Object value)
        {
            if (localContext != null)
            {
                return localContext.put(key, value);
            }
            return super.put(key, value);
        }

#No. 2806
#File: E:\bishe\1\AbstractInclude.java
#Comment:
        /**
         *  Retrieves from local or global context.
         *
         *  @param key name of item to get
         *  @return  stored object or null
         */

#Code:
        public Object get( String key )
        {
        /*
         *  always try the local context then innerContext
         */
            Object o = null;
            if (localContext != null)
            {
                o = localContext.get(key);
            }
            if (o == null)
            {
                o = super.get( key );
            }
            return o;
        }

#No. 2807
#File: E:\bishe\1\AbstractInclude.java
#Comment:
        /**
         * @see org.apache.velocity.context.Context#containsKey(java.lang.Object)
         */

#Code:
        public boolean containsKey(Object key)
        {
            return (localContext != null && localContext.containsKey(key)) ||
                    super.containsKey(key);
        }

#No. 2808
#File: E:\bishe\1\AbstractInclude.java
#Comment:
        /**
         * @see org.apache.velocity.context.Context#getKeys()
         */

#Code:
        @SuppressWarnings("unchecked")
        public Object[] getKeys()
        {
            if (localContext != null)
            {
                Set keys = new HashSet();
                Object[] localKeys = localContext.getKeys();
                for (int i=0; i < localKeys.length; i++)
                {
                    keys.add(localKeys[i]);
                }

                Object[] innerKeys = super.getKeys();
                for (int i=0; i < innerKeys.length; i++)
                {
                    keys.add(innerKeys[i]);
                }
                return keys.toArray();
            }
            return super.getKeys();
        }

#No. 2809
#File: E:\bishe\1\AbstractInclude.java
#Comment:
        /**
         * @see org.apache.velocity.context.Context#remove(java.lang.Object)
         */

#Code:
        public Object remove(Object key)
        {
            if (localContext != null)
            {
                return localContext.remove(key);
            }
            return super.remove(key);
        }

#No. 2810
#File: E:\bishe\1\AbstractInclude.java
#Comment:
        /**
         * Allows callers to explicitly put objects in the local context.
         * Objects added to the context through this method always end up
         * in the top-level context of possible wrapped contexts.
         *
         *  @param key name of item to set.
         *  @param value object to set to key.
         *  @return old stored object
         */

#Code:
        public Object localPut(final String key, final Object value)
        {
            if (localContext != null)
            {
                return localContext.put(key, value);
            }
            return super.localPut(key, value);
        }

#No. 2811
#File: E:\bishe\1\AbstractInclude.java
#Comment:
            /*
             * The new string needs to be parsed since the text has been dynamically generated.
             */

#Code:
            String templateName = ctx.getCurrentTemplateName();

            try {
                SimpleNode nodeTree = rsvc.parse(new StringReader(value), templateName, false);
                nodeTree.init(ctx, rsvc);

                // 如果只有一个节点，且是 reference, 则尝试去获取这个变量的值。
                if (nodeTree.jjtGetNumChildren() == 1 && nodeTree.jjtGetChild(0).getType() == ParserTreeConstants.JJTREFERENCE) {
                    Node right = nodeTree.jjtGetChild(0);
                    ret = right.value(ctx);
                } else {
                    StringWriter buff = new StringWriter();

                    try {
                        nodeTree.render(ctx, buff);
                    } catch (Exception err) {
                        System.out.println(err.getMessage());
                    }

                    ret = buff.toString();
                }
            } catch (Exception err) {
                System.out.println(err.getMessage());
            }

#No. 2812
#File: E:\bishe\1\AbstractInContainerTestCase.java
#Comment:
    /**
     * Returns the user created for this test run.
     *
     * @return the user
     */

#Code:
    public User getTestUser() {
        return testUser;
    }

#No. 2813
#File: E:\bishe\1\AbstractInContainerTestCase.java
#Comment:
    /**
     * Returns the base url for private endpoints.
     *
     * @return the private endpoint base url
     */

#Code:
    public String getPrivateUrlBase() {
        String hostname = serverProperties.getString("server.host");
        String port = serverProperties.getString("server.port.private");
        return "http://" + hostname + ":" + port;
    }

#No. 2814
#File: E:\bishe\1\AbstractInContainerTestCase.java
#Comment:
    /**
     * Returns the base url for public endpoints.
     *
     * @return the public endpoint base url
     */

#Code:
    public String getPublicUrlBase() {
        String hostname = serverProperties.getString("server.host");
        String port = serverProperties.getString("server.port.public");
        return "http://" + hostname + ":" + port;
    }

#No. 2815
#File: E:\bishe\1\AbstractInContainerTestCase.java
#Comment:
    /**
     * Returns the base url for public API endpoints.
     *
     * @return the public api endpoint base url
     */

#Code:
    public String getPublicApiUrlBase() {
        return getPublicUrlBase() + "/api";
    }

#No. 2816
#File: E:\bishe\1\AbstractInContainerTestCase.java
#Comment:
    /**
     * Logs in the given user and returns the user's authentication token.
     *
     * @param username the username to login as
     * @param password the password for the username
     * @return the user's authentication token
     * @throws Exception if something goes wrong
     */

#Code:
    public String login(String username, String password) throws Exception {
        HttpClient httpClient = new DefaultHttpClient();

        // Set the User-Agent to be safe
        httpClient.getParams().setParameter(HttpProtocolParams.USER_AGENT, Constants.NODEABLE_HTTP_USER_AGENT);

        HttpPost post = new HttpPost(getPublicUrlBase() + "/authentication/login");
//        HttpState state = httpClient.getState();
        String authnToken;

        try {
            // Login is done via Basic Authentication at this time

//            state.setCredentials(new AuthScope(null, AuthScope.ANY_PORT, null, AuthScope.ANY_SCHEME),
//                    new UsernamePasswordCredentials(username, password));

            HttpResponse httpReponse = httpClient.execute(post);

            Header authHeader = httpReponse.getFirstHeader(Constants.NODEABLE_AUTH_TOKEN);

            if (authHeader != null) {
                authnToken = httpReponse.getFirstHeader(Constants.NODEABLE_AUTH_TOKEN).getValue();
            } else {
                String response = IOUtils.toString(httpReponse.getEntity().getContent());

                try {
                    ErrorMessage em = jsonToObject(response,
                            TypeFactory.defaultInstance().constructType(ErrorMessage.class));
                    throw new Exception(em.getErrorMessage());
                } catch (Exception e) {
                    throw new Exception("Unable to login: " + response);
                }
            }
        } finally {
            post.releaseConnection();
        }

        return authnToken;
    }

#No. 2817
#File: E:\bishe\1\AbstractInContainerTestCase.java
#Comment:
    /**
     * Logs a user out.
     *
     * @param authnToken the user's authentication url
     * @throws Exception if something goes wrong
     */

#Code:
    public void logout(String authnToken) throws Exception {
        makeRequest(getPublicUrlBase() + "/api/user/logout", "GET", null, authnToken);
    }

#No. 2818
#File: E:\bishe\1\AbstractInContainerTestCase.java
#Comment:
    /**
     * Returns an object from the passed in JSON string based on the JavaType passed in.
     *
     * @param <T>  Variable type based on the JavaType passed in
     * @param json the JSON string to parse
     * @param type the type to return
     * @return the parsed object
     * @throws Exception if something goes wrong
     */

#Code:

    @SuppressWarnings("unchecked")
    public <T> T jsonToObject(String json, JavaType type) throws Exception {
        ObjectMapper om = new ObjectMapper();

        try {
            return (T) om.readValue(json, type);
        } catch (Exception e) {
            try {
                ErrorMessage em = om.readValue(json, ErrorMessage.class);

                throw new Exception(em.getErrorMessage());
            } catch (IOException e2) {
                throw new IOException(e.getMessage() + ": " + json);
            }
        }
    }

#No. 2819
#File: E:\bishe\1\AbstractInContainerTestCase.java
#Comment:
    /**
     * Creates a dummy AWS EC2 node used for testing inventory.
     *
     * @param cloud         the cloud to create the node in/with
     * @param securityGroup the security group to create the node in/with
     * @return the created node
     * @throws Exception if something goes wrong
     */

#Code:
    public NodeMetadata createDummyAWSEC2Node(ConnectionResponseDTO cloud, String securityGroup) throws Exception {
        ComputeService computeService = getComputeService(cloud);

        // Create a node
        Statement bootInstructions = AdminAccess.standard();
        NodeMetadata newNode = getOnlyElement(computeService.createNodesInGroup(securityGroup, 1,
                runScript(bootInstructions)));

        return newNode;
    }

#No. 2820
#File: E:\bishe\1\AbstractIndexCursor.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public void after( IndexEntry<V, String> element ) throws LdapException, CursorException
    {
        throw new UnsupportedOperationException( getUnsupportedMessage() );
    }

#No. 2821
#File: E:\bishe\1\AbstractIndexCursor.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public void before( IndexEntry<V, String> element ) throws LdapException, CursorException
    {
        throw new UnsupportedOperationException( getUnsupportedMessage() );
    }

#No. 2822
#File: E:\bishe\1\AbstractIndexCursor.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    protected boolean setAvailable( boolean available )
    {
        this.available = available;
        return available;
    }

#No. 2823
#File: E:\bishe\1\AbstractIndexedListIterator.java
#Comment:
  /**
   * Constructs an iterator across a sequence of the given size whose initial
   * position is 0. That is, the first call to {@link #next()} will return the
   * first element (or throw {@link NoSuchElementException} if {@code size} is
   * zero).
   *
   * @throws IllegalArgumentException if {@code size} is negative
   */

#Code:
  protected AbstractIndexedListIterator(int size) {
    this(size, 0);
  }

#No. 2824
#File: E:\bishe\1\AbstractIndexedListIterator.java
#Comment:
  /**
   * Constructs an iterator across a sequence of the given size with the given
   * initial position. That is, the first call to {@link #nextIndex()} will
   * return {@code position}, and the first call to {@link #next()} will return
   * the element at that index, if available. Calls to {@link #previous()} can
   * retrieve the preceding {@code position} elements.
   *
   * @throws IndexOutOfBoundsException if {@code position} is negative or is
   *         greater than {@code size}
   * @throws IllegalArgumentException if {@code size} is negative
   */

#Code:
  protected AbstractIndexedListIterator(int size, int position) {
    checkPositionIndex(position, size);
    this.size = size;
    this.position = position;
  }

#No. 2825
#File: E:\bishe\1\AbstractIndexField.java
#Comment:
  /**
   * Prints information about this field
   */

#Code:
  @Override
  public String toString() {
    return String.format("AbstractIndexField(targetFieldName:%s, targetFieldIndex:%d, serializer: %s)", 
        new Object[]{targetField.getName(), targetField.getIndex(), getSerializationStrategy().getClass().getName()});
  }

#No. 2826
#File: E:\bishe\1\AbstractIndexOperation.java
#Comment:
  /**
   * Remove all values from the index that were for the given statemanager
   * 
   * @param stateManager
   * @param queue
   */

#Code:
  public void removeIndexes(OpenJPAStateManager stateManager, IndexQueue queue,
      long clock) {

    ByteBuffer key = keyStrategy.toByteBuffer(stateManager.fetchObjectId());

    DynamicComposite composite = newComposite();

    composite.addComponent(key, buffSerializer);
    
    // queue the index values to be deleted
    queueDeletes(composite, queue, clock);

  }

#No. 2827
#File: E:\bishe\1\AbstractIndexOperation.java
#Comment:
  /**
   * @return the indexDefinition
   */

#Code:
  public IndexDefinition getIndexDefinition() {
    return indexDefinition;
  }

#No. 2828
#File: E:\bishe\1\AbstractIndexOperation.java
#Comment:
  /**
   * Create an index key in the values of version+className+indexName
   * @param className
   * @param indexName
   * @return
   */

#Code:
  protected ByteBuffer createIndexKey(String className, String indexName){
    
    String indexVersion = String.format("%d_", INDEXING_VERSION);
    
    ByteBuffer indexKey = ByteBuffer.allocate(indexVersion.length()+className.length()+indexName.length());
    indexKey.put(StringSerializer.get().toByteBuffer(indexVersion));
    indexKey.put(StringSerializer.get().toByteBuffer(className));
    indexKey.put(StringSerializer.get().toByteBuffer(indexName));
    indexKey.rewind();
    return indexKey;
  }

#No. 2829
#File: E:\bishe\1\AbstractInformationControl.java
#Comment:
	/**
	 * Sets the information to be presented by this information control.
	 * <p>
	 * The default implementation does nothing. Subclasses must either override this method
	 * or implement {@link IInformationControlExtension2}.
	 *
	 * @param information the information to be presented
	 *
	 * @see org.eclipse.jface.text.IInformationControl#setInformation(java.lang.String)
	 */

#Code:
	public void setInformation(String information) {

	}

#No. 2830
#File: E:\bishe\1\AbstractInformationControl.java
#Comment:
	/**
	 * Returns whether the information control is resizable.
	 *
	 * @return <code>true</code> if the information control is resizable,
	 *         <code>false</code> if it is not resizable.
	 */

#Code:
	public boolean isResizable() {
		return fResizable;
	}

#No. 2831
#File: E:\bishe\1\AbstractInformationControl.java
#Comment:
	/*
	 * @see IInformationControl#setVisible(boolean)
	 */

#Code:
	public void setVisible(boolean visible) {
		if (fShell.isVisible() == visible)
			return;

		fShell.setVisible(visible);
	}

#No. 2832
#File: E:\bishe\1\AbstractInformationControl.java
#Comment:
	/*
	 * @see IInformationControl#dispose()
	 */

#Code:
	public void dispose() {
		if (fShell != null && !fShell.isDisposed())
			fShell.dispose();
	}

#No. 2833
#File: E:\bishe\1\AbstractInformationControl.java
#Comment:
	/**
	 * Frees all resources allocated by this information control. Internally called when the
	 * information control's shell has been disposed.
	 * 
	 * @since 3.6
	 */

#Code:
	protected void handleDispose() {
		if (fStatusLabelFont != null) {
			fStatusLabelFont.dispose();
			fStatusLabelFont= null;
		}
		if (fStatusLabelForeground != null) {
			fStatusLabelForeground.dispose();
			fStatusLabelForeground= null;
		}
	}

#No. 2834
#File: E:\bishe\1\AbstractInformationControl.java
#Comment:
	/*
	 * @see IInformationControl#setSize(int, int)
	 */

#Code:
	public void setSize(int width, int height) {
		fShell.setSize(width, height);
	}

#No. 2835
#File: E:\bishe\1\AbstractInformationControl.java
#Comment:
	/*
	 * @see IInformationControl#setLocation(Point)
	 */

#Code:
	public void setLocation(Point location) {
		fShell.setLocation(location);
	}

#No. 2836
#File: E:\bishe\1\AbstractInformationControl.java
#Comment:
	/*
	 * @see IInformationControl#setSizeConstraints(int, int)
	 */

#Code:
	public void setSizeConstraints(int maxWidth, int maxHeight) {
		fSizeConstraints= new Point(maxWidth, maxHeight);
	}

#No. 2837
#File: E:\bishe\1\AbstractInformationControl.java
#Comment:
	/**
	 * Returns the size constraints.
	 *
	 * @return the size constraints or <code>null</code> if not set
	 * @see #setSizeConstraints(int, int)
	 */

#Code:
	protected final Point getSizeConstraints() {
		return fSizeConstraints != null ? Geometry.copy(fSizeConstraints) : null;
	}

#No. 2838
#File: E:\bishe\1\AbstractInformationControl.java
#Comment:
	/*
	 * @see IInformationControl#computeSizeHint()
	 */

#Code:
	public Point computeSizeHint() {
		// XXX: Verify whether this is a good default implementation. If yes, document it.
		Point constrains= getSizeConstraints();
		if (constrains == null)
			return fShell.computeSize(SWT.DEFAULT, SWT.DEFAULT, true);

		return fShell.computeSize(constrains.x, constrains.y, true);
	}

#No. 2839
#File: E:\bishe\1\AbstractInformationControl.java
#Comment:
	/**
	 * Computes the trim (status text and tool bar are considered as trim).
	 * Subclasses can extend this method to add additional trim (e.g. scroll
	 * bars for resizable information controls).
	 *
	 * @see org.eclipse.jface.text.IInformationControlExtension3#computeTrim()
	 */

#Code:
	public Rectangle computeTrim() {
		Rectangle trim= fShell.computeTrim(0, 0, 0, 0);

		if (fStatusComposite != null)
			trim.height+= fStatusComposite.computeSize(SWT.DEFAULT, SWT.DEFAULT).y;

		return trim;
	}

#No. 2840
#File: E:\bishe\1\AbstractInformationControl.java
#Comment:
	/*
	 * @see org.eclipse.jface.text.IInformationControlExtension3#getBounds()
	 */

#Code:
	public Rectangle getBounds() {
		return fShell.getBounds();
	}

#No. 2841
#File: E:\bishe\1\AbstractInformationControl.java
#Comment:
	/**
	 * {@inheritDoc}
	 * <p>
	 * The default implementation always returns <code>false</code>.
	 * </p>
	 * @see org.eclipse.jface.text.IInformationControlExtension3#restoresLocation()
	 */

#Code:
	public boolean restoresLocation() {
		return false;
	}

#No. 2842
#File: E:\bishe\1\AbstractInformationControl.java
#Comment:
	/**
	 * {@inheritDoc}
	 * <p>
	 * The default implementation always returns <code>false</code>.
	 * </p>
	 * @see org.eclipse.jface.text.IInformationControlExtension3#restoresSize()
	 */

#Code:
	public boolean restoresSize() {
		return false;
	}

#No. 2843
#File: E:\bishe\1\AbstractInformationControl.java
#Comment:
	/*
	 * @see IInformationControl#addDisposeListener(DisposeListener)
	 */

#Code:
	public void addDisposeListener(DisposeListener listener) {
		fShell.addDisposeListener(listener);
	}

#No. 2844
#File: E:\bishe\1\AbstractInformationControl.java
#Comment:
	/*
	 * @see IInformationControl#removeDisposeListener(DisposeListener)
	 */

#Code:
	public void removeDisposeListener(DisposeListener listener) {
		fShell.removeDisposeListener(listener);
	}

#No. 2845
#File: E:\bishe\1\AbstractInformationControl.java
#Comment:
	/*
	 * @see IInformationControl#setForegroundColor(Color)
	 */

#Code:
	public void setForegroundColor(Color foreground) {
		fContentComposite.setForeground(foreground);
	}

#No. 2846
#File: E:\bishe\1\AbstractInformationControl.java
#Comment:
	/*
	 * @see IInformationControl#setBackgroundColor(Color)
	 */

#Code:
	public void setBackgroundColor(Color background) {
		fContentComposite.setBackground(background);
	}

#No. 2847
#File: E:\bishe\1\AbstractInformationControl.java
#Comment:
	/**
	 * {@inheritDoc}
	 * This method is not intended to be overridden by subclasses.
	 */

#Code:
	public boolean isFocusControl() {
		return fShell.getDisplay().getActiveShell() == fShell;
	}

#No. 2848
#File: E:\bishe\1\AbstractInformationControl.java
#Comment:
	/**
	 * This default implementation sets the focus on the popup shell.
	 * Subclasses can override or extend.
	 *
	 * @see IInformationControl#setFocus()
	 */

#Code:
	public void setFocus() {
		boolean focusTaken= fShell.setFocus();
		if (!focusTaken)
			fShell.forceFocus();
	}

#No. 2849
#File: E:\bishe\1\AbstractInformationControl.java
#Comment:
	/**
	 * {@inheritDoc}
	 * This method is not intended to be overridden by subclasses.
	 */

#Code:
	public void addFocusListener(final FocusListener listener) {
		if (fFocusListeners.isEmpty()) {
			fShellListener= new Listener() {

				public void handleEvent(Event event) {
					Object[] listeners= fFocusListeners.getListeners();
					for (int i= 0; i < listeners.length; i++) {
						FocusListener focusListener= (FocusListener)listeners[i];
						if (event.type == SWT.Activate) {
							focusListener.focusGained(new FocusEvent(event));
						} else {
							focusListener.focusLost(new FocusEvent(event));
						}
					}
				}
			};
			fShell.addListener(SWT.Deactivate, fShellListener);
			fShell.addListener(SWT.Activate, fShellListener);
		}
		fFocusListeners.add(listener);
	}

#No. 2850
#File: E:\bishe\1\AbstractInformationControl.java
#Comment:
	/**
	 * {@inheritDoc}
	 * This method is not intended to be overridden by subclasses.
	 */

#Code:
	public void removeFocusListener(FocusListener listener) {
		fFocusListeners.remove(listener);
		if (fFocusListeners.isEmpty()) {
			fShell.removeListener(SWT.Activate, fShellListener);
			fShell.removeListener(SWT.Deactivate, fShellListener);
			fShellListener= null;
		}
	}

#No. 2851
#File: E:\bishe\1\AbstractInformationControl.java
#Comment:
	/**
	 * Sets the text of the status field.
	 * <p>
	 * The default implementation currently only updates the status field when
	 * the popup shell is not visible. The status field can currently only be
	 * shown if the information control has been created with a non-null status
	 * field text.
	 * </p>
	 *
	 * @param statusFieldText the text to be used in the optional status field
	 *        or <code>null</code> if the status field should be hidden
	 *
	 * @see org.eclipse.jface.text.IInformationControlExtension4#setStatusText(java.lang.String)
	 */

#Code:
	public void setStatusText(String statusFieldText) {
		if (fStatusLabel != null && ! getShell().isVisible()) {
			if (statusFieldText == null	) {
				fStatusComposite.setVisible(false);
			} else {
				fStatusLabel.setText(statusFieldText);
				fStatusComposite.setVisible(true);
			}
		}
	}

#No. 2852
#File: E:\bishe\1\AbstractInformationControl.java
#Comment:
	/*
	 * @see org.eclipse.jface.text.IInformationControlExtension5#containsControl(org.eclipse.swt.widgets.Control)
	 */

#Code:
	public boolean containsControl(Control control) {
		do {
			if (control == fShell)
				return true;
			if (control instanceof Shell)
				return false;
			control= control.getParent();
		} while (control != null);
		return false;
	}

#No. 2853
#File: E:\bishe\1\AbstractInformationControl.java
#Comment:
	/*
	 * @see org.eclipse.jface.text.IInformationControlExtension5#isVisible()
	 */

#Code:
	public boolean isVisible() {
		return fShell != null && !fShell.isDisposed() && fShell.isVisible();
	}

#No. 2854
#File: E:\bishe\1\AbstractInformationControl.java
#Comment:
	/**
	 * {@inheritDoc}
	 * This default implementation returns <code>null</code>. Subclasses may override.
	 */

#Code:
	public IInformationControlCreator getInformationPresenterControlCreator() {
		return null;
	}

#No. 2855
#File: E:\bishe\1\AbstractInformationControl.java
#Comment:
	/**
	 * Computes the size constraints based on the
	 * {@link JFaceResources#getDialogFont() dialog font}. Subclasses can
	 * override or extend.
	 *
	 * @see org.eclipse.jface.text.IInformationControlExtension5#computeSizeConstraints(int, int)
	 */

#Code:
	public Point computeSizeConstraints(int widthInChars, int heightInChars) {
		GC gc= new GC(fContentComposite);
		gc.setFont(JFaceResources.getDialogFont());
		int width= gc.getFontMetrics().getAverageCharWidth();
		int height= gc.getFontMetrics().getHeight();
		gc.dispose();

		return new Point(widthInChars * width, heightInChars * height);
	}

#No. 2856
#File: E:\bishe\1\AbstractIngesterFormatter.java
#Comment:
  /**
   * @param text Text to unquote.
   * @return Extracted value from inside a quoted string.
   */

#Code:
  @SuppressWarnings("WeakerAccess")  // Has users.
  public static String unquote(String text) {
    if (text.startsWith("\"")) {
      text = DOUBLE_QUOTE_PATTERN.matcher(text.substring(1, text.length() - 1)).
          replaceAll(DOUBLE_QUOTE_REPLACEMENT);
    } else if (text.startsWith("'")) {
      text = SINGLE_QUOTE_PATTERN.matcher(text.substring(1, text.length() - 1)).
          replaceAll(SINGLE_QUOTE_REPLACEMENT);
    }
    return text;
  }

#No. 2857
#File: E:\bishe\1\AbstractInitLetter.java
#Comment:
  /**
   * Constructs a new initialization letter.
   * @param locale the application locale
   */

#Code:
  public AbstractInitLetter(Locale locale) {
    this.locale = locale;
  }

#No. 2858
#File: E:\bishe\1\AbstractInitLetter.java
#Comment:
  /**
   * Builds an initialization letter.
   * @param hostId the host ID
   * @param bankName the bank name
   * @param userId the user ID
   * @param username the user name
   * @param partnerId the partner ID
   * @param version the signature version
   * @param certTitle the certificate title
   * @param certificate the certificate content
   * @param hashTitle the hash title
   * @param hash the hash value
   * @throws IOException
   */

#Code:
  protected void build(String hostId,
                       String bankName,
                       String userId,
                       String username,
                       String partnerId,
                       String version,
                       String certTitle,
                       byte[] certificate,
                       String hashTitle,
                       byte[] hash)
    throws IOException
  {
    letter = new Letter(getTitle(),
	                hostId,
	                bankName,
	                userId,
	                username,
	                partnerId,
	                version);
    letter.build(certTitle, certificate, hashTitle, hash);
  }

#No. 2859
#File: E:\bishe\1\AbstractInitLetter.java
#Comment:
  /**
   * Returns the value of the property key.
   * @param key the property key
   * @param bundleName the bundle name
   * @param locale the bundle locale
   * @return the property value
   */

#Code:
  protected String getString(String key, String bundleName, Locale locale) {
    return Messages.getString(key, bundleName, locale);
  }

#No. 2860
#File: E:\bishe\1\AbstractInitLetter.java
#Comment:
  /**
   * Returns the certificate hash
   * @param certificate the certificate
   * @return the certificate hash
   * @throws GeneralSecurityException
   */

#Code:
  protected byte[] getHash(byte[] certificate) throws GeneralSecurityException {
    String			hash256;

    hash256 = new String(Hex.encodeHex(MessageDigest.getInstance("SHA-256").digest(certificate), false));
    return format(hash256).getBytes();
  }

#No. 2861
#File: E:\bishe\1\AbstractInitLetter.java
#Comment:
  /**
   * Formats a hash 256 input.
   * @param hash256 the hash input
   * @return the formatted hash
   */

#Code:
  private String format(String hash256) {
    StringBuffer	buffer;
    String		formatted;

    buffer = new StringBuffer();
    for (int i = 0; i < hash256.length(); i += 2) {
      buffer.append(hash256.charAt(i));
      buffer.append(hash256.charAt(i + 1));
      buffer.append(' ');
    }

    formatted = buffer.substring(0, 48) + LINE_SEPARATOR + buffer.substring(48) + LINE_SEPARATOR;
    return formatted;
  }

#No. 2862
#File: E:\bishe\1\AbstractInlineMenuBuilder.java
#Comment:
    /**
     * Build a menu from message base.
     * Adds &amp; Registers all buttons.
     * Applies user predicate.
     * Applies rows.
     *
     * @param base Message
     * @return built menu
     */

#Code:
    protected InlineMenu buildMenu(Message base) {
        InlineMenu menu = new InlineMenu(base);
        rows.forEach((row) -> row.buttons.forEach((button) -> button.assignMenu(menu)));
        menu.userPredicate = userPredicate;
        menu.rows = rows;
        return menu;
    }

#No. 2863
#File: E:\bishe\1\AbstractInlineMenuBuilder.java
#Comment:
    /**
     * Remove the last row.
     *
     * @return this
     */

#Code:
    public T removeLast() {
        if (rows.size() != 0)
            rows.remove(rows.size() - 1);

        return instance();
    }

#No. 2864
#File: E:\bishe\1\AbstractInlineMenuBuilder.java
#Comment:
    /**
     * Add a user filter to the menu.
     * Predicate is called before any buttons are called, if returned true
     * the button will be called, otherwise it won't
     *
     * @param predicate user filter
     * @return this
     */

#Code:
    public T userFilter(Predicate<User> predicate) {
        this.userPredicate = predicate;
        return instance();
    }

#No. 2865
#File: E:\bishe\1\AbstractInlineMenuBuilder.java
#Comment:
    /**
     * Allow a list of users to use this menu
     * @param users Allowed users
     * @return this
     */

#Code:
    public T allowedUsers(User... users) {
        List<User> usersList = Arrays.asList(users);
        this.userPredicate = (user) -> usersList.stream()
                .anyMatch((allowedUser) -> allowedUser.getId() == user.getId());
        return instance();
    }

#No. 2866
#File: E:\bishe\1\AbstractInlineMenuBuilder.java
#Comment:
    /**
     * Allow a single user to use this menu
     * @param allowedUser allowed user
     * @return this
     */

#Code:
    public T allowedUser(User allowedUser) {
        this.userPredicate = (user) -> user.getId() == allowedUser.getId();
        return instance();
    }

#No. 2867
#File: E:\bishe\1\AbstractInlineMenuBuilder.java
#Comment:
    /**
     * Allow a list of users to use this menu
     * @param userIds allows user ids
     * @return this
     */

#Code:
    public T allowedUsers(long... userIds) {
        this.userPredicate = (user) -> {
            for (long id : userIds) {
                if (id == user.getId()) {
                    return true;
                }
            }

            return false;
        };
        return instance();
    }

#No. 2868
#File: E:\bishe\1\AbstractInlineMenuBuilder.java
#Comment:
    /**
     * Allow a single user to use this menu
     * @param userId the id of said user
     * @return this
     */

#Code:
    public T allowedUser(long userId) {
        this.userPredicate = (user) -> user.getId() == userId;
        return instance();
    }

#No. 2869
#File: E:\bishe\1\AbstractInNode.java
#Comment:
    /**
     * Override the clone method.
     */

#Code:
    public Object clone() {
        AbstractInNode cloned = (AbstractInNode) super.clone();

        if (getRightChild() != null && getRightChild().isInnerQuery())
            cloned.setRightChild((InnerQueryNode) getRightChild().clone());
        else {
            // perform a deep clone
            // so the preapred nodes are cloned as well
            HashSet<LiteralNode> clonedSet = new HashSet<LiteralNode>();

            for (LiteralNode value : valuesList) {
                clonedSet.add((LiteralNode) value.clone());
            }
            cloned.setValuesList(clonedSet);
        }
        return cloned;
    }

#No. 2870
#File: E:\bishe\1\AbstractInplaceEditor.java
#Comment:
    /**
     * @param command
     * @see JComboBox#fireActionEvent()
     */

#Code:
    protected void fireActionPerformed(String command) {
        // Guaranteed to return a non-null array
        Object[] listeners = listenerList.getListenerList();

        ActionEvent e = new ActionEvent(this, ActionEvent.ACTION_PERFORMED, command,
                EventQueue.getMostRecentEventTime(), getModifiers());

        // Process the listeners last to first, notifying
        // those that are interested in this event
        for (int i = listeners.length - 2; i >= 0; i -= 2) {
            if (listeners[i] == ActionListener.class) {
                ((ActionListener) listeners[i + 1]).actionPerformed(e);
            }
        }
    }

#No. 2871
#File: E:\bishe\1\AbstractInputAdapter.java
#Comment:
  /**
   * Set the buffer that we will be writing to
   *
   * @param ch The buffer for valid records
   */

#Code:
  @Override
  public void setBatchOutboundValidBuffer(IConsumer ch) {
    this.consumer = ch;
  }

#No. 2872
#File: E:\bishe\1\AbstractInputAdapter.java
#Comment:
  /**
   * Get the buffer that we will be writing to
   *
   * @return The consumer buffer
   */

#Code:
  @Override
  public IConsumer getBatchOutboundValidBuffer() {
    return this.consumer;
  }

#No. 2873
#File: E:\bishe\1\AbstractInputAdapter.java
#Comment:
  /**
   * return the symbolic name
   *
   * @return The symbolic name for this class stack
   */

#Code:
  @Override
  public String getSymbolicName() {
    return symbolicName;
  }

#No. 2874
#File: E:\bishe\1\AbstractInputAdapter.java
#Comment:
  /**
   * set the symbolic name
   *
   * @param name The symbolic name for this class stack
   */

#Code:
  @Override
  public void setSymbolicName(String name) {
    symbolicName = name;
  }

#No. 2875
#File: E:\bishe\1\AbstractInputAdapter.java
#Comment:
  /**
   * Increment the streams processed counter
   */

#Code:
  public void incrementStreamCount() {
    streamsProcessed++;
  }

#No. 2876
#File: E:\bishe\1\AbstractInputAdapter.java
#Comment:
  /**
   * This is called when the synthetic Header record is encountered, and has the
   * meaning that the stream is starting. In this case we have to open a new
   * dump file each time a stream starts. *
   *
   * @param r The record we are working on
   * @return The processed record
   * @throws ProcessingException
   */

#Code:
  public abstract HeaderRecord procHeader(HeaderRecord r) throws ProcessingException;

  /**
   * This is called when the synthetic trailer record is encountered, and has
   * the meaning that the stream is now finished. In this example, all we do is
   * pass the control back to the transactional layer.
   *
   * @param r The record we are working on
   * @return The processed record
   * @throws ProcessingException
   */
  public abstract TrailerRecord procTrailer(TrailerRecord r) throws ProcessingException;

  // -----------------------------------------------------------------------------
  // ------------- Start of inherited IEventInterface functions ------------------
  // -----------------------------------------------------------------------------
  /**
   * registerClientManager registers this class as a client of the ECI listener
   * and publishes the commands that the plug in understands. The listener is
   * responsible for delivering only these commands to the plug in.
   *
   * @throws OpenRate.exception.InitializationException
   */
  @Override
  public void registerClientManager() throws InitializationException {
    // Set the client reference and the base services first
    ClientManager.getClientManager().registerClient(getPipeName(), getSymbolicName(), this);

    //Register services for this Client
    ClientManager.getClientManager().registerClientService(getSymbolicName(), SERVICE_BATCHSIZE, ClientManager.PARAM_MANDATORY);
    ClientManager.getClientManager().registerClientService(getSymbolicName(), SERVICE_BUFFERSIZE, ClientManager.PARAM_MANDATORY);
    ClientManager.getClientManager().registerClientService(getSymbolicName(), SERVICE_STATS, ClientManager.PARAM_NONE);
    ClientManager.getClientManager().registerClientService(getSymbolicName(), SERVICE_STATSRESET, ClientManager.PARAM_DYNAMIC);
  }

#No. 2877
#File: E:\bishe\1\AbstractInputAdapter.java
#Comment:
  /**
   * Temporary function to gather the information from the properties file. Will
   * be removed with the introduction of the new configuration model.
   */

#Code:
  private String initGetBatchSize()
          throws InitializationException {
    String tmpValue;
    tmpValue = PropertyUtils.getPropertyUtils().getBatchInputAdapterPropertyValueDef(getPipeName(), getSymbolicName(),
            SERVICE_BATCHSIZE, DEFAULT_BATCHSIZE);

    return tmpValue;
  }

#No. 2878
#File: E:\bishe\1\AbstractInputAdapter.java
#Comment:
  /**
   * Temporary function to gather the information from the properties file. Will
   * be removed with the introduction of the new configuration model.
   */

#Code:
  private String initGetBufferSize()
          throws InitializationException {
    String tmpValue;
    tmpValue = PropertyUtils.getPropertyUtils().getBatchInputAdapterPropertyValueDef(getPipeName(), getSymbolicName(),
            SERVICE_BUFFERSIZE, DEFAULT_BUFFERSIZE);

    return tmpValue;
  }

#No. 2879
#File: E:\bishe\1\AbstractInputAdapter.java
#Comment:
  /**
   * @return the pipeName
   */

#Code:
  public String getPipeName() {
    return pipeline.getSymbolicName();
  }

#No. 2880
#File: E:\bishe\1\AbstractInputAdapter.java
#Comment:
  /**
   * @return the pipeline
   */

#Code:
  @Override
  public IPipeline getPipeline() {
    return pipeline;
  }

#No. 2881
#File: E:\bishe\1\AbstractInputAdapter.java
#Comment:
  /**
   * Set the pipeline reference so the input adapter can control the scheduler
   *
   * @param pipeline the Pipeline to set
   */

#Code:
  @Override
  public void setPipeline(IPipeline pipeline) {
    this.pipeline = pipeline;
  }

#No. 2882
#File: E:\bishe\1\AbstractInputAdapter.java
#Comment:
  /**
   * Return the pipeline logger.
   *
   * @return The logger
   */

#Code:
  protected ILogger getPipeLog() {
    return pipeline.getPipeLog();
  }

#No. 2883
#File: E:\bishe\1\AbstractInputAdapter.java
#Comment:
  /**
   * Return the exception handler.
   *
   * @return The exception handler
   */

#Code:
  protected ExceptionHandler getExceptionHandler() {
    return pipeline.getPipelineExceptionHandler();
  }

#No. 2884
#File: E:\bishe\1\AbstractInputCheckedMapDecorator.java
#Comment:
    /**
     * Hook method called to determine if <code>checkSetValue</code> has any effect.
     * <p/>
     * An implementation should return false if the <code>checkSetValue</code> method
     * has no effect as this optimises the implementation.
     * <p/>
     * This implementation returns <code>true</code>.
     */

#Code:
    protected boolean isSetValueChecking() {
        return true;
    }

#No. 2885
#File: E:\bishe\1\AbstractInputFieldsPanel.java
#Comment:
	/**
	 * Sets the model
	 * @param model
	 */

#Code:
	protected void setModel(OurGridUIModel model) {
		this.model = model;
	}

#No. 2886
#File: E:\bishe\1\AbstractInputWidget.java
#Comment:
/**
 * Base class for input widgets.
 * 
 * @author Curtis Rueden
 * @param <T> The input type of the widget.
 * @param <W> The type of UI component housing the widget.
 */

#Code:
public abstract class AbstractInputWidget<T, W> extends
	AbstractWrapperPlugin<WidgetModel> implements InputWidget<T, W>
{

	private WidgetModel widgetModel;

	// -- InputWidget methods --

	@Override
	public void updateModel() {
		widgetModel.setValue(getValue());
	}

	// -- WrapperPlugin methods --

	@Override
	public void set(final WidgetModel model) {
		if (widgetModel != null) {
			throw new IllegalStateException("Widget already initialized");
		}
		widgetModel = model;
	}

	@Override
	public WidgetModel get() {
		return widgetModel;
	}
}

#No. 2887
#File: E:\bishe\1\AbstractInternalSource.java
#Comment:
    /**
     * Shortcuts from previous version are compatible with shortcuts from this version, so we just
     * return true. If shortcuts become incompatible during an upgrade, some examination of the
     * version code should be added here.
     */

#Code:
    @Override
    public boolean isVersionCodeCompatible(int version) {
        return true;
    }

#No. 2888
#File: E:\bishe\1\AbstractInterruptibleChannel.java
#Comment:
    /**
     * Marks the beginning of an I/O operation that might block indefinitely.
     *
     * <p> This method should be invoked in tandem with the {@link #end end}
     * method, using a <tt>try</tt>&nbsp;...&nbsp;<tt>finally</tt> block as
     * shown <a href="#be">above</a>, in order to implement asynchronous
     * closing and interruption for this channel.  </p>
     */

#Code:
    protected final void begin() {
        if (interruptor == null) {
            interruptor = new Interruptible() {
                    public void interrupt(Thread target) {
                        synchronized (closeLock) {
                            if (!open)
                                return;
                            open = false;
                            interrupted = target;
                            try {
                                AbstractInterruptibleChannel.this.implCloseChannel();
                            } catch (IOException x) { }
                        }
                    }};
        }
        blockedOn(interruptor);
        Thread me = Thread.currentThread();
        if (me.isInterrupted())
            interruptor.interrupt(me);
    }

#No. 2889
#File: E:\bishe\1\AbstractInterruptibleChannel.java
#Comment:
    /**
     * Marks the end of an I/O operation that might block indefinitely.
     *
     * <p> This method should be invoked in tandem with the {@link #begin
     * begin} method, using a <tt>try</tt>&nbsp;...&nbsp;<tt>finally</tt> block
     * as shown <a href="#be">above</a>, in order to implement asynchronous
     * closing and interruption for this channel.  </p>
     *
     * @param  completed
     *         <tt>true</tt> if, and only if, the I/O operation completed
     *         successfully, that is, had some effect that would be visible to
     *         the operation's invoker
     *
     * @throws  AsynchronousCloseException
     *          If the channel was asynchronously closed
     *
     * @throws  ClosedByInterruptException
     *          If the thread blocked in the I/O operation was interrupted
     */

#Code:
    protected final void end(boolean completed)
        throws AsynchronousCloseException
    {
        blockedOn(null);
        Thread interrupted = this.interrupted;
        if (interrupted != null && interrupted == Thread.currentThread()) {
            interrupted = null;
            throw new ClosedByInterruptException();
        }
        if (!completed && !open)
            throw new AsynchronousCloseException();
    }

#No. 2890
#File: E:\bishe\1\AbstractIntSet.java
#Comment:
 /** Returns a hash code for this set.
	 *
	 * The hash code of a set is computed by summing the hash codes of
	 * its elements.
	 *
	 * @return a hash code for this set.
	 */

#Code:
 public int hashCode() {
  int h = 0, n = size();
  IntIterator i = iterator();
  int k;
  while( n-- != 0 ) {
   k = i.nextInt(); // We need k because KEY2JAVAHASH() is a macro with repeated evaluation.
   h += (k);
  }
  return h;
 }

#No. 2891
#File: E:\bishe\1\AbstractIntSet.java
#Comment:
 /** Delegates to <code>remove()</code>.
	 *
	 * @param k the element to be removed.
	 * @return true if the set was modified.
	 */

#Code:
 public boolean rem( int k ) {
  return remove( k );
 }

#No. 2892
#File: E:\bishe\1\AbstractIntVector.java
#Comment:
	/**
	 * Default constructor is required in every RA object. 
	 */

#Code:
	public AbstractIntVector() {
		super();
	}

#No. 2893
#File: E:\bishe\1\AbstractIntVector.java
#Comment:
	/**
	 * Calculates the buffer size based on the given number of dimensions. 
	 * @param dimensions Number of dimensions
	 * @return the size in bytes of the buffer. 
	 */

#Code:
	public static int revealBufferSize(int dimensions){
		return ByteConstants.Short.getSize() + (ByteConstants.Int.getSize() * dimensions);
	}

#No. 2894
#File: E:\bishe\1\AbstractIntVector.java
#Comment:
	/**
	 * Clones the vector and returns a new copy of it.
	 */

#Code:
	protected int[] cloneHelper(){
		int[] newF = new int[this.vector.length];
		System.arraycopy(vector, 0, newF, 0, vector.length);
		return newF;
	}

#No. 2895
#File: E:\bishe\1\AbstractInventory.java
#Comment:
    /**
     * Peeks for the result {@link SlotTransaction}s and {@link InventoryTransactionResult}
     * that would occur if you try to set a item through {@link Inventory#set(ItemStack)}.
     *
     * @param itemStack The item stack to set
     * @return The peeked transaction results
     */

#Code:
    protected abstract PeekSetTransactionsResult peekSetTransactions(@Nullable ItemStack itemStack);

    @Override
    public boolean hasProperty(Class<? extends InventoryProperty<?, ?>> property) {
        checkNotNull(property, "property");
        final AbstractInventory parent = parent();
        //noinspection unchecked
        Optional<InventoryProperty<?, ?>> optProperty = tryGetProperty((Class) property, null);
        if (parent != this && !optProperty.isPresent()) {
            //noinspection unchecked
            optProperty = parent.tryGetProperty(
                    this, (Class) property, null);
        }
        return optProperty.isPresent();
    }

#No. 2896
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final int minimumCapacity() {
        return minimumCapacity;
    }

#No. 2897
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final IoBuffer minimumCapacity(int minimumCapacity) {
        if (minimumCapacity < 0) {
            throw new IllegalArgumentException("minimumCapacity: " + minimumCapacity);
        }
        this.minimumCapacity = minimumCapacity;
        return this;
    }

#No. 2898
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final int capacity() {
        return buf().capacity();
    }

#No. 2899
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final IoBuffer capacity(int newCapacity) {
        if (!recapacityAllowed) {
            throw new IllegalStateException("Derived buffers and their parent can't be expanded.");
        }

        // Allocate a new buffer and transfer all settings to it.
        if (newCapacity > capacity()) {
            // Expand:
            // // Save the state.
            int pos = position();
            int limit = limit();
            ByteOrder bo = order();

            // // Reallocate.
            ByteBuffer oldBuf = buf();
            ByteBuffer newBuf = getAllocator().allocateNioBuffer(newCapacity, isDirect());
            oldBuf.clear();
            newBuf.put(oldBuf);
            buf(newBuf);

            // // Restore the state.
            buf().limit(limit);
            if (mark >= 0) {
                buf().position(mark);
                buf().mark();
            }
            buf().position(pos);
            buf().order(bo);
        }

        return this;
    }

#No. 2900
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final boolean isAutoExpand() {
        return autoExpand && recapacityAllowed;
    }

#No. 2901
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final boolean isAutoShrink() {
        return autoShrink && recapacityAllowed;
    }

#No. 2902
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final boolean isDerived() {
        return derived;
    }

#No. 2903
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final IoBuffer setAutoExpand(boolean autoExpand) {
        if (!recapacityAllowed) {
            throw new IllegalStateException("Derived buffers and their parent can't be expanded.");
        }
        this.autoExpand = autoExpand;
        return this;
    }

#No. 2904
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final IoBuffer setAutoShrink(boolean autoShrink) {
        if (!recapacityAllowed) {
            throw new IllegalStateException("Derived buffers and their parent can't be shrinked.");
        }
        this.autoShrink = autoShrink;
        return this;
    }

#No. 2905
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final IoBuffer expand(int expectedRemaining) {
        return expand(position(), expectedRemaining, false);
    }

#No. 2906
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final IoBuffer expand(int pos, int expectedRemaining) {
        return expand(pos, expectedRemaining, false);
    }

#No. 2907
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final int position() {
        return buf().position();
    }

#No. 2908
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final IoBuffer position(int newPosition) {
        autoExpand(newPosition, 0);
        buf().position(newPosition);
        if (mark > newPosition) {
            mark = -1;
        }
        return this;
    }

#No. 2909
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final int limit() {
        return buf().limit();
    }

#No. 2910
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final IoBuffer limit(int newLimit) {
        autoExpand(newLimit, 0);
        buf().limit(newLimit);
        if (mark > newLimit) {
            mark = -1;
        }
        return this;
    }

#No. 2911
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final IoBuffer mark() {
        buf().mark();
        mark = position();
        return this;
    }

#No. 2912
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final int markValue() {
        return mark;
    }

#No. 2913
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final IoBuffer reset() {
        buf().reset();
        return this;
    }

#No. 2914
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final IoBuffer clear() {
        buf().clear();
        mark = -1;
        return this;
    }

#No. 2915
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final IoBuffer sweep() {
        clear();
        return fillAndReset(remaining());
    }

#No. 2916
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final IoBuffer sweep(byte value) {
        clear();
        return fillAndReset(value, remaining());
    }

#No. 2917
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final IoBuffer flip() {
        buf().flip();
        mark = -1;
        return this;
    }

#No. 2918
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final IoBuffer rewind() {
        buf().rewind();
        mark = -1;
        return this;
    }

#No. 2919
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final int remaining() {
        return limit() - position();
    }

#No. 2920
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final boolean hasRemaining() {
        return limit() > position();
    }

#No. 2921
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final byte get() {
        return buf().get();
    }

#No. 2922
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final short getUnsigned() {
        return (short) (get() & 0xff);
    }

#No. 2923
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final IoBuffer put(byte b) {
        autoExpand(1);
        buf().put(b);
        return this;
    }

#No. 2924
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final byte get(int index) {
        return buf().get(index);
    }

#No. 2925
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final short getUnsigned(int index) {
        return (short) (get(index) & 0xff);
    }

#No. 2926
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final IoBuffer put(int index, byte b) {
        autoExpand(index, 1);
        buf().put(index, b);
        return this;
    }

#No. 2927
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final IoBuffer get(byte[] dst, int offset, int length) {
        buf().get(dst, offset, length);
        return this;
    }

#No. 2928
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final IoBuffer put(ByteBuffer src) {
        autoExpand(src.remaining());
        buf().put(src);
        return this;
    }

#No. 2929
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final IoBuffer put(byte[] src, int offset, int length) {
        autoExpand(length);
        buf().put(src, offset, length);
        return this;
    }

#No. 2930
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final ByteOrder order() {
        return buf().order();
    }

#No. 2931
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final IoBuffer order(ByteOrder bo) {
        buf().order(bo);
        return this;
    }

#No. 2932
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final char getChar() {
        return buf().getChar();
    }

#No. 2933
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final IoBuffer putChar(char value) {
        autoExpand(2);
        buf().putChar(value);
        return this;
    }

#No. 2934
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final char getChar(int index) {
        return buf().getChar(index);
    }

#No. 2935
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final IoBuffer putChar(int index, char value) {
        autoExpand(index, 2);
        buf().putChar(index, value);
        return this;
    }

#No. 2936
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final CharBuffer asCharBuffer() {
        return buf().asCharBuffer();
    }

#No. 2937
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final short getShort() {
        return buf().getShort();
    }

#No. 2938
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final IoBuffer putShort(short value) {
        autoExpand(2);
        buf().putShort(value);
        return this;
    }

#No. 2939
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final short getShort(int index) {
        return buf().getShort(index);
    }

#No. 2940
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final IoBuffer putShort(int index, short value) {
        autoExpand(index, 2);
        buf().putShort(index, value);
        return this;
    }

#No. 2941
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final ShortBuffer asShortBuffer() {
        return buf().asShortBuffer();
    }

#No. 2942
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final int getInt() {
        return buf().getInt();
    }

#No. 2943
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final IoBuffer putInt(int value) {
        autoExpand(4);
        buf().putInt(value);
        return this;
    }

#No. 2944
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final int getInt(int index) {
        return buf().getInt(index);
    }

#No. 2945
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final IoBuffer putInt(int index, int value) {
        autoExpand(index, 4);
        buf().putInt(index, value);
        return this;
    }

#No. 2946
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final IntBuffer asIntBuffer() {
        return buf().asIntBuffer();
    }

#No. 2947
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final long getLong() {
        return buf().getLong();
    }

#No. 2948
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final IoBuffer putLong(long value) {
        autoExpand(8);
        buf().putLong(value);
        return this;
    }

#No. 2949
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final long getLong(int index) {
        return buf().getLong(index);
    }

#No. 2950
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final IoBuffer putLong(int index, long value) {
        autoExpand(index, 8);
        buf().putLong(index, value);
        return this;
    }

#No. 2951
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final LongBuffer asLongBuffer() {
        return buf().asLongBuffer();
    }

#No. 2952
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final float getFloat() {
        return buf().getFloat();
    }

#No. 2953
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final IoBuffer putFloat(float value) {
        autoExpand(4);
        buf().putFloat(value);
        return this;
    }

#No. 2954
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final float getFloat(int index) {
        return buf().getFloat(index);
    }

#No. 2955
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final IoBuffer putFloat(int index, float value) {
        autoExpand(index, 4);
        buf().putFloat(index, value);
        return this;
    }

#No. 2956
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final FloatBuffer asFloatBuffer() {
        return buf().asFloatBuffer();
    }

#No. 2957
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final double getDouble() {
        return buf().getDouble();
    }

#No. 2958
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final IoBuffer putDouble(double value) {
        autoExpand(8);
        buf().putDouble(value);
        return this;
    }

#No. 2959
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final double getDouble(int index) {
        return buf().getDouble(index);
    }

#No. 2960
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final IoBuffer putDouble(int index, double value) {
        autoExpand(index, 8);
        buf().putDouble(index, value);
        return this;
    }

#No. 2961
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final DoubleBuffer asDoubleBuffer() {
        return buf().asDoubleBuffer();
    }

#No. 2962
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final IoBuffer asReadOnlyBuffer() {
        recapacityAllowed = false;
        return asReadOnlyBuffer0();
    }

#No. 2963
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final IoBuffer duplicate() {
        recapacityAllowed = false;
        return duplicate0();
    }

#No. 2964
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final IoBuffer slice() {
        recapacityAllowed = false;
        return slice0();
    }

#No. 2965
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final IoBuffer getSlice(int index, int length) {
        if (length < 0) {
            throw new IllegalArgumentException("length: " + length);
        }

        int limit = limit();

        if (index > limit) {
            throw new IllegalArgumentException("index: " + index);
        }

        int endIndex = index + length;

        if (capacity() < endIndex) {
            throw new IndexOutOfBoundsException("index + length (" + endIndex + ") is greater " + "than capacity ("
                    + capacity() + ").");
        }

        clear();
        position(index);
        limit(endIndex);

        IoBuffer slice = slice();
        position(index);
        limit(limit);
        return slice;
    }

#No. 2966
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public final IoBuffer getSlice(int length) {
        if (length < 0) {
            throw new IllegalArgumentException("length: " + length);
        }
        int pos = position();
        int limit = limit();
        int nextPos = pos + length;
        if (limit < nextPos) {
            throw new IndexOutOfBoundsException("position + length (" + nextPos + ") is greater " + "than limit ("
                    + limit + ").");
        }

        limit(pos + length);
        IoBuffer slice = slice();
        position(nextPos);
        limit(limit);
        return slice;
    }

#No. 2967
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public int hashCode() {
        int h = 1;
        int p = position();
        for (int i = limit() - 1; i >= p; i--) {
            h = 31 * h + get(i);
        }
        return h;
    }

#No. 2968
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public boolean equals(Object o) {
        if (!(o instanceof IoBuffer)) {
            return false;
        }

        IoBuffer that = (IoBuffer) o;
        if (this.remaining() != that.remaining()) {
            return false;
        }

        int p = this.position();
        for (int i = this.limit() - 1, j = that.limit() - 1; i >= p; i--, j--) {
            byte v1 = this.get(i);
            byte v2 = that.get(j);
            if (v1 != v2) {
                return false;
            }
        }
        return true;
    }

#No. 2969
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public int compareTo(IoBuffer that) {
        int n = this.position() + Math.min(this.remaining(), that.remaining());
        for (int i = this.position(), j = that.position(); i < n; i++, j++) {
            byte v1 = this.get(i);
            byte v2 = that.get(j);
            if (v1 == v2) {
                continue;
            }
            if (v1 < v2) {
                return -1;
            }

            return +1;
        }
        return this.remaining() - that.remaining();
    }

#No. 2970
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public String toString() {
        StringBuilder buf = new StringBuilder();
        if (isDirect()) {
            buf.append("DirectBuffer");
        }
        else {
            buf.append("HeapBuffer");
        }
        buf.append("[pos=");
        buf.append(position());
        buf.append(" lim=");
        buf.append(limit());
        buf.append(" cap=");
        buf.append(capacity());
        buf.append(": ");
        buf.append(getHexDump(16));
        buf.append(']');
        return buf.toString();
    }

#No. 2971
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public IoBuffer get(byte[] dst) {
        return get(dst, 0, dst.length);
    }

#No. 2972
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public IoBuffer put(IoBuffer src) {
        return put(src.buf());
    }

#No. 2973
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public IoBuffer put(byte[] src) {
        return put(src, 0, src.length);
    }

#No. 2974
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public int getUnsignedShort() {
        return getShort() & 0xffff;
    }

#No. 2975
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public int getUnsignedShort(int index) {
        return getShort(index) & 0xffff;
    }

#No. 2976
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public long getUnsignedInt() {
        return getInt() & 0xffffffffL;
    }

#No. 2977
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public int getMediumInt() {
        byte b1 = get();
        byte b2 = get();
        byte b3 = get();
        if (ByteOrder.BIG_ENDIAN.equals(order())) {
            return getMediumInt(b1, b2, b3);
        }
        else {
            return getMediumInt(b3, b2, b1);
        }
    }

#No. 2978
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public int getUnsignedMediumInt() {
        int b1 = getUnsigned();
        int b2 = getUnsigned();
        int b3 = getUnsigned();
        if (ByteOrder.BIG_ENDIAN.equals(order())) {
            return b1 << 16 | b2 << 8 | b3;
        }
        else {
            return b3 << 16 | b2 << 8 | b1;
        }
    }

#No. 2979
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public int getMediumInt(int index) {
        byte b1 = get(index);
        byte b2 = get(index + 1);
        byte b3 = get(index + 2);
        if (ByteOrder.BIG_ENDIAN.equals(order())) {
            return getMediumInt(b1, b2, b3);
        }
        else {
            return getMediumInt(b3, b2, b1);
        }
    }

#No. 2980
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public int getUnsignedMediumInt(int index) {
        int b1 = getUnsigned(index);
        int b2 = getUnsigned(index + 1);
        int b3 = getUnsigned(index + 2);
        if (ByteOrder.BIG_ENDIAN.equals(order())) {
            return b1 << 16 | b2 << 8 | b3;
        }
        else {
            return b3 << 16 | b2 << 8 | b1;
        }
    }

#No. 2981
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    private int getMediumInt(byte b1, byte b2, byte b3) {
        int ret = b1 << 16 & 0xff0000 | b2 << 8 & 0xff00 | b3 & 0xff;
        // Check to see if the medium int is negative (high bit in b1 set)
        if ((b1 & 0x80) == 0x80) {
            // Make the the whole int negative
            ret |= 0xff000000;
        }
        return ret;
    }

#No. 2982
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public IoBuffer putMediumInt(int value) {
        byte b1 = (byte) (value >> 16);
        byte b2 = (byte) (value >> 8);
        byte b3 = (byte) value;

        if (ByteOrder.BIG_ENDIAN.equals(order())) {
            put(b1).put(b2).put(b3);
        }
        else {
            put(b3).put(b2).put(b1);
        }

        return this;
    }

#No. 2983
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public IoBuffer putMediumInt(int index, int value) {
        byte b1 = (byte) (value >> 16);
        byte b2 = (byte) (value >> 8);
        byte b3 = (byte) value;

        if (ByteOrder.BIG_ENDIAN.equals(order())) {
            put(index, b1).put(index + 1, b2).put(index + 2, b3);
        }
        else {
            put(index, b3).put(index + 1, b2).put(index + 2, b1);
        }

        return this;
    }

#No. 2984
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public long getUnsignedInt(int index) {
        return getInt(index) & 0xffffffffL;
    }

#No. 2985
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public OutputStream asOutputStream() {
        return new OutputStream() {
            @Override
            public void write(byte[] b, int off, int len) {
                AbstractIoBuffer.this.put(b, off, len);
            }


            @Override
            public void write(int b) {
                AbstractIoBuffer.this.put((byte) b);
            }
        };
    }

#No. 2986
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public String getHexDump() {
        return this.getHexDump(Integer.MAX_VALUE);
    }

#No. 2987
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public String getHexDump(int lengthLimit) {
        return IoBufferHexDumper.getHexdump(this, lengthLimit);
    }

#No. 2988
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public String getPrefixedString(CharsetDecoder decoder) throws CharacterCodingException {
        return getPrefixedString(2, decoder);
    }

#No. 2989
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public IoBuffer putPrefixedString(CharSequence in, CharsetEncoder encoder) throws CharacterCodingException {
        return putPrefixedString(in, 2, 0, encoder);
    }

#No. 2990
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public IoBuffer putPrefixedString(CharSequence in, int prefixLength, CharsetEncoder encoder)
            throws CharacterCodingException {
        return putPrefixedString(in, prefixLength, 0, encoder);
    }

#No. 2991
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public IoBuffer putPrefixedString(CharSequence in, int prefixLength, int padding, CharsetEncoder encoder)
            throws CharacterCodingException {
        return putPrefixedString(in, prefixLength, padding, (byte) 0, encoder);
    }

#No. 2992
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public Object getObject() throws ClassNotFoundException {
        return getObject(Thread.currentThread().getContextClassLoader());
    }

#No. 2993
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public IoBuffer putObject(Object o) {
        int oldPos = position();
        skip(4); // Make a room for the length field.
        try {
            ObjectOutputStream out = new ObjectOutputStream(asOutputStream()) {
                @Override
                protected void writeClassDescriptor(ObjectStreamClass desc) throws IOException {
                    if (desc.forClass().isPrimitive()) {
                        write(0);
                        super.writeClassDescriptor(desc);
                    }
                    else {
                        write(1);
                        writeUTF(desc.getName());
                    }
                }
            };
            out.writeObject(o);
            out.flush();
        }
        catch (IOException e) {
            throw new BufferDataException(e);
        }

        // Fill the length field
        int newPos = position();
        position(oldPos);
        putInt(newPos - oldPos - 4);
        position(newPos);
        return this;
    }

#No. 2994
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public boolean prefixedDataAvailable(int prefixLength) {
        return prefixedDataAvailable(prefixLength, Integer.MAX_VALUE);
    }

#No. 2995
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public boolean prefixedDataAvailable(int prefixLength, int maxDataLength) {
        if (remaining() < prefixLength) {
            return false;
        }

        int dataLength;
        switch (prefixLength) {
        case 1:
            dataLength = getUnsigned(position());
            break;
        case 2:
            dataLength = getUnsignedShort(position());
            break;
        case 4:
            dataLength = getInt(position());
            break;
        default:
            throw new IllegalArgumentException("prefixLength: " + prefixLength);
        }

        if (dataLength < 0 || dataLength > maxDataLength) {
            throw new BufferDataException("dataLength: " + dataLength);
        }

        return remaining() - prefixLength >= dataLength;
    }

#No. 2996
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public int indexOf(byte b) {
        if (hasArray()) {
            int arrayOffset = arrayOffset();
            int beginPos = arrayOffset + position();
            int limit = arrayOffset + limit();
            byte[] array = array();

            for (int i = beginPos; i < limit; i++) {
                if (array[i] == b) {
                    return i - arrayOffset;
                }
            }
        }
        else {
            int beginPos = position();
            int limit = limit();

            for (int i = beginPos; i < limit; i++) {
                if (get(i) == b) {
                    return i;
                }
            }
        }

        return -1;
    }

#No. 2997
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public IoBuffer skip(int size) {
        autoExpand(size);
        return position(position() + size);
    }

#No. 2998
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public IoBuffer fill(byte value, int size) {
        autoExpand(size);
        int q = size >>> 3;
        int r = size & 7;

        if (q > 0) {
            int intValue = value | value << 8 | value << 16 | value << 24;
            long longValue = intValue;
            longValue <<= 32;
            longValue |= intValue;

            for (int i = q; i > 0; i--) {
                putLong(longValue);
            }
        }

        q = r >>> 2;
        r = r & 3;

        if (q > 0) {
            int intValue = value | value << 8 | value << 16 | value << 24;
            putInt(intValue);
        }

        q = r >> 1;
        r = r & 1;

        if (q > 0) {
            short shortValue = (short) (value | value << 8);
            putShort(shortValue);
        }

        if (r > 0) {
            put(value);
        }

        return this;
    }

#No. 2999
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public IoBuffer fillAndReset(byte value, int size) {
        autoExpand(size);
        int pos = position();
        try {
            fill(value, size);
        }
        finally {
            position(pos);
        }
        return this;
    }

#No. 3000
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public IoBuffer fill(int size) {
        autoExpand(size);
        int q = size >>> 3;
        int r = size & 7;

        for (int i = q; i > 0; i--) {
            putLong(0L);
        }

        q = r >>> 2;
        r = r & 3;

        if (q > 0) {
            putInt(0);
        }

        q = r >> 1;
        r = r & 1;

        if (q > 0) {
            putShort((short) 0);
        }

        if (r > 0) {
            put((byte) 0);
        }

        return this;
    }

#No. 3001
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public IoBuffer fillAndReset(int size) {
        autoExpand(size);
        int pos = position();
        try {
            fill(size);
        }
        finally {
            position(pos);
        }

        return this;
    }

#No. 3002
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public <E extends Enum<E>> E getEnum(Class<E> enumClass) {
        return toEnum(enumClass, getUnsigned());
    }

#No. 3003
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public <E extends Enum<E>> E getEnum(int index, Class<E> enumClass) {
        return toEnum(enumClass, getUnsigned(index));
    }

#No. 3004
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public <E extends Enum<E>> E getEnumShort(Class<E> enumClass) {
        return toEnum(enumClass, getUnsignedShort());
    }

#No. 3005
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public <E extends Enum<E>> E getEnumShort(int index, Class<E> enumClass) {
        return toEnum(enumClass, getUnsignedShort(index));
    }

#No. 3006
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public <E extends Enum<E>> E getEnumInt(Class<E> enumClass) {
        return toEnum(enumClass, getInt());
    }

#No. 3007
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public <E extends Enum<E>> E getEnumInt(int index, Class<E> enumClass) {
        return toEnum(enumClass, getInt(index));
    }

#No. 3008
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public IoBuffer putEnum(Enum<?> e) {
        if (e.ordinal() > BYTE_MASK) {
            throw new IllegalArgumentException(enumConversionErrorMessage(e, "byte"));
        }
        return put((byte) e.ordinal());
    }

#No. 3009
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public IoBuffer putEnum(int index, Enum<?> e) {
        if (e.ordinal() > BYTE_MASK) {
            throw new IllegalArgumentException(enumConversionErrorMessage(e, "byte"));
        }
        return put(index, (byte) e.ordinal());
    }

#No. 3010
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public IoBuffer putEnumShort(Enum<?> e) {
        if (e.ordinal() > SHORT_MASK) {
            throw new IllegalArgumentException(enumConversionErrorMessage(e, "short"));
        }
        return putShort((short) e.ordinal());
    }

#No. 3011
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public IoBuffer putEnumShort(int index, Enum<?> e) {
        if (e.ordinal() > SHORT_MASK) {
            throw new IllegalArgumentException(enumConversionErrorMessage(e, "short"));
        }
        return putShort(index, (short) e.ordinal());
    }

#No. 3012
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public IoBuffer putEnumInt(Enum<?> e) {
        return putInt(e.ordinal());
    }

#No. 3013
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public IoBuffer putEnumInt(int index, Enum<?> e) {
        return putInt(index, e.ordinal());
    }

#No. 3014
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public <E extends Enum<E>> EnumSet<E> getEnumSet(Class<E> enumClass) {
        return toEnumSet(enumClass, get() & BYTE_MASK);
    }

#No. 3015
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public <E extends Enum<E>> EnumSet<E> getEnumSet(int index, Class<E> enumClass) {
        return toEnumSet(enumClass, get(index) & BYTE_MASK);
    }

#No. 3016
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public <E extends Enum<E>> EnumSet<E> getEnumSetShort(Class<E> enumClass) {
        return toEnumSet(enumClass, getShort() & SHORT_MASK);
    }

#No. 3017
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public <E extends Enum<E>> EnumSet<E> getEnumSetShort(int index, Class<E> enumClass) {
        return toEnumSet(enumClass, getShort(index) & SHORT_MASK);
    }

#No. 3018
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public <E extends Enum<E>> EnumSet<E> getEnumSetInt(Class<E> enumClass) {
        return toEnumSet(enumClass, getInt() & INT_MASK);
    }

#No. 3019
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public <E extends Enum<E>> EnumSet<E> getEnumSetInt(int index, Class<E> enumClass) {
        return toEnumSet(enumClass, getInt(index) & INT_MASK);
    }

#No. 3020
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public <E extends Enum<E>> EnumSet<E> getEnumSetLong(Class<E> enumClass) {
        return toEnumSet(enumClass, getLong());
    }

#No. 3021
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public <E extends Enum<E>> EnumSet<E> getEnumSetLong(int index, Class<E> enumClass) {
        return toEnumSet(enumClass, getLong(index));
    }

#No. 3022
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public <E extends Enum<E>> IoBuffer putEnumSet(Set<E> set) {
        long vector = toLong(set);
        if ((vector & ~BYTE_MASK) != 0) {
            throw new IllegalArgumentException("The enum set is too large to fit in a byte: " + set);
        }
        return put((byte) vector);
    }

#No. 3023
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public <E extends Enum<E>> IoBuffer putEnumSet(int index, Set<E> set) {
        long vector = toLong(set);
        if ((vector & ~BYTE_MASK) != 0) {
            throw new IllegalArgumentException("The enum set is too large to fit in a byte: " + set);
        }
        return put(index, (byte) vector);
    }

#No. 3024
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public <E extends Enum<E>> IoBuffer putEnumSetShort(Set<E> set) {
        long vector = toLong(set);
        if ((vector & ~SHORT_MASK) != 0) {
            throw new IllegalArgumentException("The enum set is too large to fit in a short: " + set);
        }
        return putShort((short) vector);
    }

#No. 3025
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public <E extends Enum<E>> IoBuffer putEnumSetShort(int index, Set<E> set) {
        long vector = toLong(set);
        if ((vector & ~SHORT_MASK) != 0) {
            throw new IllegalArgumentException("The enum set is too large to fit in a short: " + set);
        }
        return putShort(index, (short) vector);
    }

#No. 3026
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public <E extends Enum<E>> IoBuffer putEnumSetInt(Set<E> set) {
        long vector = toLong(set);
        if ((vector & ~INT_MASK) != 0) {
            throw new IllegalArgumentException("The enum set is too large to fit in an int: " + set);
        }
        return putInt((int) vector);
    }

#No. 3027
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public <E extends Enum<E>> IoBuffer putEnumSetInt(int index, Set<E> set) {
        long vector = toLong(set);
        if ((vector & ~INT_MASK) != 0) {
            throw new IllegalArgumentException("The enum set is too large to fit in an int: " + set);
        }
        return putInt(index, (int) vector);
    }

#No. 3028
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public <E extends Enum<E>> IoBuffer putEnumSetLong(Set<E> set) {
        return putLong(toLong(set));
    }

#No. 3029
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public <E extends Enum<E>> IoBuffer putEnumSetLong(int index, Set<E> set) {
        return putLong(index, toLong(set));
    }

#No. 3030
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * This method forwards the call to {@link #expand(int)} only when
     * <tt>autoExpand</tt> property is <tt>true</tt>.
     */

#Code:
    private IoBuffer autoExpand(int expectedRemaining) {
        if (isAutoExpand()) {
            expand(expectedRemaining, true);
        }
        return this;
    }

#No. 3031
#File: E:\bishe\1\AbstractIoBuffer.java
#Comment:
    /**
     * This method forwards the call to {@link #expand(int)} only when
     * <tt>autoExpand</tt> property is <tt>true</tt>.
     */

#Code:
    private IoBuffer autoExpand(int pos, int expectedRemaining) {
        if (isAutoExpand()) {
            expand(pos, expectedRemaining, true);
        }
        return this;
    }

#No. 3032
#File: E:\bishe\1\AbstractIOIOActivity.java
#Comment:
        /**
         * Subclasses should use this field for controlling the IOIO.
         */

#Code:
        protected IOIO ioio_;
        private boolean abort_ = false;
        private boolean connected_ = true;
        private final IOIOConnectionFactory connectionFactory_ = currentConnectionFactory_;

        /**
         * Subclasses should override this method for performing operations to
         * be done once as soon as IOIO communication is established. Typically,
         * this will include opening pins and modules using the openXXX()
         * methods of the {@link #ioio_} field.
         */
        protected void setup() throws ConnectionLostException,
                InterruptedException {
        }

#No. 3033
#File: E:\bishe\1\AbstractIOIOActivity.java
#Comment:
        /**
         * Subclasses should override this method for performing operations to
         * be done repetitively as long as IOIO communication persists.
         * Typically, this will be the main logic of the application, processing
         * inputs and producing outputs.
         */

#Code:
        protected void loop() throws ConnectionLostException,
                InterruptedException {
            sleep(100000);
        }

#No. 3034
#File: E:\bishe\1\AbstractIOIOActivity.java
#Comment:
        /**
         * Not relevant to subclasses.
         */

#Code:
        public synchronized final void abort() {
            abort_ = true;
            if (ioio_ != null) {
                ioio_.disconnect();
            }
            if (connected_) {
                interrupt();
            }
        }

#No. 3035
#File: E:\bishe\1\AbstractionGrid.java
#Comment:
	/**
	 * Makes an AbstractionGrid using <code>internalGrid</code> as
	 * its internal buffer
	 * 
	 * @param internalGrid
	 * @return
	 */

#Code:
	public static AbstractionGrid makeUsingBuffer(TextGrid internalGrid){
		if(internalGrid.getWidth() % 3 != 0
			|| internalGrid.getHeight() % 3 != 0) throw new IllegalArgumentException("Passed TextGrid must have dimensions that are divisible by 3."); 
		AbstractionGrid result = new AbstractionGrid(internalGrid.getWidth() / 3, internalGrid.getHeight() / 3);
		result.setInternalBuffer(internalGrid);
		return result;
	}

#No. 3036
#File: E:\bishe\1\AbstractIOPlugin.java
#Comment:
/**
 * Abstract base class for {@link IOPlugin}s.
 * 
 * @author Curtis Rueden
 */

#Code:
public abstract class AbstractIOPlugin<D> extends AbstractHandlerPlugin<String>
	implements IOPlugin<D>
{
	// NB: No implementation needed.
}

#No. 3037
#File: E:\bishe\1\AbstractIOSSimulatorMojo.java
#Comment:
    /**
     * The iOS SDK version to use when choosing the simulator (e.g. "8.0"). Defaults to the newest
     * SDK version.
     */

#Code:
    @Parameter(property="robovm.iosSimSdk")
    protected String sdk;

    /**
     * The identifier of the simulator device to use (e.g. "iPhone-5s", "iPad-Retina"). Run {@code
     * ios-sim showdevicetypes} for a full list.
     */
    @Parameter(property="robovm.iosDeviceName")
    protected String deviceName;

    protected AbstractIOSSimulatorMojo(DeviceFamily deviceFamily) {
        this.deviceFamily = deviceFamily;
    }

#No. 3038
#File: E:\bishe\1\AbstractIrpQueue.java
#Comment:
    /**
     * Aborts all queued IRPs. The IRP which is currently processed can't be
     * aborted. This method returns as soon as no more IRPs are in the queue and
     * no more are processed.
     */

#Code:
    public final void abort()
    {
        this.aborting = true;
        this.irps.clear();
        while (isBusy())
        {
            try
            {
                synchronized (this.irps)
                {
                    if (isBusy()) this.irps.wait();
                }
            }
            catch (final InterruptedException e)
            {
                Thread.currentThread().interrupt();
            }
        }
        this.aborting = false;
    }

#No. 3039
#File: E:\bishe\1\AbstractIrpQueue.java
#Comment:
    /**
     * Checks if queue is busy. A busy queue is a queue which is currently
     * processing IRPs or which still has IRPs in the queue.
     * 
     * @return True if queue is busy, false if not.
     */

#Code:
    public final boolean isBusy()
    {
        return !this.irps.isEmpty() || this.processor != null;
    }

#No. 3040
#File: E:\bishe\1\AbstractIrpQueue.java
#Comment:
    /**
     * Returns the configuration.
     * 
     * @return The configuration.
     */

#Code:
    protected final Config getConfig()
    {
        return Services.getInstance().getConfig();
    }

#No. 3041
#File: E:\bishe\1\AbstractIrpQueue.java
#Comment:
    /**
     * Returns the USB device.
     * 
     * @return The USB device. Never null.
     */

#Code:
    protected final AbstractDevice getDevice()
    {
        return this.device;
    }

#No. 3042
#File: E:\bishe\1\AbstractIrpQueue.java
#Comment:
    /**
     * Processes the control IRP.
     * 
     * @param irp
     *            The IRP to process.
     * @throws UsbException
     *             When processing the IRP fails.
     */

#Code:
    protected final void processControlIrp(final UsbControlIrp irp)
        throws UsbException
    {
        final ByteBuffer buffer =
            ByteBuffer.allocateDirect(irp.getLength());
        buffer.put(irp.getData(), irp.getOffset(), irp.getLength());
        buffer.rewind();
        final DeviceHandle handle = getDevice().open();
        final int result = LibUsb.controlTransfer(handle, irp.bmRequestType(),
            irp.bRequest(), irp.wValue(), irp.wIndex(), buffer,
            getConfig().getTimeout());
        if (result < 0)
        {
            throw ExceptionUtils.createPlatformException(
                "Unable to submit control message", result);
        }
        buffer.rewind();
        buffer.get(irp.getData(), irp.getOffset(), result);
        irp.setActualLength(result);
        if (irp.getActualLength() != irp.getLength()
            && !irp.getAcceptShortPacket())
        {
            throw new UsbShortPacketException();
        }
    }

#No. 3043
#File: E:\bishe\1\AbstractIrpQueue.java
#Comment:
    /**
     * Checks if this queue is currently aborting.
     * 
     * @return True if queue is aborting, false if not.
     */

#Code:
    protected final boolean isAborting()
    {
        return this.aborting;
    }

#No. 3044
#File: E:\bishe\1\AbstractIssue.java
#Comment:
    /**
     * @return true if the pull request is closed
     */

#Code:
    public boolean isClosed() {
        return !isOpen();
    }

#No. 3045
#File: E:\bishe\1\AbstractIssueEditView.java
#Comment:
	/**
	 * @return The netId of the assignee
	 */

#Code:
	public String getAssignee(){
		Select assigneeDropdown = new Select(getDriver().findElement(By.id("assignee")));
		return assigneeDropdown.getFirstSelectedOption().getText();		
	}

#No. 3046
#File: E:\bishe\1\AbstractItemListFragment.java
#Comment:
    /**
     * The serialization (saved instance state) Bundle key representing the
     * activated item position. Only used on tablets.
     */

#Code:
    private static final String STATE_ACTIVATED_POSITION = "activated_position";
    /**
     * A dummy implementation of the {@link ListSelectionListener} interface that does
     * nothing. Used only when this fragment is not attached to an activity.
     */
    private static final ListSelectionListener<Object> dummyCallbacks =
        new ListSelectionListener<Object>() {
            @Override
            public void onItemSelected(Object item) {
                // NO OP
            }
        };

#No. 3047
#File: E:\bishe\1\AbstractItemListFragment.java
#Comment:
    /**
     * The fragment's current callback object, which is notified of list item
     * clicks.
     */

#Code:
    private ListSelectionListener<? super T> callbacks = dummyCallbacks;
    /**
     * The current activated item position. Only used on tablets.
     */
    private int activatedPosition = ListView.INVALID_POSITION;
    private boolean activateOnItemClick;

    @Override
    public void onViewCreated(View view, Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);

        // Restore the previously serialized activated item position.
        if (savedInstanceState != null
            && savedInstanceState.containsKey(STATE_ACTIVATED_POSITION)) {
            setActivatedPosition(savedInstanceState.getInt(STATE_ACTIVATED_POSITION));
        }
    }

#No. 3048
#File: E:\bishe\1\AbstractItemListFragment.java
#Comment:
    /**
     * Turns on activate-on-click mode. When this mode is on, list items will be
     * given the 'activated' state when touched.
     */

#Code:
    public void setActivateOnItemClick(boolean activateOnItemClick) {
        this.activateOnItemClick = activateOnItemClick;

        if (isVisible()) {
            // When setting CHOICE_MODE_SINGLE, ListView will automatically
            // give items the 'activated' state when touched.
            getListView().setChoiceMode(activateOnItemClick
                ? ListView.CHOICE_MODE_SINGLE
                : ListView.CHOICE_MODE_NONE);
        }
    }

#No. 3049
#File: E:\bishe\1\AbstractIterator.java
#Comment:
  /**
   * Implementations of {@link #computeNext} <b>must</b> invoke this method when
   * there are no elements left in the iteration.
   *
   * @return {@code null}; a convenience so your {@code computeNext}
   * implementation can use the simple statement {@code return endOfData();}
   */

#Code:
  protected final T endOfData() {
    state = State.DONE;
    return null;
  }

#No. 3050
#File: E:\bishe\1\AbstractIterator.java
#Comment:
  /**
   * Returns the next element in the iteration without advancing the iteration.
   *
   * <p>Implementations of {@code AbstractIterator} that wish to expose this
   * functionality should implement {@code PeekingIterator}.
   */

#Code:
  public final T peek() {
    if (!hasNext()) {
      throw new NoSuchElementException();
    }
    return next;
  }

#No. 3051
#File: E:\bishe\1\AbstractIteratorMojo.java
#Comment:
    /**
     * Convert all types {@code content}, {@code items} or {@code ItemsWithProperties} into the same type.
     * 
     * @return list {@link ItemWithProperties}
     * @throws MojoExecutionException In case of an error.
     */

#Code:
    protected List<ItemWithProperties> getItemsConverted()
        throws MojoExecutionException
    {
        List<ItemWithProperties> result = new ArrayList<>();

        if ( isItemsWithPropertiesSet() )
        {
            result = getItemsWithProperties();
        }
        else if ( isContentSet() )
        {
            for ( String itemName : getContentAsList() )
            {
                result.add( new ItemWithProperties( itemName, ItemWithProperties.NO_PROPERTIES ) );
            }
        }
        else if ( isItemsSet() )
        {
            for ( String itemName : getItems() )
            {
                result.add( new ItemWithProperties( itemName, ItemWithProperties.NO_PROPERTIES ) );
            }
        }
        else if ( isFolderSet() )
        {
            for ( String itemName : getFolders() )
            {
                result.add( new ItemWithProperties( itemName, ItemWithProperties.NO_PROPERTIES ) );
            }
        }

        return result;
    }

#No. 3052
#File: E:\bishe\1\AbstractIteratorMojo.java
#Comment:
    /**
     * This is just a convenience method to get the combination of {@link #getBeginToken()}, {@link #getIteratorName()}
     * and {@link #getEndToken()}.
     * 
     * @return The combined string.
     */

#Code:
    protected String getPlaceHolder()
    {
        return getBeginToken() + getIteratorName() + getEndToken();
    }

#No. 3053
#File: E:\bishe\1\AbstractIteratorTest.java
#Comment:
    /*
     * This sample AbstractIterator returns 0 on the first call, 1 on the
     * second, then signals that it's reached the end of the data
     */

#Code:
        AbstractIterator<Integer> iter = new AbstractIterator<Integer>() {
            private int rep;
            @Override public Integer computeNext() {
                switch (rep++) {
                    case 0:
                        return 0;
                    case 1:
                        return 1;
                    case 2:
                        return endOfData();
                    default:
                        fail("Should not have been invoked again");
                        return null;
                }
            }

#No. 3054
#File: E:\bishe\1\AbstractIteratorTest.java
#Comment:
    /**
     * Throws a undeclared checked exception.
     */

#Code:
    private static void sneakyThrow(Throwable t) {
        class SneakyThrower<T extends Throwable> {
            @SuppressWarnings("unchecked") // not really safe, but that's the point
            void throwIt(Throwable t) throws T {
                throw (T) t;
            }
        }
        new SneakyThrower<Error>().throwIt(t);
    }

#No. 3055
#File: E:\bishe\1\AbstractIvyBuild.java
#Comment:
    /**
     * Extra verbose debug switch.
     */

#Code:
    public static boolean debug = false;
    
    protected AbstractIvyBuild(P job) throws IOException {
        super(job);
    }

#No. 3056
#File: E:\bishe\1\AbstractIvyBuild.java
#Comment:
   /**
     * Determines whether any of the upstream project are either
     * building or in the queue.
     *
     * This means eventually there will be an automatic triggering of
     * the given project (provided that all builds went smoothly.)
     *
     * @param downstreamProject
     *      The AbstractProject we want to build.
     * @param excludeProject
     *      An AbstractProject to exclude - if we see this in the transitive
     *      dependencies, we're not going to bother checking to see if it's
     *      building. For example, pass the current parent project to be sure
     *      that it will be ignored when looking for building dependencies.
     * @return
     *      True if any upstream projects are building or in queue, false otherwise.
     */

#Code:
    private boolean areUpstreamsBuilding(AbstractProject downstreamProject,
                                                   AbstractProject excludeProject) {
        DependencyGraph graph = Hudson.getInstance().getDependencyGraph();
        Set<AbstractProject> tups = graph.getTransitiveUpstream(downstreamProject);
        for (AbstractProject tup : tups) {
            if(tup!=excludeProject && (tup.isBuilding() || tup.isInQueue()))
                return true;
        }
        return false;
    }

#No. 3057
#File: E:\bishe\1\AbstractJ4SStatementTest.java
#Comment:
	/*
	 * SELECT tbl.* FROM Online_Account AS tbl
	 */

#Code:
	@Test
	public void testSelectAllTableAlias() throws Exception {
		final String[][] results = {
				{
						"[StringCol]=FooString",
					"[NullableStringCol]=FooNullableFooString",
					"[NullableIntCol]=6", "[IntCol]=5",
					"[type]=http://example.com/jdbc4sparql#fooTable"
				},
				{
						"[StringCol]=Foo2String", "[NullableStringCol]=null",
					"[NullableIntCol]=null", "[IntCol]=5",
					"[type]=http://example.com/jdbc4sparql#fooTable"
				}
		};

		// get the column names.
		final List<String> colNames = getColumnNames("fooTable");
		final ResultSet rset = stmt
				.executeQuery("select tbl.* from fooTable tbl");
		int i = 0;
		while (rset.next()) {
			final List<String> lst = Arrays.asList(results[i]);
			for (final String colName : colNames) {
				lst.contains(String.format("[%s]=%s", colName,
						rset.getString(colName)));
			}
			i++;
		}
		Assert.assertEquals(2, i);
		rset.close();
	}

#No. 3058
#File: E:\bishe\1\AbstractJacksonRequestHandler.java
#Comment:
    /**
     * Handles a Lambda Function request
     *
     * @param input   The Lambda Function input
     * @param context The Lambda execution environment context object.
     * @return The Lambda Function output
     */

#Code:
    public abstract O handleRequest(I input, Context context);
}
}

#No. 3059
#File: E:\bishe\1\AbstractJarMojo.java
#Comment:
	/**
	 * Default Manifest location. Can point to a non existing file.
	 * Cannot return null.
	 */

#Code:
	protected File getDefaultManifestFile()
	{
		return defaultManifestFile;
	}

#No. 3060
#File: E:\bishe\1\AbstractJarMojo.java
#Comment:
	/**
	 * Generates the JAR.
	 *
	 * @todo Add license files in META-INF directory.
	 */

#Code:
	public void execute()
			throws MojoExecutionException
	{
		if ( skipIfEmpty && !getClassesDirectory().exists() )
		{
			getLog().info( "Skipping packaging of the test-jar" );
		}
		else
		{
			File jarFile = createArchive();

			String classifier = getClassifier();
			if ( classifier != null )
			{
				projectHelper.attachArtifact( getProject(), getType(), classifier, jarFile );
			}
			else
			{
				getProject().getArtifact().setFile( jarFile );
			}
		}
	}

#No. 3061
#File: E:\bishe\1\AbstractJarSign.java
#Comment:
    /**
     * Copy all the files in a manifest from input to output. We set the
     * modification times in the output to a fixed time, so as to reduce
     * variation in the output file and make incremental OTAs more efficient.
     */

#Code:
    private static void copyFiles(Manifest manifest, JarFile in, JarOutputStream out, long timestamp)
            throws IOException {
        byte[] buffer = new byte[4096];
        int num;

        Map<String, Attributes> entries = manifest.getEntries();
        List<String> names = new ArrayList<>(entries.keySet());
        Collections.sort(names);
        for (String name : names) {
            JarEntry inEntry = in.getJarEntry(name);
            JarEntry outEntry = null;
            if (inEntry.getMethod() == JarEntry.STORED) {
                // Preserve the STORED method of the input entry.
                outEntry = new JarEntry(inEntry);
            } else {
                // Create a new entry so that the compressed len is recomputed.
                outEntry = new JarEntry(name);
            }
            outEntry.setTime(timestamp);
            out.putNextEntry(outEntry);

            InputStream data = in.getInputStream(inEntry);
            while ((num = data.read(buffer)) > 0) {
                out.write(buffer, 0, num);
            }
            out.flush();
        }
    }

#No. 3062
#File: E:\bishe\1\AbstractJavadocExtractorTest.java
#Comment:
    /**
     * Adds a source root directory.
     *
     * @param resourcePath A non-null resource path.
     */

#Code:
    protected void addSourceRootDirectory(final String resourcePath) {

        // Check sanity
        Validate.notEmpty(resourcePath, "resourcePath");

        final String effectiveResourcePath = resourcePath.charAt(0) == '/' ? resourcePath : "/" + resourcePath;
        final URL resource = Thread.currentThread().getContextClassLoader().getResource(effectiveResourcePath);
        Assert.assertNotNull("Effective resourcePath [" + resourcePath + "] could not be found.", resource);

        final File toAdd = new File(resource.getPath());
        final boolean exists = toAdd.exists();
        final boolean isDirectory = toAdd.isDirectory();

        Assert.assertTrue("Resource [" + toAdd.getAbsolutePath() + "] was nonexistent.", exists);
        Assert.assertTrue("Resource [" + toAdd.getAbsolutePath() + "] was not a directory.", isDirectory);

        sourceRootDirectories.add(toAdd);
    }

#No. 3063
#File: E:\bishe\1\AbstractJavaNameBindingsExtractor.java
#Comment:
	/**
	 * Return a set of sets of SimpleName ASTNode objects that are bound
	 * together
	 *
	 * @param node
	 * @return
	 */

#Code:
	public abstract Set<Set<ASTNode>> getNameBindings(final ASTNode node);

	public final List<TokenNameBinding> getNameBindings(final ASTNode node,
			final File file) throws IOException {
		final Set<Set<ASTNode>> nodeBindings = getNameBindings(node);
		final SortedMap<Integer, String> tokenPositions = Maps.transformValues(
				tokenizer.tokenListWithPos(file),
				FullToken.TOKEN_NAME_CONVERTER);
		return getTokenBindings(tokenPositions, nodeBindings);
	}

#No. 3064
#File: E:\bishe\1\AbstractJavaNameBindingsExtractor.java
#Comment:
	/**
	 * Get the name bindings for the given ASTNode. This assumes that the
	 * ASTNode has been produced by the sourceCode, code with no variation.
	 *
	 * @param node
	 *            the ASTNode where bindings will be computed.
	 * @param sourceCode
	 *            the sourceCode from which the ASTNode has been extracted.
	 * @return
	 */

#Code:
	public final List<TokenNameBinding> getNameBindings(final ASTNode node,
			final String sourceCode) {
		final Set<Set<ASTNode>> nodeBindings = getNameBindings(node);
		final SortedMap<Integer, String> tokenPositions = tokenizer
				.tokenListWithPos(sourceCode.toCharArray());
		return getTokenBindings(tokenPositions, nodeBindings);
	}

#No. 3065
#File: E:\bishe\1\AbstractJavaNameBindingsExtractor.java
#Comment:
	/**
	 * Get the token bindings given the ASTNode bindings and the source code
	 * positions.
	 *
	 * @param sourceCode
	 * @param nodeBindings
	 * @return
	 */

#Code:
	public List<TokenNameBinding> getTokenBindings(
			final SortedMap<Integer, String> tokenPositions,
			final Set<Set<ASTNode>> nodeBindings) {
		final SortedMap<Integer, Integer> positionToIndex = getTokenIndexForPostion(tokenPositions);
		final List<String> tokens = Lists.newArrayList(tokenPositions.values());

		final List<TokenNameBinding> bindings = Lists.newArrayList();

		for (final Set<ASTNode> boundName : nodeBindings) {
			final List<Integer> boundPositions = Lists.newArrayList();
			for (final ASTNode name : boundName) {
				// Convert position to token index and add
				final int tokenIdx = positionToIndex.get(name
						.getStartPosition());
				boundPositions.add(tokenIdx);
			}
			bindings.add(new TokenNameBinding(Sets.newTreeSet(boundPositions),
					tokens, getFeatures(boundName)));
		}

		return bindings;
	}

#No. 3066
#File: E:\bishe\1\AbstractJavascriptMojo.java
#Comment:
    /**
     *  @component
     */

#Code:
    protected BuildContext buildContext;

    /**
     * Project being built.
     *
     * @parameter expression="${project}"
     * @required
     */
    private MavenProject project;

    /**
     * Where the .js files will be located for running.
     *
     * @parameter expression="${project.build.directory}/rhinodo"
     * @required
     */
    private String javascriptFilesDirectory;

    public String getJavascriptFilesDirectory() {
        return javascriptFilesDirectory;
    }

#No. 3067
#File: E:\bishe\1\AbstractJaxbMojo.java
#Comment:
    /**
     * Convenience method to invoke when some plugin configuration is incorrect.
     * Will output the problem as a warning with some degree of log formatting.
     *
     * @param propertyName The name of the problematic property.
     * @param description  The problem description.
     */

#Code:
    @SuppressWarnings("all")
    protected void warnAboutIncorrectPluginConfiguration(final String propertyName, final String description) {

        final StringBuilder builder = new StringBuilder();
        builder.append("\n+=================== [Incorrect Plugin Configuration Detected]\n");
        builder.append("|\n");
        builder.append("| Property : " + propertyName + "\n");
        builder.append("| Problem  : " + description + "\n");
        builder.append("|\n");
        builder.append("+=================== [End Incorrect Plugin Configuration Detected]\n\n");
        getLog().warn(builder.toString().replace("\n", NEWLINE));
    }

#No. 3068
#File: E:\bishe\1\AbstractJaxbMojo.java
#Comment:
    /**
     * @param arguments The final arguments to be passed to a JAXB tool (XJC or SchemaGen).
     * @param toolName  The name of the tool.
     * @return the arguments, untouched.
     */

#Code:
    protected final String[] logAndReturnToolArguments(final String[] arguments, final String toolName) {

        // Check sanity
        Validate.notNull(arguments, "arguments");

        if (getLog().isDebugEnabled()) {

            final StringBuilder argBuilder = new StringBuilder();
            argBuilder.append("\n+=================== [" + arguments.length + " " + toolName + " Arguments]\n");
            argBuilder.append("|\n");
            for (int i = 0; i < arguments.length; i++) {
                argBuilder.append("| [").append(i).append("]: ").append(arguments[i]).append("\n");
            }
            argBuilder.append("|\n");
            argBuilder.append("+=================== [End " + arguments.length + " " + toolName + " Arguments]\n\n");
            getLog().debug(argBuilder.toString().replace("\n", NEWLINE));
        }

        // All done.
        return arguments;
    }

#No. 3069
#File: E:\bishe\1\AbstractJaxbMojo.java
#Comment:
    /**
     * Acquires the staleFile for this execution
     *
     * @return the staleFile (used to define where) for this execution
     */

#Code:
    protected final File getStaleFile() {
        final String staleFileName = "."
                + (getExecution() == null ? "nonExecutionJaxb" : getExecution().getExecutionId())
                + "-" + getStaleFileName();
        return new File(staleFileDirectory, staleFileName);
    }

#No. 3070
#File: E:\bishe\1\AbstractJaxbMojo.java
#Comment:
    /**
     * <p>The algorithm for finding the encoding to use is as follows (where the first non-null value found
     * is used for encoding):</p>
     * <ol>
     * <li>If the configuration property is explicitly given within the plugin's configuration, use that value.</li>
     * <li>If the Maven property <code>project.build.sourceEncoding</code> is defined, use its value.</li>
     * <li>Otherwise use the value from the system property <code>file.encoding</code>.</li>
     * </ol>
     *
     * @param warnIfPlatformEncoding Defines if a warning should be logged if encoding is not configured but
     *                               the platform encoding (system property {@code file.encoding}) is used
     * @return The encoding to be used by this AbstractJaxbMojo and its tools.
     * @see #encoding
     */

#Code:
    protected final String getEncoding(final boolean warnIfPlatformEncoding) {

        // Harvest information
        final boolean configuredEncoding = encoding != null;
        final String fileEncoding = System.getProperty(SYSTEM_FILE_ENCODING_PROPERTY);
        final String effectiveEncoding = configuredEncoding ? encoding : fileEncoding;

        // Should we warn if using platform encoding (i.e. platform dependent)?
        if (!configuredEncoding && warnIfPlatformEncoding) {
            getLog().warn("Using platform encoding ["+ effectiveEncoding + "], i.e. build is platform dependent!");
        } else if (getLog().isDebugEnabled()) {
            getLog().debug("Using " + (configuredEncoding ? "explicitly configured" : "system property")
                    + " encoding [" + effectiveEncoding + "]");
        }

        // All Done.
        return effectiveEncoding;
    }

#No. 3071
#File: E:\bishe\1\AbstractJaxbMojo.java
#Comment:
    /**
     * Retrieves the JAXB episode File, and ensures that the parent directory where it exists is created.
     *
     * @param customEpisodeFileName {@code null} to indicate that the standard episode file name ("sun-jaxb.episode")
     *                              should be used, and otherwise a non-empty name which should be used
     *                              as the episode file name.
     * @return A non-null File where the JAXB episode file should be written.
     * @throws MojoExecutionException if the parent directory of the episode file could not be created.
     */

#Code:
    protected File getEpisodeFile(final String customEpisodeFileName) throws MojoExecutionException {

        // Check sanity
        final String effectiveEpisodeFileName = customEpisodeFileName == null
                ? "sun-jaxb.episode"
                : customEpisodeFileName;
        Validate.notEmpty(effectiveEpisodeFileName, "effectiveEpisodeFileName");

        // Use the standard episode location
        final File generatedMetaInfDirectory = new File(getOutputDirectory(), "META-INF");

        if (!generatedMetaInfDirectory.exists()) {

            FileSystemUtilities.createDirectory(generatedMetaInfDirectory, false);
            if (getLog().isDebugEnabled()) {
                getLog().debug("Created episode directory ["
                        + FileSystemUtilities.getCanonicalPath(generatedMetaInfDirectory) + "]: "
                        + generatedMetaInfDirectory.exists());
            }
        }

        // All done.
        return new File(generatedMetaInfDirectory, effectiveEpisodeFileName);
    }

#No. 3072
#File: E:\bishe\1\AbstractJaxbMojo.java
#Comment:
    /**
     * Prints out the system properties to the Maven Log at Debug level.
     */

#Code:
    protected void logSystemPropertiesAndBasedir() {
        if (getLog().isDebugEnabled()) {

            final StringBuilder builder = new StringBuilder();

            builder.append("\n+=================== [System properties]\n");
            builder.append("|\n");

            // Sort the system properties
            final SortedMap<String, Object> props = new TreeMap<String, Object>();
            props.put("basedir", FileSystemUtilities.getCanonicalPath(getProject().getBasedir()));

            for (Map.Entry<Object, Object> current : System.getProperties().entrySet()) {
                props.put("" + current.getKey(), current.getValue());
            }
            for (Map.Entry<String, Object> current : props.entrySet()) {
                builder.append("| [" + current.getKey() + "]: " + current.getValue() + "\n");
            }

            builder.append("|\n");
            builder.append("+=================== [End System properties]\n");

            // All done.
            getLog().debug(builder.toString().replace("\n", NEWLINE));
        }
    }

#No. 3073
#File: E:\bishe\1\AbstractJBossEnterpriseBeanOverrideTest.java
#Comment:
    /**
     * Test the simpleProperties method for consistency of the values being set and compared
     */

#Code:
    public void testSimplePropertiesMethod() throws Exception {
        BeanInfo beanInfo = Introspector.getBeanInfo(JBossSessionBeanMetaData.class);
        PropertyDescriptor[] props = beanInfo.getPropertyDescriptors();
        Set<String> ignoreNames = Collections.singleton("name");

        JBossSessionBeanMetaData original = new JBossSessionBeanMetaData();
        processSimpleProperties(props, original, true, true, ignoreNames);
        processSimpleProperties(props, original, true, false, ignoreNames);

        JBossSessionBeanMetaData override = new JBossSessionBeanMetaData();
        processSimpleProperties(props, override, false, true, ignoreNames);
        processSimpleProperties(props, override, false, false, ignoreNames);

        try {
            processSimpleProperties(props, override, true, false, ignoreNames);
            fail("override passed for original");
        } catch (AssertionFailedError e) {
            // expected
        }
    }

#No. 3074
#File: E:\bishe\1\AbstractJBossEnterpriseBeanOverrideTest.java
#Comment:
    /**
     * Tests merge/override of properties (except those in the ignoreNames set)
     * of primitive, wrapper and java.lang.String types
     * found in the class specified by the argument 'type'.
     * Since 'type' maybe abstract, 'typeImpl' argument is the non-abstract
     * subclass of the 'type'. If 'type' is not abstract then 'typeImpl' should
     * be the same as 'type' or null.
     *
     * @param type        the type tested for property merges/overrides
     * @param stopType    the superclass of the type whose properties should be
     *                    excluded from the test (can be null)
     * @param typeImpl    the type which is a non-abstract subclass
     *                    of the type argument (or the same as the type argument, or null)
     * @param ignoreNames property names that should be excluded from the test
     */

#Code:
    protected void simplePropertiesTest(Class type, Class stopType, Class typeImpl, Set<String> ignoreNames) throws Exception {
        BeanInfo beanInfo = stopType == null ? Introspector.getBeanInfo(type) : Introspector.getBeanInfo(type, stopType);
        PropertyDescriptor[] props = beanInfo.getPropertyDescriptors();

        if (typeImpl == null) { typeImpl = type; }

        JBossEnterpriseBeanMetaData original = (JBossEnterpriseBeanMetaData) typeImpl.newInstance();
        original.setEjbName(getName() + "EjbName");
        processSimpleProperties(props, original, true, true, ignoreNames);

        // merge only original
        JBossEnterpriseBeanMetaData merged = (JBossEnterpriseBeanMetaData) typeImpl.newInstance();
        merged.merge(null, original);
        assertEquals("missing super.merge(..)?", original.getEjbName(), merged.getEjbName());
        processSimpleProperties(props, merged, true, false, ignoreNames);

        // merge with override
        JBossEnterpriseBeanMetaData override = (JBossEnterpriseBeanMetaData) typeImpl.newInstance();
        override.setEjbName(getName() + "EjbName");
        processSimpleProperties(props, override, false, true, ignoreNames);
        merged = (JBossEnterpriseBeanMetaData) typeImpl.newInstance();
        merged.merge(override, original);
        processSimpleProperties(props, merged, false, false, ignoreNames);
    }

#No. 3075
#File: E:\bishe\1\AbstractJBossEnterpriseBeanOverrideTest.java
#Comment:
    /**
     * Initializes or asserts properties of java.lang.String, primitive and wrapper types.
     * If original is true then the generated property values are for the original object,
     * otherwise - for the override.
     * If init is true the object is initialized,
     * otherwise the property values are compared to the expected values.
     */

#Code:
    private void processSimpleProperties(PropertyDescriptor[] props, Object o, boolean original, boolean init, Set<String> ignoreNames) throws Exception {
        for (PropertyDescriptor prop : props) {
            if (ignoreNames.contains(prop.getName())) { continue; }

            Class<?> propertyType = prop.getPropertyType();
            boolean isString = java.lang.String.class.equals(propertyType);
            boolean isPrimitive = propertyType.isPrimitive();
            Method writeMethod = prop.getWriteMethod();
            if (writeMethod == null /*&& prop.getReadMethod() != null*/
                    || !(isPrimitive || Classes.isPrimitiveWrapper(propertyType) || isString)) { continue; }

            Object propValue;
            if (isString) {
                propValue = (original ? "original_" : "override_") + prop.getName();
            } else {
                Class wrapper = propertyType;
                if (isPrimitive) { wrapper = Classes.getPrimitiveWrapper(propertyType); }
                if (wrapper.equals(Boolean.class)) { propValue = original ? "false" : "true"; } else { propValue = original ? "0" : "1"; }

                Method method = wrapper.getMethod("valueOf", new Class[]{String.class});
                propValue = method.invoke(null, new Object[]{propValue});
            }

            if (init) {
                writeMethod.invoke(o, new Object[]{propValue});
            } else {
                Method readMethod = prop.getReadMethod();
                if (readMethod == null) {
                    if (propertyType.equals(Boolean.class)) { readMethod = Classes.getAttributeGetter(o.getClass(), prop.getName()); }
                    if (readMethod == null) { fail("Read-method not found for " + prop.getName() + " in " + o.getClass()); }
                }
                assertEquals(prop.getName(), propValue, readMethod.invoke(o, EMPTY_ARR));
            }
        }
    }

#No. 3076
#File: E:\bishe\1\AbstractJdbcCacheStore.java
#Comment:
    /**
     * Load and return a single object from the data store.
     *
     * @param key entry key that can be used to find the object in the data
     *            store
     *
     * @return loaded object or null if the object for the specified key was not
     *         found
     */

#Code:
    @Transactional(readOnly = true)
    public Object load(Object key) {
        List<T> results = getJdbcTemplate().query(
                getSelectSql(), getRowMapper(), getPrimaryKeyComponents(key));
        return results.size() == 0 ? null : results.get(0);
    }

#No. 3077
#File: E:\bishe\1\AbstractJdbcCacheStore.java
#Comment:
    /**
     * Persist a single object into the data store.
     *
     * @param key   entry key of the object that should be persisted
     * @param value object to persist
     */

#Code:
    public void store(Object key, Object value) {
        getJdbcTemplate().update(getMergeSql(),
                                 new BeanPropertySqlParameterSource(value));
    }

#No. 3078
#File: E:\bishe\1\AbstractJdbcCacheStore.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public void storeBatch(Map mapBatch) {
        SqlParameterSource[] batch =
                SqlParameterSourceUtils.createBatch(
                        mapBatch.values().toArray());

        getJdbcTemplate().batchUpdate(getMergeSql(), batch);
    }

#No. 3079
#File: E:\bishe\1\AbstractJdbcCacheStore.java
#Comment:
    /**
     * Return Spring JDBC template that should be used for data store access.
     *
     * @return Spring JDBC template that should be used for data store access
     */

#Code:
    protected SimpleJdbcTemplate getJdbcTemplate() {
        return jdbcTemplate;
    }

#No. 3080
#File: E:\bishe\1\AbstractJdbcDaoImpl.java
#Comment:
    /**
     * spring jdbcTemplate 对象
     */

#Code:
    protected JdbcOperations        jdbcTemplate;

    /**
     * 名称处理器，为空按默认执行
     */
    protected MappingHandler        mappingHandler;

    /** 主键生成器 为空默认数据库自增 */
    protected KeyGenerator          keyGenerator;

    /**
     * rowMapper，为空按默认执行
     */
    protected String                rowMapperClass;

    /**
     * 自定义sql处理
     */
    protected SqlFactory            sqlFactory;

    /**
     * 数据库方言
     */
    protected String                dialect;

    /**
     * map转bean
     * 
     * @param map
     * @param beanClass
     * @param <T>
     * @return
     */
    protected <T> T mapToBean(Map<String, Object> map, Class<T> beanClass) {
        if (map == null || map.isEmpty()) {
            return null;
        }
        BeanConverter.registerConverter(new LongIntegerConverter(Long.class, Integer.class));
        return BeanConverter.underlineKeyMapToBean(map, beanClass);
    }

#No. 3081
#File: E:\bishe\1\AbstractJdbcDaoImpl.java
#Comment:
    /**
     * map转bean
     *
     * @param <T>  the type parameter
     * @param mapList the map list
     * @param beanClass the bean class
     * @return list
     */

#Code:
    protected <T> List<T> mapToBean(List<Map<String, Object>> mapList, Class<T> beanClass) {
        if (CollectionUtils.isEmpty(mapList)) {
            return null;
        }
        BeanConverter.registerConverter(new LongIntegerConverter(Long.class, Integer.class));
        List<T> beans = BeanConverter.underlineKeyMapToBean(mapList, beanClass);
        Pager pager = PageControl.getPager();
        if (pager != null) {
            pager.setList(beans);
            PageControl.setPager(pager);
        }
        return beans;
    }

#No. 3082
#File: E:\bishe\1\AbstractJdbcDaoImpl.java
#Comment:
    /**
     * 获取rowMapper对象
     *
     * @param clazz
     * @return
     */

#Code:
    @SuppressWarnings("unchecked")
    protected <T> RowMapper<T> getRowMapper(Class<T> clazz) {

        if (StringUtils.isBlank(rowMapperClass)) {
            return JdbcRowMapper.newInstance(clazz);
        } else {
            return (RowMapper<T>) ClassUtils.newInstance(rowMapperClass);
        }
    }

#No. 3083
#File: E:\bishe\1\AbstractJdbcDaoImpl.java
#Comment:
    /**
     * 获取名称处理器
     *
     * @return
     */

#Code:
    protected MappingHandler getMappingHandler() {

        if (this.mappingHandler == null) {
            this.mappingHandler = new DefaultMappingHandler();
        }
        return this.mappingHandler;
    }

#No. 3084
#File: E:\bishe\1\AbstractJDBCMapper.java
#Comment:
	/**
	 * Helper function of various find functions.
	 * 
	 * @param <E>
	 * @param klazz
	 * @param rules
	 * @return
	 * @throws DatabaseException
	 * @throws SQLException
	 */

#Code:
	private List<Tuple> executeSelect(QueryRule... rules) throws DatabaseException, SQLException
	{
		String sql = createFindSqlInclRules(rules);
		if (rules != null)
		{
			// FIXME too complicated
			for (QueryRule rule : rules)
			{
				if (rule.getOperator() == Operator.LAST)
				{
					sql = "select * from (" + sql + ") as " + this.getClass().getSimpleName().toLowerCase() + " "
							+ createSortSql(true, rules);
					break;
				}
			}
		}
		// execute the query
		return getDatabase().sql(sql);
	}

#No. 3085
#File: E:\bishe\1\AbstractJDBCMapper.java
#Comment:
	/**
	 * Helper method for creating an escaped sql string for a value.
	 * <p>
	 * This can be used by createXXXsql methods to prevend sql-injection in data
	 * values.
	 * 
	 * @param value
	 *            to be escaped
	 */

#Code:
	public static String escapeSql(Object value)
	{
		if (value != null)
		{
			String result = StringEscapeUtils.escapeSql(value.toString());
			// odd case: if ends with \ we are in trouble
			if (result.endsWith("\\"))
			{
				result += "\\";
			}
			return result;
		}
		return null;
		// return sql.toString().replace("'", "''");
	}

#No. 3086
#File: E:\bishe\1\AbstractJDBCMapper.java
#Comment:
	/**
	 * Mref fields do not really exist in the table but instead in a separate
	 * link table. This method should query this link table to rewrite the query
	 * rules.
	 * 
	 * @param db
	 * @param user_rules
	 * @return
	 * @throws DatabaseException
	 */

#Code:
	protected QueryRule[] rewriteRules(Database db, QueryRule... user_rules) throws DatabaseException
	{
		if (user_rules == null) return null;
		List<QueryRule> rules = this.rewriteRules(db, Arrays.asList(user_rules));
		return rules.toArray(new QueryRule[rules.size()]);

	}

#No. 3087
#File: E:\bishe\1\AbstractJDBCMapper.java
#Comment:
	/**
	 * Mref fields do not really exist in the table but instead in a separate
	 * link table. This method should query this link table to rewrite the query
	 * rules.
	 * 
	 * @param db
	 * @param user_rules
	 * @return
	 * @throws DatabaseException
	 */

#Code:
	protected List<QueryRule> rewriteRules(Database db, List<QueryRule> user_rules) throws DatabaseException
	{
		List<QueryRule> rules = new ArrayList<QueryRule>();
		for (QueryRule rule : user_rules)
		{
			if (rule.getOperator() != null && rule.getOperator().equals(Operator.NESTED))
			{
				QueryRule r = new QueryRule(this.rewriteRules(db, rule.getNestedRules()));
				// r.setOr(rule.isOr());
				// rules.add(new QueryRule(Operator.AND));
				rules.add(r);
			}
			else
			{
				QueryRule r = this.rewriteMrefRule(db, rule);
				// r.setOr(rule.isOr());
				// rules.add(new QueryRule(Operator.OR));
				rules.add(r);
			}
		}
		return rules;
	}

#No. 3088
#File: E:\bishe\1\AbstractJestClient.java
#Comment:
    /**
     * @throws io.searchbox.client.config.exception.NoServerConfiguredException
     */

#Code:
    protected String getNextServer() {
        return serverPoolReference.get().getNextServer();
    }

#No. 3089
#File: E:\bishe\1\AbstractJettyRunMojo.java
#Comment:
    /**
     * @return Returns the contextPath.
     */

#Code:
    public String getContextPath()
    {
        return this.contextPath;
    }

#No. 3090
#File: E:\bishe\1\AbstractJettyRunMojo.java
#Comment:
    /**
     * @return Returns the scanIntervalSeconds.
     */

#Code:
    public int getScanIntervalSeconds()
    {
        return this.scanIntervalSeconds;
    }

#No. 3091
#File: E:\bishe\1\AbstractJettyRunMojo.java
#Comment:
    /**
     * @return returns the path to the systemPropertiesFile
     */

#Code:
    public File getSystemPropertiesFile()
    {
        return this.systemPropertiesFile;
    }

#No. 3092
#File: E:\bishe\1\AbstractJettyRunMojo.java
#Comment:
    /**
     * Subclasses should invoke this to setup basic info
     * on the webapp
     *
     * @throws MojoExecutionException
     */

#Code:
    public void configureWebApplication () throws Exception
    {
        //As of jetty-7, you must use a <webAppConfig> element
        if (webAppConfig == null)
            webAppConfig = new JettyWebAppContext();

        //Apply any context xml file to set up the webapp
        //CAUTION: if you've defined a <webAppConfig> element then the
        //context xml file can OVERRIDE those settings
        if (webAppXml != null)
        {
            File file = FileUtils.getFile(webAppXml);
            XmlConfiguration xmlConfiguration = new XmlConfiguration(file.toURL());
            getLog().info("Applying context xml file "+webAppXml);
            xmlConfiguration.configure(webAppConfig);
        }


        //If no contextPath was specified, go with our default
        String cp = webAppConfig.getContextPath();
        if (cp == null || "".equals(cp))
        {
            webAppConfig.setContextPath((contextPath.startsWith("/") ? contextPath : "/"+ contextPath));
        }

        //If no tmp directory was specified, and we have one, use it
        if (webAppConfig.getTempDirectory() == null && tmpDirectory != null)
        {
            if (!tmpDirectory.exists())
                tmpDirectory.mkdirs();

            webAppConfig.setTempDirectory(tmpDirectory);
        }

        getLog().info("Context path = " + webAppConfig.getContextPath());
        getLog().info("Tmp directory = "+ (webAppConfig.getTempDirectory()== null? " determined at runtime": webAppConfig.getTempDirectory()));
        getLog().info("Web defaults = "+(webAppConfig.getDefaultsDescriptor()==null?" jetty default":webAppConfig.getDefaultsDescriptor()));
        getLog().info("Web overrides = "+(webAppConfig.getOverrideDescriptor()==null?" none":webAppConfig.getOverrideDescriptor()));
    }

#No. 3093
#File: E:\bishe\1\AbstractJettyRunMojo.java
#Comment:
    /**
     * Run a scanner thread on the given list of files and directories, calling
     * stop/start on the given list of LifeCycle objects if any of the watched
     * files change.
     *
     */

#Code:
    private void startScanner()
    {
        // check if scanning is enabled
        if (getScanIntervalSeconds() <= 0) return;

        // check if reload is manual. It disables file scanning
        if ( "manual".equalsIgnoreCase( reload ) )
        {
            // issue a warning if both scanIntervalSeconds and reload
            // are enabled
            getLog().warn("scanIntervalSeconds is set to " + scanIntervalSeconds + " but will be IGNORED due to manual reloading");
            return;
        }

        scanner = new Scanner();
        scanner.setReportExistingFilesOnStartup(false);
        scanner.setScanInterval(getScanIntervalSeconds());
        scanner.setScanDirs(getScanList());
        scanner.setRecursive(true);
        List listeners = getScannerListeners();
        Iterator itor = (listeners==null?null:listeners.iterator());
        while (itor!=null && itor.hasNext())
            scanner.addListener((Scanner.Listener)itor.next());
        getLog().info("Starting scanner at interval of " + getScanIntervalSeconds()+ " seconds.");
        try {
            scanner.start();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

#No. 3094
#File: E:\bishe\1\AbstractJettyRunMojo.java
#Comment:
    /**
     * Run a thread that monitors the console input to detect ENTER hits.
     */

#Code:
    protected void startConsoleScanner()
    {
        if ( "manual".equalsIgnoreCase( reload ) )
        {
            getLog().info("Console reloading is ENABLED. Hit ENTER on the console to restart the context.");
            consoleScanner = new ConsoleScanner(this);
            consoleScanner.start();
        }
    }

#No. 3095
#File: E:\bishe\1\AbstractJettyRunMojo.java
#Comment:
    /**
     * Try and find a jetty-web.xml file, using some
     * historical naming conventions if necessary.
     * @param webInfDir
     * @return the jetty web xml file
     */

#Code:
    public File findJettyWebXmlFile (File webInfDir)
    {
        if (webInfDir == null)
            return null;
        if (!webInfDir.exists())
            return null;

        File f = new File (webInfDir, "jetty-web.xml");
        if (f.exists())
            return f;

        //try some historical alternatives
        f = new File (webInfDir, "web-jetty.xml");
        if (f.exists())
            return f;

        return null;
    }

#No. 3096
#File: E:\bishe\1\AbstractJettyTest.java
#Comment:
    /**
     * @param s
     */

#Code:
    public AbstractJettyTest(final String s) {
        super(s);
    }

#No. 3097
#File: E:\bishe\1\AbstractJettyTest.java
#Comment:
    /**
     * @see junit.framework.TestCase#setUp()
     */

#Code:
    @Override
    protected void setUp() throws Exception {
        setupServer();

        final HttpContext context = createContext();

        final ServletHandler servlets = createServletHandler();
        context.addHandler(servlets);

        server.addContext(context);

        server.start();
    }

#No. 3098
#File: E:\bishe\1\AbstractJettyTest.java
#Comment:
    /**
     * @throws InterruptedException
     */

#Code:
    private void setupServer() throws InterruptedException {

        // Create the server
        if (server != null) {
            server.stop();
            server = null;
        }
        server = new HttpServer();

        // Create a port listener
        final SocketListener listener = new SocketListener();
        listener.setPort(testPort);
        server.addListener(listener);
    }

#No. 3099
#File: E:\bishe\1\AbstractJettyTest.java
#Comment:
    /**
     * @return
     */

#Code:
    private ServletHandler createServletHandler() {
        final ServletHandler servlets = new ServletHandler();
        servlets.addServlet("FetcherTestServlet", FetcherTestServlet.SERVLET_MAPPING, "com.rometools.fetcher.FetcherTestServlet");
        servlets.addServlet("FetcherTestServlet", FetcherTestServlet.SERVLET_MAPPING2, "com.rometools.fetcher.FetcherTestServlet");
        return servlets;
    }

#No. 3100
#File: E:\bishe\1\AbstractJettyTest.java
#Comment:
    /**
     * @return
     */

#Code:
    private HttpContext createContext() {
        final HttpContext context = new HttpContext();
        context.setContextPath("/rome/*");
        return context;
    }

#No. 3101
#File: E:\bishe\1\AbstractJettyTest.java
#Comment:
    /**
     * @see junit.framework.TestCase#tearDown()
     */

#Code:
    @Override
    protected void tearDown() throws Exception {
        if (server != null) {
            server.stop();
            server.destroy();
            server = null;
        }
    }

#No. 3102
#File: E:\bishe\1\AbstractJettyTest.java
#Comment:
        /**
         * @see com.rometools.rome.fetcher.FetcherListener#fetcherEvent(com.rometools.rome.fetcher.FetcherEvent)
         */

#Code:
        @Override
        public void fetcherEvent(final FetcherEvent event) {
            final String eventType = event.getEventType();
            if (FetcherEvent.EVENT_TYPE_FEED_POLLED.equals(eventType)) {
                LOG.debug("\tEVENT: Feed Polled. URL = " + event.getUrlString());
                polled = true;
            } else if (FetcherEvent.EVENT_TYPE_FEED_RETRIEVED.equals(eventType)) {
                LOG.debug("\tEVENT: Feed Retrieved. URL = " + event.getUrlString());
                retrieved = true;
            } else if (FetcherEvent.EVENT_TYPE_FEED_UNCHANGED.equals(eventType)) {
                LOG.debug("\tEVENT: Feed Unchanged. URL = " + event.getUrlString());
                unchanged = true;
            }
        }

#No. 3103
#File: E:\bishe\1\AbstractJettyTest.java
#Comment:
    /**
     * Test getting a feed via a http 301 redirect
     *
     */

#Code:
    public void testRetrieveRedirectedFeed() {
        final FeedFetcher feedFetcher = getFeedFetcher();
        try {
            final SyndFeed feed = feedFetcher.retrieveFeed(new URL("http://localhost:" + testPort + "/rome/FetcherTestServlet?redirect=TRUE"));
            assertNotNull(feed);
            assertEquals("atom_1.0.feed.title", feed.getTitle());
        } catch (final Exception e) {
            e.printStackTrace();
            fail(e.getMessage());
        }
    }

#No. 3104
#File: E:\bishe\1\AbstractJettyTest.java
#Comment:
    /**
     * Test error handling
     *
     */

#Code:
    public void testErrorHandling() {
        final FeedFetcher feedFetcher = getFeedFetcher();
        try {
            feedFetcher.retrieveFeed(new URL("http://localhost:" + testPort + "/rome/FetcherTestServlet?error=404"));
            fail("4xx error handling did not work correctly");
        } catch (final FetcherException e) {
            // expect this exception
            assertEquals(404, e.getResponseCode());
        } catch (final Exception e) {
            e.printStackTrace();
            fail(e.getMessage());
        }

        try {
            feedFetcher.retrieveFeed(new URL("http://localhost:" + testPort + "/rome/FetcherTestServlet?error=500"));
            fail("5xx error handling did not work correctly");
        } catch (final FetcherException e) {
            // expect this exception
            assertEquals(500, e.getResponseCode());
        } catch (final Exception e) {
            e.printStackTrace();
            fail(e.getMessage());
        }
    }

#No. 3105
#File: E:\bishe\1\AbstractJettyTest.java
#Comment:
    /**
     * Test events fired when there is no cache in use
     *
     */

#Code:
    public void testFetchEvents() {
        final FeedFetcher feedFetcher = getFeedFetcher();
        final FetcherEventListenerImpl listener = new FetcherEventListenerImpl();
        feedFetcher.addFetcherEventListener(listener);
        try {
            SyndFeed feed = feedFetcher.retrieveFeed(new URL("http://localhost:" + testPort + "/rome/FetcherTestServlet/"));
            assertNotNull(feed);
            assertTrue(listener.polled);
            assertTrue(listener.retrieved);
            assertFalse(listener.unchanged);
            listener.reset();

            // since there is no cache, the events fired should be exactly the same if
            // we re-retrieve the feed
            feed = feedFetcher.retrieveFeed(new URL("http://localhost:" + testPort + "/rome/FetcherTestServlet/"));
            assertNotNull(feed);
            assertTrue(listener.polled);
            assertTrue(listener.retrieved);
            assertFalse(listener.unchanged);
            listener.reset();
        } catch (final Exception e) {
            e.printStackTrace();
            fail(e.getMessage());
        }
    }

#No. 3106
#File: E:\bishe\1\AbstractJettyTest.java
#Comment:
    /**
     * Test events fired when there is a cache in use
     *
     */

#Code:
    public void testFetchEventsWithCache() {
        final FeedFetcherCache feedInfoCache = new HashMapFeedInfoCache();
        final FeedFetcher feedFetcher = getFeedFetcher(feedInfoCache);
        final FetcherEventListenerImpl listener = new FetcherEventListenerImpl();
        feedFetcher.addFetcherEventListener(listener);
        try {
            SyndFeed feed = feedFetcher.retrieveFeed(new URL("http://localhost:" + testPort + "/rome/FetcherTestServlet/"));
            assertNotNull(feed);
            assertTrue(listener.polled);
            assertTrue(listener.retrieved);
            assertFalse(listener.unchanged);
            listener.reset();

            // Since the feed is cached, the second request should not
            // actually retrieve the feed
            feed = feedFetcher.retrieveFeed(new URL("http://localhost:" + testPort + "/rome/FetcherTestServlet/"));
            assertNotNull(feed);
            assertTrue(listener.polled);
            assertFalse(listener.retrieved);
            assertTrue(listener.unchanged);
            listener.reset();

            // now simulate getting the feed after it has changed
            feed = feedFetcher.retrieveFeed(new URL("http://localhost:" + testPort + "/rome/FetcherTestServlet?refreshfeed=TRUE"));
            assertNotNull(feed);
            assertTrue(listener.polled);
            assertTrue(listener.retrieved);
            assertFalse(listener.unchanged);
            listener.reset();
        } catch (final Exception e) {
            e.printStackTrace();
            fail(e.getMessage());
        }
    }

#No. 3107
#File: E:\bishe\1\AbstractJettyTest.java
#Comment:
    /**
     * Test handling of GZipped feed
     *
     */

#Code:
    public void testGZippedFeed() {
        final FeedFetcher feedFetcher = getFeedFetcher();
        try {
            final SyndFeed feed = feedFetcher.retrieveFeed(new URL("http://localhost:" + testPort + "/rome/FetcherTestServlet?gzipfeed=TRUE"));
            assertNotNull(feed);
            assertEquals("atom_1.0.feed.title", feed.getTitle());
        } catch (final Exception e) {
            e.printStackTrace();
            fail(e.getMessage());
        }
    }

#No. 3108
#File: E:\bishe\1\AbstractJettyTest.java
#Comment:
            /*
             * This is breaking with Rome 0.5 ??
             */

#Code:
            final SyndFeed feed2 = feedFetcher.retrieveFeed(new URL("http://localhost:" + testPort
                    + "/rome/FetcherTestServlet?deltaencode=TRUE&refreshfeed=TRUE"));
            assertNotNull(feed2);
            assertEquals(FetcherTestServlet.DELTA_FEED_TITLE, feed2.getTitle());
            assertEquals(3, feed2.getEntries().size());
            entry1 = feed2.getEntries().get(0);
            assertEquals(FetcherTestServlet.DELTA_FEED_ENTRY_TITLE, entry1.getTitle());

            final SyndEntry entry2 = feed2.getEntries().get(1);
            assertEquals("atom_1.0.feed.entry[0].title", entry2.getTitle());

        } catch (final Exception e) {
            e.printStackTrace();
            fail(e.getMessage());
        }

#No. 3109
#File: E:\bishe\1\AbstractJiniTransactionManager.java
#Comment:
    /**
     * Sets an optional timeout when performing rollback/abort in milliseconds. Default: {@link
     * org.openspaces.core.transaction.manager.AbstractJiniTransactionManager#DEFAULT_TX_ROLLBACK_TIMEOUT}.
     */

#Code:
    public void setRollbackTimeout(Long rollbackTimeout) {
        this.rollbackTimeout = rollbackTimeout;
    }

#No. 3110
#File: E:\bishe\1\AbstractJiniTransactionManager.java
#Comment:
    /**
     * Sets the transaction lease renewal configuration. Once set, transactions will be renewed
     * automatically. If not set, no renewals will occur.
     */

#Code:
    public void setLeaseRenewalConfig(TransactionLeaseRenewalConfig leaseRenewalConfig) {
        this.leaseRenewalConfig = leaseRenewalConfig;
    }

#No. 3111
#File: E:\bishe\1\AbstractJMXDataProviderTest.java
#Comment:
    /**
     * Test of getProvider method, of class AbstractJMXDataProvider.
     */

#Code:
    public void testGetProvider() throws Exception {
        System.out.println("getProvider");
        MBeanServerConnection mBeanServerConn = new EmulatorMBeanServerConnection();
        String params = "gc-time";
        Class expResult = GCDataProvider.class;
        AbstractJMXDataProvider result = AbstractJMXDataProvider.getProvider(mBeanServerConn, params);
        assertEquals(expResult, result.getClass());
    }

#No. 3112
#File: E:\bishe\1\AbstractJMXDataProviderTest.java
#Comment:
    /**
     * Test of getMXBeanType method, of class AbstractJMXDataProvider.
     */

#Code:
    public void testGetMXBeanType() throws Exception {
        System.out.println("getMXBeanType");
        AbstractJMXDataProvider instance = new AbstractJMXDataProviderImpl();
        String result = instance.getMXBeanType();
        assertNotNull(result);
    }

#No. 3113
#File: E:\bishe\1\AbstractJMXDataProviderTest.java
#Comment:
    /**
     * Test of getMXBeanClass method, of class AbstractJMXDataProvider.
     */

#Code:
    public void testGetMXBeanClass() throws Exception {
        System.out.println("getMXBeanClass");
        AbstractJMXDataProvider instance = new AbstractJMXDataProviderImpl();
        Class result = instance.getMXBeanClass();
        assertNotNull(result);
    }

#No. 3114
#File: E:\bishe\1\AbstractJMXDataProviderTest.java
#Comment:
    /**
     * Test of getValueFromBean method, of class AbstractJMXDataProvider.
     */

#Code:
    public void testGetValueFromBean() throws Exception {
        System.out.println("getValueFromBean");
        Object bean = null;
        AbstractJMXDataProvider instance = new AbstractJMXDataProviderImpl();
        long expResult = 0L;
        long result = instance.getValueFromBean(bean);
        assertEquals(expResult, result);
    }

#No. 3115
#File: E:\bishe\1\AbstractJMXDataProviderTest.java
#Comment:
    /**
     * Test of getValue method, of class AbstractJMXDataProvider.
     */

#Code:
    public void testGetValue() throws Exception {
        System.out.println("getValue");
        StringBuffer res = new StringBuffer();
        AbstractJMXDataProvider instance = new AbstractJMXDataProviderImpl();
        instance.getValue(res);
    }

#No. 3116
#File: E:\bishe\1\AbstractJMXDataProviderTest.java
#Comment:
    /**
     * Test of getValue method, of class AbstractJMXDataProvider.
     */

#Code:
    public void testGetValue_2Params() throws Exception {
        System.out.println("getValue_2Params");
        StringBuffer res = new StringBuffer();
        AbstractJMXDataProvider instance = new AbstractJMXDataProviderImpl();
        instance.getValue(res, 1024);
    }

#No. 3117
#File: E:\bishe\1\AbstractJMXDataProviderTest.java
#Comment:
    /**
     * Test of isByteValue method, of class AbstractJMXDataProvider.
     */

#Code:
    public void testIsBytesValue() throws Exception {
        System.out.println("isBytesValue");
        AbstractJMXDataProvider instance = new AbstractJMXDataProviderImpl();
        assertFalse(instance.isBytesValue());
    }

#No. 3118
#File: E:\bishe\1\AbstractJMXDataProviderTest.java
#Comment:
    /**
     * Test of getValue method, of class AbstractJMXDataProvider.
     */

#Code:
    public void testGetValue_StringBuffer() throws Exception {
        System.out.println("getValue");
        StringBuffer res = new StringBuffer();
        AbstractJMXDataProvider instance = new AbstractJMXDataProviderImpl();
        instance.getValue(res);
    }

#No. 3119
#File: E:\bishe\1\AbstractJMXDataProviderTest.java
#Comment:
    /**
     * Test of getValue method, of class AbstractJMXDataProvider.
     */

#Code:
    public void testGetValue_StringBuffer_int() throws Exception {
        System.out.println("getValue");
        StringBuffer res = new StringBuffer();
        int divider = 1;
        AbstractJMXDataProvider instance = new AbstractJMXDataProviderImpl();
        instance.getValue(res, divider);
    }

#No. 3120
#File: E:\bishe\1\AbstractJmxService.java
#Comment:
	/**
	 * Get a jmx bean
	 * @return
	 * @throws Exception
	 */

#Code:
	public JSONObject getJmxBean() throws Exception {
		if (json.isEmpty()) {
			synchronized (json) {
				if (json.isEmpty()) {
					JSONObject newJson = getNewJmxBean();
					json = newJson;
				}
			}
		}

		return json;
	}

#No. 3121
#File: E:\bishe\1\AbstractJmxService.java
#Comment:
	/**
	 * Run every half hour
	 * @throws Exception
	 */

#Code:
	@Scheduled(fixedDelay = 1800 * 1000)
	public void run() throws Exception {
		logger.info("Start get new jmx bean while jmx server is "
				+ getJmxServer());
		JSONObject newJson = getNewJmxBean();
		logger.info("End get new jmx bean while jmx server is "
				+ getJmxServer());
		json = newJson;
	}

#No. 3122
#File: E:\bishe\1\AbstractJndiTestCase.java
#Comment:
	/**
	 * Begins the setup of the test case
	 */

#Code:
	@Override
	public void setUp() throws NamingException {
		jndiManager = new JndiManager();
		jndiManager.initialize();
	}

#No. 3123
#File: E:\bishe\1\AbstractJndiTestCase.java
#Comment:
	/**
	 * Undoes any setup work for the test case
	 */

#Code:
	@Override
	public void tearDown() throws NamingException {
		jndiManager.destroy();
		jndiManager = null;
	}

#No. 3124
#File: E:\bishe\1\AbstractJnlpMojo.java
#Comment:
        /*
        if ( !"pom".equals( getProject().getPackaging() ) ) {
           throw new MojoExecutionException( "'" + getProject().getPackaging() + "' packaging unsupported. Use 'pom'" );
        }
        */

#Code:
    }

    private void checkExtension( JnlpExtension extension )
            throws MojoExecutionException
    {
        if ( StringUtils.isEmpty( extension.getName() ) )
        {
            throw new MojoExecutionException( "JnlpExtension name is mandatory. Review your project configuration." );
        }
        if ( StringUtils.isEmpty( extension.getVendor() ) )
        {
            throw new MojoExecutionException( "JnlpExtension vendor is mandatory. Review your project configuration." );
        }
        if ( StringUtils.isEmpty( extension.getTitle() ) )
        {
            throw new MojoExecutionException( "JnlpExtension name is title. Review your project configuration." );
        }
        if ( extension.getIncludes() == null || extension.getIncludes().isEmpty() )
        {
            throw new MojoExecutionException(
                    "JnlpExtension need at least one include artifact. Review your project configuration." );
        }
    }

#No. 3125
#File: E:\bishe\1\AbstractJnlpMojo.java
#Comment:
    /**
     * Prepare extensions.
     * <p>
     * Copy all includes of all extensions as to be excluded.
     *
     * @throws MojoExecutionException if could not prepare extensions
     */

#Code:
    private void prepareExtensions()
            throws MojoExecutionException
    {
        List<String> includes = new ArrayList<>();
        for ( JnlpExtension extension : jnlpExtensions )
        {
            // Check extensions (mandatory name, title and vendor and at least one include)

            checkExtension( extension );

            for ( String o : extension.getIncludes() )
            {
                includes.add( o.trim() );
            }

            if ( StringUtils.isEmpty( extension.getOutputFile() ) )
            {
                String name = extension.getName() + ".jnlp";
                verboseLog(
                        "Jnlp extension output file name not specified. Using default output file name: " + name + "." );
                extension.setOutputFile( name );
            }
        }
        // copy all includes libs fro extensions to be exclude from the mojo
        // treatments (extensions by nature are already signed)
        if ( dependencies == null )
        {
            dependencies = new Dependencies();
        }

        if ( dependencies.getExcludes() == null )
        {
            dependencies.setExcludes( new ArrayList<String>() );
        }

        dependencies.getExcludes().addAll( includes );
    }

#No. 3126
#File: E:\bishe\1\AbstractJnlpMojo.java
#Comment:
    /**
     * Iterate through all the extensions dependencies declared in the project and
     * collect all the runtime scope dependencies for inclusion in the .zip and just
     * copy them to the lib directory.
     * <p>
     * TODO, should check that all dependencies are well signed with the same
     * extension with the same signer.
     *
     * @throws MojoExecutionException
     */

#Code:
    private void processExtensionsDependencies()
            throws MojoExecutionException
    {

        Collection<Artifact> artifacts =
                isExcludeTransitive() ? getProject().getDependencyArtifacts() : getProject().getArtifacts();

        for ( JnlpExtension extension : jnlpExtensions )
        {
            ArtifactFilter filter = new IncludesArtifactFilter( extension.getIncludes() );

            for ( Artifact artifact : artifacts )
            {
                if ( filter.include( artifact ) )
                {
                    processExtensionDependency( extension, artifact );
                }
            }
        }
    }

#No. 3127
#File: E:\bishe\1\AbstractJnlpTask.java
#Comment:
/**
 * Created on 1/4/14.
 *
 * @author Tony Chemit - dev@tchemit.fr
 * @since XXX
 */

#Code:
public abstract class AbstractJnlpTask
        extends AbstractLogEnabled
        implements JnlpDependencyTask
{

    protected void verboseLog( JnlpDependencyConfig config, String msg )
    {
        if ( config.isVerbose() )
        {
            getLogger().info( msg );
        }
        else
        {
            getLogger().debug( msg );
        }
    }

}

#No. 3128
#File: E:\bishe\1\AbstractJob.java
#Comment:
    /**
     * @param schConf
     * @param exception
     * @param nextFireTime
     */

#Code:
    private void doJobLogPersist(JobConfig schConf, Exception exception, Date nextFireTime) {
        if (JobContext.getContext().getJobLogPersistHandler() != null) {
            try {
                if (exception == null) {
                    JobContext.getContext().getJobLogPersistHandler().onSucess(schConf,
                        nextFireTime);
                } else {
                    JobContext.getContext().getJobLogPersistHandler().onError(schConf, nextFireTime,
                        exception);
                }
            } catch (Exception e) {
                logger.warn("JobLogPersistHandler run error", e);
            }
        }
    }

#No. 3129
#File: E:\bishe\1\AbstractJob.java
#Comment:
    /**
     * 判断是否异常中断运行状态（）
     * @param schConf
     * @return
     */

#Code:
    public boolean isAbnormalabort(JobConfig schConf) {
        if (schConf.getLastFireTime() == null)
            return false;
        //上次开始执行到当前执行时长
        long runingTime = DateUtils.getDiffSeconds(schConf.getLastFireTime(),
            getTrigger().getPreviousFireTime());
        //正常阀值
        //考虑到一些长周期任务，预定一个任务执行最长周期为1800秒
        long threshold = getJobFireInterval() > 1800 ? 1800 : getJobFireInterval();

        if (runingTime > threshold) {
            if (logger.isDebugEnabled())
                logger.debug("Job_{} 执行时长[{}]秒,超过阀值[{}]秒，节点:{}可能发生故障,切换节点:{}", jobName, runingTime,
                    threshold, schConf.getCurrentNodeId(), JobContext.getContext().getNodeId());

            return true;
        }

        return false;
    }

#No. 3130
#File: E:\bishe\1\AbstractJob.java
#Comment:
    /**
     * 获取任务执行间隔
     * @return
     * @throws SchedulerException
     */

#Code:
    private long getJobFireInterval() {
        if (jobFireInterval == 0) {
            Date nextFireTime = getTrigger().getNextFireTime();
            Date previousFireTime = getTrigger().getPreviousFireTime();
            jobFireInterval = (nextFireTime.getTime() - previousFireTime.getTime()) / 1000;
        }
        return jobFireInterval;
    }

#No. 3131
#File: E:\bishe\1\AbstractJob.java
#Comment:
    /**
     * 是否开启并行处理
     * @return
     */

#Code:
    public abstract boolean parallelEnabled();

    public abstract void doJob(JobContext context) throws Exception;

}
}

#No. 3132
#File: E:\bishe\1\AbstractJobPlugin.java
#Comment:
	/**
	 * @return the jobPluginCollector
	 */

#Code:
	public JobPluginCollector getJobPluginCollector() {
		return jobPluginCollector;
	}

#No. 3133
#File: E:\bishe\1\AbstractJobPlugin.java
#Comment:
	/**
	 * @param jobPluginCollector
	 *            the jobPluginCollector to set
	 */

#Code:
	public void setJobPluginCollector(
            JobPluginCollector jobPluginCollector) {
		this.jobPluginCollector = jobPluginCollector;
	}

#No. 3134
#File: E:\bishe\1\AbstractJPAQueryPredicateExecutor.java
#Comment:
    /*
     * @see org.springframework.data.jpa.repository.support.QueryDslJpaRepository#createQuery(Predicate... predicate)
     */

#Code:
    public JPQLQuery createQuery(Predicate... predicate) {
        return new JPAQuery(entityManager).from(path).where(predicate);
    }

#No. 3135
#File: E:\bishe\1\AbstractJPAQueryPredicateExecutor.java
#Comment:
    /*
     * @see org.springframework.data.jpa.repository.support.QueryDslJpaRepository#applyPagination(JPQLQuery query,
     * Pageable pageable)
     */

#Code:
    protected JPQLQuery applyPagination(JPQLQuery query, Pageable pageable) {
        if (pageable == null) {
            return query;
        }

        query.offset(pageable.getOffset());
        query.limit(pageable.getPageSize());

        return applySorting(query, pageable.getSort());
    }

#No. 3136
#File: E:\bishe\1\AbstractJPAQueryPredicateExecutor.java
#Comment:
    /*
     * @see org.springframework.data.jpa.repository.support.QueryDslJpaRepository#applySorting(JPQLQuery query, Sort
     * sort)
     */

#Code:
    protected JPQLQuery applySorting(JPQLQuery query, Sort sort) {
        if (sort == null) {
            return query;
        }

        for (Order order : sort) {
            query.orderBy(toOrder(order));
        }

        return query;
    }

#No. 3137
#File: E:\bishe\1\AbstractJPAQueryPredicateExecutor.java
#Comment:
    /*
     * @see org.springframework.data.jpa.repository.support.QueryDslJpaRepository#toOrder(Order order)
     */

#Code:
    @SuppressWarnings({"rawtypes", "unchecked"})
    protected OrderSpecifier<?> toOrder(Order order) {
        Expression<Object> property = builder.get(order.getProperty());
        return new OrderSpecifier(order.isAscending() ? com.mysema.query.types.Order.ASC
                : com.mysema.query.types.Order.DESC, property);
    }

#No. 3138
#File: E:\bishe\1\AbstractJSBUildFileTasksTab.java
#Comment:
	/**
	 * Creates the toggle to filter internal targets from the table
	 * 
	 * @param parent
	 *            the parent composite
	 */

#Code:
	// private void createFilterInternalTargets(Composite parent) {
	// fFilterInternalTargets = createCheckButton(parent,
	// JSBuildFileLaunchConfigurationMessages.AntTargetsTab_12);
	// fFilterInternalTargets.addSelectionListener(new SelectionAdapter() {
	// @Override
	// public void widgetSelected(SelectionEvent e) {
	// handleFilterTargetsSelected();
	// }
	// });
	// }

#No. 3139
#File: E:\bishe\1\AbstractJSBUildFileTasksTab.java
#Comment:
	/**
	 * Creates the toggle to sort targets in the table
	 * 
	 * @param parent
	 *            the parent composite
	 */

#Code:
	private void createSortTargets(Composite parent) {
		fSortButton = createCheckButton(parent,
				JSBuildFileLaunchConfigurationMessages.AntTargetsTab_14);
		fSortButton.addSelectionListener(new SelectionAdapter() {
			@Override
			public void widgetSelected(SelectionEvent e) {
				handleSortTargetsSelected();
			}
		});
	}

#No. 3140
#File: E:\bishe\1\AbstractJSBUildFileTasksTab.java
#Comment:
	/**
	 * The filter targets button has been toggled. If it's been turned on,
	 * filter out internal targets. Else, restore internal targets to the table.
	 */

#Code:
	// private void handleFilterTargetsSelected() {
	// boolean filter = fFilterInternalTargets.getSelection();
	// if (filter) {
	// fTableViewer.addFilter(getInternalTargetsFilter());
	// } else {
	// fTableViewer.removeFilter(getInternalTargetsFilter());
	// }
	//
	// // Must refresh before updating selection count because the selection
	// // count's "hidden" reporting needs the content provider to be queried
	// // first to count how many targets are hidden.
	// updateSelectionCount();
	// if (!fInitializing) {
	// updateLaunchConfigurationDialog();
	// }
	// }

#No. 3141
#File: E:\bishe\1\AbstractJSBUildFileTasksTab.java
#Comment:
	/**
	 * The button to sort targets has been toggled. Set the tab's sorting as
	 * appropriate.
	 */

#Code:
	private void handleSortTargetsSelected() {
		setSort(fSortButton.getSelection() ? SORT_NAME : SORT_NONE);
	}

#No. 3142
#File: E:\bishe\1\AbstractJSBUildFileTasksTab.java
#Comment:
	/**
	 * Sets the sorting of targets in this tab. See the sort constants defined
	 * above.
	 * 
	 * @param column
	 *            the column which should be sorted on
	 */

#Code:
	private void setSort(int column) {
		fSortDirection = column;
		fTableViewer.refresh();
		if (!fInitializing) {
			updateLaunchConfigurationDialog();
		}
	}

#No. 3143
#File: E:\bishe\1\AbstractJSBUildFileTasksTab.java
#Comment:
	/**
	 * The target order button has been pressed. Prompt the user to reorder the
	 * selected targets.
	 */

#Code:
	/*
	 * private void handleOrderPressed() { TargetOrderDialog dialog = new
	 * TargetOrderDialog(getShell(), fOrderedTargets.toArray(new
	 * ITask[fOrderedTargets.size()])); int ok = dialog.open(); if (ok ==
	 * Window.OK) { fOrderedTargets.clear(); Object[] targets =
	 * dialog.getTargets(); for (int i = 0; i < targets.length; i++) {
	 * fOrderedTargets.add((ITask) targets[i]); updateSelectionCount();
	 * updateLaunchConfigurationDialog(); } } }

#No. 3144
#File: E:\bishe\1\AbstractJSBUildFileTasksTab.java
#Comment:
	/**
	 * Return the number of rows available in the current display using the
	 * current font.
	 * 
	 * @param parent
	 *            The Composite whose Font will be queried.
	 * @return int The result of the display size divided by the font size.
	 */

#Code:
	private int availableRows(Composite parent) {

		int fontHeight = (parent.getFont().getFontData())[0].getHeight();
		int displayHeight = parent.getDisplay().getClientArea().height;

		return displayHeight / fontHeight;
	}

#No. 3145
#File: E:\bishe\1\AbstractJSBUildFileTasksTab.java
#Comment:
	/**
	 * Updates the ordered targets list in response to an element being checked
	 * or unchecked. When the element is checked, it's added to the list. When
	 * unchecked, it's removed.
	 * 
	 * @param element
	 *            the element in question
	 * @param checked
	 *            whether the element has been checked or unchecked
	 */

#Code:
	private void updateOrderedTargets(Object element, boolean checked) {
		if (checked) {
			fOrderedTargets.add((ITask) element);
		} else {
			fOrderedTargets.remove(element);
		}
		updateSelectionCount();
		updateLaunchConfigurationDialog();
	}

#No. 3146
#File: E:\bishe\1\AbstractJSBUildFileTasksTab.java
#Comment:
	/**
	 * Updates the selection count widget to display how many targets are
	 * selected (example, "1 out of 6 selected") and filtered.
	 */

#Code:
	private void updateSelectionCount() {
		Object[] checked = fTableViewer.getCheckedElements();
		String numSelected = Integer.toString(checked.length);

		int all = fAllTargets == null ? 0 : fAllTargets.length;
		int visible = fTableViewer.getTable().getItemCount();
		String total = Integer.toString(visible);
		int numHidden = all - visible;
		if (numHidden > 0) {
			fSelectionCountLabel.setText(MessageFormat.format(
					JSBuildFileLaunchConfigurationMessages.AntTargetsTab_13,
					new Object[] { numSelected, String.valueOf(all),
							String.valueOf(numHidden) }));
		} else {
			fSelectionCountLabel
					.setText(MessageFormat
							.format(JSBuildFileLaunchConfigurationMessages.AntTargetsTab__0__out_of__1__selected_7,
									new Object[] { numSelected, total }));
		}

		// fOrderButton.setEnabled(checked.length > 1);

		/*
		 * StringBuffer buffer = new StringBuffer(); Iterator<ITask> iter =
		 * fOrderedTargets.iterator(); while (iter.hasNext()) {
		 * buffer.append(iter.next().getName()); buffer.append(", ");
		 * //$NON-NLS-1$ } if (buffer.length() > 2) { // remove trailing comma
		 * buffer.setLength(buffer.length() - 2); }
		 * fTargetOrderText.setText(buffer.toString());
		 */
	}

#No. 3147
#File: E:\bishe\1\AbstractJSBUildFileTasksTab.java
#Comment:
		/*
		 * if (node.isErrorNode() || node.isWarningNode()) { String message =
		 * node.getProblemMessage(); if (message != null) {
		 * setErrorMessage(message); } else {
		 * setErrorMessage(JSBuildFileLaunchConfigurationMessages
		 * .AntTargetsTab_0); } }
		 */

#Code:
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * org.eclipse.debug.ui.ILaunchConfigurationTab#setDefaults(org.eclipse.
	 * debug.core.ILaunchConfigurationWorkingCopy)
	 */
	@Override
	public void setDefaults(ILaunchConfigurationWorkingCopy configuration) {
		// do nothing
	}

#No. 3148
#File: E:\bishe\1\AbstractJSBUildFileTasksTab.java
#Comment:
	/**
	 * Sets the execute table's input to the given input.
	 */

#Code:
	private void setExecuteInput(Object input) {
		fTableViewer.setInput(input);
		updateSelectionCount();
	}

#No. 3149
#File: E:\bishe\1\AbstractJSONEntityDecoder.java
#Comment:
/**
 * TODO JavaDoc
 *
 * @author Christian Autermann <autermann@uni-muenster.de>
 */

#Code:
public abstract class AbstractJSONEntityDecoder<T>
        extends AbstractJSONMessageBodyReader<T>
        implements JSONEntityDecoder<T> {
    private DateTimeFormatter dateTimeFormat;
    private EntityFactory entityFactory;

    public AbstractJSONEntityDecoder(Class<T> type) {
        super(type);
    }

    public EntityFactory getEntityFactory() {
        return entityFactory;
    }

    @Inject
    public void setEntityFactory(EntityFactory entityFactory) {
        this.entityFactory = entityFactory;
    }

    public DateTimeFormatter getDateTimeFormat() {
        return dateTimeFormat;
    }

    @Inject
    public void setDateTimeFormat(DateTimeFormatter dateTimeFormat) {
        this.dateTimeFormat = dateTimeFormat;
    }
}

#No. 3150
#File: E:\bishe\1\AbstractJSONEntityEncoder.java
#Comment:
/**
 * TODO JavaDoc
 *
 * @author Christian Autermann <autermann@uni-muenster.de>
 */

#Code:
public abstract class AbstractJSONEntityEncoder<T>
        extends AbstractJSONMessageBodyWriter<T>
        implements JSONEntityEncoder<T> {
    private JsonNodeFactory jsonFactory;
    private DateTimeFormatter dateTimeFormat;
    private Provider<AccessRights> rights;

    public AbstractJSONEntityEncoder(Class<T> classType) {
        super(classType);
    }

    public JsonNodeFactory getJsonFactory() {
        return jsonFactory;
    }

    @Inject
    public void setJsonFactory(JsonNodeFactory jsonFactory) {
        this.jsonFactory = jsonFactory;
    }

    public DateTimeFormatter getDateTimeFormat() {
        return dateTimeFormat;
    }

    @Inject
    public void setDateTimeFormat(DateTimeFormatter dateTimeFormat) {
        this.dateTimeFormat = dateTimeFormat;
    }

    @Inject
    public void setRights(Provider<AccessRights> rights) {
        this.rights = rights;
    }

    @Override
    public ObjectNode encodeJSON(T t, MediaType mt) {
        return encodeJSON(t, rights.get(), mt);
    }
}

#No. 3151
#File: E:\bishe\1\AbstractJSONMessageBodyWriter.java
#Comment:
/**
 * TODO JavaDoc
 *
 * @author Christian Autermann <autermann@uni-muenster.de>
 */

#Code:
@Produces(MediaType.APPLICATION_JSON)
public abstract class AbstractJSONMessageBodyWriter<T>
        implements MessageBodyWriter<T>, JSONEntityEncoder<T> {
    @Inject
    private ObjectWriter writer;
    private final Class<T> classType;

    public AbstractJSONMessageBodyWriter(Class<T> classType) {
        this.classType = classType;
    }

    @Override
    public boolean isWriteable(Class<?> type, Type genericType,
                               Annotation[] annotations, MediaType mediaType) {
        return this.classType.isAssignableFrom(type) &&
               mediaType.isCompatible(MediaType.APPLICATION_JSON_TYPE);
    }

    @Override
    public void writeTo(T t, Class<?> c, Type gt, Annotation[] a, MediaType mt,
                        MultivaluedMap<String, Object> h,
                        OutputStream out) throws IOException,
                                                 WebApplicationException {
        writer.writeValue(out, encodeJSON(t, mt));
        out.flush();
    }

    @Override
    public long getSize(T t, Class<?> type, Type genericType,
                        Annotation[] annotations, MediaType mediaType) {
        return -1;
    }

    public abstract ObjectNode encodeJSON(T t, MediaType mt);
}

#No. 3152
#File: E:\bishe\1\AbstractJSONMovieParser.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    protected boolean isDataValid(final String data) {
        return super.isDataValid(data) && !"".equals(data);
    }

#No. 3153
#File: E:\bishe\1\AbstractJsonNodeTest.java
#Comment:
    /**
     * Load resource as json document.
     *
     * @param resourceName
     * @return the root json node
     * @throws IOException
     */

#Code:
    public static final JsonNode loadJsonNode(String resourceName) throws IOException {
        return JsonUtils.json(loadResource(resourceName), true);
    }

#No. 3154
#File: E:\bishe\1\AbstractJsonNodeTest.java
#Comment:
    /**
     * Load contents of resource on classpath as String using the currentThreads
     * {@link ClassLoader}.
     *
     * @param resourceName - path to resource
     * @return the resource as a String
     * @throws IOException
     */

#Code:
    public static final String loadResource(String resourceName) throws IOException {
        return loadResource(resourceName, Thread.currentThread().getContextClassLoader());
    }

#No. 3155
#File: E:\bishe\1\AbstractJsonNodeTest.java
#Comment:
    /**
     * Loads contents of resource on classpath as String using the passed in
     * {@link ClassLoader}.
     *
     * @param resourceName - path to resource
     * @param loader - {@link ClassLoader} to use
     * @return the resource as a String
     * @throws IOException
     */

#Code:
    public static final String loadResource(String resourceName, ClassLoader loader) throws IOException {
        try (InputStream is = loader.getResourceAsStream(resourceName)) {
            if (null == is) {
                throw new FileNotFoundException(resourceName);
            }
            return loadResource(is);
        }
    }

#No. 3156
#File: E:\bishe\1\AbstractJsonNodeTest.java
#Comment:
    /**
     * Loads contents of resource on classpath as String using the passed in
     * {@link Class}.
     *
     * @param resourceName
     * @param loader - {@link Class} to use.
     * @return the resource as a String
     * @throws IOException
     */

#Code:
    public static final String loadResource(String resourceName, Class<?> loader) throws IOException {
        try (InputStream is = loader.getResourceAsStream(resourceName)) {
            if (null == is) {
                throw new FileNotFoundException(resourceName);
            }
            return loadResource(is);
        }
    }

#No. 3157
#File: E:\bishe\1\AbstractJsonProvider.java
#Comment:
    /**
     * checks if object is an array
     *
     * @param obj object to check
     * @return true if obj is an array
     */

#Code:
    public boolean isArray(Object obj) {
        return (obj instanceof List);
    }

#No. 3158
#File: E:\bishe\1\AbstractJsonProvider.java
#Comment:
    /**
     * Extracts a value from an array
     *
     * @param obj an array
     * @param idx index
     * @return the entry at the given index
     */

#Code:
    public Object getArrayIndex(Object obj, int idx) {
        return ((List) obj).get(idx);
    }

#No. 3159
#File: E:\bishe\1\AbstractJsonProvider.java
#Comment:
    /**
     * Extracts a value from an map
     *
     * @param obj a map
     * @param key property key
     * @return the map entry or {@link com.jayway.jsonpath.spi.json.JsonProvider#UNDEFINED} for missing properties
     */

#Code:
    public Object getMapValue(Object obj, String key){
        Map m = (Map) obj;
        if(!m.containsKey(key)){
            return JsonProvider.UNDEFINED;
        } else {
            return m.get(key);
        }
    }

#No. 3160
#File: E:\bishe\1\AbstractJsonProvider.java
#Comment:
    /**
     * Sets a value in an object
     *
     * @param obj   an object
     * @param key   a String key
     * @param value the value to set
     */

#Code:
    @SuppressWarnings("unchecked")
    public void setProperty(Object obj, Object key, Object value) {
        if (isMap(obj))
            ((Map) obj).put(key.toString(), value);
        else {
            throw new JsonPathException("setProperty operation cannot be used with " + obj!=null?obj.getClass().getName():"null");
        }
    }

#No. 3161
#File: E:\bishe\1\AbstractJsonProvider.java
#Comment:
    /**
     * Removes a value in an object or array
     *
     * @param obj   an array or an object
     * @param key   a String key or a numerical index to remove
     */

#Code:
    @SuppressWarnings("unchecked")
    public void removeProperty(Object obj, Object key) {
        if (isMap(obj))
            ((Map) obj).remove(key.toString());
        else {
            List list = (List) obj;
            int index = key instanceof Integer ? (Integer) key : Integer.parseInt(key.toString());
            list.remove(index);
        }
    }

#No. 3162
#File: E:\bishe\1\AbstractJsonProvider.java
#Comment:
    /**
     * checks if object is a map (i.e. no array)
     *
     * @param obj object to check
     * @return true if the object is a map
     */

#Code:
    public boolean isMap(Object obj) {
        return (obj instanceof Map);
    }

#No. 3163
#File: E:\bishe\1\AbstractJsonProvider.java
#Comment:
    /**
     * Returns the keys from the given object
     *
     * @param obj an object
     * @return the keys for an object
     */

#Code:
    @SuppressWarnings("unchecked")
    public Collection<String> getPropertyKeys(Object obj) {
        if (isArray(obj)) {
          throw new UnsupportedOperationException();
        } else {
            return ((Map) obj).keySet();
        }
    }

#No. 3164
#File: E:\bishe\1\AbstractJsonProvider.java
#Comment:
    /**
     * Get the length of an array or object
     *
     * @param obj an array or an object
     * @return the number of entries in the array or object
     */

#Code:
    public int length(Object obj) {
        if (isArray(obj)) {
            return ((List) obj).size();
        } else if (isMap(obj)){
            return getPropertyKeys(obj).size();
        } else if(obj instanceof String){
            return ((String)obj).length();
        }
        throw new JsonPathException("length operation cannot be applied to " + obj!=null?obj.getClass().getName():"null");
    }

#No. 3165
#File: E:\bishe\1\AbstractJsonProvider.java
#Comment:
    /**
     * Converts given array to an {@link Iterable}
     *
     * @param obj an array
     * @return an Iterable that iterates over the entries of an array
     */

#Code:
    @SuppressWarnings("unchecked")
    public Iterable<? extends Object> toIterable(Object obj) {
        if (isArray(obj))
            return ((Iterable) obj);
        else
            throw new JsonPathException("Cannot iterate over " + obj!=null?obj.getClass().getName():"null");
    }

#No. 3166
#File: E:\bishe\1\AbstractJsonSchemaTest.java
#Comment:
    /**
     * Validate the given resource is a valid json schema.
     *
     * @param schemaResourceName
     * @throws ProcessingException
     * @throws IOException
     */

#Code:
    public void validateSchema(String schemaResourceName) throws ProcessingException, IOException {
        JsonUtils.loadSchema(schemaResourceName);
    }

#No. 3167
#File: E:\bishe\1\AbstractJsonSchemaTest.java
#Comment:
    /**
     * Verify the given document does not validate against the given schema.
     *
     * @param schemaResourceName
     * @param documentResourceName
     * @throws IOException
     * @throws ProcessingException
     */

#Code:
    public void runInvalidJsonTest(String schemaResourceName, String documentResourceName) throws IOException, ProcessingException {
        JsonSchema schema = JsonUtils.loadSchema(schemaResourceName);

        JsonNode instance = loadJsonNode(documentResourceName);

        ProcessingReport report = schema.validate(instance);
        Assert.assertFalse("Expected validation to fail!", report.isSuccess());
    }

#No. 3168
#File: E:\bishe\1\AbstractJsonSchemaTest.java
#Comment:
    /**
     * Verify the given document validates against the given schema.
     *
     * @param schemaResourceName
     * @param documentResourceName
     * @throws IOException
     * @throws ProcessingException
     */

#Code:
    public void runValidJsonTest(String schemaResourceName, String documentResourceName) throws IOException, ProcessingException {
        JsonSchema schema = JsonUtils.loadSchema(schemaResourceName);

        JsonNode instance = loadJsonNode(documentResourceName);

        // if report isn't null it's a failure and the value of report is the detail of why
        String report = JsonUtils.jsonSchemaValidation(schema, instance);
        if (report != null) {
            Assert.fail("Expected validation to succeed! Resource: " + documentResourceName + " Messages: " + report.replaceAll("\n", " "));
        }
    }

#No. 3169
#File: E:\bishe\1\AbstractJspTestCase.java
#Comment:
    /**
     * @param name
     */

#Code:
    public AbstractJspTestCase(String name) {
        super(name);
    }

#No. 3170
#File: E:\bishe\1\AbstractJTAEntityManagerTest.java
#Comment:
    /**
     * Entity manager is a "JTA entity manager". Use of {@code
     * EntityManager.getTransaction()} is forbidden.
     * 
     * @throws Throwable hopefully
     */

#Code:
    @Test(expected = IllegalStateException.class)
    public void JTAEntityManagerMustNotUseResourceLocalTransaction() throws Throwable {
        try {
            getBeanBeingTested().accept(EntityManager::getTransaction);
        }
        catch (EJBException e) {
            throw e.getCause();
        }
    }

#No. 3171
#File: E:\bishe\1\AbstractJUnitLaunchConfigurationDelegate.java
#Comment:
    /**
     * Extracts the test class names from the RemoteTestRunner arguments. Also
     * converts -testnamefile arguments to -classNames since the file with the
     * test names will not be available if we launch on a device.
     */

#Code:
    @SuppressWarnings("unchecked")
    private void processArgs(String[] args) throws CoreException {
        List<String> classes = new ArrayList<>();
        List<String> modifiedArgs = new ArrayList<>();
        for (int i = 0; i < args.length; i++) {
            String arg = args[i].toLowerCase();
            if ("-test".equals(arg)) {
                // -test <class>:<method>
                String v = args[++i];
                classes.add(v.substring(0, v.indexOf(':')));
                modifiedArgs.add("-test");
                modifiedArgs.add(v);
            } else if ("-classnames".equals(arg) || "-classname".equals(arg)) {
                // -classnames <class1> <class2> ...
                i++;
                while (i < args.length && args[i].charAt(0) != '-') {
                    classes.add(args[i++]);
                }
                modifiedArgs.add("-classNames");
                modifiedArgs.addAll(classes);
            } else if ("-testnamefile".equals(arg)) {
                try {
                    classes.addAll((List<String>) FileUtils.readLines(new File(args[++i])));
                } catch (IOException e) {
                    throw new CoreException(new Status(IStatus.ERROR, RoboVMPlugin.PLUGIN_ID, "", e));
                }
                // Convert to -classNames <class1> <class2> ...
                modifiedArgs.add("-classNames");
                modifiedArgs.addAll(classes);
            } else {
                modifiedArgs.add(args[i]);
            }
        }
        this.runnerProgramArgs = modifiedArgs.toArray(new String[modifiedArgs.size()]);
        this.testClasses = classes.toArray(new String[classes.size()]);
    }

#No. 3172
#File: E:\bishe\1\AbstractJWTFilter.java
#Comment:
  /**
   * 
   */

#Code:
  public AbstractJWTFilter() {
    super();
  }

#No. 3173
#File: E:\bishe\1\AbstractJWTFilter.java
#Comment:
  /**
   * @param expectedAudiences
   * @return
   */

#Code:
  protected List<String> parseExpectedAudiences(String expectedAudiences) {
    ArrayList<String> audList = null;
    // setup the list of valid audiences for token validation
    if (expectedAudiences != null) {
      // parse into the list
      String[] audArray = expectedAudiences.split(",");
      audList = new ArrayList<String>();
      for (String a : audArray) {
        audList.add(a);
      }
    }
    return audList;
  }

#No. 3174
#File: E:\bishe\1\AbstractJWTFilter.java
#Comment:
  /**
   * Validate whether any of the accepted audience claims is present in the
   * issued token claims list for audience. Override this method in subclasses
   * in order to customize the audience validation behavior.
   *
   * @param jwtToken
   *          the JWT token where the allowed audiences will be found
   * @return true if an expected audience is present, otherwise false
   */

#Code:
  protected boolean validateAudiences(JWTToken jwtToken) {
    boolean valid = false;
    
    String[] tokenAudienceList = jwtToken.getAudienceClaims();
    // if there were no expected audiences configured then just
    // consider any audience acceptable
    if (audiences == null) {
      valid = true;
    } else {
      // if any of the configured audiences is found then consider it
      // acceptable
      if (tokenAudienceList != null) {
        for (String aud : tokenAudienceList) {
          if (audiences.contains(aud)) {
            log.jwtAudienceValidated();
            valid = true;
            break;
          }
        }
      }
    }
    return valid;
  }

#No. 3175
#File: E:\bishe\1\AbstractKafkaAvroDeserializer.java
#Comment:
	/**
	 * Sets properties for this deserializer without overriding the schema
	 * registry client itself. Useful for testing, where a mock client is
	 * injected.
	 */

#Code:
	protected void configureNonClientProperties(KafkaAvroDeserializerConfig config) {
		useSpecificAvroReader = config.getBoolean(KafkaAvroDeserializerConfig.SPECIFIC_AVRO_READER_CONFIG);
	}

#No. 3176
#File: E:\bishe\1\AbstractKerberosITest.java
#Comment:
    /**
     * Obtains a TGT and service tickets for the user.
     * Also makes some assertions on the received tickets.
     *
     * @param encryptionType the encryption type to use
     * @throws Exception
     */

#Code:
    protected void testObtainTickets( ObtainTicketParameters parameters ) throws Exception
    {
        setupEnv( parameters );
        Subject subject = new Subject();

        KerberosTestUtils.obtainTGT( subject, USER_UID, USER_PASSWORD );

        assertEquals( 1, subject.getPrivateCredentials().size() );
        assertEquals( 0, subject.getPublicCredentials().size() );

        KerberosTestUtils.obtainServiceTickets( subject, USER_UID, LDAP_SERVICE_NAME, HOSTNAME );

        assertEquals( 2, subject.getPrivateCredentials().size() );
        assertEquals( 0, subject.getPublicCredentials().size() );
        
        for ( KerberosTicket kt : subject.getPrivateCredentials( KerberosTicket.class ) )
        {
            // System.out.println( kt.getClient() );
            // System.out.println( kt.getServer() );
            // System.out.println( kt.getSessionKeyType() );
            assertEquals( parameters.encryptionType.getValue(), kt.getSessionKeyType() );
        }
    }

#No. 3177
#File: E:\bishe\1\AbstractKerberosITest.java
#Comment:
    /**
     * Creates the krb5.conf file for the test.
     * 
     * It looks similar to this:
     * 
     * <pre>
     * [libdefaults]
     *     default_realm = EXAMPLE.COM
     *     default_tkt_enctypes = aes256-cts-hmac-sha1-96
     *     default_tgs_enctypes = aes256-cts-hmac-sha1-96
     *     permitted_enctypes = aes256-cts-hmac-sha1-96
     * 
     * [realms]
     *     EXAMPLE.COM = {
     *         kdc = localhost:6088
     *     }
     * 
     * [domain_realm]
     *     .example.com = EXAMPLE.COM
     *     example.com = EXAMPLE.COM
     * </pre>
     *
     * @param encryptionType
     * @param checksumType
     * @return the path to the krb5.conf file
     * @throws IOException
     */

#Code:
    private String createKrb5Conf( ChecksumType checksumType, EncryptionType encryptionType, boolean isTcp ) throws IOException
    {
        File file = folder.newFile( "krb5.conf" );

        String data = "";

        data += "[libdefaults]" + SystemUtils.LINE_SEPARATOR;
        data += "default_realm = " + REALM + SystemUtils.LINE_SEPARATOR;
        data += "default_tkt_enctypes = " + encryptionType.getName() + SystemUtils.LINE_SEPARATOR;
        data += "default_tgs_enctypes = " + encryptionType.getName() + SystemUtils.LINE_SEPARATOR;
        data += "permitted_enctypes = " + encryptionType.getName() + SystemUtils.LINE_SEPARATOR;
        //        data += "default_checksum = " + checksumType.getName() + SystemUtils.LINE_SEPARATOR;
        //        data += "ap_req_checksum_type = " + checksumType.getName() + SystemUtils.LINE_SEPARATOR;
        data += "default-checksum_type = " + checksumType.getName() + SystemUtils.LINE_SEPARATOR;
        
        if ( isTcp )
        {
            data += "udp_preference_limit = 1" + SystemUtils.LINE_SEPARATOR;
        }
            

        data += "[realms]" + SystemUtils.LINE_SEPARATOR;
        data += REALM + " = {" + SystemUtils.LINE_SEPARATOR;
        data += "kdc = " + HOSTNAME + ":" + kdcServer.getTransports()[0].getPort() + SystemUtils.LINE_SEPARATOR;
        data += "}" + SystemUtils.LINE_SEPARATOR;

        data += "[domain_realm]" + SystemUtils.LINE_SEPARATOR;
        data += "." + Strings.toLowerCaseAscii( REALM ) + " = " + REALM + SystemUtils.LINE_SEPARATOR;
        data += Strings.toLowerCaseAscii( REALM ) + " = " + REALM + SystemUtils.LINE_SEPARATOR;

        FileUtils.writeStringToFile( file, data );

        return file.getAbsolutePath();
    }

#No. 3178
#File: E:\bishe\1\AbstractKeyboard.java
#Comment:
    /**
     * Bind a KeyCombination to a callback function.
     * @param keyCombination keyCombination
     * @param combinationCallback callback
     */

#Code:
    protected void putCombination(KeyCombination keyCombination, CombinationCallback combinationCallback){
        synchronized (combinations){
            if(!combinations.containsKey(keyCombination)){
                combinations.put(keyCombination, new HashSet<>());
            }
            synchronized (combinations.get(keyCombination)){
                combinations.get(keyCombination).add(combinationCallback);
            }
        }
    }

#No. 3179
#File: E:\bishe\1\AbstractKeyboard.java
#Comment:
    /**
     * Bind a KeyStroke to a callback function.
     * @param keyStroke keyStroke
     * @param keyboardCallback callback
     */

#Code:
    protected void putAction(KeyStroke keyStroke, KeyboardCallback keyboardCallback){
        synchronized (actions) {
            if (!actions.containsKey(keyStroke)) {
                actions.put(keyStroke, new HashSet<>());
            }
            synchronized (actions.get(keyStroke)) {
                actions.get(keyStroke).add(keyboardCallback);
            }
        }
    }

#No. 3180
#File: E:\bishe\1\AbstractKeyboard.java
#Comment:
    /**
     * Clean combinations
     * @param keyCombination keyCombination
     */

#Code:
    protected void removeAllCombinations(KeyCombination keyCombination){
        synchronized (combinations){
            if(combinations.containsKey(keyCombination)){
                combinations.remove(keyCombination);
            }
        }
    }

#No. 3181
#File: E:\bishe\1\AbstractKeyboard.java
#Comment:
    /**
     * clean keystrokes.
     * @param keyStroke keyStroke
     */

#Code:
    protected void removeAllActions(KeyStroke keyStroke){
        synchronized (actions) {
            if (actions.containsKey(keyStroke)) {
                actions.remove(keyStroke);
            }
        }
    }

#No. 3182
#File: E:\bishe\1\AbstractKeyboard.java
#Comment:
    /**
     * remove a single combination.
     * @param keyCombination keyCombination
     * @param combinationCallback callback
     */

#Code:
    protected  void removeCombination(KeyCombination keyCombination, CombinationCallback combinationCallback){
        synchronized (combinations){
            if(combinations.containsKey(keyCombination) && combinations.get(keyCombination).contains(combinationCallback)){
                synchronized (combinations.get(keyCombination)){
                    combinations.get(keyCombination).remove(combinationCallback);
                }
            }
        }
    }

#No. 3183
#File: E:\bishe\1\AbstractKeyboard.java
#Comment:
    /**
     * remove a single action.
     * @param keyStroke keyStroke
     * @param keyboardCallback callback
     */

#Code:
    protected void removeAction(KeyStroke keyStroke, KeyboardCallback keyboardCallback){
        synchronized (actions) {
            if (actions.containsKey(keyStroke) && actions.get(keyStroke).contains(keyboardCallback)) {
                synchronized (actions.get(keyStroke)) {
                    actions.get(keyStroke).remove(keyboardCallback);
                }
            }
        }
    }

#No. 3184
#File: E:\bishe\1\AbstractKeyboard.java
#Comment:
    /**
     * Get the current pressed keystroke.
     * @return current keyStroke
     */

#Code:
    public KeyStroke getCurrentKeyStroke() {
        return currentKeyStroke;
    }

#No. 3185
#File: E:\bishe\1\AbstractKeyboard.java
#Comment:
    /**
     * Set the current pressed keys.
     * @param currentKeyStroke currentKeyStroke
     */

#Code:
    public void setCurrentKeyStroke(KeyStroke currentKeyStroke) {
        this.currentKeyStroke = currentKeyStroke;
    }

#No. 3186
#File: E:\bishe\1\AbstractKeyboard.java
#Comment:
    /**
     * Key Up Listener for a node or scene.
     * @param keyEvent keyEvent
     */

#Code:
    public void setKeyUpEvent(KeyEvent keyEvent){
        synchronized (currentKeyStroke) {
            if(keyEvent.isAltDown()){
                currentKeyStroke.removeKey(KeyCode.ALT);
            }
            if(keyEvent.isControlDown()){
                currentKeyStroke.removeKey(KeyCode.CONTROL);
            }
            if(keyEvent.isShiftDown()){
                currentKeyStroke.removeKey(KeyCode.SHIFT);
            }
            if(keyEvent.isShortcutDown()){
                currentKeyStroke.removeKey(KeyCode.SHORTCUT);
            }
            currentKeyStroke.removeKey(keyEvent.getCode());
        }
    }

#No. 3187
#File: E:\bishe\1\AbstractKeyboard.java
#Comment:
    /**
     * Create a new currentKeyStroke instance.
     */

#Code:
    public void resetKeyStroke(){
        currentKeyStroke = new KeyStroke();
    }

#No. 3188
#File: E:\bishe\1\AbstractKeyConverter.java
#Comment:
    /**
     * Convert list of KeyValueValorisation to list of KeyValueValorisationData.
     * @param list input
     * @return output
     */

#Code:
    protected Set<KeyValueValorisationData> toListKeyValueValorisationData(final Set<KeyValueValorisation> list) {
        Set<KeyValueValorisationData> newList = new HashSet<>(list.size());

        for (KeyValueValorisation kv : list) {
            newList.add(getKeyConverter().toKeyValueValorisationData(kv));
        }

        return newList;
    }

#No. 3189
#File: E:\bishe\1\AbstractKeyConverter.java
#Comment:
    /**
     * Convert list of KeyValueValorisationData to list of KeyValueValorisation.
     * @param list input
     * @return output
     */

#Code:
    protected Set<KeyValueValorisation> toListKeyValueValorisation(final Set<KeyValueValorisationData> list) {
        Set<KeyValueValorisation> newList = new HashSet<>(list.size());

        for (KeyValueValorisationData kv : list) {
            newList.add(getKeyConverter().toKeyValueValorisation(kv));
        }

        return newList;
    }

#No. 3190
#File: E:\bishe\1\AbstractKeyMaxValueIncrementer.java
#Comment:
	/**
	 * Set the name of the Key.
	 */

#Code:
	public void setKeyName(String keyName) {
		this.keyName = keyName;
	}

#No. 3191
#File: E:\bishe\1\AbstractKeyMaxValueIncrementer.java
#Comment:
	/**
	 * Return the name of the Key.
	 */

#Code:
	public String getKeyName() {
		return this.keyName;
	}

#No. 3192
#File: E:\bishe\1\AbstractKeyMaxValueIncrementer.java
#Comment:
	/**
	 * Set the number of buffered keys.
	 */

#Code:
	public void setCacheSize(int cacheSize) {
		this.cacheSize = cacheSize;
	}

#No. 3193
#File: E:\bishe\1\AbstractKeyMaxValueIncrementer.java
#Comment:
	/**
	 * Return the number of buffered keys.
	 */

#Code:
	public int getCacheSize() {
		return this.cacheSize;
	}

#No. 3194
#File: E:\bishe\1\AbstractKeyMaxValueIncrementer.java
#Comment:
	/**
	 * 获取步进。
	 */

#Code:
	public long getStep() {
		return step;
	}

#No. 3195
#File: E:\bishe\1\AbstractKeyMaxValueIncrementer.java
#Comment:
	/**
	 * 设置步进。
	 */

#Code:
	public void setStep(long step) {
		this.step = step;
	}

#No. 3196
#File: E:\bishe\1\AbstractKMeansEvaluation.java
#Comment:
  /**
   * @param evalData points to cluster for evaluation
   * @return cluster IDs as keys, and metrics for each cluster like the count, sum of distances to centroid,
   *  and sum of squared distances
   */

#Code:
  JavaPairRDD<Integer,ClusterMetric> fetchClusterMetrics(JavaRDD<Vector> evalData) {
    return evalData.mapToPair(vector -> {
      double closestDist = Double.POSITIVE_INFINITY;
      int minClusterID = Integer.MIN_VALUE;
      double[] vec = vector.toArray();
      for (ClusterInfo cluster : clusters.values()) {
        double distance = distanceFn.applyAsDouble(cluster.getCenter(), vec);
        if (distance < closestDist) {
          closestDist = distance;
          minClusterID = cluster.getID();
        }
      }
      Preconditions.checkState(!Double.isInfinite(closestDist) && !Double.isNaN(closestDist));
      return new Tuple2<>(minClusterID, new ClusterMetric(1L, closestDist, closestDist * closestDist));
    }).reduceByKey(ClusterMetric::add);
  }

#No. 3197
#File: E:\bishe\1\AbstractKnapsack.java
#Comment:
	/**
	 * @param items items to be entered into the knapsack.
	 * @param maxWeight the maximum weight that the knapsack can hold.
	 * @return a list of items maximizing the total value given {@code items} and {@code maxWeight}.
	 */

#Code:
	public abstract List<KnapsackItem> solve(KnapsackItem[] items, int maxWeight);
	
	/** @return the total value of the specific items. */
	protected int getTotalValue(Collection<KnapsackItem> items)
	{
		int total = 0;
		
		for (KnapsackItem item : items)
			total += item.getValue();
		
		return total;
	}

#No. 3198
#File: E:\bishe\1\AbstractLabel.java
#Comment:
	/**
	 * Returns a server name.
	 * 
	 * @return Server name
	 */

#Code:
	public String getName() {
		return name;
	}

#No. 3199
#File: E:\bishe\1\AbstractLabel.java
#Comment:
	/**
	 * Returns a server state.
	 * 
	 * @return Server state
	 */

#Code:
	public ServerState getState() {
		return state;
	}

#No. 3200
#File: E:\bishe\1\AbstractLabel.java
#Comment:
	/**
	 * Returns a server publish state.
	 * 
	 * @return Server publish state
	 */

#Code:
	public ServerPublishState getPublishState() {
		return status;
	}

#No. 3201
#File: E:\bishe\1\AbstractLatencyMetricsCollector.java
#Comment:
    /**
     * Helper method to remove an item out of the stored metrics.
     */

#Code:
    protected void remove(I identifier) {
        LatencyStats removed = latencyMetrics.remove(identifier);
        if (removed != null) {
            try {
                removed.stop();
            } catch (Exception ex) {
                LOGGER.warn("Caught exception while removing LatencyStats, moving on.", ex);
            }
        }
    }

#No. 3202
#File: E:\bishe\1\AbstractLatencyScoreStrategyImpl.java
#Comment:
    /**
     * 
     * @param name
     * @param updateInterval    In milliseconds
     * @param resetInterval     In milliseconds
     */

#Code:
    public AbstractLatencyScoreStrategyImpl(String name, int updateInterval, int resetInterval, int blockedThreshold, double keepRatio, double scoreThreshold) {
        this(name, updateInterval, resetInterval, blockedThreshold, keepRatio, scoreThreshold, Executors.newScheduledThreadPool(1, new ThreadFactoryBuilder().setDaemon(true).build()));
        bOwnedExecutor = true;
    }

#No. 3203
#File: E:\bishe\1\AbstractLatencyScoreStrategyImpl.java
#Comment:
    /**
     * Comparator used to sort hosts by score
     */

#Code:
    private Comparator<HostConnectionPool<?>> scoreComparator = new Comparator<HostConnectionPool<?>>() {
        @Override
        public int compare(HostConnectionPool<?> p1, HostConnectionPool<?> p2) {
            double score1 = p1.getScore();
            double score2 = p2.getScore();
            if (score1 < score2) {
                return -1;
            }
            else if (score1 > score2) {
                return 1;
            }
            return 0;
        }
    };

#No. 3204
#File: E:\bishe\1\AbstractLatencyScoreStrategyImpl.java
#Comment:
    /**
     * Comparator used to sort hosts by number of buys + blocked operations
     */

#Code:
    private Comparator<HostConnectionPool<?>> busyComparator = new Comparator<HostConnectionPool<?>>() {
        @Override
        public int compare(HostConnectionPool<?> p1, HostConnectionPool<?> p2) {
            return p1.getBusyConnectionCount() + p1.getBlockedThreadCount() - p2.getBusyConnectionCount() - p2.getBlockedThreadCount();
        }
    };

#No. 3205
#File: E:\bishe\1\AbstractLayer.java
#Comment:
  /**
   * Updates the renderer (using the given {@link UpdateType}), with then given set of
   * UI elements.  Depending on the value of {@link UpdateType}, current sources will
   * either have their state updated, or will be overwritten by the given set
   * of UI elements.
   */

#Code:
  protected void redraw(
      final ArrayList<TextSource> textSources,
      final ArrayList<PointSource> pointSources,
      final ArrayList<LineSource> lineSources,
      final ArrayList<ImageSource> imageSources,
      EnumSet<UpdateType> updateTypes) {

    // Log.d(TAG, getLayerName() + " Updating renderer: " + updateTypes);
    if (renderer == null) {
      Log.w(TAG, "Renderer not set - aborting: " + this.getClass().getSimpleName());
      return;
    }

    renderMapLock.lock();
    try {
      // Blog.d(this, "Redraw: " + updateTypes);
      AtomicSection atomic = renderer.createAtomic();
      setSources(textSources, updateTypes, TextSource.class, atomic);
      setSources(pointSources, updateTypes, PointSource.class, atomic);
      setSources(lineSources, updateTypes, LineSource.class, atomic);
      setSources(imageSources, updateTypes, ImageSource.class, atomic);
      renderer.queueAtomic(atomic);
    } finally {
      renderMapLock.unlock();
    }
  }

#No. 3206
#File: E:\bishe\1\AbstractLayer.java
#Comment:
  /**
   * Sets the objects on the {@link RenderManager} to the given values,
   * creating (or disabling) the {@link RenderManager} if necessary.
   */

#Code:
  private <E> void setSources(ArrayList<E> sources, EnumSet<UpdateType> updateType,
      Class<E> clazz, AtomicSection atomic) {

    @SuppressWarnings("unchecked")
    RenderManager<E> manager = (RenderManager<E>) renderMap.get(clazz);
    if (sources == null || sources.isEmpty()) {
      if (manager != null) {
        // TODO(brent): we should really just disable this layer, but in a
        // manner that it will automatically be reenabled when appropriate.
        Blog.d(this, "       " + clazz.getSimpleName());
        manager.queueObjects(Collections.<E>emptyList(), updateType, atomic);
      }
      return;
    }

    if (manager == null) {
      manager = createRenderManager(clazz, atomic);
      renderMap.put(clazz, manager);
    }
    // Blog.d(this, "       " + clazz.getSimpleName() + " " + sources.size());
    manager.queueObjects(sources, updateType, atomic);
  }

#No. 3207
#File: E:\bishe\1\AbstractLayer.java
#Comment:
  /**
   * Return an internationalized string from a string resource id.
   */

#Code:
  protected String getStringFromId(int resourceId) {
    return resources.getString(resourceId);
  }

#No. 3208
#File: E:\bishe\1\AbstractLayerDelegator.java
#Comment:
	/**
	 * Copy the changed properties between layers, by calling the getters of the
	 * from layer and the setters on the to layer.
	 * 
	 * @param from
	 *            Layer to get property values from
	 * @param to
	 *            Layer to set property values on
	 */

#Code:
	private void copyProperties(Layer from, Layer to)
	{
		if (from == to)
		{
			return;
		}

		synchronized (propertiesChanged)
		{
			setPropertiesChangedTrackingEnabled(false);
			for (String property : propertiesChanged)
			{
				try
				{
					PropertyDescriptor fromPropertyDescriptor = new PropertyDescriptor(property, from.getClass());
					PropertyDescriptor toPropertyDescriptor = new PropertyDescriptor(property, to.getClass());
					Method getter = fromPropertyDescriptor.getReadMethod();
					Method setter = toPropertyDescriptor.getWriteMethod();
					Object value = getter.invoke(from);
					setter.invoke(to, value);
				}
				catch (IntrospectionException e)
				{
					//ignore (invalid property name)
				}
				catch (Exception e)
				{
					logger.error("Error copying value between layers for property: " + property, e); //$NON-NLS-1$
				}
			}
			setPropertiesChangedTrackingEnabled(true);
		}
	}

#No. 3209
#File: E:\bishe\1\AbstractLayoutParameterVisitor.java
#Comment:
        /*console(layout.getDepth(), "layout:" + layout.getClass().getSimpleName() + "| content:" );
        consoleln(0, layout.getModel().getChildren().toString());
        layout.getModel().refreshBounds(false);*/

#Code:
        if(layout instanceof HierarchicalGraphLayout){
            editForceAtlas( ((HierarchicalGraphLayout)layout).getDelegate() );
        }

#No. 3210
#File: E:\bishe\1\AbstractLCS.java
#Comment:
	/**
	 * @param a the first string.
	 * @param b the second string.
	 * @return a longest common sequence of the specific strings {@code a} and {@code b}.
	 */

#Code:
	public String solve(String a, String b)
	{
		return solve(a.toCharArray(), b.toCharArray(), a.length()-1, b.length()-1);
	}

#No. 3211
#File: E:\bishe\1\AbstractLdapServer.java
#Comment:
    /**
     * Method to return the max number of results allowed.
     * @return the maximum number of results.
     */

#Code:
    protected int getMaxNumberResults() {
        return this.maxNumberResults;
    }

#No. 3212
#File: E:\bishe\1\AbstractLdapServer.java
#Comment:
    /**
     * Method to return the scope.
     * @return the scope
     */

#Code:
    protected int getScope() {
        return this.scope;
    }

#No. 3213
#File: E:\bishe\1\AbstractLdapServer.java
#Comment:
    /**
     * Method to return the timeout. 
     * @return the timeout.
     */

#Code:
    protected int getTimeout() {
        return this.timeout;
    }

#No. 3214
#File: E:\bishe\1\AbstractLdapServer.java
#Comment:
    /**
     * @param maxNumberResults The maxNumberResults to set.
     */

#Code:
    public final void setMaxNumberResults(final int maxNumberResults) {
        this.maxNumberResults = maxNumberResults;
    }

#No. 3215
#File: E:\bishe\1\AbstractLdapServer.java
#Comment:
    /**
     * @param timeout The timeout to set.
     */

#Code:
    public final void setTimeout(final int timeout) {
        this.timeout = timeout;
    }

#No. 3216
#File: E:\bishe\1\AbstractLeafletLayerConnector.java
#Comment:
            /* Doing ugly jsni hack, to avoid limiation in GWT (only one JSO can
             implement interface methods) */

#Code:
            @Override
            public void bringToFront() {
                jsniBringToFront(getLayer());
            }

#No. 3217
#File: E:\bishe\1\AbstractLeafletLayerConnector.java
#Comment:
    /**
     * Returns the map from the root of the hierarchy *
     */

#Code:
    public Map getMap() {
        LeafletMapConnector leafletMapConnector = getLeafletMapConnector();
        if (leafletMapConnector != null) {
            return leafletMapConnector.getMap();
        }
        return null;
    }

#No. 3218
#File: E:\bishe\1\AbstractLeafletLayerConnector.java
#Comment:
    /**
     * @return the pixel position of the map
     */

#Code:
    public Point getMapPixelPosition() {
        final LeafletMapConnector leafletMapConnector = getLeafletMapConnector();
        return leafletMapConnector.getMapPixelPosition();
    }

#No. 3219
#File: E:\bishe\1\AbstractLease.java
#Comment:
    /**
     * @serialData a long, which is the absolute expiration if serialFormat is ABSOLUTE, or the
     * relative duration if serialFormat is DURATION
     */

#Code:
    private void writeObject(ObjectOutputStream stream) throws IOException {
        int format;
        long val;
        synchronized (this) {
            format = serialFormat;
            val = expiration;
        }
        if (format == Lease.DURATION) {
            long exp = val;
            val -= SystemTime.timeMillis();
            // If we subtract positive from negative, and the result is
            // positive, we must have underflowed, so use Long.MIN_VALUE
            if (exp < 0 && val > 0)
                val = Long.MIN_VALUE;
        }
        stream.putFields().put("serialFormat", format);
        stream.writeFields();
        stream.writeLong(val);
    }

#No. 3220
#File: E:\bishe\1\AbstractLease.java
#Comment:
    /**
     * Throws an <code>InvalidObjectException</code>.
     *
     * @throws InvalidObjectException unconditionally
     */

#Code:
    private void readObjectNoData() throws InvalidObjectException {
        throw new InvalidObjectException("no data in stream");
    }

#No. 3221
#File: E:\bishe\1\AbstractLease.java
#Comment:
    /**
     * If serialFormat is DURATION, add the current time to the expiration, to make it absolute (and
     * if the result of the addition is negative, correct the overflow by resetting the expiration
     * to Long.MAX_VALUE).
     *
     * @throws InvalidObjectException if serialFormat is neither ABSOLUTE nor DURATION
     */

#Code:
    private void readObject(ObjectInputStream stream)
            throws IOException, ClassNotFoundException {
        stream.defaultReadObject();
        long val = stream.readLong();
        if (serialFormat == Lease.DURATION) {
            long dur = val;
            val += SystemTime.timeMillis();
            // If we add two positive numbers, and the result is negative,
            // we must have overflowed, so use Long.MAX_VALUE
            if (val < 0 && dur > 0)
                val = Long.MAX_VALUE;
        } else if (serialFormat != Lease.ABSOLUTE) {
            throw new InvalidObjectException("invalid serial format");
        }
        expiration = val;
    }

#No. 3222
#File: E:\bishe\1\AbstractLicenseMojo.java
#Comment:
    /**
     * @return the enconding used to read and write files.
     */

#Code:
    public final String getEncoding()
    {
        return encoding;
    }

#No. 3223
#File: E:\bishe\1\AbstractLicenseMojo.java
#Comment:
    /**
     * Sets new encoding used to read and write files.
     *
     * @param encoding new encodnignt ing to use
     */

#Code:
    public final void setEncoding( String encoding )
    {
        this.encoding = encoding;
    }

#No. 3224
#File: E:\bishe\1\AbstractLicenseMojo.java
#Comment:
    /**
     * @return the current maven project
     */

#Code:
    public final MavenProject getProject()
    {
        return project;
    }

#No. 3225
#File: E:\bishe\1\AbstractLicenseMojo.java
#Comment:
    /**
     * @return {@code true} if verbose flag is on, {@code false} otherwise
     */

#Code:
    public final boolean isVerbose()
    {
        return verbose;
    }

#No. 3226
#File: E:\bishe\1\AbstractLicenseMojo.java
#Comment:
    /**
     * Sets new value to {@link #verbose} flag.
     *
     * @param verbose new value to set
     */

#Code:
    public final void setVerbose( boolean verbose )
    {
        this.verbose = verbose;
    }

#No. 3227
#File: E:\bishe\1\AbstractLicenseMojo.java
#Comment:
    /**
     * @return the {@link MavenSession}.
     */

#Code:
    public final MavenSession getSession()
    {
        return session;
    }

#No. 3228
#File: E:\bishe\1\AbstractLicenseMojo.java
#Comment:
    /**
     * @return the build timestamp (used to have a unique timestamp all over a build).
     */

#Code:
    public final long getBuildTimestamp()
    {
        return session.getStartTime().getTime();
    }

#No. 3229
#File: E:\bishe\1\AbstractLicenseMojo.java
#Comment:
    /**
     * A call back to execute after the {@link #execute()} is done.
     */

#Code:
    protected void afterExecute()
    {
        // by default do nothing
    }

#No. 3230
#File: E:\bishe\1\AbstractLicenseMojo.java
#Comment:
    /**
     * Check if the project packaging is acceptable for the mojo.
     *
     * By default, accept all packaging types.
     *
     * <b>Note:</b> This method is the first instruction to be executed in
     * the {@link #execute()}.
     *
     * <b>Tip:</b> There is two method to simplify the packaging check :
     *
     * {@link #acceptPackaging(String...)}
     *
     * and
     *
     * {@link #rejectPackaging(String...)}
     *
     * @return {@code true} if can execute the goal for the packaging of the
     * project, {@code false} otherwise.
     */

#Code:
    protected boolean checkPackaging()
    {
        // by default, accept every type of packaging
        return true;
    }

#No. 3231
#File: E:\bishe\1\AbstractLicenseMojo.java
#Comment:
    /**
     * Checks if the mojo execution should be skipped.
     *
     * @return {@code false} if the mojo should not be executed.
     */

#Code:
    protected boolean checkSkip()
    {
        // by default, never skip goal
        return true;
    }

#No. 3232
#File: E:\bishe\1\AbstractLicenseMojo.java
#Comment:
    /**
     * Accept the project's packaging between some given.
     *
     * @param packages the accepted packaging
     * @return {@code true} if the project's packaging is one of the given ones.
     */

#Code:
    protected boolean acceptPackaging( String... packages )
    {
        String projectPackaging = getProject().getPackaging();

        for ( String p : packages )
        {
            if ( p.equals( projectPackaging ) )
            {
                // accept packaging
                return true;
            }
        }
        // reject packaging
        return false;
    }

#No. 3233
#File: E:\bishe\1\AbstractLicenseMojo.java
#Comment:
    /**
     * Accept the project's packaging if not in given one.
     *
     * @param packages the rejecting packagings
     * @return {@code true} if the project's packaging is not in the given ones.
     */

#Code:
    protected boolean rejectPackaging( String... packages )
    {
        String projectPackaging = getProject().getPackaging();

        for ( String p : packages )
        {
            if ( p.equals( projectPackaging ) )
            {
                // reject this packaging
                return false;
            }
        }
        // accept packaging
        return true;
    }

#No. 3234
#File: E:\bishe\1\AbstractLicenseMojo.java
#Comment:
    /**
     * Method to be invoked in init phase to check sanity of {@link #getEncoding()}.
     *
     * If no encoding was filled, then use the default for system
     * (via {@code file.encoding} environement property).
     */

#Code:
    protected void checkEncoding()
    {

        if ( isVerbose() )
        {
            getLog().info( "Will check encoding : " + getEncoding() );
        }
        if ( StringUtils.isEmpty( getEncoding() ) )
        {
            getLog().warn( "File encoding has not been set, using platform encoding " + ReaderFactory.FILE_ENCODING +
                               ", i.e. build is platform dependent!" );
            setEncoding( ReaderFactory.FILE_ENCODING );
        }
    }

#No. 3235
#File: E:\bishe\1\AbstractLicenseMojo.java
#Comment:
    /**
     * Add a new resource location to the maven project
     * (in not already present).
     *
     * @param dir      the new resource location to add
     * @param includes files to include
     */

#Code:
    protected void addResourceDir( File dir, String... includes )
    {
        boolean added = MojoHelper.addResourceDir( dir, getProject(), includes );
        if ( added && isVerbose() )
        {
            getLog().info( "add resource " + dir + " with includes " + Arrays.toString( includes ) );
        }
    }

#No. 3236
#File: E:\bishe\1\AbstractLicenseMojo.java
#Comment:
    /**
     * @return {@code true} if project is not a pom, {@code false} otherwise.
     */

#Code:
    protected boolean hasClassPath()
    {
        return rejectPackaging( "pom" );
    }

#No. 3237
#File: E:\bishe\1\AbstractLineWarningGenerator.java
#Comment:
    /**
     * Return an empty list if a stream is null.
     * @param input input stream
     * @param <P> Type of the stream
     * @return the input stream, or an empty stream if the stream was null
     */

#Code:
    protected static <P>  List<P> emptyIfNull(final List<P> input) {
        if(input == null) {
            return Collections.emptyList();
        }
        return input;
    }

#No. 3238
#File: E:\bishe\1\AbstractLink.java
#Comment:
	/**
	 * Click.
	 *
	 * @param text the text
	 * @param index the index
	 */

#Code:
	public void click(String text, int index) {
		logger.info("Click link with text '" + text + "' and index " + index);
		String eventText = LinkHandler.getInstance().getEventText(swtWidget, text,
				index);
		logger.info("Click link's text '" + eventText + "'");
		LinkHandler.getInstance().activate(swtWidget, eventText);
	}

#No. 3239
#File: E:\bishe\1\AbstractList.java
#Comment:
    /**
     * Compares the specified object with this list for equality.  Returns
     * {@code true} if and only if the specified object is also a list, both
     * lists have the same size, and all corresponding pairs of elements in
     * the two lists are <i>equal</i>.  (Two elements {@code e1} and
     * {@code e2} are <i>equal</i> if {@code (e1==null ? e2==null :
     * e1.equals(e2))}.)  In other words, two lists are defined to be
     * equal if they contain the same elements in the same order.<p>
     *
     * This implementation first checks if the specified object is this
     * list. If so, it returns {@code true}; if not, it checks if the
     * specified object is a list. If not, it returns {@code false}; if so,
     * it iterates over both lists, comparing corresponding pairs of elements.
     * If any comparison returns {@code false}, this method returns
     * {@code false}.  If either iterator runs out of elements before the
     * other it returns {@code false} (as the lists are of unequal length);
     * otherwise it returns {@code true} when the iterations complete.
     *
     * @param o the object to be compared for equality with this list
     * @return {@code true} if the specified object is equal to this list
     */

#Code:
    public boolean equals(Object o) {
        if (o == this)
            return true;
        if (!(o instanceof List))
            return false;

        ListIterator<E> e1 = listIterator();
        ListIterator e2 = ((List) o).listIterator();
        while (e1.hasNext() && e2.hasNext()) {
            E o1 = e1.next();
            Object o2 = e2.next();
            if (!(o1==null ? o2==null : o1.equals(o2)))
                return false;
        }
        return !(e1.hasNext() || e2.hasNext());
    }

#No. 3240
#File: E:\bishe\1\AbstractList.java
#Comment:
    /**
     * Returns the hash code value for this list.
     *
     * <p>This implementation uses exactly the code that is used to define the
     * list hash function in the documentation for the {@link List#hashCode}
     * method.
     *
     * @return the hash code value for this list
     */

#Code:
    public int hashCode() {
        int hashCode = 1;
        for (E e : this)
            hashCode = 31*hashCode + (e==null ? 0 : e.hashCode());
        return hashCode;
    }

#No. 3241
#File: E:\bishe\1\AbstractList.java
#Comment:
    /**
     * Removes from this list all of the elements whose index is between
     * {@code fromIndex}, inclusive, and {@code toIndex}, exclusive.
     * Shifts any succeeding elements to the left (reduces their index).
     * This call shortens the list by {@code (toIndex - fromIndex)} elements.
     * (If {@code toIndex==fromIndex}, this operation has no effect.)
     *
     * <p>This method is called by the {@code clear} operation on this list
     * and its subLists.  Overriding this method to take advantage of
     * the internals of the list implementation can <i>substantially</i>
     * improve the performance of the {@code clear} operation on this list
     * and its subLists.
     *
     * <p>This implementation gets a list iterator positioned before
     * {@code fromIndex}, and repeatedly calls {@code ListIterator.next}
     * followed by {@code ListIterator.remove} until the entire range has
     * been removed.  <b>Note: if {@code ListIterator.remove} requires linear
     * time, this implementation requires quadratic time.</b>
     *
     * @param fromIndex index of first element to be removed
     * @param toIndex index after last element to be removed
     */

#Code:
    protected void removeRange(int fromIndex, int toIndex) {
        ListIterator<E> it = listIterator(fromIndex);
        for (int i=0, n=toIndex-fromIndex; i<n; i++) {
            it.next();
            it.remove();
        }
    }

#No. 3242
#File: E:\bishe\1\AbstractList.java
#Comment:
    /**
     * The number of times this list has been <i>structurally modified</i>.
     * Structural modifications are those that change the size of the
     * list, or otherwise perturb it in such a fashion that iterations in
     * progress may yield incorrect results.
     *
     * <p>This field is used by the iterator and list iterator implementation
     * returned by the {@code iterator} and {@code listIterator} methods.
     * If the value of this field changes unexpectedly, the iterator (or list
     * iterator) will throw a {@code ConcurrentModificationException} in
     * response to the {@code next}, {@code remove}, {@code previous},
     * {@code set} or {@code add} operations.  This provides
     * <i>fail-fast</i> behavior, rather than non-deterministic behavior in
     * the face of concurrent modification during iteration.
     *
     * <p><b>Use of this field by subclasses is optional.</b> If a subclass
     * wishes to provide fail-fast iterators (and list iterators), then it
     * merely has to increment this field in its {@code add(int, E)} and
     * {@code remove(int)} methods (and any other methods that it overrides
     * that result in structural modifications to the list).  A single call to
     * {@code add(int, E)} or {@code remove(int)} must add no more than
     * one to this field, or the iterators (and list iterators) will throw
     * bogus {@code ConcurrentModificationExceptions}.  If an implementation
     * does not wish to provide fail-fast iterators, this field may be
     * ignored.
     */

#Code:
    protected transient int modCount = 0;

    private void rangeCheckForAdd(int index) {
        if (index < 0 || index > size())
            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
    }

#No. 3243
#File: E:\bishe\1\AbstractListenerAdaptor.java
#Comment:
  /**
   * Returns an upper bound on the number of listeners listening to this object.
   * The number of listeners returned is equal to the true number of listeners,
   * plus any listeners that have been garbage collected since the last time
   * getListeners() was called.
   */

#Code:
  public int getNumListeners() {
    return listeners.size();
  }

#No. 3244
#File: E:\bishe\1\AbstractListenerAdaptor.java
#Comment:
  /**
   * Adds a WeakReference with no payload to the listeners map to ensure that
   * garbage collected listeners are correctly skipped.
   */

#Code:
  @VisibleForTesting
  void addNullReference() {
    listeners.add(null);
  }

#No. 3245
#File: E:\bishe\1\AbstractListeningExecutorService.java
#Comment:
/**
 * Abstract {@link ListeningExecutorService} implementation that creates
 * {@link ListenableFutureTask} instances for each {@link Runnable} and {@link Callable} submitted
 * to it. These tasks are run with the abstract {@link #execute execute(Runnable)} method.
 *
 * <p>In addition to {@link #execute}, subclasses must implement all methods related to shutdown and
 * termination.
 *
 * @author Chris Povirk
 * @since 14.0
 */

#Code:
@Beta
public abstract class AbstractListeningExecutorService
    extends AbstractExecutorService implements ListeningExecutorService {

  @Override protected final <T> ListenableFutureTask<T> newTaskFor(Runnable runnable, T value) {
    return ListenableFutureTask.create(runnable, value);
  }

#No. 3246
#File: E:\bishe\1\AbstractListExecutable.java
#Comment:
    /**
     * Checks if this command can be executed on a single list item.
     * 
     * @param listItem the list item to check if the command can be executed on
     * @return {@code true} if the command can be executed, {@code false} otherwise
     */

#Code:
    protected boolean canExecute(Element listItem)
    {
        return listItem != null;
    }

#No. 3247
#File: E:\bishe\1\AbstractListExecutable.java
#Comment:
    /**
     * {@inheritDoc}
     * 
     * @see AbstractListExecutable#isEnabled()
     */

#Code:
    public boolean isEnabled()
    {
        if (!super.isEnabled()) {
            return false;
        }

        // Get the range and check if execution is possible: if it's collapsed, it's the common list item ancestor to
        // perform operation on, if it's expanded, it's each "touched" list item.
        Range range = rta.getDocument().getSelection().getRangeAt(0);
        if (range.isCollapsed()) {
            Element listItem = getListItem(range);
            return canExecute(listItem);
        } else {
            // Check the execution is possible on multiple items, without actually performing it.
            return executeOnMultipleItems(range, false);
        }
    }

#No. 3248
#File: E:\bishe\1\AbstractListHolder.java
#Comment:
    /**
     * Turns sort mode on using the passed sort property. The target property must be a String.
     */

#Code:
    protected void setSortProperty(String sortProperty) {
        this.sortProperty = sortProperty;
    }

#No. 3249
#File: E:\bishe\1\AbstractListHolder.java
#Comment:
    /**
     * Turns the cache on.
     */

#Code:
    protected void enableCache() {
        isCacheEnabled = true;
    }

#No. 3250
#File: E:\bishe\1\AbstractListHolder.java
#Comment:
    /**
     * Turns the cache off and clear it.
     */

#Code:
    protected void disableCache() {
        isCacheEnabled = false;
        cachedResult = null;
    }

#No. 3251
#File: E:\bishe\1\AbstractListHolder.java
#Comment:
    /**
     * Returns the list that this ListHolder backs.
     */

#Code:
    @Override
    public List<T> getList() {
        if (isCacheEnabled) {
            if (cachedResult == null) {
                cachedResult = makeUnmodifiableUniqueList();
            }
            return cachedResult;
        } else {
            return makeUnmodifiableUniqueList();
        }
    }

#No. 3252
#File: E:\bishe\1\AbstractListHolder.java
#Comment:
    /**
     * Return the size of the list returned by getSubList(maxSubListSize)
     */

#Code:
    public int getSubListSize(int maxSubListSize) {
        return Math.min(getList().size(), maxSubListSize);
    }

#No. 3253
#File: E:\bishe\1\AbstractListHolder.java
#Comment:
    /**
     * Returns at most the first maxSubListSize elements of this list.
     */

#Code:
    public List<T> getSubList(int maxSubListSize) {
        List<T> subList = newArrayList();
        int counter = 0;
        for (T t : getList()) {
            if (counter++ < maxSubListSize) {
                subList.add(t);
            } else {
                break;
            }
        }
        return subList;
    }

#No. 3254
#File: E:\bishe\1\AbstractListHolder.java
#Comment:
    /**
     * Fork this list with extra predicates.
     *
     * @param namesToExclude the name of the elements to exclude from the list.
     */

#Code:
    public SimpleListHolder<T> except(String... namesToExclude) {
        String key = "current" + getCacheKey(namesToExclude);
        SimpleListHolder<T> result = cache.get(key);
        if (result == null) {
            result = new SimpleListHolder<T>(getIterable(), asNameNotEqualsToPredicates(namesToExclude), getSortProperty());
            cache.put(key, result);
        }
        return result;
    }

#No. 3255
#File: E:\bishe\1\AbstractListMultimap.java
#Comment:
/**
 * Basic implementation of the {@link ListMultimap} interface. It's a wrapper
 * around {@link AbstractMapBasedMultimap} that converts the returned collections into
 * {@code Lists}. The {@link #createCollection} method must return a {@code
 * List}.
 *
 * @author Jared Levy
 * @since 2.0 (imported from Google Collections Library)
 */

#Code:
@GwtCompatible
abstract class AbstractListMultimap<K, V>
    extends AbstractMapBasedMultimap<K, V> implements ListMultimap<K, V> {
  /**
   * Creates a new multimap that uses the provided map.
   *
   * @param map place to store the mapping from each key to its corresponding
   *     values
   */
  protected AbstractListMultimap(Map<K, Collection<V>> map) {
    super(map);
  }

  @Override abstract List<V> createCollection();

  @Override
  List<V> createUnmodifiableEmptyCollection() {
    return ImmutableList.of();
  }

  // Following Javadoc copied from ListMultimap.

  /**
   * {@inheritDoc}
   *
   * <p>Because the values for a given key may have duplicates and follow the
   * insertion ordering, this method returns a {@link List}, instead of the
   * {@link Collection} specified in the {@link Multimap} interface.
   */
  @Override public List<V> get(@Nullable K key) {
    return (List<V>) super.get(key);
  }

#No. 3256
#File: E:\bishe\1\AbstractListTag.java
#Comment:
	/**
	 * <p>
	 * Use {@link #add(NBTTag)} instead.
	 * </p>
	 */

#Code:
	@Override
	public final void add(final int index, final NBTTag element) throws UnsupportedOperationException {
		throw new UnsupportedOperationException();
	}

#No. 3257
#File: E:\bishe\1\AbstractListTag.java
#Comment:
	/**
	 * <p>
	 * Use {@link #addAll(Collection)} instead.
	 * </p>
	 */

#Code:
	@Override
	public final boolean addAll(final int index, final Collection<? extends NBTTag> c) throws UnsupportedOperationException {
		throw new UnsupportedOperationException();
	}

#No. 3258
#File: E:\bishe\1\AbstractListTag.java
#Comment:
	/**
	 * <p>
	 * Can not set specific element.
	 * </p>
	 */

#Code:
	@Override
	public final NBTTag set(final int index, final NBTTag element) throws UnsupportedOperationException {
		throw new UnsupportedOperationException();
	}

#No. 3259
#File: E:\bishe\1\AbstractLiveOperations.java
#Comment:
	/**
	 * Base URL Live API's
	 */

#Code:
	private static final String API_URL_BASE = "https://apis.live.net/v5.0/";

}
}

#No. 3260
#File: E:\bishe\1\AbstractLivingDocMacro.java
#Comment:
    /**
     * Setter for IoC
     */

#Code:
    public void setConfluenceLivingDoc(LivingDocConfluenceManager confluenceLivingDoc) {
        this.ldUtil = confluenceLivingDoc;
    }

#No. 3261
#File: E:\bishe\1\AbstractLoadBalancerSupport.java
#Comment:
/**
 * Provides a basic implementation of load balancer support that you can extend and customize to support your cloud.
 * <p>Created by George Reese: 3/7/13 9:48 PM</p>
 * @author George Reese
 * @version 2013.04 initial version
 * @since 2013.04
 */

#Code:
public abstract class AbstractLoadBalancerSupport<T extends CloudProvider> extends AbstractProviderService<T> implements
        LoadBalancerSupport {

    protected AbstractLoadBalancerSupport(T provider) {
        super(provider);
    }

    @Override
    public void addDataCenters(@Nonnull String toLoadBalancerId, @Nonnull String ... dataCenterIdsToAdd) throws CloudException, InternalException {
        if( getCapabilities().isDataCenterLimited() ) {
            throw new OperationNotSupportedException("Adding data centers has not been implemented for " + getContext().getRegionId() + " of " + getProvider().getCloudName());
        }
        else {
            throw new OperationNotSupportedException("Load balancers are not data-center constrained in " + getContext().getRegionId() + " of " + getProvider().getCloudName());
        }
    }

#No. 3262
#File: E:\bishe\1\AbstractLoadingCache.java
#Comment:
/**
 * This class provides a skeletal implementation of the {@code Cache} interface to minimize the
 * effort required to implement this interface.
 *
 * <p>To implement a cache, the programmer needs only to extend this class and provide an
 * implementation for the {@link #get(Object)} and {@link #getIfPresent} methods.
 * {@link #getUnchecked}, {@link #get(Object, Callable)}, and {@link #getAll} are implemented in
 * terms of {@code get}; {@link #getAllPresent} is implemented in terms of {@code getIfPresent};
 * {@link #putAll} is implemented in terms of {@link #put}, {@link #invalidateAll(Iterable)} is
 * implemented in terms of {@link #invalidate}. The method {@link #cleanUp} is a no-op. All other
 * methods throw an {@link UnsupportedOperationException}.
 *
 * @author Charles Fry
 * @since 11.0
 */

#Code:
@Beta
public abstract class AbstractLoadingCache<K, V>
    extends AbstractCache<K, V> implements LoadingCache<K, V> {

  /** Constructor for use by subclasses. */
  protected AbstractLoadingCache() {}

  @Override
  public V getUnchecked(K key) {
    try {
      return get(key);
    } catch (ExecutionException e) {
      throw new UncheckedExecutionException(e.getCause());
    }
  }

  @Override
  public ImmutableMap<K, V> getAll(Iterable<? extends K> keys) throws ExecutionException {
    Map<K, V> result = Maps.newLinkedHashMap();
    for (K key : keys) {
      if (!result.containsKey(key)) {
        result.put(key, get(key));
      }
    }
    return ImmutableMap.copyOf(result);
  }

  @Override
  public final V apply(K key) {
    return getUnchecked(key);
  }

  @Override
  public void refresh(K key) {
    throw new UnsupportedOperationException();
  }
}

#No. 3263
#File: E:\bishe\1\AbstractLoadOverlayTask.java
#Comment:
/**
 * @author nicolasguillot
 * @author Damien Raude-Morvan
 * 
 * @param <O>
 *            Type de l'objet traité dans la couche (overlay) de la carte
 */

#Code:
public abstract class AbstractLoadOverlayTask<O extends OverlayItem> extends
		RoboAsyncTask<List<O>> {

	private AbstractItemizedOverlay<O> overlay;

	protected AbstractLoadOverlayTask(Context context,
			AbstractItemizedOverlay<O> overlay) {
		super(context, overlay.getExecutor());
		this.overlay = overlay;
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected void onSuccess(List<O> list) throws Exception {
		overlay.clear();
		overlay.addAll(list);
		overlay.doPopulate();
		overlay.postInvalidate();

		super.onSuccess(list);
	};

	@Override
	protected void onInterrupted(Exception e) {
	}

}

#No. 3264
#File: E:\bishe\1\AbstractLocalDestination.java
#Comment:
    /**
     * Put a new message in the destination. The message is locked and the lock registered in the provided lock set
     * @return true if a commit is required to ensure data safety
     */

#Code:
    public abstract boolean putLocked( AbstractMessage message , LocalSession session , MessageLockSet locks ) throws JMSException;
}
}

#No. 3265
#File: E:\bishe\1\AbstractLockupHandler.java
#Comment:
    /**
     * Collects details: version of VM, locker event, threads dump.
     *
     * @param event locker.
     *
     * @return details.
     */

#Code:
    protected String collectDetails(AWTEvent event)
    {
        StringBuffer buf = new StringBuffer();

        buf.append(getVMVersion());
        buf.append("\n");

        if (event != null)
        {
            buf.append(event.toString());
            buf.append("\n\n");
        }

        buf.append(getProperties());

        buf.append(getThreadsDump(getLogger()));

        return buf.toString();
    }

#No. 3266
#File: E:\bishe\1\AbstractLockupHandler.java
#Comment:
    /**
     * Returns application properties.
     *
     * @return application properties.
     */

#Code:
    private String getProperties()
    {
        StringBuffer buf = new StringBuffer();

        buf.append("Properties:\n");

        buf.append("Installation ID: ");
        buf.append(ApplicationLauncher.getInstallationId()).append("\n");
        buf.append("Installation Runs: ");
        buf.append(ApplicationLauncher.getInstallationRuns()).append("\n");
        buf.append("JGoodies - System Exit Allowed: ");
        buf.append(System.getProperty("jgoodies.SystemExitAllowed")).append("\n");
        buf.append("Context Path: ");
        buf.append(ApplicationLauncher.getContextPath()).append("\n");
        buf.append("Running under JWS: ");
        buf.append(BrowserLauncher.isRunningUnderJWS()).append("\n");
        buf.append("OS: ");
        buf.append(System.getProperty("os.name")).append("\n");
        buf.append("\n");

        buf.append("\n");

        return buf.toString();
    }

#No. 3267
#File: E:\bishe\1\AbstractLockupHandler.java
#Comment:
    /**
     * Returns VM version information.
     *
     * @return VM information.
     */

#Code:
    private String getVMVersion()
    {
        OutputStream os = new ByteArrayOutputStream();
        PrintStream ps = new PrintStream(os);

        sun.misc.Version.print(ps);

        return os.toString();
    }

#No. 3268
#File: E:\bishe\1\AbstractLockupHandler.java
#Comment:
    /**
     * Prints information about all threads.
     *
     * @param aLogger logger to use for error reporting.
     *
     * @return threads dump.
     */

#Code:
    public static String getThreadsDump(Logger aLogger)
    {
        ThreadGroup rootTG = findRootTG(Thread.currentThread().getThreadGroup());
        int activeThreads = rootTG.activeCount();
        Thread[] threads = new Thread[activeThreads];
        int actualThreads = rootTG.enumerate(threads, true);

        StringBuffer buf = new StringBuffer();
        for (int i = 0; i < actualThreads; i++)
        {
            Thread thread = threads[i];
            buf.append(getThreadInfo(thread));
        }

        buf.append(getDeadlockedThreads());

        return buf.toString();
    }

#No. 3269
#File: E:\bishe\1\AbstractLockupHandler.java
#Comment:
    /**
     * Gathers info about deadlocked threads.
     *
     * @return threads summary.
     */

#Code:
    private static String getDeadlockedThreads()
    {
        StringBuffer buf = new StringBuffer();

        // Get ID's of all threads
        ThreadMXBean mbean = ManagementFactory.getThreadMXBean();
        long[] ids = mbean.getAllThreadIds();
        if (ids != null)
        {
            for (long id : ids)
            {
                ThreadInfo threadInfo = mbean.getThreadInfo(id, STACK_DUMP_SIZE_BLOCKED);
                buf.append("\n").append(threadInfo).append("\n");

                // Dump the monitor blocks
                String lockName = threadInfo.getLockName();
                if (lockName != null)
                {
                    buf.append("  waiting for ");
                    buf.append(lockName);
                    buf.append(" blocked by ");
                    buf.append(threadInfo.getLockOwnerName());
                    buf.append("@").append(threadInfo.getLockOwnerId()).append("\n");
                }

                // Write the stack trace of thread
                StackTraceElement[] traces = threadInfo.getStackTrace();
                int steps = requiresDetails(threadInfo)
                    ? traces.length : Math.min(STACK_DUMP_SIZE_NORMAL, traces.length);

                for (int j = 0; j < steps; j++)
                {
                    buf.append("\t").append(traces[j]).append("\n");
                }
            }
        }

        return buf.toString();
    }

#No. 3270
#File: E:\bishe\1\AbstractLockupHandler.java
#Comment:
    /**
     * Returns <code>TRUE</code> if the thread is reported as BLOCKED by someone or it is EDT
     * thread.
     *
     * @param aThreadInfo thread info to analyze.
     *
     * @return thread info.
     */

#Code:
    private static boolean requiresDetails(Object aThreadInfo)
    {
        String threadInfo = aThreadInfo.toString();
        return threadInfo.indexOf("BLOCKED") != -1 || threadInfo.indexOf("AWT-EventQueue") != -1;
    }

#No. 3271
#File: E:\bishe\1\AbstractLockupHandler.java
#Comment:
    /**
     * Prints information about single thread.
     *
     * @param thread thread.
     *
     * @return thread info.
     */

#Code:
    private static String getThreadInfo(Thread thread)
    {
        return "Thread: " + thread.getName() +
               " Running=" + thread.isAlive() +
               " Daemon=" + thread.isDaemon() +
               " Priority=" + thread.getPriority() + "\n";
    }

#No. 3272
#File: E:\bishe\1\AbstractLockupHandler.java
#Comment:
    /**
     * Finds root group of threads.
     *
     * @param threadGroup group of threads to find parents for.
     * 
     * @return root group.
     */

#Code:
    private static ThreadGroup findRootTG(ThreadGroup threadGroup)
    {
        return (threadGroup.getParent() == null) ? threadGroup : threadGroup.getParent();
    }

#No. 3273
#File: E:\bishe\1\AbstractLog.java
#Comment:
    /** Factory for diagnostics
     */

#Code:
    protected JCDiagnostic.Factory diags;

    /** The file that's currently being translated.
     */
    protected DiagnosticSource source;

    /** A cache of lightweight DiagnosticSource objects.
     */
    protected Map<JavaFileObject, DiagnosticSource> sourceMap;
}
}

#No. 3274
#File: E:\bishe\1\AbstractLoggerAdapter.java
#Comment:
    /**
     * Gets the {@link LoggerContext} associated with the given caller class.
     *
     * @param callerClass the caller class
     * @return the LoggerContext for the calling class
     */

#Code:
    protected LoggerContext getContext(final Class<?> callerClass) {
        ClassLoader cl = null;
        if (callerClass != null) {
            cl = callerClass.getClassLoader();
        }
        if (cl == null) {
            cl = LoaderUtil.getThreadContextClassLoader();
        }
        return LogManager.getContext(cl, false);
    }

#No. 3275
#File: E:\bishe\1\AbstractLongFPSet.java
#Comment:
    /**
     * Note access (hook for subclass cache-replacement strategies)
     *
     * @param index The index of the slot to check.
     */

#Code:
    private void noteAccess(long index) {
        // by default do nothing
        // cache subclasses may use to update access counts, etc.
    }

#No. 3276
#File: E:\bishe\1\AbstractLongFPSet.java
#Comment:
    /**
     * Return the number of entries in this set.
     *
     * @see org.archive.util.fingerprint.LongFPSet#count()
     */

#Code:
    public long count() {
        return count;
    }

#No. 3277
#File: E:\bishe\1\AbstractLongFPSet.java
#Comment:
    /**
     * Add the given value to this set
     *
     * @see org.archive.util.fingerprint.LongFPSet#add(long)
     */

#Code:
    public boolean add(long val) {
        logger.finest("Adding " + val);
        long i = indexFor(val);
        if (slotHasData(i)) {
            // positive index indicates already in set
            return false;
        }
        // we have a possible slot now, which is encoded as a negative number

        // check for space, and grow if needed
        if ((count + 1) > (loadFactor * (1 << capacityPowerOfTwo))) {
            makeSpace();
            // find new i
            i = indexFor(val);
            assert i < 0 : "slot should be empty";
        }

        i = asDataSlot(i); // convert to positive index
        setAt(i, val);
        count++;
        noteAccess(i);
        return true;
    }

#No. 3278
#File: E:\bishe\1\AbstractLongFPSet.java
#Comment:
    /** 
     * Given a value, check the store for its existence. If it exists, it
     * will return the index where the value resides.  Otherwise it return
     * an encoded index, which is a possible storage location for the value.
     *
     * <p>Note, if we have a loading factor less than 1.0, there should always
     * be an empty location where we can store the value
     *
     * @param val the fingerprint value to check for
     * @return The (positive) index where the value already resides,
     * or an empty index where it could be inserted (encoded as a
     * negative number).
     */

#Code:
    private long indexFor(long val) {
        long candidateIndex = startIndexFor(val);
        while (true) {
            if (getSlotState(candidateIndex) < 0) {
                // slot empty; return negative number encoding index
                return asEmptySlot(candidateIndex);
            }
            if (getAt(candidateIndex) == val) {
                // already present; return positive index
                return candidateIndex;
            }
            candidateIndex++;
            if (candidateIndex == 1 << capacityPowerOfTwo) {
                candidateIndex = 0; // wraparound
            }
        }
    }

#No. 3279
#File: E:\bishe\1\AbstractLongFPSet.java
#Comment:
    /**
     * Return the recommended storage index for the given value.
     * Assumes values are already well-distributed; merely uses
     * high-order bits.
     *
     * @param val
     * @return The recommended storage index for the given value.
     */

#Code:
    private long startIndexFor(long val) {
        return (val >>> (64 - capacityPowerOfTwo));
    }

#No. 3280
#File: E:\bishe\1\AbstractLongFPSet.java
#Comment:
    /**
     * Remove the value at the given index, relocating its
     * successors as necessary.
     *
     *  @param index
     */

#Code:
    protected void removeAt(long index) {
        count--;
        clearAt(index);
        long probeIndex = index + 1;
        while (true) {
            if (probeIndex == 1 << capacityPowerOfTwo) {
                probeIndex = 0; //wraparound
            }
            if (getSlotState(probeIndex) < 0) {
                // vacant
                break;
            }
            long val = getAt(probeIndex);
            long newIndex = indexFor(val);
            if (newIndex != probeIndex) {
                // value must shift down
                newIndex = asDataSlot(newIndex); // positivize
                relocate(val, probeIndex, newIndex);
            }
            probeIndex++;
        }
    }

#No. 3281
#File: E:\bishe\1\AbstractLongFPSet.java
#Comment:
    /**
     * Low-cost, non-definitive (except when true) contains
     * test. Default answer of false is acceptable.
     *
     * @see org.archive.util.fingerprint.LongFPSet#quickContains(long)
     */

#Code:
    public boolean quickContains(long fp) {
        return false;
    }

#No. 3282
#File: E:\bishe\1\AbstractLongFPSet.java
#Comment:
    /**
     * given a slot index, which could or could not be empty, return it as
     * a slot index indicating an non-empty slot
     *
     * @param index the slot index to convert
     * @return the index, converted to represent an slot with data
     */

#Code:
    private long asDataSlot(final long index) {
        if (slotHasData(index)) { // slot already has data
            return index;
        }
        return - (index + 1);
    }

#No. 3283
#File: E:\bishe\1\AbstractLongFPSet.java
#Comment:
    /** 
     * Given a slot index, which could or could not be empty, return it as
     * a slot index indicating an empty slot
     * @param index the slot index to convert
     * @return the index, converted to represent an empty slot
     */

#Code:
    private long asEmptySlot(final long index) {
        if (!slotHasData(index)) { // already empty slot
            return index;
        }
        return -index - 1;
    }

#No. 3284
#File: E:\bishe\1\AbstractLongFPSet.java
#Comment:
    /** 
     * Does this index represent a slot with data?
     *
     * @param index the index to check
     * @return <code>true</code> if the slot has data
     */

#Code:
    private boolean slotHasData(final long index) {
        return index >= 0;
    }

#No. 3285
#File: E:\bishe\1\AbstractLongList.java
#Comment:
    /**
     * Returns the index of the first occurrence of the specified element.
     * Returns <code>-1</code> if the receiver does not contain this element.
     * 
     * @param element
     *            the element to be searched for.
     * @return the index of the first occurrence of the element in the receiver;
     *         returns <code>-1</code> if the element is not found.
     */

#Code:
    public int indexOf(long element) { // delta
        return indexOfFromTo(element, 0, size - 1);
    }

#No. 3286
#File: E:\bishe\1\AbstractLongList.java
#Comment:
    /**
     * Returns the index of the first occurrence of the specified element.
     * Returns <code>-1</code> if the receiver does not contain this element.
     * Searches between <code>from</code>, inclusive and <code>to</code>,
     * inclusive. Tests for identity.
     * 
     * @param element
     *            element to search for.
     * @param from
     *            the leftmost search position, inclusive.
     * @param to
     *            the rightmost search position, inclusive.
     * @return the index of the first occurrence of the element in the receiver;
     *         returns <code>-1</code> if the element is not found.
     * @exception IndexOutOfBoundsException
     *                index is out of range (
     *                <tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>
     *                ).
     */

#Code:
    public int indexOfFromTo(long element, int from, int to) {
        checkRangeFromTo(from, to, size);

        for (int i = from; i <= to; i++) {
            if (element == getQuick(i))
                return i; // found
        }
        return -1; // not found
    }

#No. 3287
#File: E:\bishe\1\AbstractLongList.java
#Comment:
    /**
     * Returns the index of the last occurrence of the specified element.
     * Returns <code>-1</code> if the receiver does not contain this element.
     * 
     * @param element
     *            the element to be searched for.
     * @return the index of the last occurrence of the element in the receiver;
     *         returns <code>-1</code> if the element is not found.
     */

#Code:
    public int lastIndexOf(long element) {
        return lastIndexOfFromTo(element, 0, size - 1);
    }

#No. 3288
#File: E:\bishe\1\AbstractLongList.java
#Comment:
    /**
     * Returns the index of the last occurrence of the specified element.
     * Returns <code>-1</code> if the receiver does not contain this element.
     * Searches beginning at <code>to</code>, inclusive until <code>from</code>,
     * inclusive. Tests for identity.
     * 
     * @param element
     *            element to search for.
     * @param from
     *            the leftmost search position, inclusive.
     * @param to
     *            the rightmost search position, inclusive.
     * @return the index of the last occurrence of the element in the receiver;
     *         returns <code>-1</code> if the element is not found.
     * @exception IndexOutOfBoundsException
     *                index is out of range (
     *                <tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>
     *                ).
     */

#Code:
    public int lastIndexOfFromTo(long element, int from, int to) {
        checkRangeFromTo(from, to, size());

        for (int i = to; i >= from; i--) {
            if (element == getQuick(i))
                return i; // found
        }
        return -1; // not found
    }

#No. 3289
#File: E:\bishe\1\AbstractLongList.java
#Comment:
    /**
     * Sorts the specified range of the receiver into ascending order.
     * 
     * The sorting algorithm is a modified mergesort (in which the merge is
     * omitted if the highest element in the low sublist is less than the lowest
     * element in the high sublist). This algorithm offers guaranteed n*log(n)
     * performance, and can approach linear performance on nearly sorted lists.
     * 
     * <p>
     * <b>You should never call this method unless you are sure that this
     * particular sorting algorithm is the right one for your data set.</b> It
     * is generally better to call <tt>sort()</tt> or <tt>sortFromTo(...)</tt>
     * instead, because those methods automatically choose the best sorting
     * algorithm.
     * 
     * @param from
     *            the index of the first element (inclusive) to be sorted.
     * @param to
     *            the index of the last element (inclusive) to be sorted.
     * @exception IndexOutOfBoundsException
     *                index is out of range (
     *                <tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>
     *                ).
     */

#Code:

    public void mergeSortFromTo(int from, int to) {
        int mySize = size();
        checkRangeFromTo(from, to, mySize);

        long[] myElements = elements();
        cern.colt.Sorting.mergeSort(myElements, from, to + 1);
        elements(myElements);
        setSizeRaw(mySize);
    }

#No. 3290
#File: E:\bishe\1\AbstractLongList.java
#Comment:
    /**
     * Sorts the receiver according to the order induced by the specified
     * comparator. All elements in the range must be <i>mutually comparable</i>
     * by the specified comparator (that is, <tt>c.compare(e1, e2)</tt> must not
     * throw a <tt>ClassCastException</tt> for any elements <tt>e1</tt> and
     * <tt>e2</tt> in the range).
     * <p>
     * 
     * This sort is guaranteed to be <i>stable</i>: equal elements will not be
     * reordered as a result of the sort.
     * <p>
     * 
     * The sorting algorithm is a modified mergesort (in which the merge is
     * omitted if the highest element in the low sublist is less than the lowest
     * element in the high sublist). This algorithm offers guaranteed n*log(n)
     * performance, and can approach linear performance on nearly sorted lists.
     * 
     * @param from
     *            the index of the first element (inclusive) to be sorted.
     * @param to
     *            the index of the last element (inclusive) to be sorted.
     * @param c
     *            the comparator to determine the order of the receiver.
     * @throws ClassCastException
     *             if the array contains elements that are not <i>mutually
     *             comparable</i> using the specified comparator.
     * @throws IllegalArgumentException
     *             if <tt>fromIndex &gt; toIndex</tt>
     * @throws ArrayIndexOutOfBoundsException
     *             if <tt>fromIndex &lt; 0</tt> or
     *             <tt>toIndex &gt; a.length</tt>
     * @exception IndexOutOfBoundsException
     *                index is out of range (
     *                <tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>
     *                ).
     */

#Code:
    public void mergeSortFromTo(int from, int to, LongComparator c) {
        int mySize = size();
        checkRangeFromTo(from, to, mySize);

        long[] myElements = elements();
        cern.colt.Sorting.mergeSort(myElements, from, to + 1, c);
        elements(myElements);
        setSizeRaw(mySize);
    }

#No. 3291
#File: E:\bishe\1\AbstractLongList.java
#Comment:
    /**
     * Returns a new list of the part of the receiver between <code>from</code>,
     * inclusive, and <code>to</code>, inclusive.
     * 
     * @param from
     *            the index of the first element (inclusive).
     * @param to
     *            the index of the last element (inclusive).
     * @return a new list
     * @exception IndexOutOfBoundsException
     *                index is out of range (
     *                <tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>
     *                ).
     */

#Code:
    public AbstractLongList partFromTo(int from, int to) {
        checkRangeFromTo(from, to, size);

        int length = to - from + 1;
        LongArrayList part = new LongArrayList(length);
        part.addAllOfFromTo(this, from, to);
        return part;
    }

#No. 3292
#File: E:\bishe\1\AbstractLongList.java
#Comment:
    /**
     * Sorts the specified range of the receiver into ascending numerical order.
     * The sorting algorithm is a tuned quicksort, adapted from Jon L. Bentley
     * and M. Douglas McIlroy's "Engineering a Sort Function", Software-Practice
     * and Experience, Vol. 23(11) P. 1249-1265 (November 1993). This algorithm
     * offers n*log(n) performance on many data sets that cause other quicksorts
     * to degrade to quadratic performance.
     * 
     * <p>
     * <b>You should never call this method unless you are sure that this
     * particular sorting algorithm is the right one for your data set.</b> It
     * is generally better to call <tt>sort()</tt> or <tt>sortFromTo(...)</tt>
     * instead, because those methods automatically choose the best sorting
     * algorithm.
     * 
     * @param from
     *            the index of the first element (inclusive) to be sorted.
     * @param to
     *            the index of the last element (inclusive) to be sorted.
     * @exception IndexOutOfBoundsException
     *                index is out of range (
     *                <tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>
     *                ).
     */

#Code:

    public void quickSortFromTo(int from, int to) {
        int mySize = size();
        checkRangeFromTo(from, to, mySize);

        long[] myElements = elements();
        cern.colt.Sorting.parallelQuickSort(myElements, from, to + 1, new LongComparator() {
            public int compare(long a, long b) {
                return a < b ? -1 : (a == b ? 0 : 1);
            }
        });
        //        java.util.Arrays.sort(myElements, from, to + 1);
        elements(myElements);
        setSizeRaw(mySize);
    }

#No. 3293
#File: E:\bishe\1\AbstractLongList.java
#Comment:
    /**
     * Sorts the receiver according to the order induced by the specified
     * comparator. All elements in the range must be <i>mutually comparable</i>
     * by the specified comparator (that is, <tt>c.compare(e1, e2)</tt> must not
     * throw a <tt>ClassCastException</tt> for any elements <tt>e1</tt> and
     * <tt>e2</tt> in the range).
     * <p>
     * 
     * The sorting algorithm is a tuned quicksort, adapted from Jon L. Bentley
     * and M. Douglas McIlroy's "Engineering a Sort Function", Software-Practice
     * and Experience, Vol. 23(11) P. 1249-1265 (November 1993). This algorithm
     * offers n*log(n) performance on many data sets that cause other quicksorts
     * to degrade to quadratic performance.
     * 
     * @param from
     *            the index of the first element (inclusive) to be sorted.
     * @param to
     *            the index of the last element (inclusive) to be sorted.
     * @param c
     *            the comparator to determine the order of the receiver.
     * @throws ClassCastException
     *             if the array contains elements that are not <i>mutually
     *             comparable</i> using the specified comparator.
     * @throws IllegalArgumentException
     *             if <tt>fromIndex &gt; toIndex</tt>
     * @throws ArrayIndexOutOfBoundsException
     *             if <tt>fromIndex &lt; 0</tt> or
     *             <tt>toIndex &gt; a.length</tt>
     * @exception IndexOutOfBoundsException
     *                index is out of range (
     *                <tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>
     *                ).
     */

#Code:
    public void quickSortFromTo(int from, int to, LongComparator c) {
        int mySize = size();
        checkRangeFromTo(from, to, mySize);

        long[] myElements = elements();
        cern.colt.Sorting.parallelQuickSort(myElements, from, to + 1, c);
        elements(myElements);
        setSizeRaw(mySize);
    }

#No. 3294
#File: E:\bishe\1\AbstractLongList.java
#Comment:
    /**
     * Removes from the receiver all elements that are contained in the
     * specified list. Tests for identity.
     * 
     * @param other
     *            the other list.
     * @return <code>true</code> if the receiver changed as a result of the
     *         call.
     */

#Code:
    public boolean removeAll(AbstractLongList other) {
        if (other.size() == 0)
            return false; // nothing to do
        int limit = other.size() - 1;
        int j = 0;

        for (int i = 0; i < size; i++) {
            if (other.indexOfFromTo(getQuick(i), 0, limit) < 0)
                setQuick(j++, getQuick(i));
        }

        boolean modified = (j != size);
        setSize(j);
        return modified;
    }

#No. 3295
#File: E:\bishe\1\AbstractLongList.java
#Comment:
    /**
     * Removes from the receiver all elements whose index is between
     * <code>from</code>, inclusive and <code>to</code>, inclusive. Shifts any
     * succeeding elements to the left (reduces their index). This call shortens
     * the list by <tt>(to - from + 1)</tt> elements.
     * 
     * @param from
     *            index of first element to be removed.
     * @param to
     *            index of last element to be removed.
     * @exception IndexOutOfBoundsException
     *                index is out of range (
     *                <tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>
     *                ).
     */

#Code:

    public void removeFromTo(int from, int to) {
        checkRangeFromTo(from, to, size);
        int numMoved = size - to - 1;
        if (numMoved > 0) {
            replaceFromToWithFrom(from, from - 1 + numMoved, this, to + 1);
            // fillFromToWith(from+numMoved, size-1, 0.0f); //delta
        }
        int width = to - from + 1;
        if (width > 0)
            setSizeRaw(size - width);
    }

#No. 3296
#File: E:\bishe\1\AbstractLongList.java
#Comment:
    /**
     * Replaces a number of elements in the receiver with the same number of
     * elements of another list. Replaces elements in the receiver, between
     * <code>from</code> (inclusive) and <code>to</code> (inclusive), with
     * elements of <code>other</code>, starting from <code>otherFrom</code>
     * (inclusive).
     * 
     * @param from
     *            the position of the first element to be replaced in the
     *            receiver
     * @param to
     *            the position of the last element to be replaced in the
     *            receiver
     * @param other
     *            list holding elements to be copied into the receiver.
     * @param otherFrom
     *            position of first element within other list to be copied.
     */

#Code:
    public void replaceFromToWithFrom(int from, int to, AbstractLongList other, int otherFrom) {
        int length = to - from + 1;
        if (length > 0) {
            checkRangeFromTo(from, to, size());
            checkRangeFromTo(otherFrom, otherFrom + length - 1, other.size());

            // unambiguous copy (it may hold other==this)
            if (from <= otherFrom) {
                for (; --length >= 0;)
                    setQuick(from++, other.getQuick(otherFrom++));
            } else {
                int otherTo = otherFrom + length - 1;
                for (; --length >= 0;)
                    setQuick(to--, other.getQuick(otherTo--));
            }

        }
    }

#No. 3297
#File: E:\bishe\1\AbstractLongList.java
#Comment:
    /**
     * Replaces the part between <code>from</code> (inclusive) and
     * <code>to</code> (inclusive) with the other list's part between
     * <code>otherFrom</code> and <code>otherTo</code>. Powerful (and tricky)
     * method! Both parts need not be of the same size (part A can both be
     * smaller or larger than part B). Parts may overlap. Receiver and other
     * list may (but most not) be identical. If <code>from &gt; to</code>, then
     * inserts other part before <code>from</code>.
     * 
     * @param from
     *            the first element of the receiver (inclusive)
     * @param to
     *            the last element of the receiver (inclusive)
     * @param other
     *            the other list (may be identical with receiver)
     * @param otherFrom
     *            the first element of the other list (inclusive)
     * @param otherTo
     *            the last element of the other list (inclusive)
     * 
     *            <p>
     *            <b>Examples:</b>
     * 
     *            <pre>
     * a=[0, 1, 2, 3, 4, 5, 6, 7]
     * b=[50, 60, 70, 80, 90]
     * a.R(...)=a.replaceFromToWithFromTo(...)
     * 
     * a.R(3,5,b,0,4)--&gt;[0, 1, 2, 50, 60, 70, 80, 90, 6, 7]
     * a.R(1,6,b,0,4)--&gt;[0, 50, 60, 70, 80, 90, 7]
     * a.R(0,6,b,0,4)--&gt;[50, 60, 70, 80, 90, 7]
     * a.R(3,5,b,1,2)--&gt;[0, 1, 2, 60, 70, 6, 7]
     * a.R(1,6,b,1,2)--&gt;[0, 60, 70, 7]
     * a.R(0,6,b,1,2)--&gt;[60, 70, 7]
     * a.R(5,3,b,0,4)--&gt;[0, 1, 2, 3, 4, 50, 60, 70, 80, 90, 5, 6, 7]
     * a.R(5,0,b,0,4)--&gt;[0, 1, 2, 3, 4, 50, 60, 70, 80, 90, 5, 6, 7]
     * a.R(5,3,b,1,2)--&gt;[0, 1, 2, 3, 4, 60, 70, 5, 6, 7]
     * a.R(5,0,b,1,2)--&gt;[0, 1, 2, 3, 4, 60, 70, 5, 6, 7]
     * 
     * Extreme cases:
     * a.R(5,3,b,0,0)--&gt;[0, 1, 2, 3, 4, 50, 5, 6, 7]
     * a.R(5,3,b,4,4)--&gt;[0, 1, 2, 3, 4, 90, 5, 6, 7]
     * a.R(3,5,a,0,1)--&gt;[0, 1, 2, 0, 1, 6, 7]
     * a.R(3,5,a,3,5)--&gt;[0, 1, 2, 3, 4, 5, 6, 7]
     * a.R(3,5,a,4,4)--&gt;[0, 1, 2, 4, 6, 7]
     * a.R(5,3,a,0,4)--&gt;[0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 5, 6, 7]
     * a.R(0,-1,b,0,4)--&gt;[50, 60, 70, 80, 90, 0, 1, 2, 3, 4, 5, 6, 7]
     * a.R(0,-1,a,0,4)--&gt;[0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 5, 6, 7]
     * a.R(8,0,a,0,4)--&gt;[0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4]
     * </pre>
     */

#Code:
    public void replaceFromToWithFromTo(int from, int to, AbstractLongList other, int otherFrom, int otherTo) {
        if (otherFrom > otherTo) {
            throw new IndexOutOfBoundsException("otherFrom: " + otherFrom + ", otherTo: " + otherTo);
        }

        if (this == other && to - from != otherTo - otherFrom) { // avoid
            // stumbling
            // over my
            // own feet
            replaceFromToWithFromTo(from, to, partFromTo(otherFrom, otherTo), 0, otherTo - otherFrom);
            return;
        }

        int length = otherTo - otherFrom + 1;
        int diff = length;
        int theLast = from - 1;

        if (to >= from) {
            diff -= (to - from + 1);
            theLast = to;
        }

        if (diff > 0) {
            beforeInsertDummies(theLast + 1, diff);
        } else {
            if (diff < 0) {
                removeFromTo(theLast + diff, theLast - 1);
            }
        }

        if (length > 0) {
            replaceFromToWithFrom(from, from + length - 1, other, otherFrom);
        }
    }

#No. 3298
#File: E:\bishe\1\AbstractLongList.java
#Comment:
    /**
     * Replaces the part of the receiver starting at <code>from</code>
     * (inclusive) with all the elements of the specified collection. Does not
     * alter the size of the receiver. Replaces exactly
     * <tt>Math.max(0,Math.min(size()-from, other.size()))</tt> elements.
     * 
     * @param from
     *            the index at which to copy the first element from the
     *            specified collection.
     * @param other
     *            Collection to replace part of the receiver
     * @exception IndexOutOfBoundsException
     *                index is out of range (index &lt; 0 || index &gt;=
     *                size()).
     */

#Code:

    public void replaceFromWith(int from, java.util.Collection other) {
        checkRange(from, size());
        java.util.Iterator e = other.iterator();
        int index = from;
        int limit = Math.min(size() - from, other.size());
        for (int i = 0; i < limit; i++)
            set(index++, ((Number) e.next()).longValue()); // delta
    }

#No. 3299
#File: E:\bishe\1\AbstractLongList.java
#Comment:
    /**
     * Retains (keeps) only the elements in the receiver that are contained in
     * the specified other list. In other words, removes from the receiver all
     * of its elements that are not contained in the specified other list.
     * 
     * @param other
     *            the other list to test against.
     * @return <code>true</code> if the receiver changed as a result of the
     *         call.
     */

#Code:
    public boolean retainAll(AbstractLongList other) {
        if (other.size() == 0) {
            if (size == 0)
                return false;
            setSize(0);
            return true;
        }

        int limit = other.size() - 1;
        int j = 0;
        for (int i = 0; i < size; i++) {
            if (other.indexOfFromTo(getQuick(i), 0, limit) >= 0)
                setQuick(j++, getQuick(i));
        }

        boolean modified = (j != size);
        setSize(j);
        return modified;
    }

#No. 3300
#File: E:\bishe\1\AbstractLongList.java
#Comment:
    /**
     * Reverses the elements of the receiver. Last becomes first, second last
     * becomes second first, and so on.
     */

#Code:

    public void reverse() {
        long tmp;
        int limit = size() / 2;
        int j = size() - 1;

        for (int i = 0; i < limit;) { // swap
            tmp = getQuick(i);
            setQuick(i++, getQuick(j));
            setQuick(j--, tmp);
        }
    }

#No. 3301
#File: E:\bishe\1\AbstractLongList.java
#Comment:
    /**
     * Replaces the element at the specified position in the receiver with the
     * specified element.
     * 
     * @param index
     *            index of element to replace.
     * @param element
     *            element to be stored at the specified position.
     * @throws IndexOutOfBoundsException
     *             if <tt>index &lt; 0 || index &gt;= size()</tt>.
     */

#Code:
    public void set(int index, long element) {
        if (index >= size || index < 0)
            throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size);
        setQuick(index, element);
    }

#No. 3302
#File: E:\bishe\1\AbstractLongList.java
#Comment:
    /**
     * Sets the size of the receiver without modifying it otherwise. This method
     * should not release or allocate new memory but simply set some instance
     * variable like <tt>size</tt>.
     * 
     * If your subclass overrides and delegates size changing methods to some
     * other object, you must make sure that those overriding methods not only
     * update the size of the delegate but also of this class. For example:
     * public DatabaseList extends AbstractLongList { ... public void
     * removeFromTo(int from,int to) { myDatabase.removeFromTo(from,to);
     * this.setSizeRaw(size-(to-from+1)); } }
     */

#Code:
    public void setSizeRaw(int newSize) {
        size = newSize;
    }

#No. 3303
#File: E:\bishe\1\AbstractLongList.java
#Comment:
    /**
     * Randomly permutes the part of the receiver between <code>from</code>
     * (inclusive) and <code>to</code> (inclusive).
     * 
     * @param from
     *            the index of the first element (inclusive) to be permuted.
     * @param to
     *            the index of the last element (inclusive) to be permuted.
     * @exception IndexOutOfBoundsException
     *                index is out of range (
     *                <tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>
     *                ).
     */

#Code:

    public void shuffleFromTo(int from, int to) {
        checkRangeFromTo(from, to, size());

        cern.jet.random.tdouble.DoubleUniform gen = new cern.jet.random.tdouble.DoubleUniform(
                new cern.jet.random.tdouble.engine.DRand(new java.util.Date()));
        for (int i = from; i < to; i++) {
            int random = gen.nextIntFromTo(i, to);

            // swap(i, random)
            long tmpElement = getQuick(random);
            setQuick(random, getQuick(i));
            setQuick(i, tmpElement);
        }
    }

#No. 3304
#File: E:\bishe\1\AbstractLongList.java
#Comment:
    /**
     * Returns the number of elements contained in the receiver.
     * 
     * @return the number of elements contained in the receiver.
     */

#Code:

    public int size() {
        return size;
    }

#No. 3305
#File: E:\bishe\1\AbstractLongList.java
#Comment:
    /**
     * Returns a list which is a concatenation of <code>times</code> times the
     * receiver.
     * 
     * @param times
     *            the number of times the receiver shall be copied.
     */

#Code:
    public AbstractLongList times(int times) {
        AbstractLongList newList = new LongArrayList(times * size());
        for (int i = times; --i >= 0;) {
            newList.addAllOfFromTo(this, 0, size() - 1);
        }
        return newList;
    }

#No. 3306
#File: E:\bishe\1\AbstractLongList.java
#Comment:
    /**
     * Returns a <code>java.util.ArrayList</code> containing all the elements in
     * the receiver.
     */

#Code:

    public java.util.ArrayList toList() {
        int mySize = size();
        java.util.ArrayList list = new java.util.ArrayList(mySize);
        for (int i = 0; i < mySize; i++)
            list.add(new Long(get(i)));
        return list;
    }

#No. 3307
#File: E:\bishe\1\AbstractLongList.java
#Comment:
    /**
     * Returns a string representation of the receiver, containing the String
     * representation of each element.
     */

#Code:

    public String toString() {
        return cern.colt.Arrays.toString(partFromTo(0, size() - 1).elements());
    }

#No. 3308
#File: E:\bishe\1\AbstractLookupd.java
#Comment:
	/**
	 * This should handle making a request to lookupd, and returning which producers match the channel we want
	 * Netty presumably can wait on the future or something, who knows...
	 */

#Code:
	public abstract List<String> query(String topic);

	public static List<String> parseResponseForProducers(Reader response){
		ObjectMapper mapper = new ObjectMapper();
		List<String> outputs = new ArrayList<String>();
		try {	 
			 JsonNode rootNode = mapper.readTree(response);
			 JsonNode producers = rootNode.path("data").path("producers");
			 Iterator<JsonNode> prodItr = producers.getElements();
			 while(prodItr.hasNext()){
				 JsonNode producer = prodItr.next();
                 String addr = producer.path("broadcast_address").getTextValue();
                 if (addr == null || addr.length() == 0) {
                     addr = producer.path("address").getTextValue();
                 }
				 int tcpPort = producer.path("tcp_port").getIntValue();
				 outputs.add(addr + ":" + tcpPort);
			 }
		} catch (JsonParseException e) {
            LOGGER.log(Level.WARNING, e.getMessage(), e);
		} catch (JsonMappingException e) {
            LOGGER.log(Level.WARNING, e.getMessage(), e);
		} catch (IOException e) {
            LOGGER.log(Level.WARNING, e.getMessage(), e);
		}
		return outputs;
	}

#No. 3309
#File: E:\bishe\1\AbstractMailboxManagerClient.java
#Comment:
/**
 * Abstract implementation of a client that manages emails stored in mailbox.
 */

#Code:
class AbstractMailboxManagerClient {

  protected MailboxManagerConnection connection;
  protected RetrieveOperations retriever = new RetrieveOperations();
  protected DeleteOperations deleter = new DeleteOperations();

  AbstractMailboxManagerClient(EmailProtocol protocol,
                               String username,
                               String password,
                               String host,
                               int port,
                               ClientConfiguration config) {
    connection = new MailboxManagerConnection(protocol,
                                              username,
                                              password,
                                              host,
                                              port,
                                              config.getConnectionTimeout(),
                                              config.getReadTimeout(),
                                              config.getWriteTimeout(),
                                              config.getProperties());
  }

  public void disconnect() {
    connection.disconnect();
  }
}

#No. 3310
#File: E:\bishe\1\AbstractMailJimpService.java
#Comment:
  /**
   * Constructs the url of the MailChimp server to talk to. This takes the data
   * center out of the api key and knows if the connection should get secured
   * via ssl.
   * 
   * @return The URL of the MailChimp server to use.
   */

#Code:
  protected String buildServerURL() {
    StringBuilder serverURL = new StringBuilder();
    // choose the protocol
    if (ssl) {
      serverURL.append(SERVER_URL_PREFIX_HTTPS);
    } else {
      serverURL.append(SERVER_URL_PREFIX_HTTP);
    }

    final int dcSeparater = apiKey.lastIndexOf('-');
    final String dcLocation = dcSeparater != -1 ? apiKey.substring(dcSeparater + 1) : "us1";

    serverURL
    // parse the data center
    .append(dcLocation)
    // bring in the clue
    .append(SERVER_URL_MAIN)
    // add the version
    .append(apiVersion)
    // and finish with a slash.
    .append('/');
    return serverURL.toString();
  }

#No. 3311
#File: E:\bishe\1\AbstractMainItemAdapter.java
#Comment:
		/**
		 * Slight delay imposed to handle the first-time loading case where not
		 * flinging but where every item is going to call
		 * {@link #sendFetchMissingRequest()}. With a slight delay, we can
		 * ensure that under normal load all items fade-in at the same time.
		 */

#Code:
		private static final int SHORT_FETCH_DELAY = 200;

		@Override
		public void handleMessage(Message msg)
		{
			switch (msg.what)
			{
				case MSG_FETCH_MISSING:
					AsyncBadgeLoader bitmapLoader = getOrCreateBitmapLoader();

					for (View row: mViewsMissingImagery)
					{
						ItemHolder holder = getHolder(row);
						if (holder.badgeUri != null)
						{
							if (DEBUG_BITMAP_LOADS) {
								Log.d(Constants.TAG, "Reading badge: " + holder.badgeUri);
							}
							bitmapLoader.startDecode(holder.position,
									Pair.create(holder.id, row), holder.badgeUri);
						}
					}

					/*
					 * Send a sort of termination request that we'll use to
					 * reflect updates to the UI only when all requests are
					 * processed. Prevents kind of a weird looking tile-loading
					 * problem that exists in the contacts app (which doesn't
					 * use this trick).
					 */
					bitmapLoader.sendSentinel();

					break;
			}
		}

#No. 3312
#File: E:\bishe\1\AbstractMainItemAdapter.java
#Comment:
				/*
				 * Loop through all views that may need revealing. Some of these
				 * items may have changed or may no longer need revealing so
				 * it's important to check that condition inside the loop.
				 */

#Code:
				for (View row: mViewsMissingImagery)
				{
					ItemHolder holder = getHolder(row);

					if (holder.badgeNeedsRevealing)
					{
						Bitmap bitmap = sBitmapCache.get(holder.id);
						if (bitmap != null)
						{
							BitmapDrawable drawable = new BitmapDrawable(mContext.getResources(),
									bitmap);
							drawable.setBounds(holder.badgeTransition.getBounds());
							holder.badgeTransition.setDrawableByLayerId(MainItemHolder.SECOND_LAYER_ID,
									drawable);
							holder.badgeTransition.startTransition(ON_LOAD_FADE_IN_DURATION);
						}

						holder.badgeNeedsRevealing = false;
					}
				}

#No. 3313
#File: E:\bishe\1\AbstractMainListActivity.java
#Comment:
	/**
	 * Helper to display and respond to common screen menu controls.
	 */

#Code:
	public static class OptionsMenuHelper
	{
		private WeakReference<Activity> mContext;

		public OptionsMenuHelper(Activity context)
		{
			mContext = new WeakReference<Activity>(context);
		}

		private Activity getContext()
		{
			return mContext.get();
		}

		public boolean dispatchOnCreateOptionsMenu(Menu menu)
		{
			getContext().getMenuInflater().inflate(R.menu.browse_controls, menu);
			return true;
		}

		public boolean dispatchOnOptionsItemSelected(MenuItem item)
		{
			switch (item.getItemId())
			{
				case R.id.return_library:
					Main.show(getContext());
					return true;

				case R.id.goto_player:
					Player.show(getContext());
					return true;
			}

			return false;
		}
	}

#No. 3314
#File: E:\bishe\1\AbstractMainMockTransformer.java
#Comment:
    /**
     * According to JVM specification method size must be lower than 65536 bytes.
     * When that limit is exceeded class loader will fail to load the class.
     * Since instrumentation can increase method size significantly it must be
     * ensured that JVM limit is not exceeded.
     * <p/>
     * When the limit is exceeded method's body is replaced by exception throw.
     * Method is then instrumented again to allow mocking and suppression.
     *
     * @see <a href="http://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.3">JVM specification</a>
     */

#Code:
    protected CtClass ensureJvmMethodSizeLimit(CtClass clazz) throws CannotCompileException, NotFoundException {
        for (CtMethod method : clazz.getDeclaredMethods()) {
            if (isMethodSizeExceeded(method)) {
                String code = "{throw new IllegalAccessException(\"" +
                                      "Method was too large and after instrumentation exceeded JVM limit. " +
                                      "PowerMock modified the method to allow JVM to load the class. " +
                                      "You can use PowerMock API to suppress or mock this method behaviour." +
                                      "\");}";
                method.setBody(code);
                modifyMethod(method);
            }
        }
        return clazz;
    }

#No. 3315
#File: E:\bishe\1\AbstractMainMockTransformer.java
#Comment:
    /**
     * @return The correct return type, i.e. takes care of casting the a wrapper
     * type to primitive type if needed.
     */

#Code:
    private String getCorrectReturnValueType(final CtClass returnTypeAsCtClass) {
        final String returnTypeAsString = returnTypeAsCtClass.getName();
        final String returnValue;
        if (returnTypeAsCtClass.equals(CtClass.voidType)) {
            returnValue = VOID;
        } else if (returnTypeAsCtClass.isPrimitive()) {
            if (returnTypeAsString.equals("char")) {
                returnValue = "((java.lang.Character)value).charValue()";
            } else if (returnTypeAsString.equals("boolean")) {
                returnValue = "((java.lang.Boolean)value).booleanValue()";
            } else {
                returnValue = "((java.lang.Number)value)." + returnTypeAsString + "Value()";
            }
        } else {
            returnValue = "(" + returnTypeAsString + ")value";
        }
        return returnValue;
    }

#No. 3316
#File: E:\bishe\1\AbstractMainMockTransformer.java
#Comment:
                        /*
                         * If multiple java agents are active (in INST_REDEFINE mode), the types implicitly loaded by javassist from disk
                         * might differ from the types available in memory. Thus, this error might occur.
                         *
                         * It may also happen if PowerMock is modifying an SPI where the SPI require some classes to be available in the classpath
                         * at runtime but they are not! This is valid in some cases such as slf4j.
                         */

#Code:
                    return;
                }

                if (isNotSyntheticField(fieldInfo)) {
                    String code = "{Object value =  " +
                                          MockGateway.class.getName() +
                                          ".fieldCall(" +
                                          "$0,$class,\"" +
                                          f.getFieldName() +
                                          "\",$type);" +
                                          "if(value == " + MockGateway.class.getName() + ".PROCEED) {" +
                                          "	$_ = $proceed($$);" +
                                          "} else {" +
                                          "	$_ = " + getCorrectReturnValueType(returnTypeAsCtClass) + ";" +
                                          "}}";
                    f.replace(code);
                }

#No. 3317
#File: E:\bishe\1\AbstractMainMockTransformer.java
#Comment:
                    /*
                     * If multiple java agents are active (in INST_REDEFINE mode), the types implicitly loaded by javassist from disk
                     * might differ from the types available in memory. Thus, this error might occur.
                     *
                     * It may also happen if PowerMock is modifying an SPI where the SPI require some classes to be available in the classpath
                     * at runtime but they are not! This is valid in some cases such as slf4j.
                     */

#Code:
            }
        }

        private boolean shouldTreatAsSystemClassCall(CtClass declaringClass) {
            final String className = declaringClass.getName();
            return className.startsWith("java.");
        }

#No. 3318
#File: E:\bishe\1\AbstractMainMockTransformer.java
#Comment:
            /*
             * Note that constructor call only intercepts calls to super or this
             * from an instantiated class. This means that A a = new A(); will
             * NOT trigger a ConstructorCall for the default constructor in A.
             * If A where to extend B and A's constructor only delegates to
             * super(), the default constructor of B would trigger a
             * ConstructorCall. This means that we need to handle
             * "suppressConstructorCode" both here and in NewExpr.
             */

#Code:
            if (strategy != INST_REDEFINE && !c.getClassName().startsWith("java.lang")) {
                final CtClass superclass;
                try {
                    superclass = clazz.getSuperclass();
                } catch (NotFoundException e) {
                    throw new RuntimeException(e);
                }

                /*
                 * Create a default constructor in the super class if it doesn't
                 * exist. This is needed because if the code in the current
                 * constructor should be suppressed (which we don't know at this
                 * moment of time) the parent class must have a default
                 * constructor that we can delegate to.
                 */
                addNewDeferConstructor(clazz);
                final StringBuilder code = new StringBuilder();
                code.append("{Object value =")
                    .append(MockGateway.class.getName())
                    .append(".constructorCall($class, $args, $sig);");
                code.append("if (value != ").append(MockGateway.class.getName()).append(".PROCEED){");

                /*
                 * TODO Suppress and lazy inject field (when this feature is ready).
                 */
                if (superclass.getName().equals(Object.class.getName())) {
                    code.append(" super();");
                } else {
                    code.append(" super((").append(IndicateReloadClass.class.getName()).append(") null);");
                }
                code.append("} else {");
                code.append("   $proceed($$);");
                code.append("}}");
                c.replace(code.toString());
            }

#No. 3319
#File: E:\bishe\1\AbstractMainMockTransformer.java
#Comment:
        /**
         * Create a defer constructor in the class which will be called when the
         * constructor is suppressed.
         *
         * @param clazz The class whose super constructor will get a new defer
         *              constructor if it doesn't already have one.
         * @throws CannotCompileException If an unexpected compilation error occurs.
         */

#Code:
        private void addNewDeferConstructor(final CtClass clazz) throws CannotCompileException {
            final CtClass superClass;
            try {
                superClass = clazz.getSuperclass();
            } catch (NotFoundException e1) {
                throw new IllegalArgumentException("Internal error: Failed to get superclass for " + clazz.getName()
                                                           + " when about to create a new default constructor.");
            }

            ClassPool classPool = clazz.getClassPool();
            /*
             * To make a unique defer constructor we create a new constructor
             * with one argument (IndicateReloadClass). So we get this class a
             * Javassist class below.
             */
            final CtClass constructorType;
            try {
                constructorType = classPool.get(IndicateReloadClass.class.getName());
            } catch (NotFoundException e) {
                throw new IllegalArgumentException("Internal error: failed to get the " + IndicateReloadClass.class.getName()
                                                           + " when added defer constructor.");
            }
            clazz.defrost();
            if (superClass.getName().equals(Object.class.getName())) {
                try {
                    clazz.addConstructor(CtNewConstructor.make(new CtClass[]{constructorType}, new CtClass[0], "{super();}", clazz));
                } catch (DuplicateMemberException e) {
                    // OK, the constructor has already been added.
                }
            } else {
                addNewDeferConstructor(superClass);
                try {
                    clazz.addConstructor(CtNewConstructor.make(new CtClass[]{constructorType}, new CtClass[0], "{super($$);}", clazz));
                } catch (DuplicateMemberException e) {
                    // OK, the constructor has already been added.
                }
            }
        }

#No. 3320
#File: E:\bishe\1\AbstractMangoVoRestV2Controller.java
#Comment:
	/**
	 * Construct a Controller using the default callback
	 * @param dao
	 */

#Code:
	public AbstractMangoVoRestV2Controller(DAO dao){
		this.dao = dao;
		this.modelMap = new HashMap<String,String>();
		this.appenders = new HashMap<String, SQLColumnQueryAppender>();
	}

#No. 3321
#File: E:\bishe\1\AbstractMangoVoRestV2Controller.java
#Comment:
	/**
	 * Get the Query Stream for Streaming an array of data
	 * @param query
	 * @return
	 */

#Code:
	protected QueryStream<VO, MODEL, DAO> getStream(ASTNode root){
		return this.getStream(root, new VoStreamCallback<VO, MODEL, DAO>(this));
	}

#No. 3322
#File: E:\bishe\1\AbstractMangoVoRestV2Controller.java
#Comment:
	/**
	 * Get the Query Stream for Streaming an array of data
	 * @param query
	 * @return
	 */

#Code:
	protected QueryStream<VO, MODEL, DAO> getStream(ASTNode root, VoStreamCallback<VO, MODEL, DAO> callback){
		QueryStream<VO, MODEL, DAO> stream = new QueryStream<VO, MODEL, DAO>(dao, this, root, callback);
		//Ensure its ready
		stream.setupQuery();
		return stream;
	}

#No. 3323
#File: E:\bishe\1\AbstractMangoVoRestV2Controller.java
#Comment:
	/**
	 * Get a Stream that is more like a result set with a count
	 * @param query
	 * @return
	 */

#Code:
	protected PageQueryStream<VO, MODEL, DAO> getPageStream(ASTNode root){
		return getPageStream(root, new VoStreamCallback<VO, MODEL, DAO>(this));
	}

#No. 3324
#File: E:\bishe\1\AbstractMangoVoRestV2Controller.java
#Comment:
	/**
	 * Get a Stream that is more like a result set with a count
	 * @param query
	 * @return
	 */

#Code:
	protected PageQueryStream<VO, MODEL, DAO> getPageStream(ASTNode node, VoStreamCallback<VO, MODEL, DAO> callback){
		PageQueryStream<VO, MODEL, DAO> stream = new PageQueryStream<VO, MODEL, DAO>(dao, this, node, callback);
		//Ensure its ready
		stream.setupQuery();
		return stream;
	}

#No. 3325
#File: E:\bishe\1\AbstractMangoVoRestV2Controller.java
#Comment:
	/**
	 * Get the Table Model
	 * @return
	 */

#Code:
	protected TableModel getQueryAttributeModel(){
		TableModel model = this.dao.getTableModel();
	
		
		//Add in our mappings
		Iterator<String> it = this.modelMap.keySet().iterator();
		while(it.hasNext()){
			String modelMember = it.next();
			String mappedTo = this.modelMap.get(modelMember);
			for(QueryAttribute attribute : model.getAttributes()){
				if(attribute.getColumnName().equals(mappedTo)){
					attribute.addAlias(modelMember);
				}
			}
		}
		return model;
	}

#No. 3326
#File: E:\bishe\1\AbstractMap.java
#Comment:
    /**
     * Compares the specified object with this map for equality.  Returns
     * <tt>true</tt> if the given object is also a map and the two maps
     * represent the same mappings.  More formally, two maps <tt>m1</tt> and
     * <tt>m2</tt> represent the same mappings if
     * <tt>m1.entrySet().equals(m2.entrySet())</tt>.  This ensures that the
     * <tt>equals</tt> method works properly across different implementations
     * of the <tt>Map</tt> interface.
     *
     * <p>This implementation first checks if the specified object is this map;
     * if so it returns <tt>true</tt>.  Then, it checks if the specified
     * object is a map whose size is identical to the size of this map; if
     * not, it returns <tt>false</tt>.  If so, it iterates over this map's
     * <tt>entrySet</tt> collection, and checks that the specified map
     * contains each mapping that this map contains.  If the specified map
     * fails to contain such a mapping, <tt>false</tt> is returned.  If the
     * iteration completes, <tt>true</tt> is returned.
     *
     * @param o object to be compared for equality with this map
     * @return <tt>true</tt> if the specified object is equal to this map
     */

#Code:
    public boolean equals(Object o) {
        if (o == this)
            return true;

        if (!(o instanceof Map))
            return false;
        Map<K,V> m = (Map<K,V>) o;
        if (m.size() != size())
            return false;

        try {
            Iterator<Entry<K,V>> i = entrySet().iterator();
            while (i.hasNext()) {
                Entry<K,V> e = i.next();
                K key = e.getKey();
                V value = e.getValue();
                if (value == null) {
                    if (!(m.get(key)==null && m.containsKey(key)))
                        return false;
                } else {
                    if (!value.equals(m.get(key)))
                        return false;
                }
            }
        } catch (ClassCastException unused) {
            return false;
        } catch (NullPointerException unused) {
            return false;
        }

        return true;
    }

#No. 3327
#File: E:\bishe\1\AbstractMap.java
#Comment:
    /**
     * Returns the hash code value for this map.  The hash code of a map is
     * defined to be the sum of the hash codes of each entry in the map's
     * <tt>entrySet()</tt> view.  This ensures that <tt>m1.equals(m2)</tt>
     * implies that <tt>m1.hashCode()==m2.hashCode()</tt> for any two maps
     * <tt>m1</tt> and <tt>m2</tt>, as required by the general contract of
     * {@link Object#hashCode}.
     *
     * <p>This implementation iterates over <tt>entrySet()</tt>, calling
     * {@link Map.Entry#hashCode hashCode()} on each element (entry) in the
     * set, and adding up the results.
     *
     * @return the hash code value for this map
     * @see Map.Entry#hashCode()
     * @see Object#equals(Object)
     * @see Set#equals(Object)
     */

#Code:
    public int hashCode() {
        int h = 0;
        Iterator<Entry<K,V>> i = entrySet().iterator();
        while (i.hasNext())
            h += i.next().hashCode();
        return h;
    }

#No. 3328
#File: E:\bishe\1\AbstractMap.java
#Comment:
    /**
     * Returns a string representation of this map.  The string representation
     * consists of a list of key-value mappings in the order returned by the
     * map's <tt>entrySet</tt> view's iterator, enclosed in braces
     * (<tt>"{}"</tt>).  Adjacent mappings are separated by the characters
     * <tt>", "</tt> (comma and space).  Each key-value mapping is rendered as
     * the key followed by an equals sign (<tt>"="</tt>) followed by the
     * associated value.  Keys and values are converted to strings as by
     * {@link String#valueOf(Object)}.
     *
     * @return a string representation of this map
     */

#Code:
    public String toString() {
        Iterator<Entry<K,V>> i = entrySet().iterator();
        if (! i.hasNext())
            return "{}";

        StringBuilder sb = new StringBuilder();
        sb.append('{');
        for (;;) {
            Entry<K,V> e = i.next();
            K key = e.getKey();
            V value = e.getValue();
            sb.append(key   == this ? "(this Map)" : key);
            sb.append('=');
            sb.append(value == this ? "(this Map)" : value);
            if (! i.hasNext())
                return sb.append('}').toString();
            sb.append(',').append(' ');
        }
    }

#No. 3329
#File: E:\bishe\1\AbstractMap.java
#Comment:
    /**
     * Returns a shallow copy of this <tt>AbstractMap</tt> instance: the keys
     * and values themselves are not cloned.
     *
     * @return a shallow copy of this map
     */

#Code:
    protected Object clone() throws CloneNotSupportedException {
        AbstractMap<K,V> result = (AbstractMap<K,V>)super.clone();
        result.keySet = null;
        result.values = null;
        return result;
    }

#No. 3330
#File: E:\bishe\1\AbstractMap.java
#Comment:
    /**
     * Utility method for SimpleEntry and SimpleImmutableEntry.
     * Test for equality, checking for nulls.
     */

#Code:
    private static boolean eq(Object o1, Object o2) {
        return o1 == null ? o2 == null : o1.equals(o2);
    }

#No. 3331
#File: E:\bishe\1\AbstractMapBasedMultimap.java
#Comment:
  /**
   * {@inheritDoc}
   *
   * <p>The returned collection is immutable.
   */

#Code:
  @Override
  public Collection<V> replaceValues(@Nullable K key, Iterable<? extends V> values) {
    Iterator<? extends V> iterator = values.iterator();
    if (!iterator.hasNext()) {
      return removeAll(key);
    }

#No. 3332
#File: E:\bishe\1\AbstractMapBasedMultimap.java
#Comment:
  /**
   * {@inheritDoc}
   *
   * <p>The returned collection is immutable.
   */

#Code:
  @Override
  public Collection<V> removeAll(@Nullable Object key) {
    Collection<V> collection = map.remove(key);

    if (collection == null) {
      return createUnmodifiableEmptyCollection();
    }

#No. 3333
#File: E:\bishe\1\AbstractMapBasedMultimap.java
#Comment:
  /**
   * {@inheritDoc}
   *
   * <p>The returned collection is not serializable.
   */

#Code:
  @Override
  public Collection<V> get(@Nullable K key) {
    Collection<V> collection = map.get(key);
    if (collection == null) {
      collection = createCollection(key);
    }

#No. 3334
#File: E:\bishe\1\AbstractMapBasedMultimap.java
#Comment:
  /**
   * Generates a decorated collection that remains consistent with the values in
   * the multimap for the provided key. Changes to the multimap may alter the
   * returned collection, and vice versa.
   */

#Code:
  Collection<V> wrapCollection(@Nullable K key, Collection<V> collection) {
    // We don't deal with NavigableSet here yet for GWT reasons -- instead,
    // non-GWT TreeMultimap explicitly overrides this and uses NavigableSet.
    if (collection instanceof SortedSet) {
      return new WrappedSortedSet(key, (SortedSet<V>) collection, null);
    } else if (collection instanceof Set) {
      return new WrappedSet(key, (Set<V>) collection);
    } else if (collection instanceof List) {
      return wrapList(key, (List<V>) collection, null);
    } else {
      return new WrappedCollection(key, collection, null);
    }

#No. 3335
#File: E:\bishe\1\AbstractMapBasedMultimap.java
#Comment:
    /**
     * If the delegate collection is empty, but the multimap has values for the
     * key, replace the delegate with the new collection for the key.
     *
     * <p>For a subcollection, refresh its ancestor and validate that the
     * ancestor delegate hasn't changed.
     */

#Code:
    void refreshIfEmpty() {
      if (ancestor != null) {
        ancestor.refreshIfEmpty();
        if (ancestor.getDelegate() != ancestorDelegate) {
          throw new ConcurrentModificationException();
        }
      } else if (delegate.isEmpty()) {
        Collection<V> newDelegate = map.get(key);
        if (newDelegate != null) {
          delegate = newDelegate;
        }
      }
    }

#No. 3336
#File: E:\bishe\1\AbstractMapBasedMultimap.java
#Comment:
    /**
     * If collection is empty, remove it from {@code AbstractMapBasedMultimap.this.map}.
     * For subcollections, check whether the ancestor collection is empty.
     */

#Code:
    void removeIfEmpty() {
      if (ancestor != null) {
        ancestor.removeIfEmpty();
      } else if (delegate.isEmpty()) {
        map.remove(key);
      }
    }

#No. 3337
#File: E:\bishe\1\AbstractMapBasedMultimap.java
#Comment:
    /**
     * Add the delegate to the map. Other {@code WrappedCollection} methods
     * should call this method after adding elements to a previously empty
     * collection.
     *
     * <p>Subcollection add the ancestor's delegate instead.
     */

#Code:
    void addToMap() {
      if (ancestor != null) {
        ancestor.addToMap();
      } else {
        map.put(key, delegate);
      }
    }

#No. 3338
#File: E:\bishe\1\AbstractMapBasedMultimap.java
#Comment:
      /**
       * If the delegate changed since the iterator was created, the iterator is
       * no longer valid.
       */

#Code:
      void validateIterator() {
        refreshIfEmpty();
        if (delegate != originalDelegate) {
          throw new ConcurrentModificationException();
        }
      }

#No. 3339
#File: E:\bishe\1\AbstractMapBasedMultimap.java
#Comment:
  /**
   * SortedSet decorator that stays in sync with the multimap values for a key.
   */

#Code:
  private class WrappedSortedSet extends WrappedCollection
      implements SortedSet<V> {
    WrappedSortedSet(@Nullable K key, SortedSet<V> delegate,
        @Nullable WrappedCollection ancestor) {
      super(key, delegate, ancestor);
    }

#No. 3340
#File: E:\bishe\1\AbstractMapBasedMultimap.java
#Comment:
  /**
   * List decorator that stays in sync with the multimap values for a key and
   * supports rapid random access.
   */

#Code:
  private class RandomAccessWrappedList extends WrappedList
      implements RandomAccess {
    RandomAccessWrappedList(@Nullable K key, List<V> delegate,
        @Nullable WrappedCollection ancestor) {
      super(key, delegate, ancestor);
    }

#No. 3341
#File: E:\bishe\1\AbstractMapBasedMultimap.java
#Comment:
  /**
   * Removes all values for the provided key. Unlike {@link #removeAll}, it
   * returns the number of removed mappings.
   */

#Code:
  private int removeValuesForKey(Object key) {
    Collection<V> collection = Maps.safeRemove(map, key);

    int count = 0;
    if (collection != null) {
      count = collection.size();
      collection.clear();
      totalSize -= count;
    }
    return count;
  }

#No. 3342
#File: E:\bishe\1\AbstractMapBasedMultimap.java
#Comment:
  /**
   * {@inheritDoc}
   *
   * <p>The iterator generated by the returned collection traverses the values
   * for one key, followed by the values of a second key, and so on.
   */

#Code:
  @Override public Collection<V> values() {
    return super.values();
  }

  @Override
  Iterator<V> valueIterator() {
    return new Itr<V>() {
      @Override
      V output(K key, V value) {
        return value;
      }
    };
  }

#No. 3343
#File: E:\bishe\1\AbstractMapBasedMultimap.java
#Comment:
  /*
   * TODO(kevinb): should we copy this javadoc to each concrete class, so that
   * classes like LinkedHashMultimap that need to say something different are
   * still able to {@inheritDoc} all the way from Multimap?
   */

#Code:

  /**
   * {@inheritDoc}
   *
   * <p>The iterator generated by the returned collection traverses the values
   * for one key, followed by the values of a second key, and so on.
   *
   * <p>Each entry is an immutable snapshot of a key-value mapping in the
   * multimap, taken at the time the entry is returned by a method call to the
   * collection or its iterator.
   */
  @Override
  public Collection<Map.Entry<K, V>> entries() {
    return super.entries();
  }

#No. 3344
#File: E:\bishe\1\AbstractMapBasedMultimap.java
#Comment:
  /**
   * Returns an iterator across all key-value map entries, used by {@code
   * entries().iterator()} and {@code values().iterator()}. The default
   * behavior, which traverses the values for one key, the values for a second
   * key, and so on, suffices for most {@code AbstractMapBasedMultimap} implementations.
   *
   * @return an iterator across map entries
   */

#Code:
  @Override
  Iterator<Map.Entry<K, V>> entryIterator() {
    return new Itr<Map.Entry<K, V>>() {
      @Override
      Entry<K, V> output(K key, V value) {
        return Maps.immutableEntry(key, value);
      }
    };
  }

#No. 3345
#File: E:\bishe\1\AbstractMapBasedMultimap.java
#Comment:
    /**
     * Usually the same as map, but smaller for the headMap(), tailMap(), or
     * subMap() of a SortedAsMap.
     */

#Code:
    final transient Map<K, Collection<V>> submap;

    AsMap(Map<K, Collection<V>> submap) {
      this.submap = submap;
    }

#No. 3346
#File: E:\bishe\1\AbstractMapBasedMultiset.java
#Comment:
  /**
   * {@inheritDoc}
   *
   * @throws IllegalArgumentException if the call would result in more than
   *     {@link Integer#MAX_VALUE} occurrences of {@code element} in this
   *     multiset.
   */

#Code:
  @Override public int add(@Nullable E element, int occurrences) {
    if (occurrences == 0) {
      return count(element);
    }

#No. 3347
#File: E:\bishe\1\AbstractMapOneInstanceMultiSet.java
#Comment:
	/*
	**********************************************************************
	*
	*                           FIELDS
	*
	**********************************************************************
	*/

#Code:

	@Nonnull
	private final Map<E, Value<E>> backingMap;

	/*
	**********************************************************************
	*
	*                           CONSTRUCTORS
	*
	**********************************************************************
	*/

	protected AbstractMapOneInstanceMultiSet(@Nonnull Map<E, Value<E>> backingMap) {
		this.backingMap = backingMap;
	}

	/*
	**********************************************************************
	*
	*                           METHODS
	*
	**********************************************************************
	*/

	@Override
	public int remove(@Nullable E e, int count) {
		MultiSets.checkRemove(count);

		final int oldCount = count(e);

		if (oldCount > count) {
			setCount(e, oldCount - count);
		} else {
			this.backingMap.remove(e);
		}

#No. 3348
#File: E:\bishe\1\AbstractMappedMetaDataWithOverride.java
#Comment:
/**
 * MappedMetaData.
 *
 * @param <C> the overriden component type
 * @param <T> the mapped type
 * @param <O> the overriden type
 * @author <a href="adrian@jboss.com">Adrian Brock</a>
 * @version $Revision: 1.1 $
 */

#Code:
public abstract class AbstractMappedMetaDataWithOverride<C extends MappableMetaData, T extends MappableMetaDataWithOverride<C>, O extends MappedMetaData<C>>
        extends AbstractMappedMetaData<T> implements MappedMetaDataWithOverride<C, T, O> {
    /**
     * The serialVersionUID
     */
    private static final long serialVersionUID = 1646142944205417776L;

    /**
     * The overriden metadata
     */
    private O data;

    /**
     * Create a new MappedMetaData.
     *
     * @param keyName the key name
     */
    protected AbstractMappedMetaDataWithOverride(String keyName) {
        super(keyName);
    }

    @Override
    public O getOverridenMetaData() {
        return data;
    }

    // @SchemaProperty(ignore=true)
    @Override
    public void setOverridenMetaData(O data) {
        if (data == null)
            throw new IllegalArgumentException("Null data");
        this.data = data;
    }

    @Override
    public C createOriginal(T data) {
        throw new UnsupportedOperationException("Create originals from overrides is not supported for " + getClass().getName());
    }
}

#No. 3349
#File: E:\bishe\1\AbstractMapStrategy.java
#Comment:
    /**
     * The copy action puts the source's value to the target. When @BeanDefault has been set and the
     * value to copy is empty, it will use the default.
     * @param beanFieldMatch contains the fields belonging to the source/target field match
     */

#Code:
    private void copySourceToTarget(BeanFieldMatch beanFieldMatch) {
        Object copyableSource = beanFieldMatch.getSourceObject();

        if (copyableSource == null) {
            if (beanFieldMatch.targetHasAnnotation(BeanDefault.class)) {
                copyableSource = beanFieldMatch.getTargetDefaultValue();
            } else if (beanFieldMatch.sourceHasAnnotation(BeanDefault.class)) {
                copyableSource = beanFieldMatch.getSourceDefaultValue();
            }
        }

        final Object convertedValue;
        if (beanFieldMatch.sourceHasAnnotation(BeanParent.class) || beanFieldMatch.targetHasAnnotation(BeanParent.class)) {
            convertedValue = beanMapper.getConfiguration().getParent();
        } else {
            convertedValue = convert(copyableSource, beanFieldMatch.getTargetClass(), beanFieldMatch);
        }

        beanFieldMatch.writeObject(convertedValue);
    }

#No. 3350
#File: E:\bishe\1\AbstractMapStrategy.java
#Comment:
    /**
     * If the field is a class which can itself be mapped to another class, it must be treated
     * as such. The matching process is called recursively to deal with this pair.
     * @param beanFieldMatch contains the fields belonging to the source/target field match
     */

#Code:
    private void dealWithMappableNestedClass(BeanFieldMatch beanFieldMatch) {
        Object encapsulatedSource = beanFieldMatch.getSourceObject();
        Object target;
        if (encapsulatedSource != null) {
            logger.debug("    {");
            BeanMapper beanMapper = getBeanMapper()
                    .wrapConfig()
                    .setParent(beanFieldMatch.getTarget())
                    .build();
            if(beanFieldMatch.getTargetObject() == null){
                target = beanMapper.map(encapsulatedSource, beanFieldMatch.getTargetClass());
            } else {
                target = beanMapper.map(encapsulatedSource, beanFieldMatch.getTargetObject());
            }
            beanFieldMatch.writeObject(target);
            logger.debug("    }");
        }
    }

#No. 3351
#File: E:\bishe\1\AbstractMapStrategy.java
#Comment:
    /**
     * Converts a value into the target class.
     * @param value the value to convert
     * @param targetClass the target class
     * @param beanFieldMatch contains the fields belonging to the source/target field match
     * @return the converted value
     */

#Code:
    @SuppressWarnings("unchecked")
    public Object convert(Object value, Class<?> targetClass, BeanFieldMatch beanFieldMatch) {
        if (value == null) {
            return null;
        }

        Class<?> valueClass = getConfiguration().getBeanUnproxy().unproxy(value.getClass());

        BeanConverter converter = getConverterOptional(valueClass, targetClass);
        if (converter != null) {
            logger.debug(INDENT + converter.getClass().getSimpleName() + ARROW);
            BeanMapper wrappedBeanMapper = beanMapper
                    .wrapConfig()
                    .setParent(beanFieldMatch.getTarget())
                    .build();
            return converter.convert(wrappedBeanMapper, value, targetClass, beanFieldMatch);
        }

        if (targetClass.isAssignableFrom(valueClass)) {
            return value;
        }

        throw new BeanConversionException(beanFieldMatch.getSourceClass(), targetClass);
    }

#No. 3352
#File: E:\bishe\1\AbstractMapStrategy.java
#Comment:
    /**
     * Try to match the source fields on the target fields from the given classes.
     * First get all fields on the right level with method getAllFields.
     * Second match the fields and handle encapsulated classes.
     * Finally copy the data from the source to the target.
     *
     * @param source The source from which the values get copied.
     * @param target The target to which the values get copied.
     * @param <S>    The source type
     * @param <T>    The target type
     * @param beanMatch the matchup of source and target
     * @return A filled target object.
     */

#Code:
    public <S, T> T processFields(S source, T target, BeanMatch beanMatch) {
        for (String fieldName : beanMatch.getTargetNode().keySet()) {
            BeanField sourceField = beanMatch.getSourceNode().get(fieldName);
            if(sourceField == null) {
                // No source field found -> check for alias
                sourceField = beanMatch.getAliases().get(fieldName);
            }
            BeanField targetField = beanMatch.getTargetNode().get(fieldName);
            if(targetField == null) {
                // No target field found -> check for alias
                targetField = beanMatch.getAliases().get(fieldName);
            }
            processField(new BeanFieldMatch(source, target, sourceField, targetField, fieldName, beanMatch));
        }
        return target;
    }

#No. 3353
#File: E:\bishe\1\AbstractMapStrategy.java
#Comment:
    /**
     * Process a single combination of a source and a target field.
     * @param beanFieldMatch contains the fields belonging to the source/target field match
     */

#Code:
    private void processField(BeanFieldMatch beanFieldMatch) {
        if (!beanFieldMatch.hasMatchingSource()) {
            dealWithNonMatchingNode(beanFieldMatch);
            return;
        }
        if (!isConverterFor(beanFieldMatch.getSourceClass(), beanFieldMatch.getTargetClass()) &&
                (!beanFieldMatch.hasSimilarClasses() || (beanFieldMatch.hasSimilarClasses() && beanFieldMatch.getTargetObject() != null)) &&
                !(beanFieldMatch.getSourceClass().isEnum() || beanFieldMatch.getTargetClass().isEnum()) &&
                isMappableClass(beanFieldMatch.getTargetClass()) &&
                beanFieldMatch.getSourceObject() != null) {

            dealWithMappableNestedClass(beanFieldMatch);
            return;
        }
        if (beanFieldMatch.isMappable()) {
            logger.debug(beanFieldMatch.sourceToString() + ARROW);
            copySourceToTarget(beanFieldMatch);
            logger.debug(INDENT + beanFieldMatch.targetToString());
        }
    }

#No. 3354
#File: E:\bishe\1\AbstractMapStrategy.java
#Comment:
    /**
     * This method is run when there is no matching source field for a target field. The result
     * could be that a default is set, or an exception is thrown when a BeanProperty has been set.
     * @param beanFieldMatch contains the fields belonging to the source/target field match
     */

#Code:
    private void dealWithNonMatchingNode(BeanFieldMatch beanFieldMatch) {
        if (beanFieldMatch.targetHasAnnotation(BeanDefault.class)) {
            beanFieldMatch.setTarget(beanFieldMatch.getTargetDefaultValue());
        } else if (beanFieldMatch.targetHasAnnotation(BeanProperty.class)) {
            throw new BeanFieldNoMatchException("No source field found while attempting to map to " + beanFieldMatch.getTargetFieldName());
        }
    }

#No. 3355
#File: E:\bishe\1\AbstractMapStrategy.java
#Comment:
    /**
     * Verifies whether the class is part of the beans which may be mapped by the BeanMapper. This logic is
     * used when nested classes are encountered which need to be treated in a similar way as the main source/
     * target classes.
     * @param clazz the class to be verified against the allowed packages
     * @return true if the class may be mapped, false if it may not
     */

#Code:
    public boolean isMappableClass(Class<?> clazz) {
        return clazz.getPackage() != null && isMappable(clazz.getPackage().getName());
    }

#No. 3356
#File: E:\bishe\1\AbstractMapStrategy.java
#Comment:
    /**
     * Verifies whether the package is part of the beans which may be mapped by the bean mapper. This logic is
     * used when nested classes are encountered which need to be treated in a similar way as the main source/
     * target classes.
     * @param packageName the package
     * @return true if the class may be mapped, false if it may not
     */

#Code:
    public boolean isMappable(String packageName) {
        for (String packagePrefix : getConfiguration().getPackagePrefixes()) {
            if (packageName.startsWith(packagePrefix)) {
                return true;
            }
        }
        return false;
    }

#No. 3357
#File: E:\bishe\1\AbstractMarker.java
#Comment:
    /**
     * Loads the provided bitmap into the image view.
     * @param iconView The view to load the icon into.
     */

#Code:
    public void loadIcon(ImageView iconView) {
        iconView.setImageBitmap(this.getNamedBitmapProvider().getBitmap());
    }

#No. 3358
#File: E:\bishe\1\AbstractMarkupDocBuilder.java
#Comment:
    /**
     * Explicit line break default behavior for line returns, when not specified. Please, change documentation accordingly.
     */

#Code:
    protected static final boolean LINE_BREAK_DEFAULT = false;

    protected static final Pattern ANCHOR_UNIGNORABLE_PATTERN = Pattern.compile("[^0-9a-zA-Z-_]+");
    protected static final Pattern ANCHOR_IGNORABLE_PATTERN = Pattern.compile("[\\s@#&(){}\\[\\]!$*%+=/:.;,?\\\\<>|]+");
    protected static final String ANCHOR_SEPARATION_CHARACTERS = "_-";
    protected static final int MAX_TITLE_LEVEL = 5;
    protected static final String NEW_LINES = "\\r\\n|\\r|\\n";
    protected static final String WHITESPACE = " ";

    protected StringBuilder documentBuilder = new StringBuilder();
    protected String newLine;
    protected Logger logger = LoggerFactory.getLogger(getClass());

    protected String anchorPrefix = null;

    public AbstractMarkupDocBuilder() {
        this(System.getProperty("line.separator"));
    }

#No. 3359
#File: E:\bishe\1\AbstractMarkupDocBuilder.java
#Comment:
    /*
     * Generic normalization algorithm for all markups (less common denominator character set).
     * Key points :
     * - Anchor is normalized (Normalized.Form.NFD)
     * - Punctuations (excluding [-_]) and spaces are replaced with escape character (depends on markup : Markup.E)
     * - Beginning, ending separation characters [-_] are ignored, repeating separation characters are simplified (keep first one)
     * - Anchor is trimmed and lower cased
     * - If the anchor still contains forbidden characters (non-ASCII, ...), replace the whole anchor with an hash (MD5).
     * - Add the anchor prefix if configured
     */

#Code:
    protected String normalizeAnchor(Markup spaceEscape, String anchor) {
        String normalizedAnchor = defaultString(anchorPrefix) + anchor.trim();
        normalizedAnchor = Normalizer.normalize(normalizedAnchor, Normalizer.Form.NFD).replaceAll("\\p{InCombiningDiacriticalMarks}+", "");
        normalizedAnchor = ANCHOR_IGNORABLE_PATTERN.matcher(normalizedAnchor).replaceAll(spaceEscape.toString());
        normalizedAnchor = normalizedAnchor.replaceAll(String.format("([%1$s])([%1$s]+)", ANCHOR_SEPARATION_CHARACTERS), "$1");
        normalizedAnchor = StringUtils.strip(normalizedAnchor, ANCHOR_SEPARATION_CHARACTERS);
        normalizedAnchor = normalizedAnchor.trim().toLowerCase();

        String validAnchor = ANCHOR_UNIGNORABLE_PATTERN.matcher(normalizedAnchor).replaceAll("");
        if (validAnchor.length() != normalizedAnchor.length())
            normalizedAnchor = DigestUtils.md5Hex(normalizedAnchor);
        else
            normalizedAnchor = validAnchor;

        return normalizedAnchor;
    }

#No. 3360
#File: E:\bishe\1\AbstractMarkupDocBuilder.java
#Comment:
    /**
     * 2 newLines are needed at the end of file for file to be included without protection.
     */

#Code:
    @Override
    public void writeToFileWithoutExtension(Path file, Charset charset, OpenOption... options) {
        try {
            Files.createDirectories(file.getParent());
        } catch (IOException e) {
            throw new RuntimeException("Failed create directory", e);
        }
        try (BufferedWriter writer = Files.newBufferedWriter(file, charset, options)) {
            writer.write(toString());
            writer.write(newLine);
            writer.write(newLine);
        } catch (IOException e) {
            throw new RuntimeException("Failed to write file", e);
        }
        if (logger.isInfoEnabled()) {
            logger.info("Markup document written to: {}", file);
        }
    }

#No. 3361
#File: E:\bishe\1\AbstractMarkupLanguageSupport.java
#Comment:
	/**
	 * Sets whether closing tags should be automatically added when the user
	 * types a (non-self-closing) start tag.  This will only be done for tags
	 * where closing tags are accepted and valid, based on the doctype.
	 *
	 * @param autoAdd Whether to automatically add closing tags.
	 * @see #getAutoAddClosingTags()
	 */

#Code:
	public void setAutoAddClosingTags(boolean autoAdd) {
		autoAddClosingTags = autoAdd;
	}

#No. 3362
#File: E:\bishe\1\AbstractMarkupLanguageSupport.java
#Comment:
	/**
	 * Uninstalls any keyboard shortcuts specific to this language support.<p>
	 *
	 * Subclasses should call this method in their
	 * {@link #uninstall(RSyntaxTextArea)} methods.
	 *
	 * @param textArea The text area to uninstall the actions from.
	 * @see #installKeyboardShortcuts(RSyntaxTextArea)
	 */

#Code:
	protected void uninstallKeyboardShortcuts(RSyntaxTextArea textArea) {

		InputMap im = textArea.getInputMap();
		ActionMap am = textArea.getActionMap();

		im.remove(KeyStroke.getKeyStroke('>'));
		am.remove(INSERT_CLOSING_TAG_ACTION);

	}

#No. 3363
#File: E:\bishe\1\AbstractMatrix.java
#Comment:
	/**
	 * Returns the number of rows in the matrix.
	 * @return the number of rows in the matrix.
	 * @see org.apache.commons.math.linear.RealMatrix
	 */

#Code:
	public int getRowDimension(){
		return matrix.getRowDimension();
	}

#No. 3364
#File: E:\bishe\1\AbstractMatrix.java
#Comment:
	/**
	 * Returns the number of columns in the matrix.
	 * @return the number of columns in the matrix.
	 * @see org.apache.commons.math.linear.RealMatrix
	 */

#Code:
	public int getColumnDimension(){
		return matrix.getColumnDimension();
	}

#No. 3365
#File: E:\bishe\1\AbstractMatrix.java
#Comment:
	/**
	 * Clones the matrix and returns a new copy of it.
	 * @return a new, deep copied matrix.
	 * @see org.apache.commons.math.linear.RealMatrix
	 */

#Code:
	protected RealMatrix cloneHelper(){
		return matrix.copy();
	}

#No. 3366
#File: E:\bishe\1\AbstractMavenAntTask.java
#Comment:
	/**
	 * Only relevant for ant based mojo
	 * @return
	 */

#Code:
	protected MojoExecution getCurrentMojoExecution(){
		return (MojoExecution)getProject().getReference("mojoExecution");
	}

#No. 3367
#File: E:\bishe\1\AbstractMavenExecutor.java
#Comment:
    /**
     * When this plugin requires Maven 3.0 as minimum, this component can be removed and o.a.m.s.c.SettingsDecrypter be
     * used instead.
     */

#Code:
    @Requirement( role = SecDispatcher.class, hint = "mng-4384" )
    private DefaultSecDispatcher secDispatcher;

    /**
     * 
     */
    @Requirement
    private PlexusCipher cipher;
    
    protected AbstractMavenExecutor()
    {
    }

#No. 3368
#File: E:\bishe\1\AbstractMemberWriter.java
#Comment:
    /**
     * Return a string describing the access modifier flags.
     * Don't include native or synchronized.
     *
     * The modifier names are returned in canonical order, as
     * specified by <em>The Java Language Specification</em>.
     */

#Code:
    protected String modifierString(MemberDoc member) {
        int ms = member.modifierSpecifier();
        int no = Modifier.NATIVE | Modifier.SYNCHRONIZED;
    return Modifier.toString(ms & ~no);
    }

#No. 3369
#File: E:\bishe\1\AbstractMemberWriter.java
#Comment:
    /**
     * Print 'static' if static and type link.
     */

#Code:
    protected void printStaticAndType(boolean isStatic, Type type) {
        writer.printTypeSummaryHeader();
        if (isStatic) {
            print("static");
        }
        writer.space();
        if (type != null) {
            writer.printLink(new LinkInfoImpl(LinkInfoImpl.CONTEXT_MEMBER, 
                type));
        }
        writer.printTypeSummaryFooter();
    }

#No. 3370
#File: E:\bishe\1\AbstractMemberWriter.java
#Comment:
    /**
     * Forward to containing writer
     */

#Code:
    public void printSummaryHeader(ClassDoc cd) {
        printedSummaryHeader = true;
        writer.printSummaryHeader(this, cd);
    }

#No. 3371
#File: E:\bishe\1\AbstractMemberWriter.java
#Comment:
    /**
     * Forward to containing writer
     */

#Code:
    public void printInheritedSummaryHeader(ClassDoc cd) {
        writer.printInheritedSummaryHeader(this, cd);
    }

#No. 3372
#File: E:\bishe\1\AbstractMemberWriter.java
#Comment:
    /**
     * Forward to containing writer
     */

#Code:
    public void printInheritedSummaryFooter(ClassDoc cd) {
        writer.printInheritedSummaryFooter(this, cd);
    }

#No. 3373
#File: E:\bishe\1\AbstractMemberWriter.java
#Comment:
    /**
     * Forward to containing writer
     */

#Code:
    public void printSummaryFooter(ClassDoc cd) {
        writer.printSummaryFooter(this, cd);
    }

#No. 3374
#File: E:\bishe\1\AbstractMemberWriter.java
#Comment:
   /**
    * Return true if the given <code>ProgramElement</code> is inherited
    * by the class that is being documented.
    *
    * @param ped The <code>ProgramElement</code> being checked.
    * return true if the <code>ProgramElement</code> is being inherited and
    * false otherwise.
    */

#Code:
    protected boolean isInherited(ProgramElementDoc ped){
        if(ped.isPrivate() || (ped.isPackagePrivate() &&
            ! ped.containingPackage().equals(classdoc.containingPackage()))){
            return false;
        }
        return true;
    }

#No. 3375
#File: E:\bishe\1\AbstractMemberWriter.java
#Comment:
    /**
     * Generate the code for listing the deprecated APIs. Create the table
     * format for listing the API. Call methods from the sub-class to complete
     * the generation.
     */

#Code:
    protected void printDeprecatedAPI(List deprmembers, String headingKey) {
        if (deprmembers.size() > 0) {
            writer.tableIndexSummary();
            writer.tableHeaderStart("#CCCCFF");
            writer.boldText(headingKey);
            writer.tableHeaderEnd();
            for (int i = 0; i < deprmembers.size(); i++) {
                ProgramElementDoc member =(ProgramElementDoc)deprmembers.get(i);
                writer.trBgcolorStyle("white", "TableRowColor");
                writer.summaryRow(0);
                writeDeprecatedLink(member);
                writer.br();
                writer.printNbsps();
                if (member.tags("deprecated").length > 0)
                    writer.printInlineDeprecatedComment(member, member.tags("deprecated")[0]);
                writer.space();
                writer.summaryRowEnd();
                writer.trEnd();
            }
            writer.tableEnd();
            writer.space();
            writer.p();
        }
    }

#No. 3376
#File: E:\bishe\1\AbstractMemberWriter.java
#Comment:
    /**
     * Print use info.
     */

#Code:
    protected void printUseInfo(Object mems, String heading) {
        if (mems == null) {
            return;
        }
        List members = (List)mems;
        if (members.size() > 0) {
            writer.tableIndexSummary();
            writer.tableUseInfoHeaderStart("#CCCCFF");
            writer.print(heading);
            writer.tableHeaderEnd();
            for (Iterator it = members.iterator(); it.hasNext(); ) {
                ProgramElementDoc pgmdoc = (ProgramElementDoc)it.next();
                ClassDoc cd = pgmdoc.containingClass();

                writer.printSummaryLinkType(this, pgmdoc);
                if (cd != null && !(pgmdoc instanceof ConstructorDoc)
                               && !(pgmdoc instanceof ClassDoc)) {
                    // Add class context
                    writer.bold(cd.name() + ".");
                }
                writeSummaryLink(
                    pgmdoc instanceof ClassDoc ? 
                        LinkInfoImpl.CONTEXT_CLASS_USE : LinkInfoImpl.CONTEXT_MEMBER, 
                    cd, pgmdoc);
                writer.printSummaryLinkComment(this, pgmdoc);
            }
            writer.tableEnd();
            writer.space();
            writer.p();
        }
    }

#No. 3377
#File: E:\bishe\1\AbstractMemberWriter.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public void writeMemberSummary(ClassDoc classDoc, ProgramElementDoc member, 
        Tag[] firstSentenceTags, boolean isFirst, boolean isLast) {
        writer.printSummaryLinkType(this, member);
        writeSummaryLink(classDoc, member);
        writer.printSummaryLinkComment(this, member, firstSentenceTags);
    }

#No. 3378
#File: E:\bishe\1\AbstractMemcachedAccessStrategy.java
#Comment:
    /**
     * The settings for this persistence unit.
     */

#Code:
    protected SessionFactoryOptions settings() {
        return settings;
    }

#No. 3379
#File: E:\bishe\1\AbstractMemcachedAccessStrategy.java
#Comment:
    /**
     * This method is a placeholder for method signatures supplied by interfaces pulled in further down the class
     * hierarchy.
     */

#Code:
    public final boolean putFromLoad(SharedSessionContractImplementor session, Object key, Object value, long txTimestamp, Object version) throws CacheException {
        return putFromLoad(session, key, value, txTimestamp, version, settings.isMinimalPutsEnabled());
    }

#No. 3380
#File: E:\bishe\1\AbstractMemcachedAccessStrategy.java
#Comment:
    /**
     * This method is a placeholder for method signatures supplied by interfaces pulled in further down the class
     * hierarchy.
     */

#Code:
    public abstract boolean putFromLoad(SharedSessionContractImplementor session, Object key, Object value, long txTimestamp, Object version, boolean minimalPutOverride)
            throws CacheException;

    /**
     * Region locks are not supported.
     */
    @SuppressWarnings("UnusedDeclaration")
    public SoftLock lockRegion() {
        return null;
    }

#No. 3381
#File: E:\bishe\1\AbstractMemcachedAccessStrategy.java
#Comment:
    /**
     * Region locks are not supported - perform a cache clear as a precaution.
     *
     * @see org.hibernate.cache.spi.access.EntityRegionAccessStrategy#unlockRegion(org.hibernate.cache.spi.access.SoftLock)
     * @see org.hibernate.cache.spi.access.CollectionRegionAccessStrategy#unlockRegion(org.hibernate.cache.spi.access.SoftLock)
     */

#Code:
    @SuppressWarnings("UnusedDeclaration")
    public void unlockRegion(SoftLock lock) throws CacheException {
        region.getCache().clear();
    }

#No. 3382
#File: E:\bishe\1\AbstractMemcachedAccessStrategy.java
#Comment:
    /**
     * Called to evict data from the entire region
     */

#Code:
    @SuppressWarnings("UnusedDeclaration")
    public final void removeAll() throws CacheException {
        region().clear();
    }

#No. 3383
#File: E:\bishe\1\AbstractMemcachedAccessStrategy.java
#Comment:
    /**
     * Remove the given mapping without regard to transactional safety
     */

#Code:
    @SuppressWarnings("UnusedDeclaration")
    public final void evict(Object key) throws CacheException {
        region().remove(key);
    }

#No. 3384
#File: E:\bishe\1\AbstractMemcachedAccessStrategy.java
#Comment:
    /**
     * Remove all mappings without regard to transactional safety
     */

#Code:
    @SuppressWarnings("UnusedDeclaration")
    public final void evictAll() throws CacheException {
        region().clear();
    }

#No. 3385
#File: E:\bishe\1\AbstractMemcachedRegion.java
#Comment:
    /**
     * {@inheritDoc}
     *
     * @return emptyMap, since memcached doesn't support this notion.
     */

#Code:
    @Override
    public Map toMap() {
        return Collections.emptyMap();
    }

#No. 3386
#File: E:\bishe\1\AbstractMemcachedRegion.java
#Comment:
    /**
     * @return next timestamp in ms
     */

#Code:
    public long nextTimestamp() {
        return System.currentTimeMillis();
    }

#No. 3387
#File: E:\bishe\1\AbstractMemcachedRegion.java
#Comment:
    /**
     * @return cache lock timeout in ms
     */

#Code:
    public int getTimeout() {
        return lockTimeout;
    }

#No. 3388
#File: E:\bishe\1\AbstractMemcacheObjectEncoder.java
#Comment:
    /**
     * Determine the content length of the given object.
     *
     * @param msg the object to determine the length of.
     * @return the determined content length.
     */

#Code:
    private static int contentLength(Object msg) {
        if (msg instanceof MemcacheContent) {
            return ((MemcacheContent) msg).content().readableBytes();
        }
        if (msg instanceof ByteBuf) {
            return ((ByteBuf) msg).readableBytes();
        }
        if (msg instanceof FileRegion) {
            return (int) ((FileRegion) msg).count();
        }
        throw new IllegalStateException("unexpected message type: " + StringUtil.simpleClassName(msg));
    }

#No. 3389
#File: E:\bishe\1\AbstractMemcacheObjectEncoder.java
#Comment:
    /**
     * Encode the content, depending on the object type.
     *
     * @param msg the object to encode.
     * @return the encoded object.
     */

#Code:
    private static Object encodeAndRetain(Object msg) {
        if (msg instanceof ByteBuf) {
            return ((ByteBuf) msg).retain();
        }
        if (msg instanceof MemcacheContent) {
            return ((MemcacheContent) msg).content().retain();
        }
        if (msg instanceof FileRegion) {
            return ((FileRegion) msg).retain();
        }
        throw new IllegalStateException("unexpected message type: " + StringUtil.simpleClassName(msg));
    }

#No. 3390
#File: E:\bishe\1\AbstractMemMetricTest.java
#Comment:
    /**
     * Test of getMetric method, of class AbstractMemMetric.
     */

#Code:
    public void testGetMetric() {
        System.out.println("getMetric");
        StringBuffer res = new StringBuffer();
        SigarProxy sigar = SigarProxyCache.newInstance(new Sigar(), 500);
        MetricParamsSigar params = new MetricParamsSigar(sigar);
        AbstractMemMetric result = AbstractMemMetric.getMetric(sigar, params);
        assertEquals(params, result.params);
    }

#No. 3391
#File: E:\bishe\1\AbstractMemoized.java
#Comment:
  /**
   * Memoizes the distance between terms, {@code v} and {@code w}, and returns
   * it.
   * @param v Term to compare with {@code w}
   * @param w Term to compare with {@code v}
   * @return Distance between {@code v} and {@code w}
   */

#Code:
  public abstract int memoizedDistance(String v, String w);
}
}

#No. 3392
#File: E:\bishe\1\AbstractMemoryHttpDataTest.java
#Comment:
    /**
     * Provide content into HTTP data with input stream.
     *
     * @throws Exception In case of any exception.
     */

#Code:
    @Test
    public void testSetContentFromStream() throws Exception {
        Random random = new SecureRandom();

        for (int i = 0; i < 20; i++) {
            // Generate input data bytes.
            int size = random.nextInt(Short.MAX_VALUE);
            byte[] bytes = new byte[size];

            random.nextBytes(bytes);

            // Generate parsed HTTP data block.
            TestHttpData data = new TestHttpData("name", UTF_8, 0);

            data.setContent(new ByteArrayInputStream(bytes));

            // Validate stored data.
            ChannelBuffer buffer = data.getChannelBuffer();

            assertEquals(0, buffer.readerIndex());
            assertEquals(bytes.length, buffer.writerIndex());
            assertArrayEquals(bytes, Arrays.copyOf(buffer.array(), bytes.length));
        }
    }

#No. 3393
#File: E:\bishe\1\AbstractMemoryHttpDataTest.java
#Comment:
        /**
         * Constructs HTTP data for tests.
         *
         * @param name    Name of parsed data block.
         * @param charset Used charset for data decoding.
         * @param size    Expected data block size.
         */

#Code:
        protected TestHttpData(String name, Charset charset, long size) {
            super(name, charset, size);
        }

#No. 3394
#File: E:\bishe\1\AbstractMenuComponent.java
#Comment:
    /**
     * Listener to monitor changes to state model.
     */

#Code:
    private ChangeListener stateModelListener = new ChangeListener() {

        /**
         * @see nextapp.echo.app.event.ChangeListener#stateChanged(nextapp.echo.app.event.ChangeEvent)
         */
        public void stateChanged(ChangeEvent e) {
            firePropertyChange(STATE_MODEL_CHANGED_PROPERTY, null, stateModel);
        }
    };

#No. 3395
#File: E:\bishe\1\AbstractMenuComponent.java
#Comment:
    /**
     * Creates a new <code>AbstractMenuComponent</code> displaying the specified 
     * <code>MenuModel</code> and using the specified 
     * <code>MenuStateModel</code> to provide state information.
     * 
     * @param model the model
     * @param stateModel the selection model
     */

#Code:
    public AbstractMenuComponent(MenuModel model, MenuStateModel stateModel) {
        super();
        setModel(model == null ? new DefaultMenuModel() : model);
        setStateModel(stateModel == null ? new DefaultMenuStateModel() : stateModel);
    }

#No. 3396
#File: E:\bishe\1\AbstractMenuComponent.java
#Comment:
    /**
     * Adds an <code>ActionListener</code> to be notified when a menu item 
     * is selected.
     * 
     * @param l the listener to add
     */

#Code:
    public void addActionListener(ActionListener l) {
        getEventListenerList().addListener(ActionListener.class, l);
        firePropertyChange(ACTION_LISTENERS_CHANGED_PROPERTY, null, l);
    }

#No. 3397
#File: E:\bishe\1\AbstractMenuComponent.java
#Comment:
    /**
     * Adds an <code>ActionListener</code> to be notified when the menu is activated. 
     * 
     * @param l the listener to add
     */

#Code:
    public void addActivationListener(MenuActivationListener l) {
        getEventListenerList().addListener(MenuActivationListener.class, l);
        firePropertyChange(ACTIVATION_LISTENERS_CHANGED_PROPERTY, null, l);
    }

#No. 3398
#File: E:\bishe\1\AbstractMenuComponent.java
#Comment:
    /**
     * Returns the animation time (in milliseconds).  A value of zero indicates animation is disabled.
     * 
     * @return the animation time
     */

#Code:
    public int getAnimationTime() {
        Integer animationTime = (Integer) get(PROPERTY_ANIMATION_TIME);
        return animationTime == null ? DEFAULT_ANIMATION_TIME : animationTime.intValue(); 
    }

#No. 3399
#File: E:\bishe\1\AbstractMenuComponent.java
#Comment:
    /**
     * Determines if the menu has any <code>ActionListener</code>s registered.
     * 
     * @return true if any action listeners are registered
     */

#Code:
    public boolean hasActionListeners() {
        return hasEventListenerList() && getEventListenerList().getListenerCount(ActionListener.class) != 0;
    }

#No. 3400
#File: E:\bishe\1\AbstractMenuComponent.java
#Comment:
    /**
     * Determines if the menu has any <code>ActivationListener</code>s registered.
     * 
     * @return true if any action listeners are registered
     */

#Code:
    public boolean hasActivationListeners() {
        return hasEventListenerList() && getEventListenerList().getListenerCount(MenuActivationListener.class) != 0;
    }

#No. 3401
#File: E:\bishe\1\AbstractMenuComponent.java
#Comment:
    /**
     * Deselects <code>RadioOptionModel</code> items in a group when a selection
     * is made within that group.  Operates by recursively searching 
     * <code>MenuModel</code>s for <code>RadioOptionModel</code>s with a specific
     * group id. 
     * 
     * @param menuModel the <code>MenuModel</code> to search 
     * @param groupId the id of the group to deselect
     * @param newSelectionId the id of the new selection in the group
     */

#Code:
    private void deselectGroup(MenuModel menuModel, Object groupId, Object newSelectionId) {
        int count = menuModel.getItemCount();
        for (int i = 0; i < count; ++i) {
            ItemModel itemModel = menuModel.getItem(i);
            if (itemModel instanceof MenuModel) {
                deselectGroup((MenuModel) itemModel, groupId, newSelectionId);
            } else if (itemModel instanceof RadioOptionModel) {
                RadioOptionModel radioOptionModel = (RadioOptionModel) itemModel;
                if (radioOptionModel.getGroupId() != null && radioOptionModel.getGroupId().equals(groupId)) {
                    getStateModel().setSelected(radioOptionModel.getId(), false);
                }
            }
        }
    }

#No. 3402
#File: E:\bishe\1\AbstractMenuComponent.java
#Comment:
    /**
     * Programmatically performs a menu action.
     * 
     * @param optionModel the <code>OptionModel</code> whose action is to be 
     *        invoked
     */

#Code:
    public void doAction(OptionModel optionModel) {
        if (getStateModel() != null && !getStateModel().isEnabled(optionModel.getId())) {
            // Do nothing, item is disabled.
            return;
        }
        if (getStateModel() != null && optionModel instanceof ToggleOptionModel) {
            if (optionModel instanceof RadioOptionModel) {
                RadioOptionModel radioOptionModel = (RadioOptionModel) optionModel;
                deselectGroup(getModel(), radioOptionModel.getGroupId(), radioOptionModel.getId());
                getStateModel().setSelected(radioOptionModel.getId(), true);
            } else {
                ToggleOptionModel toggleOptionModel = (ToggleOptionModel) optionModel;
                getStateModel().setSelected(toggleOptionModel.getId(), !getStateModel().isSelected(toggleOptionModel.getId()));
            }
            firePropertyChange(STATE_MODEL_CHANGED_PROPERTY, null, null);
        }
        fireActionPerformed(optionModel);
    }

#No. 3403
#File: E:\bishe\1\AbstractMenuComponent.java
#Comment:
    /**
     * Programmatically activates the menu.
     */

#Code:
    public void doActivation() {
        fireMenuActivated();
    }

#No. 3404
#File: E:\bishe\1\AbstractMenuComponent.java
#Comment:
    /**
     * Notifies <code>MenuActivationListener</code>s that the menu has been activated.
     */

#Code:
    protected void fireMenuActivated() {
        if (!hasEventListenerList()) {
            return;
        }
        MenuActivationEvent e = new MenuActivationEvent(this);
        EventListener[] listeners = getEventListenerList().getListeners(MenuActivationListener.class);
        for (int i = 0; i < listeners.length; ++i) {
            ((MenuActivationListener) listeners[i]).menuActivated(e);
        }
    }

#No. 3405
#File: E:\bishe\1\AbstractMenuComponent.java
#Comment:
    /**
     * Notifies <code>ActionListener</code>s that an option was chosen. 
     * 
     * @param optionModel the selected <code>OptionModel</code>
     */

#Code:
    protected void fireActionPerformed(OptionModel optionModel) {
        if (!hasEventListenerList()) {
            return;
        }
        ActionEvent e = new ActionEvent(this, optionModel.getId());
        EventListener[] listeners = getEventListenerList().getListeners(ActionListener.class);
        for (int i = 0; i < listeners.length; ++i) {
            ((ActionListener) listeners[i]).actionPerformed(e);
        }
    }

#No. 3406
#File: E:\bishe\1\AbstractMenuComponent.java
#Comment:
    /**
     * Returns the model
     * 
     * @return the model
     */

#Code:
    public MenuModel getModel() {
        return model;
    }

#No. 3407
#File: E:\bishe\1\AbstractMenuComponent.java
#Comment:
    /**
     * Returns the selection model
     * 
     * @return the selection model
     */

#Code:
    public MenuStateModel getStateModel() {
        return stateModel;
    }

#No. 3408
#File: E:\bishe\1\AbstractMenuComponent.java
#Comment:
    /**
     * @see nextapp.echo.app.Component#processInput(java.lang.String, java.lang.Object)
     */

#Code:
    public void processInput(String name, Object value) {
        if (INPUT_ACTION.equals(name)) {
            OptionModel optionModel = (OptionModel) value;
            doAction(optionModel);
        } else if (INPUT_ACTIVATION.equals(name)) {
            doActivation();
        }
    }

#No. 3409
#File: E:\bishe\1\AbstractMenuComponent.java
#Comment:
    /**
     * Removes an <code>ActionListener</code> from being notified when a menu 
     * item is selected.
     * 
     * @param l the listener to remove
     */

#Code:
    public void removeActionListener(ActionListener l) {
        getEventListenerList().removeListener(ActionListener.class, l);
        firePropertyChange(ACTION_LISTENERS_CHANGED_PROPERTY, l, null);

    }

#No. 3410
#File: E:\bishe\1\AbstractMenuComponent.java
#Comment:
    /**
     * Removes an <code>ActionListener</code> from being notified when the menu is activated. 
     * 
     * @param l the listener to remove
     */

#Code:
    public void removeActivationListener(MenuActivationListener l) {
        getEventListenerList().removeListener(MenuActivationListener.class, l);
        firePropertyChange(ACTIVATION_LISTENERS_CHANGED_PROPERTY, l, null);
    }

#No. 3411
#File: E:\bishe\1\AbstractMenuComponent.java
#Comment:
    /**
     * Sets the animation time (in milliseconds).  A value of zero indicates animation is disabled.
     * 
     * @param newValue the new animation time
     */

#Code:
    public void setAnimationTime(int newValue) {
        set(PROPERTY_ANIMATION_TIME, new Integer(newValue));
    }

#No. 3412
#File: E:\bishe\1\AbstractMenuComponent.java
#Comment:
    /**
     * Sets the model.
     * 
     * @param newValue the new model
     */

#Code:
    public void setModel(MenuModel newValue) {
        if (newValue == null) {
            throw new IllegalArgumentException("Model may not be null.");
        }
        MenuModel oldValue = model;
        model = newValue;
        firePropertyChange(MODEL_CHANGED_PROPERTY, oldValue, newValue);
    }

#No. 3413
#File: E:\bishe\1\AbstractMenuComponent.java
#Comment:
    /**
     * Sets the state model.
     * 
     * @param newValue the new state model
     */

#Code:
    public void setStateModel(MenuStateModel newValue) {
        if (newValue == null) {
            throw new IllegalArgumentException("State model may not be null.");
        }
        MenuStateModel oldValue = stateModel;
        if (oldValue != null) {
            oldValue.removeChangeListener(stateModelListener);
        }
        stateModel = newValue;
        newValue.addChangeListener(stateModelListener);
        firePropertyChange(STATE_MODEL_CHANGED_PROPERTY, oldValue, newValue);
    }

#No. 3414
#File: E:\bishe\1\AbstractMenuSelectionModel.java
#Comment:
    /**
     * @see nextapp.echo.extras.app.menu.MenuSelectionModel#addChangeListener(nextapp.echo.app.event.ChangeListener)
     */

#Code:
    public void addChangeListener(ChangeListener l) {
        listenerList.addListener(ChangeListener.class, l);
    }

#No. 3415
#File: E:\bishe\1\AbstractMenuSelectionModel.java
#Comment:
    /**
     * Notifies <code>ChangeListener</code>s of a selection state change.
     */

#Code:
    protected void fireStateChanged() {
        ChangeEvent e = new ChangeEvent(this);
        EventListener[] listeners = listenerList.getListeners(ChangeListener.class);
        for (int i = 0; i < listeners.length; ++i) {
            ((ChangeListener) listeners[i]).stateChanged(e);
        }
    }

#No. 3416
#File: E:\bishe\1\AbstractMenuSelectionModel.java
#Comment:
    /**
     * @see nextapp.echo.extras.app.menu.MenuSelectionModel#removeChangeListener(nextapp.echo.app.event.ChangeListener)
     */

#Code:
    public void removeChangeListener(ChangeListener l) {
        listenerList.removeListener(ChangeListener.class, l);
    }

#No. 3417
#File: E:\bishe\1\AbstractMenuStateModel.java
#Comment:
/**
 * An abstract base class for <code>MenuStateModel</code> implementations
 * that provides event listener management and notification capabilities.
 */

#Code:
public abstract class AbstractMenuStateModel 
implements MenuStateModel {

    private EventListenerList listenerList = new EventListenerList();

    /**
     * @see nextapp.echo.extras.app.menu.MenuStateModel#addChangeListener(nextapp.echo.app.event.ChangeListener)
     */
    public void addChangeListener(ChangeListener l) {
        listenerList.addListener(ChangeListener.class, l);
    }

    /**
     * Notifies <code>ChangeListener</code>s of a selection state change.
     */
    protected void fireStateChanged() {
        ChangeEvent e = new ChangeEvent(this);
        EventListener[] listeners = listenerList.getListeners(ChangeListener.class);
        for (int i = 0; i < listeners.length; ++i) {
            ((ChangeListener) listeners[i]).stateChanged(e);
        }
    }

    /**
     * @see nextapp.echo.extras.app.menu.MenuStateModel#removeChangeListener(nextapp.echo.app.event.ChangeListener)
     */
    public void removeChangeListener(ChangeListener l) {
        listenerList.removeListener(ChangeListener.class, l);
    }
}

#No. 3418
#File: E:\bishe\1\AbstractMerger.java
#Comment:
  /**
   * first check if mapper of the type T exist, if existed return it
   * else check if mapper of the supper type exist, then return it
   *
   * @param <T>   the generic type which extends from Node
   * @param clazz The class of type T
   * @return null if not found else the merger of the type T
   */

#Code:
  public static <T extends Node> AbstractMerger<T> getMerger(Class<T> clazz) {

    AbstractMerger<T> merger = null;

    Class<?> type = clazz;

    while (merger == null && type != null) {
      merger = map.get(type);
      type = type.getSuperclass();
    }

    return merger;
  }

#No. 3419
#File: E:\bishe\1\AbstractMerger.java
#Comment:
    /**
     * ensure the parameter passed to the merge is either not null
     */

#Code:
    if (first == null) return second;
    if (second == null) return first;

    if (first.getClass().equals(second.getClass())) {

      AbstractMerger merger = getMerger(first.getClass());

      if (merger.isEquals(first, second)) {
        return (T) merger.merge(first, second);
      }
    }

#No. 3420
#File: E:\bishe\1\AbstractMessageDrivenBeanParser.java
#Comment:
    /**
     * Creates and returns {@link org.jboss.metadata.ejb.spec.MessageDrivenBeanMetaData} after parsing the session element.
     *
     * @param reader
     * @return
     * @throws XMLStreamException
     */

#Code:
    @Override
    public MD parse(XMLStreamReader reader, final PropertyReplacer propertyReplacer) throws XMLStreamException {
        MD sessionBean = createMessageDrivenBeanMetaData();
        processAttributes(sessionBean, reader, this);
        this.processElements(sessionBean, reader, propertyReplacer);
        // return the metadata created out of parsing
        return sessionBean;
    }

#No. 3421
#File: E:\bishe\1\AbstractMessageEventDefinitionBuilder.java
#Comment:
  /**
   * Sets the message attribute.
   *
   * @param message the message for the message event definition
   * @return the builder object
   */

#Code:
  public B message(String message) {
    element.setMessage(findMessageForName(message));
    return myself;
  }

#No. 3422
#File: E:\bishe\1\AbstractMessageEventDefinitionBuilder.java
#Comment:
  /**
   * Sets the camunda topic attribute. This is only meaningful when
   * the {@link #camundaType(String)} attribute has the value <code>external</code>.
   *
   * @param camundaTopic the topic to set
   * @return the builder object
   */

#Code:
  public B camundaTopic(String camundaTopic) {
    element.setCamundaTopic(camundaTopic);
    return myself;
  }

#No. 3423
#File: E:\bishe\1\AbstractMessageEventDefinitionBuilder.java
#Comment:
  /**
   * Sets the camunda type attribute.
   *
   * @param camundaType  the type of the service task
   * @return the builder object
   */

#Code:
  public B camundaType(String camundaType) {
    element.setCamundaType(camundaType);
    return myself;
  }

#No. 3424
#File: E:\bishe\1\AbstractMessageEventDefinitionBuilder.java
#Comment:
  /**
   * Sets the camunda task priority attribute. This is only meaningful when
   * the {@link #camundaType(String)} attribute has the value <code>external</code>.
   *
   *
   * @param taskPriority the priority for the external task
   * @return the builder object
   */

#Code:
  public B camundaTaskPriority(String taskPriority) {
    element.setCamundaTaskPriority(taskPriority);
    return myself;
  }

#No. 3425
#File: E:\bishe\1\AbstractMessageEventDefinitionBuilder.java
#Comment:
  /**
   * Finishes the building of a message event definition.
   *
   * @param <T>
   * @return the parent event builder
   */

#Code:
  @SuppressWarnings({ "rawtypes", "unchecked" })
  public <T extends AbstractFlowNodeBuilder> T messageEventDefinitionDone() {
    return (T) ((Event) element.getParentElement()).builder();
  }

#No. 3426
#File: E:\bishe\1\AbstractMessageImpl.java
#Comment:
    /**
     * Set the From: header field
     *
     * @param from
     */

#Code:
    public void setFrom(String from) {
        this.from = from;
    }

#No. 3427
#File: E:\bishe\1\AbstractMessageImpl.java
#Comment:
    /**
     * Return the From: header field
     *
     * @return from
     */

#Code:
    public String getFrom() {
        return from;
    }

#No. 3428
#File: E:\bishe\1\AbstractMessageImpl.java
#Comment:
    /**
     * Set the Subject: header field
     *
     * @param subject
     */

#Code:
    public void setSubject(String subject) {
        this.subject = subject;
    }

#No. 3429
#File: E:\bishe\1\AbstractMessageImpl.java
#Comment:
    /**
     * Return the Subject: header field
     *
     * @return subject
     */

#Code:
    public String getSubject() {
        return subject;
    }

#No. 3430
#File: E:\bishe\1\AbstractMessageKeyVerifier.java
#Comment:
  /**
   * Verify all declared locales in one step.
   */

#Code:
  public List<Cal10nError> verifyAllLocales() {
    List<Cal10nError> errorList = new ArrayList<Cal10nError>();

    String[] localeNameArray = getLocaleNames();

    ErrorFactory errorFactory = new ErrorFactory(enumTypeAsStr, null, getBaseName());


    if (localeNameArray == null || localeNameArray.length == 0) {
      errorList.add(errorFactory.buildError(MISSING_LOCALE_DATA_ANNOTATION, "*"));
      return errorList;
    }
    for (String localeName : localeNameArray) {
      Locale locale = MiscUtil.toLocale(localeName);
      List<Cal10nError> tmpList = verify(locale);
      errorList.addAll(tmpList);
    }

    return errorList;
  }

#No. 3431
#File: E:\bishe\1\AbstractMessageSectionMatcher.java
#Comment:
    /**
     * @param receivedBinary
     *      The received Binary value that should be validated.
     *
     * @return the number of bytes consumed from the provided Binary
     *
     * @throws RuntimeException if the provided Binary does not match expectation in some way
     */

#Code:
    public int verify(Binary receivedBinary) throws RuntimeException
    {
        int length = receivedBinary.getLength();
        Data data = Data.Factory.create();
        long decoded = data.decode(receivedBinary.asByteBuffer());
        if(decoded > Integer.MAX_VALUE)
        {
            throw new IllegalStateException("Decoded more bytes than Binary supports holding");
        }

        if(decoded < length && !_expectTrailingBytes)
        {
            throw new IllegalArgumentException("Expected to consume all bytes, but trailing bytes remain: Got "
                                        + length + ", consumed "+ decoded);
        }

        DescribedType decodedDescribedType = data.getDescribedType();
        verifyReceivedDescribedType(decodedDescribedType);

        //Need to cast to int, but verified earlier that it is < Integer.MAX_VALUE
        return (int) decoded;
    }

#No. 3432
#File: E:\bishe\1\AbstractMessageSectionMatcher.java
#Comment:
    /**
     * Utility method for use by sub-classes that expect field-based sections, i.e lists or maps.
     */

#Code:
    protected void verifyReceivedFields(Map<Object, Object> valueMap)
    {
        _receivedFields = valueMap;

        _logger.debug("About to check the fields of the section."
                + "\n  Received:" + valueMap
                + "\n  Expectations: " + _fieldMatchers);
        for(Map.Entry<Object, Matcher<?>> entry : _fieldMatchers.entrySet())
        {
            @SuppressWarnings("unchecked")
            Matcher<Object> matcher = (Matcher<Object>) entry.getValue();
            Object field = entry.getKey();
            assertThat("Field " + field + " value should match", valueMap.get(field), matcher);
        }
    }

#No. 3433
#File: E:\bishe\1\AbstractMessageSectionMatcher.java
#Comment:
    /**
     * Intended to be overridden in most cases that use the above method (but not necessarily all - hence not marked as abstract)
     */

#Code:
    protected Enum<?> getField(int fieldIndex)
    {
        throw new UnsupportedOperationException("getFieldName is expected to be overridden by subclass if it is required");
    }

#No. 3434
#File: E:\bishe\1\AbstractMessageStore.java
#Comment:
    /**
     * Find the nearest known handle of the preceding message, taking priorities into account
     */

#Code:
    private int getNearestHandle( int priority )
    {
        for (int n = priority+1 ; n < 10  ; n++)
        {
            int handle = handleByPriority[n];
            if (handle != -1)
                return handle;
        }
        return -1;
    }

#No. 3435
#File: E:\bishe\1\AbstractMessageStore.java
#Comment:
    /**
     * Find the handle of the preceding message, taking priorities into account
     */

#Code:
    private int getLastHandleForPriority( int priority )
    {
        int lastHandle = handleByPriority[priority];
        if (lastHandle != -1)
            return lastHandle;
        
        return getNearestHandle(priority);
    }

#No. 3436
#File: E:\bishe\1\AbstractMetaCrawler.java
#Comment:
	/**
	 * getting the table's column
	 * 
	 * @param tableName
	 * @return
	 */

#Code:
	protected Map<String, Column> crawlColumnInfo(String tableName, SchemaInfo schemaInfo) {
		Map<String, Column> columns = new HashMap<String, Column>();
		ResultSet rs = null;
		try {
			if (schemaInfo == null) {
				rs = dbm.getColumns(null, null, tableName, null);
			} else {
				rs = dbm.getColumns(schemaInfo.getCatalogName(), schemaInfo.getSchemaName(), tableName, null);
			}
			while (rs.next()) {
				if(!rs.getString("TABLE_NAME").equals(tableName)) continue;
				Column column = packColumn(rs);
				columns.put(column.getName(), column);
			}
		} catch (SQLException e) {
			throw new DatabaseMetaGetMetaException("Table " + tableName + " get column information error!", e);
		} finally {
			JDBCUtils.closeResultSet(rs);
		}
		return columns;
	}

#No. 3437
#File: E:\bishe\1\AbstractMetaDataParser.java
#Comment:
    /**
     * Start parsing and generate the associated meta-data.
     *
     * @param reader
     * @param propertyReplacer
     * @return the parsed meta-data
     * @throws XMLStreamException
     */

#Code:
    public abstract MD parse(XMLStreamReader reader, PropertyReplacer propertyReplacer) throws XMLStreamException;

    /**
     * Process the single element. If it could not be processed, delegate to the super class.
     *
     * @param metaData
     * @param propertyReplacer
     * @param reader
     * @throws XMLStreamException
     */
    protected void processElement(MD metaData, XMLStreamReader reader, PropertyReplacer propertyReplacer) throws XMLStreamException {
        // Nobody processed the element, so it was unexpected
        throw unexpectedElement(reader);
    }

#No. 3438
#File: E:\bishe\1\AbstractMetaDataParser.java
#Comment:
    /**
     * Iterate over all elements calling processElement for each.
     *
     * @param reader
     * @param propertyReplacer
     */

#Code:
    protected void processElements(MD metaData, XMLStreamReader reader, PropertyReplacer propertyReplacer) throws XMLStreamException {
        while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {
            processElement(metaData, reader, propertyReplacer);
        }
    }

#No. 3439
#File: E:\bishe\1\AbstractMetaKeyBean.java
#Comment:
    /**
     * Return an array that gives the column index in the cursor for each field defined
     * @param cursor Database cursor over some columns, possibly including this table
     * @return array of column indices; -1 if the column with that id is not in cursor
     */

#Code:
    public int[] Gen_columnIndices(android.database.Cursor cursor) {
        int[] result=new int[GEN_COUNT];
        result[0] = cursor.getColumnIndex(GEN_FIELD__ID);
        // Make compatible with database generated by older version of plugin with uppercase column name
        if (result[0] == -1) {
            result[0] = cursor.getColumnIndex("_ID");
        }
        result[1] = cursor.getColumnIndex(GEN_FIELD_METALISTID);
        result[2] = cursor.getColumnIndex(GEN_FIELD_KEYDESC);
        result[3] = cursor.getColumnIndex(GEN_FIELD_METAFLAGS);
        result[4] = cursor.getColumnIndex(GEN_FIELD_MOUSECLICK);
        result[5] = cursor.getColumnIndex(GEN_FIELD_MOUSEBUTTONS);
        result[6] = cursor.getColumnIndex(GEN_FIELD_KEYSYM);
        result[7] = cursor.getColumnIndex(GEN_FIELD_SHORTCUT);
        return result;
    }

#No. 3440
#File: E:\bishe\1\AbstractMetaKeyBean.java
#Comment:
    /**
     * Populate one instance from a cursor 
     */

#Code:
    public void Gen_populate(android.database.Cursor cursor,int[] columnIndices) {
        if ( columnIndices[GEN_ID__ID] >= 0 && ! cursor.isNull(columnIndices[GEN_ID__ID])) {
            gen__Id = cursor.getLong(columnIndices[GEN_ID__ID]);
        }
        if ( columnIndices[GEN_ID_METALISTID] >= 0 && ! cursor.isNull(columnIndices[GEN_ID_METALISTID])) {
            gen_metaListId = cursor.getLong(columnIndices[GEN_ID_METALISTID]);
        }
        if ( columnIndices[GEN_ID_KEYDESC] >= 0 && ! cursor.isNull(columnIndices[GEN_ID_KEYDESC])) {
            gen_keyDesc = cursor.getString(columnIndices[GEN_ID_KEYDESC]);
        }
        if ( columnIndices[GEN_ID_METAFLAGS] >= 0 && ! cursor.isNull(columnIndices[GEN_ID_METAFLAGS])) {
            gen_metaFlags = (int)cursor.getInt(columnIndices[GEN_ID_METAFLAGS]);
        }
        if ( columnIndices[GEN_ID_MOUSECLICK] >= 0 && ! cursor.isNull(columnIndices[GEN_ID_MOUSECLICK])) {
            gen_mouseClick = (cursor.getInt(columnIndices[GEN_ID_MOUSECLICK]) != 0);
        }
        if ( columnIndices[GEN_ID_MOUSEBUTTONS] >= 0 && ! cursor.isNull(columnIndices[GEN_ID_MOUSEBUTTONS])) {
            gen_mouseButtons = (int)cursor.getInt(columnIndices[GEN_ID_MOUSEBUTTONS]);
        }
        if ( columnIndices[GEN_ID_KEYSYM] >= 0 && ! cursor.isNull(columnIndices[GEN_ID_KEYSYM])) {
            gen_keySym = (int)cursor.getInt(columnIndices[GEN_ID_KEYSYM]);
        }
        if ( columnIndices[GEN_ID_SHORTCUT] >= 0 && ! cursor.isNull(columnIndices[GEN_ID_SHORTCUT])) {
            gen_shortcut = cursor.getString(columnIndices[GEN_ID_SHORTCUT]);
        }
    }

#No. 3441
#File: E:\bishe\1\AbstractMetaKeyBean.java
#Comment:
    /**
     * Populate one instance from a ContentValues 
     */

#Code:
    public void Gen_populate(android.content.ContentValues values) {
        gen__Id = values.getAsLong(GEN_FIELD__ID);
        gen_metaListId = values.getAsLong(GEN_FIELD_METALISTID);
        gen_keyDesc = values.getAsString(GEN_FIELD_KEYDESC);
        gen_metaFlags = (int)values.getAsInteger(GEN_FIELD_METAFLAGS);
        gen_mouseClick = (values.getAsInteger(GEN_FIELD_MOUSECLICK) != 0);
        gen_mouseButtons = (int)values.getAsInteger(GEN_FIELD_MOUSEBUTTONS);
        gen_keySym = (int)values.getAsInteger(GEN_FIELD_KEYSYM);
        gen_shortcut = values.getAsString(GEN_FIELD_SHORTCUT);
    }

#No. 3442
#File: E:\bishe\1\AbstractMetaMember.java
#Comment:
		/*
		 * builder.append(REGEX_ZERO_OR_MORE_SPACES);
		 * 
		 * builder.append(S_ESCAPED_OPEN_PARENTHESES);
		 * 
		 * if (paramTypes.size() > 0) { for (Class<?> paramClass : paramTypes) {
		 * builder.append(REGEX_ZERO_OR_MORE_SPACES);
		 * 
		 * String paramType = expandParamRegEx(paramClass.getName());
		 * 
		 * builder.append(paramType); builder.append(REGEX_ONE_OR_MORE_SPACES);
		 * builder.append(REGEX_UNICODE_PARAM_NAME); builder.append(S_COMMA); }
		 * 
		 * builder.deleteCharAt(builder.length() - 1); }
		 * 
		 * builder.append(REGEX_ZERO_OR_MORE_SPACES);
		 * builder.append(S_ESCAPED_CLOSE_PARENTHESES);
		 * builder.append(REGEX_GROUP_ANY); builder.append(C_DOLLAR);
		 */

#Code:

		return builder.toString();
	}

	public static String expandParam(String inParamType, boolean fullyQualifiedType)
	{
		String paramType = inParamType;

		if (paramType.charAt(0) == C_OPEN_SQUARE_BRACKET)
		{
			paramType = ParseUtil.expandParameterType(paramType);
		}

		if (paramType.contains(S_DOT) && !fullyQualifiedType)
		{
			paramType = StringUtil.getUnqualifiedClassName(paramType);
		}

		return paramType;
	}

#No. 3443
#File: E:\bishe\1\AbstractMetastoreTestWithStaticConfiguration.java
#Comment:
  /**
   * create a metastore table using the given attributes
   * @param client
   * @param dbName
   * @param tabName
   * @param cols
   * @return
   * @throws Exception
   */

#Code:
  public Table createMetastoreTable(HiveMetaStoreClient client, String dbName,
      String tabName, List<FieldSchema> cols) throws Exception {

    Table tbl = makeMetastoreTableObject(client, dbName, tabName, cols);
    client.createTable(tbl);
    return tbl;
  }

#No. 3444
#File: E:\bishe\1\AbstractMethod.java
#Comment:
    /**
     * Construct and return a RequestBuilder instance from the provided request.
     *
     * @param request A RequestT representing input to the REST call to be made
     * @return A ResultT representing the response from the executed REST call
     * @throws NexmoClientException         if a problem is encountered constructing the request or response.
     * @throws UnsupportedEncodingException if UTF-8 encoding is not supported by the JVM
     */

#Code:
    public abstract RequestBuilder makeRequest(RequestT request)
            throws NexmoClientException, UnsupportedEncodingException;

    /**
     * Construct a ResultT representing the contents of the HTTP response returned from the Nexmo Voice API.
     *
     * @param response An HttpResponse returned from the Nexmo Voice API
     * @return A ResultT type representing the result of the REST call
     * @throws IOException if a problem occurs parsing the response
     */
    public abstract ResultT parseResponse(HttpResponse response) throws IOException;
}
}

#No. 3445
#File: E:\bishe\1\AbstractMethodError.java
#Comment:
/**
 * Thrown when an application tries to call an abstract method.
 * Normally, this error is caught by the compiler; this error can
 * only occur at run time if the definition of some class has
 * incompatibly changed since the currently executing method was last
 * compiled.
 *
 * @author  unascribed
 * @since   JDK1.0
 */

#Code:
public
class AbstractMethodError extends IncompatibleClassChangeError {
    private static final long serialVersionUID = -1654391082989018462L;

    /**
     * Constructs an <code>AbstractMethodError</code> with no detail  message.
     */
    public AbstractMethodError() {
        super();
    }

    /**
     * Constructs an <code>AbstractMethodError</code> with the specified
     * detail message.
     *
     * @param   s   the detail message.
     */
    public AbstractMethodError(String s) {
        super(s);
    }
}

#No. 3446
#File: E:\bishe\1\AbstractMethodInterceptor.java
#Comment:
	/**
	 * 切面逻辑 obj 代理对象实例 method 源对象的方法名 args 传递给方法的实际入参 proxyMethod
	 * 与源对象中的method相对应的代理对象中的方法
	 */

#Code:
	public Object intercept(Object target, Method method, Object[] args, MethodProxy proxy) throws Throwable {
		// 执行源对象的method方法
		try {
			Aop aop = method.getDeclaringClass().getAnnotation(Aop.class);
			if(null != aop){
				String methodPrefix = aop.methodPrefix();
				String methodName = method.getName();
				if(!"".equals(methodPrefix) && !methodName.startsWith(methodPrefix)){
					return proxy.invokeSuper(target, args);
				}
			} else {
				return proxy.invokeSuper(target, args);
			}
			
			Invocaction invocaction = new Invocaction(target, args, proxy);
			before(invocaction);
			Object returnValue = doInvoke(invocaction);
			after(invocaction);
			return returnValue;
		} catch (Exception e) {
			throw e;
		}
	}

#No. 3447
#File: E:\bishe\1\AbstractMethodSampler.java
#Comment:
    /**
     * root方法列表，可以根据每个root方法解析出调用栈
     */

#Code:
    private final Collection<MethodInfo> rootMethodList;

    AbstractMethodSampler() {
        rootMethodList = new ArrayList<>();
    }

#No. 3448
#File: E:\bishe\1\AbstractMethodSampler.java
#Comment:
    /**
     * 当进入方法时，回调该接口
     *
     * @param cls
     * @param method
     * @param argTypes
     */

#Code:
    public abstract void onMethodEnter(String cls, String method, String argTypes);

    /**
     * 当方法正常return时，回调该接口
     *
     * @param wallClockTimeNs
     * @param cpuTimeMs
     * @param cls
     * @param method
     * @param argTypes
     */
    public abstract void onMethodExit(long wallClockTimeNs, long cpuTimeMs, String cls, String method,
            String argTypes);

    /**
     * 方法无论怎样退出（比如异常退出、throw等），都回调此接口
     *
     * @param cls
     * @param method
     * @param argTypes
     */
    public abstract void onMethodExitFinally(String cls, String method, String argTypes);

    void addRootMethod(MethodInfo method) {
        synchronized (rootMethodList) {
            rootMethodList.add(method);
        }
    }

#No. 3449
#File: E:\bishe\1\AbstractMethodsBoundMetaData.java
#Comment:
    /**
     * The methods
     */

#Code:
    private MethodsMetaData methods;

    /**
     * Get the methods.
     *
     * @return the methods.
     */
    public MethodsMetaData getMethods() {
        return methods;
    }

#No. 3450
#File: E:\bishe\1\AbstractMethodsBoundMetaData.java
#Comment:
    /**
     * Set the methods.
     *
     * @param methods the methods.
     * @throws IllegalArgumentException for a null methods
     */

#Code:
    public void setMethods(MethodsMetaData methods) {
        if (methods == null)
            throw new IllegalArgumentException("Null methods");
        this.methods = methods;
    }

#No. 3451
#File: E:\bishe\1\AbstractMethodSynthesizer.java
#Comment:
	/**
	 * Perform writer validation.
	 * 
	 * @param descriptor descriptor
	 * @throws InspectionPropertyNotFoundException property not found
	 * @throws GeDARuntimeException any abnormality
	 */

#Code:
	protected void preMakeWriterValidation(final PropertyDescriptor descriptor)
			throws InspectionPropertyNotFoundException, GeDARuntimeException {
		final Method writeMethod = descriptor.getWriteMethod();
        if (writeMethod == null) {
            throw new InspectionPropertyNotFoundException("No write method for: ", descriptor.getName());
        }
		final Class< ? > target = getValidDeclaringClass(writeMethod);
		if ((target.getModifiers() & PUBLIC) == 0) {
			throw new GeDARuntimeException(target.getCanonicalName() 
					+ " does not have [public] modifier. This will cause IllegalAccessError during runtime.");
		}

	}

#No. 3452
#File: E:\bishe\1\AbstractMethodSynthesizer.java
#Comment:
	/**
	 * @param sourceClassSetterMethodArgumentClass class name of the argument type passed to setter
	 * @return context
	 */

#Code:
	protected final ArgumentTypeContext getArgumentTypeContext(final Class< ? > sourceClassSetterMethodArgumentClass) {

		if (sourceClassSetterMethodArgumentClass.isPrimitive()) {
			return new ArgumentTypeContext(sourceClassSetterMethodArgumentClass,
					PRIMITIVE_TO_WRAPPER.get(sourceClassSetterMethodArgumentClass.getCanonicalName()), 
					sourceClassSetterMethodArgumentClass.getCanonicalName());
		} 
		return new ArgumentTypeContext(sourceClassSetterMethodArgumentClass, sourceClassSetterMethodArgumentClass.getCanonicalName(), null);

	}

#No. 3453
#File: E:\bishe\1\AbstractMethodSynthesizer.java
#Comment:
	/**
	 * Class loader reference.
	 */

#Code:
	protected ClassLoader getClassLoader() {
        ClassLoader cl = loader.get();
        if (cl == null) { // Cl was garbage collected - something gone really wrong
            throw new GeDARuntimeException("Class loader has been gc'ed");
        }
		return cl;
	}

#No. 3454
#File: E:\bishe\1\AbstractMethodTreeNode.java
#Comment:
    /**
     * @param node
     */

#Code:
    public AbstractMethodTreeNode(Node node) {
        super(node);
    }

#No. 3455
#File: E:\bishe\1\AbstractMetricsContext.java
#Comment:
  /**
   * Called by MetricsRecordImpl.update().  Creates or updates a row in
   * the internal table of metric data.
   */

#Code:
  protected void update(MetricsRecordImpl record) {
    String recordName = record.getRecordName();
    TagMap tagTable = record.getTagTable();
    Map<String,MetricValue> metricUpdates = record.getMetricTable();
        
    RecordMap recordMap = getRecordMap(recordName);
    synchronized (recordMap) {
      MetricMap metricMap = recordMap.get(tagTable);
      if (metricMap == null) {
        metricMap = new MetricMap();
        TagMap tagMap = new TagMap(tagTable); // clone tags
        recordMap.put(tagMap, metricMap);
      }

      Set<Entry<String, MetricValue>> entrySet = metricUpdates.entrySet();
      for (Entry<String, MetricValue> entry : entrySet) {
        String metricName = entry.getKey ();
        MetricValue updateValue = entry.getValue ();
        Number updateNumber = updateValue.getNumber();
        Number currentNumber = metricMap.get(metricName);
        if (currentNumber == null || updateValue.isAbsolute()) {
          metricMap.put(metricName, updateNumber);
        }
        else {
          Number newNumber = sum(updateNumber, currentNumber);
          metricMap.put(metricName, newNumber);
        }
      }
    }
  }

#No. 3456
#File: E:\bishe\1\AbstractMetricsContext.java
#Comment:
  /**
   * Adds two numbers, coercing the second to the type of the first.
   *
   */

#Code:
  private Number sum(Number a, Number b) {
    if (a instanceof Integer) {
      return Integer.valueOf(a.intValue() + b.intValue());
    }
    else if (a instanceof Float) {
      return new Float(a.floatValue() + b.floatValue());
    }
    else if (a instanceof Short) {
      return Short.valueOf((short)(a.shortValue() + b.shortValue()));
    }
    else if (a instanceof Byte) {
      return Byte.valueOf((byte)(a.byteValue() + b.byteValue()));
    }
    else if (a instanceof Long) {
      return Long.valueOf((a.longValue() + b.longValue()));
    }
    else {
      // should never happen
      throw new MetricsException("Invalid number type");
    }
            
  }

#No. 3457
#File: E:\bishe\1\AbstractMetricsContext.java
#Comment:
  /**
   * Called by MetricsRecordImpl.remove().  Removes all matching rows in
   * the internal table of metric data.  A row matches if it has the same
   * tag names and values as record, but it may also have additional
   * tags.
   */    

#Code:
  protected void remove(MetricsRecordImpl record) {
    String recordName = record.getRecordName();
    TagMap tagTable = record.getTagTable();
        
    RecordMap recordMap = getRecordMap(recordName);
    synchronized (recordMap) {
      Iterator<TagMap> it = recordMap.keySet().iterator();
      while (it.hasNext()) {
        TagMap rowTags = it.next();
        if (rowTags.containsAll(tagTable)) {
          it.remove();
        }
      }
    }
  }

#No. 3458
#File: E:\bishe\1\AbstractMetricsContext.java
#Comment:
  /**
   * Returns the timer period.
   */

#Code:
  public int getPeriod() {
    return period;
  }

#No. 3459
#File: E:\bishe\1\AbstractMetricsContext.java
#Comment:
  /**
   * Sets the timer period
   */

#Code:
  protected void setPeriod(int period) {
    this.period = period;
  }

#No. 3460
#File: E:\bishe\1\AbstractMetricsDispatcher.java
#Comment:
    /**
     * Register Jackson module that maps enums as lowercase. Per http://stackoverflow.com/a/24173645.
     */

#Code:
    @SuppressWarnings("rawtypes")
    private static void registerEnumModule(ObjectMapper mapper) {
        SimpleModule module = new SimpleModule();
        module.setDeserializerModifier(new BeanDeserializerModifier() {
            @Override
            public JsonDeserializer<Enum> modifyEnumDeserializer(DeserializationConfig config,
                                                                 final JavaType type,
                                                                 BeanDescription beanDesc,
                                                                 final JsonDeserializer<?> deserializer) {
                return new JsonDeserializer<Enum>() {
                    @Override
                    public Enum deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {
                        @SuppressWarnings("unchecked") Class<? extends Enum> rawClass = (Class<Enum<?>>) type.getRawClass();
                        return Enum.valueOf(rawClass, jp.getValueAsString().toUpperCase());
                    }
                };
            }
        });
        module.addSerializer(Enum.class, new StdSerializer<Enum>(Enum.class) {
            @Override
            public void serialize(Enum value, JsonGenerator jgen, SerializerProvider provider) throws IOException {
                jgen.writeString(value.name().toLowerCase());
            }
        });
        mapper.registerModule(module);
    }

#No. 3461
#File: E:\bishe\1\AbstractMetricsDispatcher.java
#Comment:
    /*
     * Override this method to transform the Build object into a different Build representation. For
     * example, when the Build format needs to be flattened out.
     */

#Code:
    protected Object transformBuild(Build build) {
        checkNotNull(build);
        return build;
    }

#No. 3462
#File: E:\bishe\1\AbstractMicroManager.java
#Comment:
    /**
     * If chances to win the skirmish with the nearby enemy units aren't favorable, avoid fight and retreat.
     */

#Code:
    protected static boolean handleUnfavorableOdds(AUnit unit) {
        boolean isNewFight = (unit.getUnitAction() != null && !unit.getUnitAction().isRunningOrRetreating());
        boolean isSituationFavorable = ACombatEvaluator.isSituationFavorable(unit, isNewFight);

        // If situation is unfavorable, retreat
//        if (!isSituationFavorable && !unit.isReadyToShoot() && (unit.canAnyCloseEnemyShootThisUnit()
        if (!isSituationFavorable && (unit.canAnyCloseEnemyShootThisUnit()
                || Select.enemy().combatUnits().inRadius(2.5, unit).count() > 0)) {
            unit.setTooltip("Retreat");
//            System.out.println("RETREAT " + unit);
            return unit.runFrom(null);
        }

        return false;
    }

#No. 3463
#File: E:\bishe\1\AbstractMicroManager.java
#Comment:
    /**
     * If combat evaluator tells us that the potential skirmish with nearby enemies wouldn't result in
     * decisive victory either retreat or stand where you are.
     */

#Code:
    protected boolean handleNotExtremelyFavorableOdds(AUnit unit) {
//        if (!AtlantisCombatEvaluator.isSituationExtremelyFavorable(unit)) {
//            if (isInShootRangeOfAnyEnemyUnit(unit)) {
////                unit.moveAwayFrom(_nearestEnemyThatCanShootAtThisUnit, 2);
////                return true;
//                return AtlantisRunManager.run(unit);
//            }
//        }

        return false;
    }

#No. 3464
#File: E:\bishe\1\AbstractMicroManager.java
#Comment:
    /**
     * If unit is severly wounded, it should run.
     */

#Code:
    protected boolean handleLowHealthIfNeeded(AUnit unit) {
        if (AGame.playsAsTerran()) {
            if (unit.getHP() <= 7) {
                AUnit rendezvousWithMedics = (AUnit) Select.ourBuildings().ofType(AtlantisConfig.BARRACKS).first();
                if (rendezvousWithMedics != null && rendezvousWithMedics.distanceTo(unit) > 5) {
                    unit.move(rendezvousWithMedics.getPosition(), UnitActions.HEAL);
                }
                return true;
            }
        }

        AUnit nearestEnemy = Select.nearestEnemy(unit.getPosition());
        if (nearestEnemy == null || PositionUtil.distanceTo(nearestEnemy, unit) > 6) {
            return false;
        }

        if (unit.getHitPoints() <= 16 || unit.getHPPercent() < 30) {
            if (Select.ourCombatUnits().inRadius(4, unit).count() <= 6) {
                return unit.getRunManager().run();
            }
        }

        return false;
    }

#No. 3465
#File: E:\bishe\1\AbstractMicroManager.java
#Comment:
    /**
     * If e.g. Terran Marine stands too far forward, it makes him vulnerable. Make him go back.
     */

#Code:
    protected boolean handleDontSpreadTooMuch(AUnit unit) {
        Squad squad = unit.getSquad();
        Select ourUnits = Select.from(squad.arrayList()).inRadius(10, unit);
        int ourUnitsNearby = ourUnits.count();
        int minUnitsNearby = (int) (squad.size() * 0.66);

        // =========================================================
        if (ourUnitsNearby < minUnitsNearby && ourUnitsNearby <= 3) {
            APosition goTo = PositionOperationsWrapper.averagePosition(ourUnits.list());
            if (goTo != null && goTo.distanceTo(unit) > 1) {
                unit.move(goTo, UnitActions.MOVE);
                unit.setTooltip("Closer");
                return true;
            }
        }

        return false;
    }

#No. 3466
#File: E:\bishe\1\AbstractMicroManager.java
#Comment:
    /**
     * @return <b>true</b> if any of the enemy units in range can shoot at this unit.
     */

#Code:
    protected boolean isInShootRangeOfAnyEnemyUnit(AUnit unit) {
        Collection<AUnit> enemiesInRange = (Collection<AUnit>) Select.enemy().combatUnits().inRadius(12, unit).listUnits();
        for (AUnit enemy : enemiesInRange) {
            WeaponType enemyWeapon = (unit.isAirUnit() ? enemy.getAirWeapon() : enemy.getGroundWeapon());
            double distToEnemy = PositionUtil.distanceTo(unit, enemy);

            // Compare against max range
            if (distToEnemy + 0.5 <= enemyWeapon.maxRange()) {
                _nearestEnemyThatCanShootAtThisUnit = enemy;
                return true;
            }

            // Compare against min range
//            if () {
//                distToEnemy >= enemyWeapon.getMinRange()
//                return true;
//            }
        }

        // =========================================================
        _nearestEnemyThatCanShootAtThisUnit = null;
        return false;
    }

#No. 3467
#File: E:\bishe\1\AbstractModbusReadRequest.java
#Comment:
	/**
	 * The number of times to retry this request, assuming the {@link com.inductiveautomation.xopc.drivers.modbus2.structs.ExceptionCode} is one in the
	 * set {@value #RETRYABLE_EXCEPTION_CODES}, before setting bad quality on this request's items.
	 */

#Code:
	public static final int MAX_EXCEPTION_RESPONSES_TO_RETRY = 1;

	/**
	 * The set of {@link com.inductiveautomation.xopc.drivers.modbus2.structs.ExceptionCode}s that will increment a count towards
	 * {@value #MAX_EXCEPTION_RESPONSES_TO_RETRY} before setting bad quality on this request's
	 * items.
	 */
	public static final EnumSet<ExceptionCode> RETRYABLE_EXCEPTION_CODES = EnumSet.of(
			ExceptionCode.GatewayPathUnavailable,
			ExceptionCode.GatewayTargetDeviceFailToRespond,
			ExceptionCode.SlaveDeviceBusy,
			ExceptionCode.SlaveDeviceFailure);

	/**
	 * Tracks the number of consecutive responses containing {@link com.inductiveautomation.xopc.drivers.modbus2.structs.ExceptionCode}'s allowed by
	 * {@value #RETRYABLE_EXCEPTION_CODES}. Any other response, success or error, resets the count.
	 */
	protected volatile int exceptionResponseCount = 0;

	public AbstractModbusReadRequest(
			List<ReadItem> items,
			ChannelWriter channelWriter,
			ModbusTransport transport,
			boolean zeroBased,
			byte unitId,
			int timeout,
			Logger log,
			CommunicationCallback communicationCallback) {
		super(items, channelWriter, transport, zeroBased, unitId, timeout, log, communicationCallback);
	}

#No. 3468
#File: E:\bishe\1\AbstractModbusWriteRequest.java
#Comment:
	/**
	 * Set the StatusCode for all WriteItem's to the given StatusCode.
	 * 
	 * @param status
	 *            StatusCode to set.
	 */

#Code:
	protected void setItemStatus(StatusCode status) {
		for (WriteItem item : items) {
			item.setWriteStatus(status);
		}
	}

#No. 3469
#File: E:\bishe\1\AbstractModeDelegate.java
#Comment:
    /**
     * get color type parameter from the AccuRev Version If version less than 6 or equal to 6.0.x the color parameter will be style if
     * version greater than 6 like 6.1.x or 7 then color parameter will streamStyle
     *
     * @return String
     */

#Code:
    private String getStreamTypeParameter() {
        String fullVersion = GetAccuRevVersion.getAccuRevVersion().trim();
        String partialversion = fullVersion.substring(fullVersion.indexOf(" ") + 1);
        String version = partialversion.substring(0, partialversion.indexOf(" "));
        String[] versionSplits = version.split("\\.");
        String type = ((Integer.parseInt(versionSplits[0]) < 6) || (Integer.parseInt(versionSplits[0]) == 6 && Integer
            .parseInt(versionSplits[1]) < 1)) ? "style" : "streamStyle";
        logger.info("Current AccuRev version " + fullVersion + " color type parameter " + type);
        return type;
    }

#No. 3470
#File: E:\bishe\1\AbstractModeDelegate.java
#Comment:
    /**
     * Get last transaction build from the jenkins for the currently running project
     *
     * @return String
     * @throws IOException Failing to read file
     */

#Code:
    private String getLastBuildTransaction(Run<?, ?> build) throws IOException {
        File f = new File(build.getParent().getRootDir(), ACCUREVLASTTRANSFILENAME);
        if (!f.exists()) {
            return null;
        }
        try (BufferedReader br = Files.newBufferedReader(f.toPath(), UTF_8)) {
            return br.readLine();
        }
    }

#No. 3471
#File: E:\bishe\1\AbstractModeDelegate.java
#Comment:
    /**
     * Get list of new files to be added into the jenkins build from a given a transaction.
     *
     * @param lastTransaction the last transaction stored
     * @param stream          stream populate from
     * @return String
     * @throws IOException failed to open file
     */

#Code:

    private FilePath getFileRevisionsTobePopulated(int lastTransaction, String stream) throws IOException, InterruptedException {
        List<AccurevTransaction> transactions = History.getTransactionsAfterLastTransaction(scm, server, accurevEnv,
            accurevWorkingSpace, listener, launcher, stream, lastTransaction);
        if (transactions.isEmpty()) {
            return null;
        }
        // collect all the files from the list of transactions and remove duplicates from the list of files.
        Set<String> fileRevisions = new HashSet<>();
        transactions.stream()
            .filter(t -> t != null && !t.getAction().equals("defunct") && !t.getAffectedPaths().isEmpty())
            .map(AccurevTransaction::getAffectedPaths)
            .forEach(fileRevisions::addAll);
        if (fileRevisions.isEmpty()) return null;
        return checkFilesOnStream(getPopulateFilePath(fileRevisions));
    }

#No. 3472
#File: E:\bishe\1\AbstractModeDelegate.java
#Comment:
    /**
     * Create a text file to keep the list of files to be populated.
     *
     * @param fileRevisions current file revisions
     * @return String
     */

#Code:
    private FilePath getPopulateFilePath(Set<String> fileRevisions) throws IOException, InterruptedException {
        FilePath populateFiles = accurevWorkingSpace.createTextTempFile("PopulateFiles", ".txt", String.join("\n", fileRevisions));
        populateFiles.chmod(0600);
        return populateFiles;
    }

#No. 3473
#File: E:\bishe\1\AbstractModelDeserializer.java
#Comment:
	/**
	 * 
	 * @param vc
	 */

#Code:
	protected AbstractModelDeserializer(Class<?> vc) {
		super(vc);
	}

#No. 3474
#File: E:\bishe\1\AbstractModelDeserializer.java
#Comment:
	/**
	 * Find the specific Model definition
	 * 
	 * @return
	 */

#Code:
	public ModelDefinition findModelDefinition(String typeName) throws ModelNotFoundException{
		List<ModelDefinition> definitions = ModuleRegistry.getModelDefinitions();
		for(ModelDefinition definition : definitions){
			if(definition.getModelTypeName().equalsIgnoreCase(typeName))
				return definition;
		}
		throw new ModelNotFoundException(typeName);
	}

#No. 3475
#File: E:\bishe\1\AbstractModelerNodeForm.java
#Comment:
  /**
   * This will listen for changes to all property values except for validation messages and flag the model as dirty.
   */

#Code:
  protected PropertyChangeListener propertyValueListener = new PropertyChangeListener() {
    public void propertyChange( PropertyChangeEvent evt ) {
      if ( !( "validMessages".equals( evt.getPropertyName() ) || "valid".equals( evt.getPropertyName() ) ) ) {
        // Set the model's dirty flag to true when anything except valid messages are changed
        workspace.setDirty( true );
      }
    }
  };

#No. 3476
#File: E:\bishe\1\AbstractModelerNodeForm.java
#Comment:
  /**
   * Utility method to show/hide a container with specific components appropriate only in particular circumstances. For
   * example: only time dimension levels need time level type and format, but not geo type
   * 
   * @param containerId
   * @param visible
   */

#Code:
  protected void setContainerVisible( String containerId, boolean visible ) {
    XulContainer container = (XulContainer) document.getElementById( containerId );
    container.setVisible( visible );
  }

#No. 3477
#File: E:\bishe\1\AbstractModelLoader.java
#Comment:
    /**
     * Adds the given module to the set of modules from which we can load classes.
     * 
     * @param module the module
     * @param artifact the module's artifact, if any. Can be null. 
     */

#Code:
    public abstract void addModuleToClassPath(Module module, ArtifactResult artifact);

    /**
     * Returns true if the given module has been added to this model loader's classpath.
     * Defaults to true.
     */
    public boolean isModuleInClassPath(Module module){
        return true;
    }

#No. 3478
#File: E:\bishe\1\AbstractModelLoader.java
#Comment:
        /*
         * We start by loading java.lang and ceylon.language because we will need them no matter what.
         */

#Code:
        nested.startTask("load standard packages");
        loadPackage(jdkModule, "java.lang", false);
        loadPackage(languageModule, "com.redhat.ceylon.compiler.java.metadata", false);
        loadPackage(languageModule, "com.redhat.ceylon.compiler.java.language", false);
        nested.endTask();
    }
    protected Module loadLanguageModuleAndPackage() {
        Module languageModule = findOrCreateModule(CEYLON_LANGUAGE, null);
        addModuleToClassPath(languageModule, null);
        Package languagePackage = findOrCreatePackage(languageModule, CEYLON_LANGUAGE);
        typeFactory.setPackage(languagePackage);
        
        // make sure the language module has its real dependencies added, because we need them in the classpath
        // otherwise we will get errors on the Util and Metamodel calls we insert
        // WARNING! Make sure this list is always the same as the one in /ceylon-runtime/dist/repo/ceylon/language/_version_/module.xml
        languageModule.addImport(new ModuleImport(findOrCreateModule("com.redhat.ceylon.compiler.java", Versions.CEYLON_VERSION_NUMBER), false, false, Backend.Java));
        languageModule.addImport(new ModuleImport(findOrCreateModule("com.redhat.ceylon.compiler.js", Versions.CEYLON_VERSION_NUMBER), false, false, Backend.Java));
        languageModule.addImport(new ModuleImport(findOrCreateModule("com.redhat.ceylon.common", Versions.CEYLON_VERSION_NUMBER), false, false, Backend.Java));
        languageModule.addImport(new ModuleImport(findOrCreateModule("com.redhat.ceylon.model", Versions.CEYLON_VERSION_NUMBER), false, false, Backend.Java));
        languageModule.addImport(new ModuleImport(findOrCreateModule("com.redhat.ceylon.module-resolver", Versions.CEYLON_VERSION_NUMBER), false, false, Backend.Java));
        languageModule.addImport(new ModuleImport(findOrCreateModule("com.redhat.ceylon.typechecker", Versions.CEYLON_VERSION_NUMBER), false, false, Backend.Java));
        languageModule.addImport(new ModuleImport(findOrCreateModule("org.jboss.modules", Versions.DEPENDENCY_JBOSS_MODULES_VERSION), false, false, Backend.Java));
        languageModule.addImport(new ModuleImport(findOrCreateModule("org.jboss.jandex", Versions.DEPENDENCY_JANDEX_VERSION), false, false, Backend.Java));
        
        return languageModule;
    }

#No. 3479
#File: E:\bishe\1\AbstractModelLoader.java
#Comment:
    /**
     * This is meant to be called if your subclass doesn't call loadStandardModules for whatever reason
     */

#Code:
    public void setupWithNoStandardModules() {
        Module languageModule = modules.getLanguageModule();
        if(languageModule == null)
            throw new RuntimeException("Assertion failed: language module is null");
        Package languagePackage = languageModule.getPackage(CEYLON_LANGUAGE);
        if(languagePackage == null)
            throw new RuntimeException("Assertion failed: language package is null");
        typeFactory.setPackage(languagePackage);
    }

#No. 3480
#File: E:\bishe\1\AbstractModelLoader.java
#Comment:
    /**
     * Looks for a direct member of type ClassOrInterface. We're not using Class.getDirectMember()
     * because it skips object types and we want them.
     */

#Code:
    public static Declaration getDirectMember(Scope container, String name) {
        if(name.isEmpty())
            return null;
        boolean wantsSetter = false;
        if(name.startsWith(NamingBase.Suffix.$setter$.name())){
            wantsSetter = true;
            name = name.substring(8);
        }
            
        if(Character.isDigit(name.charAt(0))){
            // this is a local type we have a different accessor for it
            return ((LocalDeclarationContainer)container).getLocalDeclaration(name);
        }
        // don't even try using getDirectMember except on Package,
        // because it will fail miserably during completion, since we
        // will for instance have only anonymous types first, before we load their anonymous values, and
        // when we go looking for them we won't be able to find them until we add their anonymous values,
        // which is too late
        if(container instanceof Package){
            // don't use Package.getMembers() as it loads the whole package
            Declaration result = container.getDirectMember(name, null, false);
            return selectTypeOrSetter(result, wantsSetter);
        }else{
            // must be a Declaration
            for(Declaration member : container.getMembers()){
                // avoid constructors with no name
                if(member.getName() == null)
                    continue;
                if(!member.getName().equals(name))
                    continue;
                Declaration result = selectTypeOrSetter(member, wantsSetter);
                if(result != null)
                    return result;
            }
        }
        // not found
        return null;
    }

#No. 3481
#File: E:\bishe\1\AbstractModelLoader.java
#Comment:
    /** Returns:
     * <ul>
     * <li>true if the class has named constructors ({@code @Class(...constructors=true)}).</li>
     * <li>false if the class has an initializer constructor.</li>
     * <li>null if the class lacks {@code @Class} (i.e. is not a Ceylon class).</li>
     * </ul>
     * @param classMirror
     * @return
     */

#Code:
    private Boolean hasConstructors(ClassMirror classMirror) {
        AnnotationMirror a = classMirror.getAnnotation(CEYLON_CLASS_ANNOTATION);
        Boolean hasConstructors;
        if (a != null) {
            hasConstructors = (Boolean)a.getValue("constructors");
            if (hasConstructors == null) {
                hasConstructors = false;
            }
        } else {
            hasConstructors = null;
        }
        return hasConstructors;
    }

#No. 3482
#File: E:\bishe\1\AbstractModelLoader.java
#Comment:
    /**
     * Finds or creates a new module. This is mostly useful to force creation of modules such as jdk
     * or ceylon.language modules.
     */

#Code:
    protected Module findOrCreateModule(String moduleName, String version)  {
        synchronized(getLock()){
            boolean isJdk = false;
            boolean defaultModule = false;

            // make sure it isn't loaded
            Module module = getLoadedModule(moduleName, version);
            if(module != null)
                return module;

            if(JDKUtils.isJDKModule(moduleName) || JDKUtils.isOracleJDKModule(moduleName)){
                isJdk = true;
            }

            java.util.List<String> moduleNameList = Arrays.asList(moduleName.split("\\."));
            module = moduleManager.getOrCreateModule(moduleNameList, version);
            // make sure that when we load the ceylon language module we set it to where
            // the typechecker will look for it
            if(moduleName.equals(CEYLON_LANGUAGE)
                    && modules.getLanguageModule() == null){
                modules.setLanguageModule(module);
            }

            // TRICKY We do this only when isJava is true to prevent resetting
            // the value to false by mistake. LazyModule get's created with
            // this attribute to false by default, so it should work
            if (isJdk && module instanceof LazyModule) {
                ((LazyModule)module).setJava(true);
                module.setNativeBackends(Backend.Java.asSet());
            }

            // FIXME: this can't be that easy.
            if(isJdk)
                module.setAvailable(true);
            module.setDefault(defaultModule);
            return module;
        }
    }

#No. 3483
#File: E:\bishe\1\AbstractModelLoader.java
#Comment:
                    /*
                     * Getters do not support overloading since they have no parameters, so they can only differ based on
                     * name. For boolean properties we favour "is" getters, otherwise "get" getters.
                     */

#Code:
                    for(MethodMirror getterMethod : getterList){
                        if(propertiesMatch(klass, getterMethod, matchingSetter)){
                            if(bestGetter == null)
                                bestGetter = getterMethod;
                            else{
                                // we have two getters, find the best one
                                if(booleanSetter){
                                    // favour the "is" getter
                                    if(getterMethod.getName().startsWith("is"))
                                        bestGetter = getterMethod;
                                    // else keep the current best, it must be an "is" getter
                                }else{
                                    // favour the "get" getter
                                    if(getterMethod.getName().startsWith("get"))
                                        bestGetter = getterMethod;
                                    // else keep the current best, it must be a "get" getter
                                }
                                break;
                            }
                        }
                    }

#No. 3484
#File: E:\bishe\1\AbstractModelLoader.java
#Comment:
    /**
     * Allows subclasses to do something to the class name
     */

#Code:
    protected String assembleJavaClass(String javaClass, String packageName) {
        return javaClass;
    }

#No. 3485
#File: E:\bishe\1\AbstractModelLoader.java
#Comment:
    /**
     * To be overridden by subclasses
     */

#Code:
    protected UnknownType.ErrorReporter makeModelErrorReporter(String message) {
        return new LogErrorRunnable(this, message);
    }

#No. 3486
#File: E:\bishe\1\AbstractModelLoader.java
#Comment:
    /*private boolean hasTypeParameterWithConstraints(TypeMirror type) {
        switch(type.getKind()){
        case BOOLEAN:
        case BYTE:
        case CHAR:
        case DOUBLE:
        case FLOAT:
        case INT:
        case LONG:
        case SHORT:
        case VOID:
        case WILDCARD:
            return false;
        case ARRAY:
            return hasTypeParameterWithConstraints(type.getComponentType());
        case DECLARED:
            for(TypeMirror ta : type.getTypeArguments()){
                if(hasTypeParameterWithConstraints(ta))
                    return true;
            }
            return false;
        case TYPEVAR:
            TypeParameterMirror typeParameter = type.getTypeParameter();
            return typeParameter != null && hasNonErasedBounds(typeParameter);
        default:
            return false;
        }
    }*/

#Code:
    
    private void markUnboxed(TypedDeclaration decl, MethodMirror methodMirror, TypeMirror type) {
        boolean unboxed = false;
        if(type.isPrimitive() 
                || type.getKind() == TypeKind.ARRAY
                || sameType(type, STRING_TYPE)
                || (methodMirror != null && methodMirror.isDeclaredVoid())) {
            unboxed = true;
        }
        decl.setUnboxed(unboxed);
    }

#No. 3487
#File: E:\bishe\1\AbstractModelLoader.java
#Comment:
        /**
         * Used in parameter
         */

#Code:
        CONTRAVARIANT,
        /**
         * Used in method return value
         */
        COVARIANT,
        /**
         * For field
         */
        INVARIANT;
    }

    private String getUnderlyingType(TypeMirror type, TypeLocation location){
        // don't erase to c.l.String if in a type param location
        if ((sameType(type, STRING_TYPE) && location != TypeLocation.TYPE_PARAM)
            || sameType(type, PRIM_BYTE_TYPE)
            || sameType(type, PRIM_SHORT_TYPE)
            || sameType(type, PRIM_INT_TYPE)
            || sameType(type, PRIM_FLOAT_TYPE)
            || sameType(type, PRIM_CHAR_TYPE)) {
            return type.getQualifiedName();
        }
        return null;
    }

#No. 3488
#File: E:\bishe\1\AbstractModelLoader.java
#Comment:
    /*private Type getQualifyingType(TypeDeclaration declaration) {
        // As taken from Type.getType():
        if (declaration.isMember()) {
            return((ClassOrInterface) declaration.getContainer()).getType();
        }
        return null;
    }*/

#Code:

    @Override
    public Type getType(Module module, String pkgName, String name, Scope scope)  {
        Declaration decl = getDeclaration(module, pkgName, name, scope);
        if(decl == null)
            return null;
        if(decl instanceof TypeDeclaration)
            return ((TypeDeclaration) decl).getType();
        // it's a method or non-object value, but it's not a type
        return null;
    }

#No. 3489
#File: E:\bishe\1\AbstractModelLoader.java
#Comment:
    /**
     * See explanation in cacheModulelessPackages() below. This is called by LanguageCompiler during loadCompiledModules().
     */

#Code:
    public LazyPackage findOrCreateModulelessPackage(String pkgName)  {
        synchronized(getLock()){
            LazyPackage pkg = modulelessPackages.get(pkgName);
            if(pkg != null)
                return pkg;
            pkg = new LazyPackage(this);
            // FIXME: some refactoring needed
            pkg.setName(pkgName == null ? Collections.<String>emptyList() : Arrays.asList(pkgName.split("\\.")));
            modulelessPackages.put(pkgName, pkg);
            return pkg;
        }
    }

#No. 3490
#File: E:\bishe\1\AbstractModelLoader.java
#Comment:
    /**
     * Stef: this sucks balls, but the typechecker wants Packages created before we have any Module set up, including for parsing a module
     * file, and because the model loader looks up packages and caches them using their modules, we can't really have packages before we
     * have modules. Rather than rewrite the typechecker, we create moduleless packages during parsing, which means they are not cached with
     * their modules, and after the loadCompiledModules step above, we fix the package modules. Remains to be done is to move the packages
     * created from their cache to the right per-module cache.
     */

#Code:
    public void cacheModulelessPackages() {
        synchronized(getLock()){
            for(LazyPackage pkg : modulelessPackages.values()){
                String quotedPkgName = JVMModuleUtil.quoteJavaKeywords(pkg.getQualifiedNameString());
                if (pkg.getModule() != null) {
                    packagesByName.put(cacheKeyByModule(pkg.getModule(), quotedPkgName), pkg);
                }
            }
            modulelessPackages.clear();
        }
    }

#No. 3491
#File: E:\bishe\1\AbstractModelLoader.java
#Comment:
    /**
     * Stef: after a lot of attempting, I failed to make the CompilerModuleManager produce a LazyPackage when the ModuleManager.initCoreModules
     * is called for the default package. Because it is called by the PhasedUnits constructor, which is called by the ModelLoader constructor,
     * which means the model loader is not yet in the context, so the CompilerModuleManager can't obtain it to pass it to the LazyPackage
     * constructor. A rewrite of the logic of the typechecker scanning would fix this, but at this point it's just faster to let it create
     * the wrong default package and fix it before we start parsing anything.
     */

#Code:
    public void fixDefaultPackage()  {
        synchronized(getLock()){
            Module defaultModule = modules.getDefaultModule();
            Package defaultPackage = defaultModule.getDirectPackage("");
            if(defaultPackage instanceof LazyPackage == false){
                LazyPackage newPkg = findOrCreateModulelessPackage("");
                List<Package> defaultModulePackages = defaultModule.getPackages();
                if(defaultModulePackages.size() != 1)
                    throw new RuntimeException("Assertion failed: default module has more than the default package: "+defaultModulePackages.size());
                defaultModulePackages.clear();
                defaultModulePackages.add(newPkg);
                newPkg.setModule(defaultModule);
                defaultPackage.setModule(null);
            }
        }
    }

#No. 3492
#File: E:\bishe\1\AbstractModelLoader.java
#Comment:
    /**
     * To be overridden by subclasses, defaults to false.
     */

#Code:
    protected boolean isAutoExportMavenDependencies(){
        return false;
    }

#No. 3493
#File: E:\bishe\1\AbstractModelLoader.java
#Comment:
    /**
     * To be overridden by subclasses, defaults to false.
     */

#Code:
    protected boolean isFlatClasspath(){
        return false;
    }

#No. 3494
#File: E:\bishe\1\AbstractModelResource.java
#Comment:
/**
 * <p>Abstract AbstractModelResource class.</p>
 *
 * @author icode
 * @since 0.1.6e
 *
 */

#Code:
public abstract class AbstractModelResource<URI_ID, MODEL>
        extends ModelResource<URI_ID, URI_ID, MODEL> {
    /**
     * <p>Constructor for AbstractModelResource.</p>
     *
     * @param modelType a {@link java.lang.Class} object.
     */
    public AbstractModelResource(Class<MODEL> modelType) {
        super(modelType);
    }

    /**
     * <p>Constructor for AbstractModelResource.</p>
     *
     * @param modelType a {@link java.lang.Class} object.
     * @param server    a {@link io.ebeaninternal.api.SpiEbeanServer} object.
     */
    public AbstractModelResource(Class<MODEL> modelType, SpiEbeanServer server) {
        super(modelType, server);
    }
}

#No. 3495
#File: E:\bishe\1\AbstractModelWithHolder_.java
#Comment:
  /**
   * Register a listener that will be called when this model is bound to a view.
   * <p>
   * The listener will contribute to this model's hashCode state per the {@link
   * com.airbnb.epoxy.EpoxyAttribute.Option#DoNotHash} rules.
   * <p>
   * You may clear the listener by setting a null value, or by calling {@link #reset()} */

#Code:
  public AbstractModelWithHolder_ onBind(OnModelBoundListener<AbstractModelWithHolder_, AbstractModelWithHolder.Holder> listener) {
    onMutation();
    this.onModelBoundListener_epoxyGeneratedModel = listener;
    return this;
  }

#No. 3496
#File: E:\bishe\1\AbstractModelWithHolder_.java
#Comment:
  /**
   * Register a listener that will be called when this model is unbound from a view.
   * <p>
   * The listener will contribute to this model's hashCode state per the {@link
   * com.airbnb.epoxy.EpoxyAttribute.Option#DoNotHash} rules.
   * <p>
   * You may clear the listener by setting a null value, or by calling {@link #reset()} */

#Code:
  public AbstractModelWithHolder_ onUnbind(OnModelUnboundListener<AbstractModelWithHolder_, AbstractModelWithHolder.Holder> listener) {
    onMutation();
    this.onModelUnboundListener_epoxyGeneratedModel = listener;
    return this;
  }

#No. 3497
#File: E:\bishe\1\AbstractModifiableEntity.java
#Comment:
    /**
     * Enables optimistic locking.
     */

#Code:
    @Version
    private Long version;

    @LastModifiedDate
    @NotNull(groups = { PersistenceOnly.class })
    @Column(nullable = false)
    private DateTime lastModified;

    public DateTime getLastModified() {
        return lastModified;
    }

#No. 3498
#File: E:\bishe\1\AbstractMojoWithLoadedClasspath.java
#Comment:
    /**
     * @parameter expression="${project.testClasspathElements}"
     * @required
     * @readonly
     */

#Code:
    private List<String> classpathElements;

    /**
     * @parameter expression="${settings.localRepository}"
     * @required
     * @readonly
     */
    private String localRepository;

    public void execute()
            throws MojoExecutionException, MojoFailureException {
        loadClassPath();
        subclassExecute();
    }

#No. 3499
#File: E:\bishe\1\AbstractMOServletTest.java
#Comment:
    /**
     * If validateUserCredentials is true, and the servlet is instantiated with null username and password,
     * no validation is actually done.
     */

#Code:
    @Test
    public void testHandleValidateNullCredentials() throws IOException, ServletException {
        HttpServletRequest request = dummyTextRequest();
        HttpServletResponse response = mock(HttpServletResponse.class);
        StringWriter dummyResponseWriter = new StringWriter();

        when(request.getParameter("username")).thenReturn("admin");
        when(request.getParameter("password")).thenReturn("password");

        when(response.getWriter()).thenReturn(new PrintWriter(dummyResponseWriter));

        TestMOServlet servlet = new TestMOServlet(false, null, true, null, null);
        servlet.doPost(request, response);
        assertEquals("OK", dummyResponseWriter.toString());

        MO mo = servlet.result;
        assertEquals("anisdn", mo.getSender());
        assertEquals("to", mo.getDestination());
        assertEquals("networkcode", mo.getNetworkCode());
        assertEquals("messageid", mo.getMessageId());
        assertEquals("asessionid", mo.getSessionId());
        assertEquals("akeyword", mo.getKeyword());
        assertEquals("text", mo.getMessageType().getType());
        assertEquals("Dear John", mo.getMessageBody());
    }

#No. 3500
#File: E:\bishe\1\AbstractMostReadPinnedReport.java
#Comment:
    /**
     * Creates a table for stats display.
     *
     * @param table table component to initialize.
     * @param max   maximum number of rows.
     *
     * @return table.
     */

#Code:
    protected JPanel createDataTable(JPanel table, int max)
    {
        BBFormBuilder builder = new BBFormBuilder("16px, 4dlu, 50dlu:grow, 2dlu, p, 7dlu, p", table);
        builder.setDefaultDialogBorder();

        // Output header
        builder.append(UifUtilities.boldFont(new JLabel(headerEntityTitle)), 3);
        builder.append(UifUtilities.boldFont(new JLabel(Strings.message("report.activity"))), 1,
            CellConstraints.CENTER, CellConstraints.DEFAULT);
        builder.append(UifUtilities.boldFont(new JLabel(Strings.message("report.stats"))), 1,
            CellConstraints.CENTER, CellConstraints.DEFAULT);

        LineChartConfig config = new SparklineConfig();
        config.setValueXStep(2);

        // Output data
        if (stats != null)
        {
            int i = 0;
            for (ReadStats stat : stats)
            {
                if (i++ == max) break;

                LineChartData data = new LineChartData(stat.getCounts());
                LineChart chart = new LineChart(data, config);

                builder.appendRelatedComponentsGapRow(2);
                builder.appendRow("max(p;20px)");
                builder.append(new JLabel(itemIcon));
                builder.append(createLabel(stat.getObjectId(), stat.getObjectTitle()));
                builder.append(chart, 1, CellConstraints.CENTER, CellConstraints.FILL);
                builder.append(new JLabel("<html><b>" + stat.getTotal() + " articles</b><br>" +
                    getAvg(stat) + " a day"));
            }
        }

        return builder.getPanel();
    }

#No. 3501
#File: E:\bishe\1\AbstractMostReadPinnedReport.java
#Comment:
    /**
     * Formats the average.
     *
     * @param stat stat.
     *
     * @return avg.
     */

#Code:
    private static String getAvg(ReadStats stat)
    {
        float avg = stat.getTotal() / (float)(stat.getCounts().length);
        return MessageFormat.format("{0,number,#.##}", avg);
    }

#No. 3502
#File: E:\bishe\1\AbstractMovieParser.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public List<Movie> parse(final String data) {
        if (!isDataValid(data)) {
            return Collections.emptyList();
        }

        return getStructureStream(data)
                .map(getDataMapper())
                .collect(Collectors.toList());
    }

#No. 3503
#File: E:\bishe\1\AbstractMovieParser.java
#Comment:
    /**
     * Checks that data is valid.
     *
     * @param data Data to check
     * @return Is data valid or not
     */

#Code:
    protected boolean isDataValid(final String data) {
        return data != null;
    }

#No. 3504
#File: E:\bishe\1\AbstractMovieParser.java
#Comment:
    /**
     * Returns String representation of element using mapper or null
     * @param element Element
     * @param mapper Mapper
     * @param <E> Type of element
     * @return String representation of element or null
     */

#Code:
    protected <E> String stringOrNull(E element, Function<E, String> mapper) {
        return Optional.ofNullable(element)
                .map(mapper)
                .orElse(null);
    }

#No. 3505
#File: E:\bishe\1\AbstractMovieParser.java
#Comment:
    /**
     * Parses title, and returns "null" string if not valid
     *
     * @param title String to parseResponse
     * @return Parsed title
     */

#Code:
    String parseTitle(final String title) {
        val resultTitle = String.valueOf(title).trim();

        if ("".equals(resultTitle)) {
            return "null";
        }

        return resultTitle;
    }

#No. 3506
#File: E:\bishe\1\AbstractMovieParser.java
#Comment:
    /**
     * Parses year, returns 0 if it not valid
     *
     * @param year String containing year to parse
     * @return Parsed year or 0
     */

#Code:
    int parseYear(final String year) {
        val yearLength = 4;

        try {
            val resultYear = String.valueOf(year).trim().substring(0, yearLength);

            return Integer.parseInt(resultYear);
        } catch (NumberFormatException | IndexOutOfBoundsException e) {
            return 0;
        }
    }

#No. 3507
#File: E:\bishe\1\AbstractMovieParser.java
#Comment:
    /**
     * Parses type, returns {@link Movie.Type#MOVIE} if undefined
     *
     * @param type String containing type to parse
     * @return Parsed Type or {@link Movie.Type#MOVIE}
     */

#Code:
    Movie.Type parseType(final String type) {
        val safeType = String.valueOf(type);

        if (safeType.contains("TV series") || safeType.contains("TV mini-series")) {
            return Movie.Type.SERIES;
        } else if (safeType.contains("documentary")) {
            return Movie.Type.DOCUMENTARY;
        } else if (safeType.contains("short")) {
            return Movie.Type.SHORT;
        } else if (safeType.contains("video game")) {
            return Movie.Type.VIDEO_GAME;
        }

        return Movie.Type.MOVIE;
    }

#No. 3508
#File: E:\bishe\1\AbstractMovieParser.java
#Comment:
    /**
     * Parses IMDB ID or returns null if it not valid
     *
     * @param imdbId String to parseResponse
     * @return Parsed IMDB ID or null
     */

#Code:
    String parseIMDBId(final String imdbId) {
        val resultImdbId = String.valueOf(imdbId).trim();

        if (!resultImdbId.startsWith("tt") || resultImdbId.length() < 3) {
            return null;
        }

        return resultImdbId;
    }

#No. 3509
#File: E:\bishe\1\AbstractMovieParser.java
#Comment:
    /**
     * Parses rating or returns null if it not valid
     *
     * @param rating String to parseResponse
     * @return Parsed rating or null
     */

#Code:
    Integer parseRating(final String rating) {
        val resultRating = String.valueOf(rating).trim();
        val zeroValues = Arrays.asList("", "null", "zero", "0");

        if (zeroValues.contains(resultRating)) {
            return null;
        }

        try {
            val result = Integer.parseInt(resultRating);

            return result <= 10 ? result : null;
        } catch (NumberFormatException ignore) {
            return null;
        }
    }

#No. 3510
#File: E:\bishe\1\AbstractMqttAdapter.java
#Comment:
	/**
	 * Called when a message from arduino (ardulink) is received and should be
	 * published to the mqtt broker.
	 * 
	 * @param topic
	 *            the message's topic
	 * @param message
	 *            the payload
	 */

#Code:
	abstract void fromArduino(String topic, String message);

}
}

#No. 3511
#File: E:\bishe\1\AbstractMqttChannelTest.java
#Comment:
	/**
	 * @see net.xenqtt.message.MqttChannelTestBase#newClientChannel(net.xenqtt.message.BlockingCommand)
	 */

#Code:
	@Override
	TestChannel newClientChannel(BlockingCommand<?> connectionCompleteCommand) throws Exception {
		return new TestChannel("localhost", port, clientHandler, selector, 10000, connectionCompleteCommand);
	}

#No. 3512
#File: E:\bishe\1\AbstractMqttOperator.java
#Comment:
	/**
	 * @return error output port if present, null if not specified
	 */

#Code:
	abstract protected StreamingOutput<OutputTuple> getErrorOutputPort();
	
	protected void submitToErrorPort(String errorMsg, ConsistentRegionContext crContext) {
		StreamingOutput<OutputTuple> errorOutputPort = getErrorOutputPort();
		if (errorOutputPort != null) {
			OutputTuple errorTuple = errorOutputPort.newTuple();

			errorTuple.setString(0, errorMsg);

			try {
				if(crContext != null) {
					crContext.acquirePermit();
				}
				errorOutputPort.submit(errorTuple);
			} catch (Exception e) {
				TRACE.log(TraceLevel.ERROR,
						Messages.getString("CANNOT_SUBMIT_ERROR_TUPLE"), e); //$NON-NLS-1$
			} finally {
				if(crContext != null) {
					crContext.releasePermit();
				}
			}
		}
	}

#No. 3513
#File: E:\bishe\1\AbstractMsgAction.java
#Comment:
	/**
	 * 获取消息列表
	 * @param cust_id
	 * @param page
	 * @param pageSize
	 * @return
	 */

#Code:
	protected List<LocalMsgBean> getMsgList(int cust_id, int page, int pageSize){
		if(getLevel() == LEVEL1)
			return msgBeanMapper.getL1List(cust_id, 0, pageSize);
		else if(getLevel() == LEVEL2)
			return msgBeanMapper.getL2List(cust_id, (page - 1) * pageSize, pageSize);
		else if(getLevel() == LEVEL3)
			return msgBeanMapper.getL3List((page - 1) * pageSize, pageSize);
		return null;
	}

#No. 3514
#File: E:\bishe\1\AbstractMsgAction.java
#Comment:
	/**
	 * 显示操作主页面
	 * @param user
	 * @param page
	 * @return
	 */

#Code:
	public final ModelAndView showIndex(User user, int page) {
		// 获取Main数据
		List<LocalMsgBean> msgList = getMsgList(user.getCust_id(), page, getPageSize());
		obtainResult(msgList);
		if(getLevel() == LEVEL1){
			return getListResult(user.getRole_id(), getMainViewName(), msgList);
		}else{
			Pagination pg = new Pagination(page, getPageSize(), getResultCount(user.getCust_id()));
			return getListResultByPagination(pg, user.getRole_id(), getMainViewName(), msgList);
		}
	}

#No. 3515
#File: E:\bishe\1\AbstractMsgAction.java
#Comment:
	/**
	 * 显示添加或者编辑客户信息的页面
	 * @param id
	 * @return
	 */

#Code:
	@RequestMapping(value = "add-edit-page", method = RequestMethod.GET)
	public ModelAndView addOrEditPage(
			@RequestParam(value = "id", required = false, defaultValue = "0") long id) {
		LocalMsgBean mb = null;
		if(id > 0)
			mb = msgBeanMapper.getMsg(id, getLevel());
		if(null == mb)
			mb = new LocalMsgBean();
		String title = getAddEditTitle(id);
		Map<String, Object>	param = new HashMap<>();
		param.put("msg", mb);
		param.put("title", title);
		return new ModelAndView("manage/message/msg-add-edit", "param", param);
	}
	
	/**
	 * 跳转到主页
	 * @return
	 */
	@RequestMapping("list")
	public String index() {
		return "redirect:/webservices/message/level"+getLevel()+"/list/1";
	}

#No. 3516
#File: E:\bishe\1\AbstractMsgAction.java
#Comment:
	/**
	 * 删除消息
	 * @param id
	 * @return
	 */

#Code:
	@ResponseBody
	@RequestMapping(value = "delete", method = RequestMethod.POST, produces = "text/html;charset=UTF-8")
	public String delete(String id) {
		if (id == null || "".equals(id))
			return sendJSONError("删除失败： 信息不存在。");
		int result = msgBeanMapper.deleteMsg(id, getLevel());
		if (0 != result)
			return sendJSONMsg("删除成功。");
		else
			return sendJSONError("删除失败。");
	}

#No. 3517
#File: E:\bishe\1\AbstractMsgAction.java
#Comment:
	/**
	 * 获取添加编辑页面的标题
	 * @param id
	 * @return
	 */

#Code:
	private String getAddEditTitle(long id){
		StringBuilder sb = new StringBuilder();
		if(id > 0){
			sb.append("编辑");
			if(getLevel() == 2) sb.append("二级");
			else sb.append("通用");
		}else{
			sb.append("添加");
			if(getLevel() == 2) sb.append("二级");
			else sb.append("通用");
		}
		return sb.toString();
	}

#No. 3518
#File: E:\bishe\1\AbstractMsgAction.java
#Comment:
	/**
	 * 获取主页模板名称
	 * @return
	 */

#Code:
	private String getMainViewName(){
		return "list";
	}

#No. 3519
#File: E:\bishe\1\AbstractMsgGateWay.java
#Comment:
  /**
   * 身份认证
   * 
   * @param cfg
   * @param req
   */

#Code:
  protected void doAuthentication(MmtConfig cfg, HttpServletRequest req) {
    // 加密签名
    String signature = req.getParameter("signature");
    // 时间戳
    String timestamp = req.getParameter("timestamp");
    // 随机数
    String nonce = req.getParameter("nonce");
    // 随机字符串
    String echostr = req.getParameter("echostr");

    // 参数装箱
    Access sa = new Access();
    sa.setEchostr(echostr);
    sa.setNonce(nonce);
    sa.setSignature(signature);
    sa.setTimestamp_api(timestamp);
    sa.setCust_id(cfg.getCust_id());
    sa.setToken(cfg.getToken());

    if (!getProcessor(cfg).verifySignature(sa))
      throw new MmtException("身份认证失败：CUST_ID=" + cfg.getCust_id());
  }

#No. 3520
#File: E:\bishe\1\AbstractMsgGateWay.java
#Comment:
  /**
   * 网址接入
   * 
   * @param cfg
   * @param req
   * @param resp
   * @throws IOException
   */

#Code:
  private void access(MmtConfig cfg, HttpServletRequest req, HttpServletResponse resp)
      throws IOException {
    if (logger.isDebugEnabled())
      logger.debug("Verify signature[cust_id=" + cfg.getCust_id() + "].");
    // 身份认证
    doAuthentication(cfg, req);
    // 回应Server
    resp.getWriter().print(req.getParameter("echostr"));
    // FIXME 验证签名结束
  }

#No. 3521
#File: E:\bishe\1\AbstractMsgGateWay.java
#Comment:
  /**
   * 获取客户令牌
   * 
   * @param path
   * @return
   */

#Code:
  private String getMmtToken(String path) {
    if (path.lastIndexOf("/") == 0) path = path + "/";
    path = path.substring(path.lastIndexOf("/"));
    return path.length() > 0 ? path.substring(1) : null;
  }

#No. 3522
#File: E:\bishe\1\AbstractMsgGateWay.java
#Comment:
  /**
   * get receive message
   * 
   * @param xml
   * @return
   */

#Code:
  private BaseMessage getMessage(String xml) {
    return MmtXMLParser.fromXML(xml);
  }

#No. 3523
#File: E:\bishe\1\AbstractMsgGateWay.java
#Comment:
  /**
   * 处理文字信息
   * 
   * @param cfg
   * @param req
   * @param resp
   */

#Code:
  private void process0(MmtConfig cfg, HttpServletRequest request, HttpServletResponse response) {
    if (logger.isDebugEnabled())
      logger.debug("process message[cust_id=" + cfg.getCust_id() + "].");
    response.setCharacterEncoding(LOCAL_CHARSET);
    // 预处理
    preProcessMsg(cfg, request);
    try (PrintWriter out = response.getWriter()) {
      BaseMessage result = processMsg(cfg, request.getInputStream());
      String respXML = MmtXMLParser.toXML(result);
      // save log
      saveSendLog(cfg, respXML);
      // response to server
      out.println(respXML);
      out.flush();
      // FIXME 消息处理正常结束
    } catch (IOException e) {
      // FIXME 消息异常结束
      throw new MmtException("Process message failed. ", e.getCause());
    }
  }

#No. 3524
#File: E:\bishe\1\AbstractMsgGateWay.java
#Comment:
  /**
   * 保存接收日志
   * 
   * @param cfg
   * @param xml
   */

#Code:
  private void saveRecvLog(MmtConfig cfg, String xml) {
    MsgLog log = prepareLog(cfg, xml);
    if (msgLogManager.saveRecvLog(log) == 0) throw new MmtException("保存接收日志失败。");
  }

#No. 3525
#File: E:\bishe\1\AbstractMsgGateWay.java
#Comment:
  /**
   * 保存发送日志
   * 
   * @param cfg
   * @param xml
   */

#Code:
  private void saveSendLog(MmtConfig cfg, String xml) {
    MsgLog log = prepareLog(cfg, xml);
    if (msgLogManager.saveSendLog(log) == 0) throw new MmtException("保存发送日志失败。");
  }

#No. 3526
#File: E:\bishe\1\AbstractMsgGateWay.java
#Comment:
  /**
   * 生成Log对象
   * 
   * @param cfg
   * @param xml
   * @return
   */

#Code:
  private MsgLog prepareLog(MmtConfig cfg, String xml) {
    MsgLog log = new MsgLog();
    log.setCust_id(cfg.getCust_id());
    log.setMsg(xml);
    log.setService_type(getProcessor(cfg).getServiceType());
    return log;
  }

#No. 3527
#File: E:\bishe\1\AbstractMsgGateWay.java
#Comment:
  /**
   * get string from input stream
   * 
   * @param is0
   * @return
   */

#Code:
  private String getStringFromStream(InputStream is0) {
    try (InputStream is = is0) {
      BufferedReader br = new BufferedReader(new InputStreamReader(is));
      StringBuilder sb = new StringBuilder();
      String line;
      while ((line = br.readLine()) != null)
        sb.append(line);
      return new String(sb.toString().getBytes(LOCAL_CHARSET), getGateWayCharset());
    } catch (IOException e) {
      throw new MmtException("Cant't get string from InputStream.", e.getCause());
    }
  }

#No. 3528
#File: E:\bishe\1\AbstractMsgGateWay.java
#Comment:
  /**
   * get passive message processor
   * 
   * @param cfg
   * @return
   */

#Code:
  private PassiveMsgProcessor getProcessor(MmtConfig cfg) {
    if (cfg == null || cfg.getBiz_class() == null || "".equals(cfg.getBiz_class()))
      throw new MmtException("No implement bussiness class found!!!");
    try {
      return (PassiveMsgProcessor) context.getApplicationContext().getBean(
          Class.forName(cfg.getBiz_class()));
    } catch (BeansException | ClassNotFoundException e) {
      throw new MmtException("No implement bussiness class found!!!", e.getCause());
    }
  }

#No. 3529
#File: E:\bishe\1\AbstractMsgTester.java
#Comment:
	/**
	 * set the message's fields with initialize value
	 * @param service_type
	 * @param original
	 */

#Code:
	private void setCommonFields(SimpleMessage original){
		original.setCust_id(CUST_ID);
		original.setId(0);
		original.setToUser("ot9x4jpm4x_rBrqacQ8hzikL9D-M");
	}

#No. 3530
#File: E:\bishe\1\AbstractMsgTester.java
#Comment:
	/**
	 * Test case
	 */

#Code:
	private void test(){
		SimpleMessage original = getMsgInstance();
		setCommonFields(original);
		setSpecFields(original);
		String json = MmtJSONParser.toJSON(original);
		logger.debug("Generate JSON string: " + json);
		//verify special field
		SimpleMessage after = verifySpecFields(original, json);
		//verify common field
		verifyCommonFields(original, after);
	}

#No. 3531
#File: E:\bishe\1\AbstractMsgTester.java
#Comment:
	/**
	 * verify common field
	 * @param original
	 * @param after
	 */

#Code:
	private void verifyCommonFields(SimpleMessage original, SimpleMessage after){
		assertNotNull(after);
		assertEquals(after.getMsgType(), original.getMsgType());
		assertEquals(after.getToUser(), original.getToUser());
	}

#No. 3532
#File: E:\bishe\1\AbstractMultiBrokerTest.java
#Comment:
    /**
     * Creates {@code topic} on currently running broker
     *
     * @param topic
     *        name to create
     */

#Code:
    public static void createTopic(String topic) {

        createTopic(topic, 1, 1);
    }

#No. 3533
#File: E:\bishe\1\AbstractMultiFactorAuthenticationViaFormAction.java
#Comment:
    /**
     * Checks if is valid login ticket.
     *
     * @param context the context
     * @param messageContext the message context
     *
     * @return true, if is valid login ticket
     */

#Code:
    protected final boolean isValidLoginTicket(final RequestContext context, final MessageContext messageContext) {
        final String authoritativeLoginTicket = WebUtils.getLoginTicketFromFlowScope(context);
        final String providedLoginTicket = WebUtils.getLoginTicketFromRequest(context);
        if (!authoritativeLoginTicket.equals(providedLoginTicket)) {
            logger.warn("Invalid login ticket {}", providedLoginTicket);
            final String code = "INVALID_TICKET";
            messageContext.addMessage(new MessageBuilder().error().code(code).arg(providedLoginTicket).defaultText(code).build());
            return false;
        }
        return true;
    }

#No. 3534
#File: E:\bishe\1\AbstractMultiFactorAuthenticationViaFormAction.java
#Comment:
    /**
     * Submit.
     *
     * @param context the context
     * @param credentials the credentials
     * @param messageContext the message context
     * @param id the id
     *
     * @return the event
     *
     * @throws Exception the exception
     */

#Code:
    private Event submit(final RequestContext context, final Credential credentials, final MessageContext messageContext,
                              final String id) throws Exception {

        if (isMultiFactorAuthenticationRequest(context)) {
            if (isValidLoginTicket(context, messageContext)) {
                return doMultiFactorAuthentication(context, credentials, messageContext, id);
            }
            return getErrorEvent(context);
        }
        return doAuthentication(context, credentials, messageContext, id);
    }

#No. 3535
#File: E:\bishe\1\AbstractMultiFactorAuthenticationViaFormAction.java
#Comment:
    /**
     * CAS instance used to handle authentications. This CAS instance is only
     * effective when the incoming service does not specify a valid loa.
     *
     * @param centralAuthenticationService the cas instance.
     */

#Code:
    public final void setCentralAuthenticationService(final CentralAuthenticationService centralAuthenticationService) {
        this.cas = centralAuthenticationService;
    }

#No. 3536
#File: E:\bishe\1\AbstractMultiFactorAuthenticationViaFormAction.java
#Comment:
    /**
     * Authentication manager instance to authenticate the user by its configured
     * handlers as the first leg of an multifactor authentication sequence.
     *
     * @param manager the new multifactor authentication manager
     */

#Code:
    public final void setMultiFactorAuthenticationManager(final AuthenticationManager manager) {
        this.authenticationManager = manager;
    }

#No. 3537
#File: E:\bishe\1\AbstractMultiFactorAuthenticationViaFormAction.java
#Comment:
    /**
     * The webflow error event id.
     *
     * @param context the context
     * @return error event id
     */

#Code:
    protected final Event getErrorEvent(final RequestContext context) {
        final Event event = this.errorEventBuilder.buildEvent(context);
        final FlowDefinition flow = context.getActiveFlow();
        final String flowId = flow != null ? flow.getId() : "[none]";
        logger.debug("Returning an error event [{}] in the active flow id [{}]", event.getId(), flowId);
        return event;

    }

#No. 3538
#File: E:\bishe\1\AbstractMultiFactorAuthenticationViaFormAction.java
#Comment:
    /**
     * Return the mfa webflow id.
     *
     * @param context the request context
     *
     * @return the webflow id
     */

#Code:
    protected final Event getSuccessEvent(final RequestContext context) {
        return this.successfulEventBuilder.buildEvent(context);
    }

#No. 3539
#File: E:\bishe\1\AbstractMultiFactorAuthenticationViaFormAction.java
#Comment:
    /**
     * Populate errors instance.
     *
     * @param code the error code
     * @param messageContext the message context
     */

#Code:
    protected final void populateErrorsInstance(final String code, final MessageContext messageContext) {
        try {
            messageContext.addMessage(new MessageBuilder().error().code(code).defaultText(code).build());
        }  catch (final Exception fe) {
            logger.error(fe.getMessage(), fe);
        }
    }

#No. 3540
#File: E:\bishe\1\AbstractMultiFactorAuthenticationViaFormAction.java
#Comment:
    /**
     * Get MFA request or null.
     *
     * <p>The service may be null and not available in the context, in cases where
     * one is simply logging into CAS without noting the service application.
     * In those cases, we need to mock up a service instance in order for authentication
     * request resolver (i.e. based on principal attributes) to be able to establish the
     * mfa context and walk the user through the mfa sequence if need be. This dummy service
     * is based on the hostname provided to CAS via configuration, and is CAS itself.</p>
     * @param authentication the authentication
     * @param service the service
     * @param context the context
     *
     * @return mfa request or null
     */

#Code:
    protected List<MultiFactorAuthenticationRequestContext> getMfaRequestOrNull(final Authentication authentication,
                                                                          final WebApplicationService service,
                                                                          final RequestContext context) {

        WebApplicationService serviceToUse = service;
        final HttpServletRequest request = HttpServletRequest.class.cast(context.getExternalContext().getNativeRequest());
        final String responseMethod = request.getParameter("method");
        final ResponseType responseType = "POST".equalsIgnoreCase(responseMethod) ? ResponseType.POST : ResponseType.REDIRECT;
        if (service == null) {
            serviceToUse = new SimpleWebApplicationServiceImpl(this.hostname);
        }

        final List<MultiFactorAuthenticationRequestContext> mfaRequests =
                this.multiFactorAuthenticationRequestResolver.resolve(authentication, serviceToUse, responseType);
        if (mfaRequests != null) {
            for (final MultiFactorAuthenticationRequestContext mfaRequest : mfaRequests) {
                this.authenticationMethodVerifier.verifyAuthenticationMethod(mfaRequest.getMfaService().getAuthenticationMethod(),
                        mfaRequest.getMfaService(),
                        request);

                logger.info("There is an existing mfa request for service [{}] with a requested authentication method of [{}]",
                        mfaRequest.getMfaService().getId(), mfaRequest.getMfaService().getAuthenticationMethod());
            }
            logger.debug("Resolved {} multifactor authentication requests", mfaRequests.size());
            if (mfaRequests.isEmpty()) {
                logger.debug("No multifactor authentication requests could be resolved.");
                return null;
            }
        }
        return mfaRequests;
    }

#No. 3541
#File: E:\bishe\1\AbstractMultiFactorAuthenticationViaFormAction.java
#Comment:
    /**
     * Add the request to mfa transaction, re-rank and return the newly ranked one.
     *
     * @param mfaRequests the mfaRequest
     * @param context the context
     *
     * @return newly ranked mfa request in the current mfa transaction
     */

#Code:
    protected MultiFactorAuthenticationSupportingWebApplicationService
                addToMfaTransactionAndGetHighestRankedMfaRequest(final List<MultiFactorAuthenticationRequestContext> mfaRequests,
                                                     final RequestContext context) {

        MultiFactorAuthenticationTransactionContext mfaTx = MultiFactorRequestContextUtils.getMfaTransaction(context);
        if (mfaTx == null && !mfaRequests.isEmpty()) {
            final WebApplicationService svc = mfaRequests.get(0).getMfaService();
            mfaTx = new MultiFactorAuthenticationTransactionContext(svc.getId());
        }
        for (final MultiFactorAuthenticationRequestContext mfaRequest : mfaRequests) {
            mfaTx.addMfaRequest(mfaRequest);
        }

        MultiFactorRequestContextUtils.setMfaTransaction(context, mfaTx);
        return getHighestRankedMfaRequestFromMfaTransaction(context);
    }

#No. 3542
#File: E:\bishe\1\AbstractMultiFactorAuthenticationViaFormAction.java
#Comment:
    /**
     * Get highest ranked mfa request from mfa transaction. Assumes that mfa transaction is already in the flow scope.
     *
     * @param context the context
     *
     * @return highest ranked mfa request
     */

#Code:
    private MultiFactorAuthenticationSupportingWebApplicationService
            getHighestRankedMfaRequestFromMfaTransaction(final RequestContext context) {
        return this.authnMethodRankingStrategy.computeHighestRankingAuthenticationMethod(
                MultiFactorRequestContextUtils.getMfaTransaction(context));
    }

#No. 3543
#File: E:\bishe\1\AbstractMultiIndexActionBuilder.java
#Comment:
    /**
     * Ignore unavailable indices, this includes indices that not exists or closed indices.
     * @param ignore whether to ignore unavailable indices
     */

#Code:
    public K ignoreUnavailable(boolean ignore) {
        setParameter(Parameters.IGNORE_UNAVAILABLE, String.valueOf(ignore));
        return (K) this;
    }

#No. 3544
#File: E:\bishe\1\AbstractMultiIndexActionBuilder.java
#Comment:
    /**
     * Fail of wildcard indices expressions results into no concrete indices.
     * @param allow whether to allow no indices.
     */

#Code:
    public K allowNoIndices(boolean allow) {
        setParameter(Parameters.ALLOW_NO_INDICES, String.valueOf(allow));
        return (K) this;
    }

#No. 3545
#File: E:\bishe\1\AbstractMultiINodeActionBuilder.java
#Comment:
    /**
     * Most cluster level APIs allow to specify which nodes to execute on (for example, getting the node stats for a node).
     * Nodes can be identified in the APIs either using their internal node id, the node name, address, custom attributes,
     * or just the _local node receiving the request. For example, here are some sample values for node:
     * <p/>
     * <pre>
     *    # Local   ->  _local
     *
     *    # Address ->  10.0.0.3,10.0.0.4
     *              ->  10.0.0.*
     *
     *    # Names   ->  node_name_goes_here
     *              ->  node_name_goes_*
     *
     *    # Attributes (set something like node.rack: 2 in the config)
     *              ->  rack:2
     *                  ->  ra*:2
     *              ->  ra*:2*
     * </pre>
     */

#Code:
    public K addNode(String node) {
        if (!Strings.isNullOrEmpty(node)) {
            nodes.add(node);
        }
        return (K) this;
    }

#No. 3546
#File: E:\bishe\1\AbstractMultiINodeActionBuilder.java
#Comment:
    /**
     * Most cluster level APIs allow to specify which nodes to execute on (for example, getting the node stats for a node).
     * Nodes can be identified in the APIs either using their internal node id, the node name, address, custom attributes,
     * or just the _local node receiving the request. For example, here are some sample values for node:
     * <p/>
     * <pre>
     *    # Local   ->  _local
     *
     *    # Address ->  10.0.0.3,10.0.0.4
     *              ->  10.0.0.*
     *
     *    # Names   ->  node_name_goes_here
     *              ->  node_name_goes_*
     *
     *    # Attributes (set something like node.rack: 2 in the config)
     *              ->  rack:2
     *                  ->  ra*:2
     *              ->  ra*:2*
     * </pre>
     */

#Code:
    public K addNode(Collection<? extends String> nodes) {
        this.nodes.addAll(nodes);
        return (K) this;
    }

#No. 3547
#File: E:\bishe\1\AbstractMultiLabelledQuery.java
#Comment:
  /**
   * Initialize the queries launcher.
   * 
   * @param d
   *          The Dump object, allows the use to modify the output easily.
   */

#Code:
  public AbstractMultiLabelledQuery(Dump d) {
    super(d);
  }

#No. 3548
#File: E:\bishe\1\AbstractMultiLabelledQuery.java
#Comment:
  /**
   * Initialize the queries launcher.
   */

#Code:
  public AbstractMultiLabelledQuery() {
    super();
  }

#No. 3549
#File: E:\bishe\1\AbstractMultiLabelledQuery.java
#Comment:
  /**
   * Create a valid SPARQL command for a GROUP_CONCAT.
   * 
   * @param unchangedVar
   *          All the variable which will be keep after the GROUP_CONCAT
   * @param initialVar
   *          The variable to group.
   * @param newVar
   *          The new name of this variable.
   */

#Code:
  protected String makeGroupConcat(String initialVar, String newVar) {
    return " (GROUP_CONCAT(IF(isURI(" + initialVar + "),\n"
        + "                concat('<', str(" + initialVar + "), '>'),\n"
        + "                concat('\"', ENCODE_FOR_URI(" + initialVar
        + "), '\"'))) AS " + newVar + ")\n";
  }

#No. 3550
#File: E:\bishe\1\AbstractMultiLabelledQuery.java
#Comment:
  /**
   * Get the name and the cardinality of the nodes.
   * 
   * @throws Exception
   */

#Code:
  @Override
  public void computeName() throws Exception {
    String query = "SELECT ?label ?pType ?pDescription (COUNT (?s) AS ?cardinality)\n"
        + _graphFrom
        + "WHERE {\n{\n"
        + "SELECT ?s (GROUP_CONCAT(IF(isURI(?type),\n"
        + "           concat('{<', str(?type), '>,',?p,'}'),\n"
        + "           concat('{\"', ENCODE_FOR_URI(?type), '\",',?p,'}'))) AS ?label)\n"
        + "        WHERE {\n"
        + "        {\n"
        + "            SELECT ?s ?type ?p WHERE\n" + "            {\n";

    if (AnalyticsClassAttributes.getClassAttributes().size() > 0) {
      query += "{ ?s <" + AnalyticsClassAttributes.getClassAttributes().get(0)
          + "> ?type .\n  BIND ('0' AS ?p) }\n";
      for (int i = 1; i < AnalyticsClassAttributes.getClassAttributes().size(); ++i) {
        query += "UNION{ ?s <"
            + AnalyticsClassAttributes.getClassAttributes().get(i)
            + "> ?type .\n BIND ('" + i + "' AS ?p) }\n";
      }
    }
    query += "            }\n" + "            ORDER BY ?type\n"
        + "        }\n" + "        }\n" + "        GROUP BY ?s\n" + "    }\n"
        + "FILTER(?label != \"\")\n" + "}\n"
        + "GROUP BY ?label ?pType ?pDescription\n";

    _logger.debug(query);
    launchQueryNode(query);

  }

#No. 3551
#File: E:\bishe\1\AbstractMultiPageApplication.java
#Comment:
  /*****************************************************************************
   * Private Members
   ****************************************************************************/

#Code:

  private ContextManager _contextManager = new HistoryContextManager();

  private Map<String, IPageSource> _pages = new HashMap<String, IPageSource>();

  private FlowPanel _panel;

  private String _activePage = null;

  private IPageSource _exceptionPage = new ExceptionPage();

  private boolean _hadError;

  /*****************************************************************************
   * Static Methods
   ****************************************************************************/

  public static AbstractMultiPageApplication getApp() {
    return _app;
  }

#No. 3552
#File: E:\bishe\1\AbstractMultiPageApplication.java
#Comment:
  /*****************************************************************************
   * {@link ExceptionListener} Interface
   ****************************************************************************/

#Code:

  public void onException(Throwable ex) {

    ex.printStackTrace();

    String msg = ex.getMessage();

    Map<String, String> p = new HashMap<String, String>();
    p.put("message", msg);
    ContextImpl c = new ContextImpl(p);

    try {
      _panel.clear();
      Widget widget = _exceptionPage.create(c);
      _panel.add(widget);
      _hadError = true;
    } catch (PageException e) {
      e.printStackTrace();
    }
  }

#No. 3553
#File: E:\bishe\1\AbstractMultiPageApplication.java
#Comment:
  /*****************************************************************************
   * {@link EntryPoint}
   ****************************************************************************/

#Code:

  public void onModuleLoad() {
    
    System.out.println("load=" + getClass());

    _app = this;

    RootPanel panel = RootPanel.get("content");

    _panel = new FlowPanel();

    panel.add(_panel);

    _contextManager.addContextListener(this);

    Context context = _contextManager.getContext();

    if (context == null)
      context = new ContextImpl();
    onContextChanged(context);
  }

#No. 3554
#File: E:\bishe\1\AbstractMultiPageApplication.java
#Comment:
  /*****************************************************************************
   * {@link ContextListener} Interface
   ****************************************************************************/

#Code:

  public void onContextChanged(Context context) {

    try {

      CommonLibraryMessages c = CommonLibraryMessages.MESSAGES;

      String pageKey = context.getParam(DEFAULT_PAGE_KEY);

      if (pageKey == null)
        pageKey = "index";

      IPageSource pageFactory = _pages.get(pageKey);

      if (pageFactory == null)
        throw new PageException(c.invalidPage(pageKey));

      if (_activePage == null || !_activePage.equals(pageKey) || _hadError) {
        _panel.clear();
        _hadError = false;
        _panel.add(pageFactory.create(context));
      } else {
        Widget widget = pageFactory.update(context);
        if (widget != null) {
          _hadError = false;
          _panel.clear();
          _panel.add(widget);
        }
      }

      _activePage = pageKey;

    } catch (PageException ex) {
      Window.alert("had exception");
      onException(ex);
    }
  }

#No. 3555
#File: E:\bishe\1\AbstractMultiPageApplication.java
#Comment:
  /*****************************************************************************
   * Private Methods
   ****************************************************************************/

#Code:

  protected void addPage(String key, IPageSource page) {
    _pages.put(key, page);
  }

#No. 3556
#File: E:\bishe\1\AbstractMultipartRequestParser.java
#Comment:
	/**
	 * Convenience method for common configuration of {@link FileUpload}.
	 * Can be called from {@link #parseRequest(FileItemFactory, long, long, String)} method
	 * that must be implemented by subclasses.
	 * @param upload
	 * @param singleFileSizeMax
	 * @param totalSizeMax
	 * @param defaultEncoding
	 */

#Code:
	protected void configureUpload(final FileUpload upload, long singleFileSizeMax, long totalSizeMax, String defaultEncoding) {
		// set overall request size constraint
		// maximum allowed size of a single uploaded file
		upload.setFileSizeMax(singleFileSizeMax);
		// maximum allowed size of the whole request
		upload.setSizeMax(totalSizeMax);
		if (defaultEncoding != null) {
			upload.setHeaderEncoding(defaultEncoding);
		}
	}

#No. 3557
#File: E:\bishe\1\AbstractMultipleJobCommand.java
#Comment:
    /**
     * Returns a list of projects for the given arguments.
     * 
     * @param projects the list to which the projects are added
     * @return a pair of Mode (single job, jobs from view or all) and view name -
     * where view name will be null if mode != VIEW
     */

#Code:
    Pair<Mode, String> getProjects(JBotSender sender, String[] args, Collection<AbstractProject<?, ?>> projects)
        throws CommandException {
        final Mode mode;
        String view = null;
        if (args.length >= 2) {
            if ("-v".equals(args[1])) {
                mode = Mode.VIEW;
                view = MessageHelper.getJoinedName(args, 2);
                getProjectsForView(projects, view);
            } else {
                mode = Mode.SINGLE;
                String jobName = MessageHelper.getJoinedName(args, 1);

                AbstractProject<?, ?> project = getJobProvider().getJobByNameOrDisplayName(jobName);
                if (project != null) {
                    projects.add(project);
                } else {
                    throw new CommandException(sender.getNickname() + ": " + UNKNOWN_JOB_STR + " " + jobName);
                }
            }
        } else if (args.length == 1) {
            mode = Mode.ALL;
            // don't show really all - could by quite many - but only the top-level jobs
            projects.addAll(getJobProvider().getTopLevelJobs());
        } else {
            throw new CommandException(sender + ": 'args' must not be empty!");
        }
        return Pair.create(mode, view);
    }

#No. 3558
#File: E:\bishe\1\AbstractMultipleValidityMatchTest.java
#Comment:
  /**
   * Test of procHeader method, of class AbstractMultipleValidityMatch.
   */

#Code:
  @Test
  public void testProcHeader()
  {
    System.out.println("procHeader");
  }

#No. 3559
#File: E:\bishe\1\AbstractMultipleValidityMatchTest.java
#Comment:
  /**
   * Test of procTrailer method, of class AbstractMultipleValidityMatch.
   */

#Code:
  @Test
  public void testProcTrailer()
  {
    System.out.println("procTrailer");
  }

#No. 3560
#File: E:\bishe\1\AbstractMultipleValidityMatchTest.java
#Comment:
   /**
    * Override the unused event handling routines.
    *
    * @param r input record
    * @return return record
    * @throws ProcessingException
    */

#Code:
    @Override
    public IRecord procValidRecord(IRecord r) throws ProcessingException
    {
      return r;
    }

#No. 3561
#File: E:\bishe\1\AbstractMultipleValidityMatchTest.java
#Comment:
   /**
    * Override the unused event handling routines.
    *
    * @param r input record
    * @return return record
    * @throws ProcessingException
    */

#Code:
    @Override
    public IRecord procErrorRecord(IRecord r) throws ProcessingException
    {
      return r;
    }

#No. 3562
#File: E:\bishe\1\AbstractMultipleValidityMatchTest.java
#Comment:
 /**
  * Method to get an instance of the implementation. Done this way to allow
  * tests to be executed individually.
  *
  * @throws InitializationException
  */

#Code:
  private void getInstance()
  {
    if (instance == null)
    {
      // Get an initialise the cache
      instance = new AbstractMultipleValidityMatchTest.AbstractMultipleValidityMatchImpl();
      
      try
      {
        // Get the instance
        instance.init("DBTestPipe", "AbstractMultipleValidityMatchTest");
      }
      catch (InitializationException ex)
      {
        Assert.fail();
      }

    }
    else
    {
      Assert.fail("Instance already allocated");
    }
  }

#No. 3563
#File: E:\bishe\1\AbstractMultipleValidityMatchTest.java
#Comment:
 /**
  * Method to release an instance of the implementation.
  */

#Code:
  private void releaseInstance()
  {
    instance = null;
  }

#No. 3564
#File: E:\bishe\1\AbstractMultiSpaceReplicaDataProducer.java
#Comment:
    /*public synchronized void close()
    {
        if (_closed)
            return;
        _closed = true;

        for (ISingleStageReplicaDataProducer<? extends IExecutableSpaceReplicaData> dataProducer : _dataProducers)
            dataProducer.close();

        onClose();
    }*/

#Code:

    /**
     * @return true if any thread is trying to close and the lease reaper thread is trying to close
     * at the same time.
     */
    public CloseStatus close(boolean forced) {
        if (!_closing.compareAndSet(false, true) && _engine.getLeaseManager().isCurrentLeaseReaperThread()) {
            return CloseStatus.CLOSING;
        }
        synchronized (this) {
            if (_closed)
                return CloseStatus.CLOSED;
            _closed = true;

            for (ISingleStageReplicaDataProducer<? extends IExecutableSpaceReplicaData> dataProducer : _dataProducers)
                dataProducer.close(forced);

            onClose();
        }
        _closing.set(false);
        return CloseStatus.CLOSED;
    }

#No. 3565
#File: E:\bishe\1\AbstractMultiTreadBatchTester.java
#Comment:
	/**
	 * can parse values like 200M ,200K,200M1(2000001)
	 * 
	 * @param val
	 * @return
	 */

#Code:
	private static long parseLong(String val) {
		val = val.toUpperCase();
		int indx = val.indexOf("M");

		int plus = 10000;
		if (indx < 0) {
			indx = val.indexOf("K");
			plus = 1000;
		}
		if (indx > 0) {
			String longVal = val.substring(0, indx);

			long theVale = Long.parseLong(longVal) * plus;
			String remain = val.substring(indx + 1);
			if (remain.length() > 0) {
				theVale += Integer.parseInt(remain);
			}
			return theVale;
		} else {
			return Long.parseLong(val);
		}

	}

#No. 3566
#File: E:\bishe\1\AbstractMutableInventory.java
#Comment:
    /**
     * The plugin container that created this {@link AbstractMutableInventory}.
     */

#Code:
    @Nullable private PluginContainer pluginContainer;

    @Nullable private final Inventory parent;
    @Nullable private Translation name;

    /**
     * All the {@link InventoryProperty}s of this inventory mapped by their type.
     */
    private final Multimap<Class<?>, InventoryProperty<?,?>> inventoryPropertiesByClass = HashMultimap.create();

    /**
     * All the {@link InventoryProperty}s of this inventory mapped by their key.
     */
    private final Map<InventoryPropertyKey, InventoryProperty<?,?>> inventoryPropertiesByKey = new HashMap<>();

    private final Set<ContainerViewListener> viewerListeners = new HashSet<>();

    public AbstractMutableInventory(@Nullable Inventory parent, @Nullable Translation name) {
        this.parent = parent;
        this.name = name;
    }

    void setName(@Nullable Translation name) {
        this.name = name;
    }

    void setPluginContainer(@Nullable PluginContainer pluginContainer) {
        this.pluginContainer = pluginContainer;
    }

    protected void finalizeContent() {
    }

#No. 3567
#File: E:\bishe\1\AbstractMutableInventory.java
#Comment:
    /**
     * Registers a {@link InventoryProperty} for this inventory.
     *
     * @param inventoryProperty The inventory property
     */

#Code:
    protected void registerProperty(InventoryProperty<?, ?> inventoryProperty) {
        checkNotNull(inventoryProperty, "inventoryProperty");
        this.inventoryPropertiesByClass.put(inventoryProperty.getClass(), inventoryProperty);
        final InventoryPropertyKey propertyKey = new InventoryPropertyKey(inventoryProperty.getClass(), inventoryProperty.getKey());
        this.inventoryPropertiesByKey.put(propertyKey, inventoryProperty);
    }

#No. 3568
#File: E:\bishe\1\AbstractMutationBatchImpl.java
#Comment:
	/**
	 * Checks whether the mutation object contains rows. While the map may
	 * contain row keys the row keys may not contain any mutations.
	 * 
	 * @return
	 */

#Code:
	@Override
	public boolean isEmpty() {
		return mutationMap.isEmpty();
	}

#No. 3569
#File: E:\bishe\1\AbstractMutationBatchImpl.java
#Comment:
	/**
	 * Generate a string representation of the mutation with the following
	 * syntax Key1: [cf1, cf2],  Key2: [cf1, cf3]
	 */

#Code:
	@Override
	public String toString() {
		StringBuilder sb = new StringBuilder();
		sb.append("MutationBatch[");
		boolean first = true;
		for (Entry<ByteBuffer, Map<String, ColumnListMutation<?>>> row : mutationMap.entrySet()) {
			if (!first)
				sb.append(",");
			sb.append(Hex.encodeHex(row.getKey().array()));
			sb.append(row.getValue().entrySet().toString());
		}
		sb.append("]");
		return sb.toString();
	}

#No. 3570
#File: E:\bishe\1\AbstractMutationReproductionOperator.java
#Comment:
    /**
     * Each Individual has only one parent.
     * @return 1 means that there is only one parent for new Individual
     */

#Code:
    public int getInputArity() {
        return 1;
    }

#No. 3571
#File: E:\bishe\1\AbstractMXBeanListener.java
#Comment:
    /**
     * Dummy listener. Does nothing.
     */

#Code:
    private static final NotificationListener DUMMY_LISTENER = new NotificationListener() {

        @Override
        public final void handleNotification(final Notification notification, final Object handback) {
            // No op
        }
    };

#No. 3572
#File: E:\bishe\1\AbstractMybatisBundle.java
#Comment:
    /**
     * Returns the {@link SqlSessionFactory} created by this bundle. Until {@link #run(DataSource,
     * io.dropwizard.setup.Environment)} completes, this will return <code>null</code>.
     * <p>
     * Care is needed when using this bundle in other bundles: this method will return null throughout the
     * <code>initialize</code> phase of Dropwizard's startup. It's generally better to pass this whole bundle to its
     * dependents, and let them obtain session factories at the appropriate time, than it is to take the session factory
     * from this bundle and pass it to other bundles. This awkwardness is inherent in MyBatis' design.
     *
     * @return the configured session factory for this bundle, or <code>null</code> if the bundle hasn't been started
     * yet.
     */

#Code:
    @Nullable
    public SqlSessionFactory getSqlSessionFactory() {
        return sqlSessionFactory;
    }

#No. 3573
#File: E:\bishe\1\AbstractMybatisBundle.java
#Comment:
    /**
     * Creates the bundle's MyBatis session factory and registers health checks.
     *
     * @param dataSource
     *         the data source to use for the Mybatis environment.
     * @param environment
     *         the Dropwizard environment being started.
     * @throws Exception
     *         if MyBatis setup fails for any reason. MyBatis exceptions will be thrown as-is.
     */

#Code:
    public void run(DataSource dataSource, io.dropwizard.setup.Environment environment) throws Exception {
        sqlSessionFactory = createSqlSessionFactory(dataSource);

        environment.healthChecks().register(getName(), new SqlSessionFactoryHealthCheck(sqlSessionFactory));
        environment.jersey().register(SqlSessionProvider.binder(sqlSessionFactory));
    }

#No. 3574
#File: E:\bishe\1\AbstractMysqlBinlogDataSource.java
#Comment:
    /**
     * 加载已经同步数据的位置,从该位置继续加载数据，防止重复
     *
     * @return BinlogAndOffsetSyncPoint
     *
     * @throws IOException
     * @throws NoSuchAlgorithmException
     */

#Code:
    protected BinlogAndOffsetSyncPoint getBinlogFileAndPosition()
            throws IOException, NoSuchAlgorithmException {
        checkRowFormat();
        SyncPoint eventPosition = getEventPositionFromThreadLocalCache();
        if (eventPosition != null) {
            getLogger().info("Get valid start position from JVM TheadLocal:{}",
                    eventPosition);
            return extender.extend(eventPosition, this);
        }
        eventPosition = disposeEventPosition.loadSyncPoint();
        if (eventPosition != null) {
            getLogger().info("Get valid start position from local file:{}",
                    eventPosition);
            return extender.extend(eventPosition, this);
        }
        eventPosition = getConfigureStartPosition();
        if (eventPosition != null) {
            getLogger().info("Get valid start position from configuration xml or properties file:{}",
                    eventPosition);
            return extender.extend(eventPosition, this);
        }
        eventPosition = getMasterCurrentEventPosition();
        getLogger().info("Get valid start position from MySQL query status result:{}.",
                eventPosition);
        return extender.extend(eventPosition, this);
    }

#No. 3575
#File: E:\bishe\1\AbstractMysqlBinlogDataSource.java
#Comment:
        /**
         * 针对MySQL Ares V5.1版本的逻辑，
         * 防止在不关心的增量下发时候，{@link AbstractProducer}内部会
         * 调用{@link AbstractProducer#endTrans(BaseLogEvent)}，
         * 来记录点，而一般点的都会wrap一个本地local存储的{@link net.neoremind.fountain.eventposition
         * .ReadonlyDisposeEventPosition}的delegate，但是threadlocal里面却记录了。
         * 导致切换数据源的时候这里会因此读取-1这个groupId的点。
         */

#Code:
        if (syncPoint instanceof BaiduGroupIdSyncPoint &&
                ((BaiduGroupIdSyncPoint) syncPoint).getGroupId().equals(BigInteger.valueOf(-1))) {
            return null;
        }

#No. 3576
#File: E:\bishe\1\AbstractMysqlBinlogDataSource.java
#Comment:
    /**
     * 检查mysql binlog的格式,用于原生的row base bin log
     *
     * @throws IOException
     */

#Code:
    protected void checkRowFormat() throws IOException {
        ResultSetPacket resultSetPacket =
                query("show variables like 'binlog_format';");
        if (resultSetPacket == null) {
            throw new IOException("Can not query mysql binlog format");
        }

        List<RowValuePacket> rowValueList = resultSetPacket.getRowValueList();
        if (CollectionUtils.isEmpty(rowValueList) || rowValueList.size() != 1) {
            throw new DataErrorException("Query binlog format error");
        }

        RowValuePacket rowPacket = rowValueList.get(0);
        if (rowPacket == null
                || CollectionUtils.isEmpty(rowPacket.getFieldValueList())
                || rowPacket.getFieldValueList().size() != 2) {
            throw new DataErrorException("Query binlog format error");
        }

        boolean isRow =
                MysqlCommonConstants.RowFormat.BINLOG_FORMAT_ROW.getValue()
                        .equalsIgnoreCase(rowPacket.getFieldValueList().get(1));
        ;
        if (!isRow) {
            throw new DataErrorException(
                    "Mysql binlog format is not row-based!");
        }
    }

#No. 3577
#File: E:\bishe\1\AbstractMysqlDataSource.java
#Comment:
    /**
     * 安全的关闭socket连接，使用apache commons io组件实现
     *
     * @param socket
     */

#Code:
    protected void closeSocket(Socket socket) {
        if (socket != null) {
            logClose(socket);
            IOUtils.closeQuietly(socket);
        }
    }

#No. 3578
#File: E:\bishe\1\AbstractMysqlDataSource.java
#Comment:
    /**
     * 打印当前mysql的信息
     *
     * @throws IOException
     */

#Code:
    protected void printMysqlInfo() throws IOException {
        getLogger().info("----- print mysql info ");
        getLogger().info(conf.toString());
    }

#No. 3579
#File: E:\bishe\1\AbstractMysqlDataSource.java
#Comment:
    /**
     * 创建一个新的socket连接，完成mysql握手和权限验证，并且后续建立network stream，后续使用
     *
     * @return 和服务端的Socket连接
     *
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws TimeoutException
     */

#Code:
    protected Socket getNewSocket() throws IOException, NoSuchAlgorithmException, TimeoutException {
        // 发起连接
        Socket socket = new Socket();
        socket.setKeepAlive(true);
        socket.setReuseAddress(true);
        socket.setSoTimeout(conf.getSoTimeout());
        socket.setTcpNoDelay(true);
        socket.setReceiveBufferSize(conf.getReceiveBufferSize());
        socket.setSendBufferSize(conf.getSendBufferSize());

        InetSocketAddress address = new InetSocketAddress(conf.getMysqlServer(), conf.getMysqlPort());
        try {
            socket.connect(address, conf.getConnectTimeout());
        } catch (SocketTimeoutException e) {
            IOUtils.closeQuietly(socket);
            throw e;
        } catch (IOException e) {
            IOUtils.closeQuietly(socket);
            throw e;
        }

        // 连接到mysql
        HandshakePacket handshakePacket = handshake(socket);

        // 进行身份验证
        clientAuthorise(socket, handshakePacket);

        return socket;
    }

#No. 3580
#File: E:\bishe\1\AbstractMysqlDataSource.java
#Comment:
    /**
     * 封装mysql query text协议，实现update语句的执行
     *
     * @param socket
     * @param query
     *
     * @return
     *
     * @throws IOException
     */

#Code:
    protected OKPacket update(Socket socket, String query) throws IOException {

        if (socket == null || query == null) {
            throw new DataSourceInvalidException("dataSource is not open or query is null");
        }

        byte[] data = sendRequestAndGetResponse(socket, query);

        OKPacket packet = new OKPacket();
        packet.fromBytes(data);

        return packet;
    }

#No. 3581
#File: E:\bishe\1\AbstractMysqlDataSource.java
#Comment:
    /**
     * 对新构建的mysql 连接设置配置信息：
     * <ul>
     * <li>wait_timeout</li>
     * <li>net_write_timeout</li>
     * <li>net_read_timeout</li>
     * <li>charset</li>
     * </ul>
     *
     * @param socket
     *
     * @return
     *
     * @throws IOException
     */

#Code:
    protected Socket updateSettings(Socket socket) throws IOException {
        getLogger().debug("update MySQL socket params...");
        try {
            getLogger().debug("set wait_timeout = " + conf.getWaitTimeout());
            update(socket, "set wait_timeout=" + conf.getWaitTimeout());
        } catch (Exception e) {
            getLogger().warn(null, e);
        }
        try {
            getLogger().debug("set net_write_timeout = " + conf.getNetWriteTimeout());
            update(socket, "set net_write_timeout=" + conf.getNetWriteTimeout());
        } catch (Exception e) {
            getLogger().warn(null, e);
        }

        try {
            getLogger().debug("set net_read_timeout = " + conf.getNetReadTimeout());
            update(socket, "set net_read_timeout=" + conf.getNetReadTimeout());
        } catch (Exception e) {
            getLogger().warn(null, e);
        }

        try {
            // 设置服务端返回结果时不做编码转化，直接按照数据库的二进制编码进行发送，由客户端自己根据需求进行编码转化
            getLogger().debug("set charset = " + conf.getCharset());
            update(socket, "set names '" + conf.getCharset() + "'");
        } catch (Exception e) {
            getLogger().warn(null, e);
        }
        return socket;
    }

#No. 3582
#File: E:\bishe\1\AbstractMysqlDataSource.java
#Comment:
    /**
     * 记录关闭socket的日志
     *
     * @param socket
     */

#Code:
    private void logClose(Socket socket) {
        StringBuffer sb =
                new StringBuffer("Close MySQL datasource, [ip, port] is [").append(socket.getInetAddress())
                        .append(", ").append(socket.getPort()).append("].");
        getLogger().info(sb.toString());
    }

#No. 3583
#File: E:\bishe\1\AbstractMysqlDataSource.java
#Comment:
    /**
     * 完成mysql连接的握手协议
     *
     * @param socket
     *
     * @return
     *
     * @throws IOException
     */

#Code:
    private HandshakePacket handshake(Socket socket) throws IOException {

        // 接受欢迎信息
        byte[] data = SocketHelper.getBuffer(socket, 4);
        PacketHeader header = ProtocolHelper.getProtocolHeader(data);

        data = SocketHelper.getBuffer(socket, header.getPacketLength());
        if (data == null || data.length <= 0) {
            throw new DataErrorException("data is null or empty");
        }
        if (data[0] == -1 || data[0] == -2) {
            ErrorPacket errorPacket = new ErrorPacket();
            errorPacket.fromBytes(data);
            throw new DataErrorException(
                    "Receive Error Packet! first byte is " + data[0] + ", detail is " + errorPacket.toString());
        }

        HandshakePacket handshakePacket = new HandshakePacket();
        handshakePacket.fromBytes(data);

        return handshakePacket;
    }

#No. 3584
#File: E:\bishe\1\AbstractMysqlDataSource.java
#Comment:
    /**
     * 实现mysql的权限验证协议
     *
     * @param socket
     * @param handshakePacket
     *
     * @throws IOException
     * @throws NoSuchAlgorithmException
     */

#Code:
    private void clientAuthorise(Socket socket, HandshakePacket handshakePacket) throws IOException,
            NoSuchAlgorithmException {
        // 发送验证信息
        ClientAuthPacket clientAuthPacket = new ClientAuthPacket();
        clientAuthPacket.setUsername(conf.getUserName());
        clientAuthPacket.setPassword(conf.getPassword());
        clientAuthPacket.setDatabaseName(conf.getDatabaseName());
        clientAuthPacket.setCharsetNumber(MysqlCommonConstants.CLIENT_CHARSET_NUMBER);
        clientAuthPacket.setScrumbleBuff(handshakePacket.getScrambleBuff());

        byte[] clientAuthPacketBody = clientAuthPacket.toBytes();
        PacketHeader header = new PacketHeader();
        header.setPacketLength(clientAuthPacketBody.length);
        header.setPacketNumber((byte) (header.getPacketNumber() + 1));

        SocketHelper.writeByte(socket, header.toBytes());
        SocketHelper.writeByte(socket, clientAuthPacketBody);

        // 接受验证通过信息
        byte[] data = SocketHelper.getBuffer(socket, 4);
        header = ProtocolHelper.getProtocolHeader(data);
        data = SocketHelper.getBuffer(socket, header.getPacketLength());
        if ((data[0] & 0xff) == 0xff) {
            ErrorPacket errorPacket = new ErrorPacket();
            errorPacket.fromBytes(data);
            throw new IOException("Error When doing Client Authentication:" + errorPacket.getErrorCode() + ", "
                    + errorPacket.getMessage());
        } else if ((data[0] & 0xff) == 0xfe) {
            EOFPacket eof = new EOFPacket();
            eof.fromBytes(data);
            throw new IOException("Eof When doing Client Authentication:" + eof.getEofFlag());
        }

    }

#No. 3585
#File: E:\bishe\1\AbstractMysqlDataSource.java
#Comment:
    /**
     * 使用文本协议<a href="http://dev.mysql.com/doc/internals/en/text-protocol.html">Text
     * Protocol</a>中的<a href="http://dev.mysql.com/doc/internals/en/com-query
     * .html">COM_QUERY</a>进行堵塞模式下发生mysql请求并读取返回信息。
     * <p/>
     * Payload如下：
     * <pre>
     * 1              [03] COM_QUERY
     * string[EOF]    the query the server shall execute
     * </pre>
     * 返回的信息是返回Packet的Payload字节数组
     *
     * @param socket query socket stream
     * @param query  query sql语句
     *
     * @return Packet的Payload字节数组，可能是{@link OKPacket}或者ResultSet，详细参考<a href="http://dev.mysql
     * .com/doc/internals/en/com-query-response.html#packet-COM_QUERY_Response">packet-COM_QUERY_Response</a>
     *
     * @throws IOException 当返回的Packet Payload第一个字节小于0x00，则有可能是{@link ErrorPacket}
     */

#Code:
    private byte[] sendRequestAndGetResponse(Socket socket, String query) throws IOException {

        // 构造查询
        QueryCommandPacket queryPacket = new QueryCommandPacket();
        queryPacket.setSql(query);

        // 发送请求
        byte[] queryPacketBody = queryPacket.toBytes();
        PacketHeader header = new PacketHeader();
        header.setPacketLength(queryPacketBody.length);
        header.setPacketNumber((byte) 0);

        SocketHelper.writeByte(socket, header.toBytes());
        SocketHelper.writeByte(socket, queryPacketBody);

        // 接受结果
        byte[] data = readPacket(socket);
        if (data[0] < 0) {
            ErrorPacket errorPacket = new ErrorPacket();
            errorPacket.fromBytes(data);
            throw new IOException("error when execute sql of [" + query + "], error code is :"
                    + errorPacket.getErrorCode() + ", " + errorPacket.getMessage());
        }

        return data;
    }

#No. 3586
#File: E:\bishe\1\AbstractMysqlDataSource.java
#Comment:
    /**
     * 从msyql连接中读取信息
     *
     * @param socket
     *
     * @return
     *
     * @throws IOException
     */

#Code:
    private byte[] readPacket(Socket socket) throws IOException {
        byte[] data = SocketHelper.getBuffer(socket, 4);
        PacketHeader header = ProtocolHelper.getProtocolHeader(data);
        data = SocketHelper.getBuffer(socket, header.getPacketLength());
        return data;
    }

#No. 3587
#File: E:\bishe\1\AbstractMysqlDataSource.java
#Comment:
    /**
     * 从mysql连接中读取Eof信息
     *
     * @param socket
     *
     * @throws IOException
     */

#Code:
    private void readEofPacket(Socket socket) throws IOException {
        byte[] eofBody = readPacket(socket);
        if (eofBody[0] != -2) {
            throw new IOException("EOF Packet is expected, but packet with field_count=" + eofBody[0] + " is found.");
        }
    }

#No. 3588
#File: E:\bishe\1\AbstractNaiveBayes.java
#Comment:
    /**
     * This executor is used for the parallel processing of streams with custom 
     * Thread pool.
     */

#Code:
    protected final ForkJoinStream streamExecutor;
    
    /** {@inheritDoc} */
    @Override
    public boolean isParallelized() {
        return parallelized;
    }

#No. 3589
#File: E:\bishe\1\AbstractNaiveBayes.java
#Comment:
        /*
            Implementation note:
            The code below uses the metadata from the Dataframe to avoid looping through all the data. 
            This means that if the metadata are stale (contain more columns than the actual data due to 
            updates/removes) we will initialize more parameters here. Nevertheless this should not have 
            any effects on the results of the algorithm since the scores will be the same in all classes
            and it will be taken care by the normalization.
        */

#Code:
        streamExecutor.forEach(StreamMethods.stream(trainingData.getXDataTypes().keySet().stream(), isParallelized()), feature -> {
            for(Object theClass : classesSet) {
                List<Object> featureClassTuple = Arrays.asList(feature, theClass);
                logLikelihoods.put(featureClassTuple, 0.0); //the key is unique across threads and the map is concurrent
            }
        });

#No. 3590
#File: E:\bishe\1\AbstractNamer.java
#Comment:
    /**
     * ex: com.jaxio.toto.tutu ==> getPackageNode(0) = tutu ==> getPackageNode(1) = toto etc.. note: useful on evdev project.
     */

#Code:
    String[] packageNodes;

    /**
     * Get node of the package name.
     * <p>
     * Ex: Assuming the package name is<code>com.jaxio.toto.tutu</code> you get <br>
     * <code>getPackageNode(0) -&gt; tutu</code> <br>
     * <code>getPackageNode(1) = toto</code> etc.
     */
    public String getPackageNode(int index) {
        if (packageNodes == null) {
            packageNodes = StringUtils.split(getPackageName(), '.');
        }

        int i = packageNodes.length - 1 - index;
        if (i >= 0 && i < packageNodes.length) {
            return packageNodes[i];
        }
        return "";
    }

#No. 3591
#File: E:\bishe\1\AbstractNamer.java
#Comment:
    /**
     * Same as {@link #getPackageNode} with the first character upper cased.
     */

#Code:
    public String getPackageNodeUp(int index) {
        return getFirstCharacterUppered(getPackageNode(index));
    }

#No. 3592
#File: E:\bishe\1\AbstractNamer.java
#Comment:
    /**
     * return the concatenation of #{@link #getType} + <code>"Test"</code>.
     */

#Code:
    public String getTestType() {
        return getType() + "Test";
    }

#No. 3593
#File: E:\bishe\1\AbstractNameResolver.java
#Comment:
    /**
     * @return the the IP of the resolver
     */

#Code:
    public String getResolver() {
        return resolver;
    }

#No. 3594
#File: E:\bishe\1\AbstractNameResolver.java
#Comment:
    /**
     * @param resolver The IP of the resolver
     */

#Code:
    public void setResolver(String resolver) {
        this.resolver = resolver;
    }

#No. 3595
#File: E:\bishe\1\AbstractNamespacesStore.java
#Comment:
	/**
	 * Adds a given policy to a given map. It is assumed that the map is indexed by issuer hash
	 * and the value maps are indexed by issuer id.
	 * This method is useful only for stores which keep all their namespaces in memory.
	 * @param policy policy to add
	 * @param policies policy map to add to
	 */

#Code:
	protected void addPolicy(NamespacePolicy policy, Map<String, Map<String, List<NamespacePolicy>>> policies)
	{
		String definedFor = policy.getDefinedFor();
		Map<String, List<NamespacePolicy>> current = policies.get(definedFor);
		if (current == null)
		{
			current = new HashMap<String, List<NamespacePolicy>>();
			policies.put(definedFor, current);
		}
		
		addPolicyToMap(policy, current);
	}

#No. 3596
#File: E:\bishe\1\AbstractNamespacesStore.java
#Comment:
	/**
	 * Adds policy to a map indexed by a policy issuer.
	 * @param policy policy to add
	 * @param map policy map to add to
	 */

#Code:
	protected void addPolicyToMap(NamespacePolicy policy, Map<String, List<NamespacePolicy>> map)
	{
		String issuer = policy.getIssuer();
		List<NamespacePolicy> currentList = map.get(issuer);
		if (currentList == null)
		{
			currentList = new ArrayList<NamespacePolicy>();
			map.put(issuer, currentList);
		}

		currentList.add(policy);
	}

#No. 3597
#File: E:\bishe\1\AbstractNamespacesStore.java
#Comment:
	/**
	 * Utility method useful for lazy stores. Retrieves a cached policies for the given ca hash and issuer. 
	 * If there is no policy in the cache then it is tried to load one from disk. The 
	 * loaded policy is cached before being returned. 
	 * @param policies policies
	 * @param definedForHash defined for hash
	 * @param issuer issuer
	 * @param path path
	 * @param maxTTL max TTL
	 * @return cached policies
	 */

#Code:
	protected List<NamespacePolicy> getCachedPolicies(Map<String, CachedElement<Map<String, List<NamespacePolicy>>>> policies,
			String definedForHash, String issuer, String path, long maxTTL)
	{
		CachedElement<Map<String, List<NamespacePolicy>>> cachedEntry = policies.get(definedForHash);
		if (cachedEntry != null && !cachedEntry.isExpired(maxTTL))
		{
			Map<String, List<NamespacePolicy>> policiesMap = cachedEntry.getElement();
			return policiesMap.get(issuer);
		}
		List<NamespacePolicy> loaded = tryLoadNsPath(path);
		if (loaded != null)
		{
			Map<String, List<NamespacePolicy>> current = new HashMap<String, List<NamespacePolicy>>();
			for (NamespacePolicy policy: loaded)
				addPolicyToMap(policy, current);
			policies.put(definedForHash, new CachedElement<Map<String,List<NamespacePolicy>>>(current));
		}
		return loaded;
	}

#No. 3598
#File: E:\bishe\1\AbstractNativeBinaryBuildDelegate.java
#Comment:
	/**
	 * Returns the build artifact that was last build by calling
	 * {@link #buildNow(IProgressMonitor)} method. 
	 * Will return null if the build is not yet complete or 
	 * {@link #buildNow(IProgressMonitor)} is not called yet for this instance.
	 * @return
	 */

#Code:
	public File getBuildArtifact() {
		return buildArtifact;
	}

#No. 3599
#File: E:\bishe\1\AbstractNavigatorModel.java
#Comment:
	/**
	 *  note: this has the unfortunate effect of clearing the array under some
	 *  circumstances therefore this method is private.
	 */

#Code:
	private void ensureCapacity()
	{
		int size = 0;
		for (Object o = navigator.first(); o != null; o = navigator.next())
			size++;
		
		rows = size != rows.length ? new Object[size] : rows;
	}

#No. 3600
#File: E:\bishe\1\AbstractNCSARequestLog.java
#Comment:
  /**
   * Write requestEntry out. (to disk or slf4j log)
   */

#Code:
  public abstract void write(String requestEntry) throws IOException;

    /* ------------------------------------------------------------ */

  private void append(StringBuilder buf,String s)
  {
    if (s==null || s.length()==0)
      buf.append('-');
    else
      buf.append(s);
  }

#No. 3601
#File: E:\bishe\1\AbstractNCSARequestLog.java
#Comment:
  /**
   * Writes extended request and response information to the output stream.
   *
   * @param request  request object
   * @param b        StringBuilder to write to
   * @throws IOException
   */

#Code:
  protected void logExtended(Request request,
                             StringBuilder b) throws IOException
  {
    String referer = request.getHeader(HttpHeader.REFERER.toString());
    if (referer == null)
      b.append("\"-\" ");
    else
    {
      b.append('"');
      b.append(referer);
      b.append("\" ");
    }

    String agent = request.getHeader(HttpHeader.USER_AGENT.toString());
    if (agent == null)
      b.append("\"-\" ");
    else
    {
      b.append('"');
      b.append(agent);
      b.append('"');
    }
  }

#No. 3602
#File: E:\bishe\1\AbstractNCSARequestLog.java
#Comment:
  /**
   * Set request paths that will not be logged.
   *
   * @param ignorePaths array of request paths
   */

#Code:
  public void setIgnorePaths(String[] ignorePaths)
  {
    _ignorePaths = ignorePaths;
  }

#No. 3603
#File: E:\bishe\1\AbstractNCSARequestLog.java
#Comment:
  /**
   * Retrieve the request paths that will not be logged.
   *
   * @return array of request paths
   */

#Code:
  public String[] getIgnorePaths()
  {
    return _ignorePaths;
  }

#No. 3604
#File: E:\bishe\1\AbstractNCSARequestLog.java
#Comment:
  /**
   * Controls logging of the request cookies.
   *
   * @param logCookies true - values of request cookies will be logged, false - values of request cookies will not be
   *                   logged
   */

#Code:
  public void setLogCookies(boolean logCookies)
  {
    _logCookies = logCookies;
  }

#No. 3605
#File: E:\bishe\1\AbstractNCSARequestLog.java
#Comment:
  /**
   * Retrieve log cookies flag
   *
   * @return value of the flag
   */

#Code:
  public boolean getLogCookies()
  {
    return _logCookies;
  }

#No. 3606
#File: E:\bishe\1\AbstractNCSARequestLog.java
#Comment:
  /**
   * Controls logging of the request hostname.
   *
   * @param logServer true - request hostname will be logged, false - request hostname will not be logged
   */

#Code:
  public void setLogServer(boolean logServer)
  {
    _logServer = logServer;
  }

#No. 3607
#File: E:\bishe\1\AbstractNCSARequestLog.java
#Comment:
  /**
   * Retrieve log hostname flag.
   *
   * @return value of the flag
   */

#Code:
  public boolean getLogServer()
  {
    return _logServer;
  }

#No. 3608
#File: E:\bishe\1\AbstractNCSARequestLog.java
#Comment:
  /**
   * Controls logging of request processing time.
   *
   * @param logLatency true - request processing time will be logged false - request processing time will not be
   *                   logged
   */

#Code:
  public void setLogLatency(boolean logLatency)
  {
    _logLatency = logLatency;
  }

#No. 3609
#File: E:\bishe\1\AbstractNCSARequestLog.java
#Comment:
  /**
   * Retrieve log request processing time flag.
   *
   * @return value of the flag
   */

#Code:
  public boolean getLogLatency()
  {
    return _logLatency;
  }

#No. 3610
#File: E:\bishe\1\AbstractNCSARequestLog.java
#Comment:
  /**
   * @deprecated use {@link StatisticsHandler}
   */

#Code:
  public void setLogDispatch(boolean value)
  {
  }

#No. 3611
#File: E:\bishe\1\AbstractNCSARequestLog.java
#Comment:
  /**
   * @deprecated use {@link StatisticsHandler}
   */

#Code:
  public boolean isLogDispatch()
  {
    return false;
  }

#No. 3612
#File: E:\bishe\1\AbstractNCSARequestLog.java
#Comment:
  /**
   * Controls whether the actual IP address of the connection or the IP address from the X-Forwarded-For header will
   * be logged.
   *
   * @param preferProxiedForAddress true - IP address from header will be logged, false - IP address from the
   *                                connection will be logged
   */

#Code:
  public void setPreferProxiedForAddress(boolean preferProxiedForAddress)
  {
    _preferProxiedForAddress = preferProxiedForAddress;
  }

#No. 3613
#File: E:\bishe\1\AbstractNCSARequestLog.java
#Comment:
  /**
   * Retrieved log X-Forwarded-For IP address flag.
   *
   * @return value of the flag
   */

#Code:
  public boolean getPreferProxiedForAddress()
  {
    return _preferProxiedForAddress;
  }

#No. 3614
#File: E:\bishe\1\AbstractNCSARequestLog.java
#Comment:
  /**
   * Set the extended request log format flag.
   *
   * @param extended true - log the extended request information, false - do not log the extended request information
   */

#Code:
  public void setExtended(boolean extended)
  {
    _extended = extended;
  }

#No. 3615
#File: E:\bishe\1\AbstractNCSARequestLog.java
#Comment:
  /**
   * Retrieve the extended request log format flag.
   *
   * @return value of the flag
   */

#Code:
  public boolean isExtended()
  {
    return _extended;
  }

#No. 3616
#File: E:\bishe\1\AbstractNCSARequestLog.java
#Comment:
  /**
   * Set up request logging and open log file.
   *
   * @see org.eclipse.jetty.util.component.AbstractLifeCycle#doStart()
   */

#Code:
  @Override
  protected synchronized void doStart() throws Exception
  {
    if (_logDateFormat != null)
    {
      // FIXME _logTimeZone should be used for DateCache but Jetty 8's implementation doesn't support it
      _logDateCache = new DateCache(_logDateFormat, _logLocale);
    }

    if (_ignorePaths != null && _ignorePaths.length > 0)
    {
      _ignorePathMap = new PathMap();
      for (int i = 0; i < _ignorePaths.length; i++)
        _ignorePathMap.put(_ignorePaths[i], _ignorePaths[i]);
    }
    else
      _ignorePathMap = null;

    super.doStart();
  }

#No. 3617
#File: E:\bishe\1\AbstractNCSARequestLog.java
#Comment:
  /**
   * Set the timestamp format for request log entries in the file. If this is not set, the pre-formated request
   * timestamp is used.
   *
   * @param format timestamp format string
   */

#Code:
  public void setLogDateFormat(String format)
  {
    _logDateFormat = format;
  }

#No. 3618
#File: E:\bishe\1\AbstractNCSARequestLog.java
#Comment:
  /**
   * Retrieve the timestamp format string for request log entries.
   *
   * @return timestamp format string.
   */

#Code:
  public String getLogDateFormat()
  {
    return _logDateFormat;
  }

#No. 3619
#File: E:\bishe\1\AbstractNCSARequestLog.java
#Comment:
  /**
   * Set the locale of the request log.
   *
   * @param logLocale locale object
   */

#Code:
  public void setLogLocale(Locale logLocale)
  {
    _logLocale = logLocale;
  }

#No. 3620
#File: E:\bishe\1\AbstractNCSARequestLog.java
#Comment:
  /**
   * Retrieve the locale of the request log.
   *
   * @return locale object
   */

#Code:
  public Locale getLogLocale()
  {
    return _logLocale;
  }

#No. 3621
#File: E:\bishe\1\AbstractNCSARequestLog.java
#Comment:
  /**
   * Set the timezone of the request log.
   *
   * @param tz timezone string
   */

#Code:
  public void setLogTimeZone(String tz)
  {
    _logTimeZone = tz;
  }

#No. 3622
#File: E:\bishe\1\AbstractNCSARequestLog.java
#Comment:
  /**
   * Retrieve the timezone of the request log.
   *
   * @return timezone string
   */

#Code:
  public String getLogTimeZone()
  {
    return _logTimeZone;
  }

#No. 3623
#File: E:\bishe\1\AbstractNeo4jDatastore.java
#Comment:
    /**
     * Ensures that an index exists for the given entity and property.
     *
     * @param entityTypeMetadata
     *            The entity.
     * @param indexedProperty
     *            The index metadata.
     */

#Code:
    private void ensureIndex(DS session, EntityTypeMetadata<NodeMetadata<L>> entityTypeMetadata,
            IndexedPropertyMethodMetadata<IndexedPropertyMetadata> indexedProperty) {
        if (indexedProperty != null) {
            IndexedPropertyMetadata datastoreMetadata = indexedProperty.getDatastoreMetadata();
            if (datastoreMetadata.isCreate()) {
                L label = entityTypeMetadata.getDatastoreMetadata().getDiscriminator();
                PrimitivePropertyMethodMetadata<PropertyMetadata> propertyMethodMetadata = indexedProperty.getPropertyMethodMetadata();
                if (label != null && propertyMethodMetadata != null) {
                    ensureIndex(session, label, propertyMethodMetadata, datastoreMetadata.isUnique());
                }
            }
        }
    }

#No. 3624
#File: E:\bishe\1\AbstractNestedChangeListenerBuilderTest.java
#Comment:
	/**
	 * Tests whether the builder can be created with a null {@link Nesting}.
	 */

#Code:
	@Test(expected = NullPointerException.class)
	public void testCreationWithNullNesting() {
		NestedChangeListenerBuilder.forNesting(null);
	}

#No. 3625
#File: E:\bishe\1\AbstractNestedChangeListenerBuilderTest.java
#Comment:
	/**
	 * Tests whether the builder accepts null as a listener.
	 */

#Code:
	@Test(expected = NullPointerException.class)
	public void testUsingNullListener() {
		builder.withListener(null);
	}

#No. 3626
#File: E:\bishe\1\AbstractNestedChangeListenerBuilderTest.java
#Comment:
	/**
	 * Tests whether building creates an instance.
	 */

#Code:
	@Test
	public void testBuildCreatesInstance() {
		NestedChangeListenerHandle<String> listener = builder
				.withListener((observable, oldValue, newValue) -> {/* don't do anything */})
				.buildAttached();

		assertNotNull(listener);
	}

#No. 3627
#File: E:\bishe\1\AbstractNestedChangeListenerBuilderTest.java
#Comment:
	/**
	 * Tests whether building more than once throws an exceptions.
	 */

#Code:
	@Test(expected = IllegalStateException.class)
	public void testBuildSeveralInstances() {
		NestedChangeListenerBuilder<String, Property<String>>.Buildable buildable =
				builder.withListener((observable, oldValue, newValue) -> {/* don't do anything */});

		// first build must work (see other tests)
		buildable.buildAttached();

		// second build must fail
		buildable.buildAttached();
	}

#No. 3628
#File: E:\bishe\1\AbstractNestedChangeListenerHandleTest.java
#Comment:
	/**
	 * Tests whether the properties the tested nested listener owns have the correct bean.
	 */

#Code:
	@Test
	public void testPropertyBean() {
		nestedListenerHandle = createDetachedNestedListenerHandle(nesting, listener);
		assertSame(nestedListenerHandle, nestedListenerHandle.innerObservablePresentProperty().getBean());
	}

#No. 3629
#File: E:\bishe\1\AbstractNestedChangeListenerHandleTest.java
#Comment:
	/**
	 * Tests whether the {@link #nestedListenerHandle} correctly reports whether the inner observable is present.
	 */

#Code:
	@Test
	public void testObservablePresentAfterConstruction() {
		nestedListenerHandle = createDetachedNestedListenerHandle(nesting, listener);
		assertTrue(nestedListenerHandle.isInnerObservablePresent());
	}

#No. 3630
#File: E:\bishe\1\AbstractNestedChangeListenerHandleTest.java
#Comment:
	/**
	 * Tests whether the construction does not call the {@link #listener}.
	 */

#Code:
	@Test
	public void testNoInteractionWithListenerDuringConstruction() {
		nestedListenerHandle = createDetachedNestedListenerHandle(nesting, listenerWhichFailsWhenCalled);
		nestedListenerHandle = createAttachedNestedListenerHandle(nesting, listenerWhichFailsWhenCalled);
	}

#No. 3631
#File: E:\bishe\1\AbstractNestedChangeListenerHandleTest.java
#Comment:
	/**
	 * Tests whether no listener invocation occurs when the nesting's observable changes its value and the listener is
	 * initially detached.
	 */

#Code:
	@Test
	public void testChangingValueWhenInitiallyDetached() {
		nestedListenerHandle = createDetachedNestedListenerHandle(nesting, listenerWhichFailsWhenCalled);
		innerObservable.set("new value");
	}

#No. 3632
#File: E:\bishe\1\AbstractNestedChangeListenerHandleTest.java
#Comment:
	/**
	 * Tests whether the listener is correctly invoked when the nesting's observable changes its value.
	 */

#Code:
	@Test
	public void testChangingValue() {
		nestedListenerHandle = createAttachedNestedListenerHandle(nesting, listener);
		innerObservable.set("new value");

		// assert that 'changed' was called once and with the right arguments
		verify(listener, times(1)).changed(innerObservable, "initial value", "new value");
		verifyNoMoreInteractions(listener);
	}

#No. 3633
#File: E:\bishe\1\AbstractNestedChangeListenerHandleTest.java
#Comment:
	/**
	 * Tests whether no listener invocation occurs when the nesting's inner observable is changed.
	 */

#Code:
	@Test
	public void testChangingObservable() {
		nestedListenerHandle = createAttachedNestedListenerHandle(nesting, listenerWhichFailsWhenCalled);
		StringProperty newObservable = new SimpleStringProperty("new observable's initial value");
		setNestingObservable(nesting, newObservable);

		assertTrue(nestedListenerHandle.isInnerObservablePresent());
	}

#No. 3634
#File: E:\bishe\1\AbstractNestedChangeListenerHandleTest.java
#Comment:
	/**
	 * Tests whether no listener invocation occurs when the nesting's inner observable is changed to null.
	 */

#Code:
	@Test
	public void testChangingObservableToNull() {
		nestedListenerHandle = createAttachedNestedListenerHandle(nesting, listenerWhichFailsWhenCalled);
		setNestingObservable(nesting, null);

		assertFalse(nestedListenerHandle.isInnerObservablePresent());
	}

#No. 3635
#File: E:\bishe\1\AbstractNestedChangeListenerHandleTest.java
#Comment:
	/**
	 * Tests whether the listener is correctly invoked when the nesting's new observable gets a new value.
	 */

#Code:
	@Test
	public void testChangingNewObservablesValue() {
		nestedListenerHandle = createAttachedNestedListenerHandle(nesting, listener);
		// set a new observable ...
		StringProperty newObservable = new SimpleStringProperty("new observable's initial value");
		setNestingObservable(nesting, newObservable);
		// (assert that setting the observable worked)
		assertEquals(newObservable, getNestingObservable(nesting));

		// ... and change its value
		newObservable.setValue("new observable's new value");

		// assert that the listener was invoked once and with the new observable's old and new value
		verify(listener, times(1)).changed(newObservable,
				"new observable's initial value", "new observable's new value");
		verifyNoMoreInteractions(listener);
	}

#No. 3636
#File: E:\bishe\1\AbstractNestedChangeListenerHandleTest.java
#Comment:
	/**
	 * Tests whether the listener is not invoked when the nesting's old observable gets a new value.
	 */

#Code:
	@Test
	public void testChangingOldObservablesValue() {
		nestedListenerHandle = createAttachedNestedListenerHandle(nesting, listenerWhichFailsWhenCalled);
		// set a new observable ...
		StringProperty newObservable = new SimpleStringProperty("new observable's initial value");
		setNestingObservable(nesting, newObservable);
		// (assert that setting the observable worked)
		assertEquals(newObservable, getNestingObservable(nesting));

		// ... and change the old observable's value
		innerObservable.setValue("intial observable's new value");
	}

#No. 3637
#File: E:\bishe\1\AbstractNestedChangeListenerHandleTest.java
#Comment:
	/**
	 * Tests whether no listener invocation occurs when the nesting's inner observable's value is changed after the
	 * listener was detached.
	 */

#Code:
	@Test
	public void testDetach() {
		nestedListenerHandle = createAttachedNestedListenerHandle(nesting, listenerWhichFailsWhenCalled);
		nestedListenerHandle.detach();

		innerObservable.set("new value while detached");
	}

#No. 3638
#File: E:\bishe\1\AbstractNestedChangeListenerHandleTest.java
#Comment:
	/**
	 * Tests whether the listener ignores values after it was detached repeatedly.
	 */

#Code:
	@Test
	public void testMultipleDetach() {
		nestedListenerHandle = createAttachedNestedListenerHandle(nesting, listenerWhichFailsWhenCalled);
		nestedListenerHandle.detach();
		nestedListenerHandle.detach();
		nestedListenerHandle.detach();

		innerObservable.set("new value while detached");
	}

#No. 3639
#File: E:\bishe\1\AbstractNestedChangeListenerHandleTest.java
#Comment:
	/**
	 * Tests whether the listener is correctly invoked when the nesting's observable changes its value after the
	 * listener was detached and reattached.
	 */

#Code:
	@Test
	public void testReattach() {
		nestedListenerHandle = createAttachedNestedListenerHandle(nesting, listener);
		nestedListenerHandle.detach();
		nestedListenerHandle.attach();
		innerObservable.set("new value");

		// assert that 'changed' was called once and with the right arguments
		verify(listener, times(1)).changed(innerObservable, "initial value", "new value");
		verifyNoMoreInteractions(listener);
	}

#No. 3640
#File: E:\bishe\1\AbstractNestedChangeListenerHandleTest.java
#Comment:
	/**
	 * Tests whether the listener is only called once even when attached is called repeatedly.
	 */

#Code:
	@Test
	public void testMultipleAttach() {
		nestedListenerHandle = createAttachedNestedListenerHandle(nesting, listener);
		nestedListenerHandle.attach();
		nestedListenerHandle.attach();
		nestedListenerHandle.attach();
		innerObservable.set("new value");

		// assert that 'changed' was called only once
		verify(listener, times(1)).changed(innerObservable, "initial value", "new value");
		verifyNoMoreInteractions(listener);
	}

#No. 3641
#File: E:\bishe\1\AbstractNestedDoublePropertyTest.java
#Comment:
/**
 * Abstract superclass to tests for {@link NestedDoubleProperty NestedDoubleProperty} which only leaves the creation of
 * the tested properties (by {@link #createNestedPropertyFromNesting(Nesting, InnerObservableMissingBehavior)}) to the
 * subclasses.
 */

#Code:
public abstract class AbstractNestedDoublePropertyTest extends
		AbstractNestedPropertyTest<Double, Number, DoubleProperty> {

	/**
	 * The last value returned by {@link #createNewValue()}.
	 */
	private double lastValue = 1.5;

	@Override
	protected boolean wrapsPrimitive() {
		return true;
	}

	@Override
	protected Double createNewValue() {
		lastValue += 1;
		return lastValue;
	}

	@Override
	protected DoubleProperty createNewObservableWithValue(Number value) {
		return new SimpleDoubleProperty(value.doubleValue());
	}

	@Override
	protected DoubleProperty createNewObservableWithSomeValue() {
		return createNewObservableWithValue(0.0);
	}

}

#No. 3642
#File: E:\bishe\1\AbstractNestedFloatPropertyTest.java
#Comment:
/**
 * Abstract superclass to tests for {@link NestedFloatProperty NestedFloatProperty} which only leaves the creation of
 * the tested properties (by {@link #createNestedPropertyFromNesting(Nesting, InnerObservableMissingBehavior)}) to the
 * subclasses.
 */

#Code:
public abstract class AbstractNestedFloatPropertyTest extends
		AbstractNestedPropertyTest<Float, Number, FloatProperty> {

	/**
	 * The last value returned by {@link #createNewValue()}.
	 */
	private float lastValue = 1.5f;

	@Override
	protected boolean wrapsPrimitive() {
		return true;
	}

	@Override
	protected Float createNewValue() {
		lastValue += 1;
		return lastValue;
	}

	@Override
	protected FloatProperty createNewObservableWithValue(Number value) {
		return new SimpleFloatProperty(value.floatValue());
	}

	@Override
	protected FloatProperty createNewObservableWithSomeValue() {
		return createNewObservableWithValue(0.0);
	}

}

#No. 3643
#File: E:\bishe\1\AbstractNestedIntegerPropertyTest.java
#Comment:
/**
 * Abstract superclass to tests for {@link NestedIntegerProperty NestedIntegerProperty} which only leaves the creation
 * of the tested properties (by {@link #createNestedPropertyFromNesting(Nesting, InnerObservableMissingBehavior)}) to
 * the subclasses.
 */

#Code:
public abstract class AbstractNestedIntegerPropertyTest extends
		AbstractNestedPropertyTest<Integer, Number, IntegerProperty> {

	/**
	 * The last value returned by {@link #createNewValue()}.
	 */
	private int lastValue = 0;

	@Override
	protected boolean wrapsPrimitive() {
		return true;
	}

	@Override
	protected Integer createNewValue() {
		return lastValue++;
	}

	@Override
	protected IntegerProperty createNewObservableWithValue(Number value) {
		return new SimpleIntegerProperty(value.intValue());
	}

	@Override
	protected IntegerProperty createNewObservableWithSomeValue() {
		return createNewObservableWithValue(0);
	}

}

#No. 3644
#File: E:\bishe\1\AbstractNestedInvalidationListenerBuilderTest.java
#Comment:
	/**
	 * Tests whether the builder can be created with a null {@link Nesting}.
	 */

#Code:
	@Test(expected = NullPointerException.class)
	public void testCreationWithNullNesting() {
		NestedInvalidationListenerBuilder.forNesting(null);
	}

#No. 3645
#File: E:\bishe\1\AbstractNestedInvalidationListenerBuilderTest.java
#Comment:
	/**
	 * Tests whether the builder accepts null as a listener.
	 */

#Code:
	@Test(expected = NullPointerException.class)
	public void testUsingNullListener() {
		builder.withListener(null);
	}

#No. 3646
#File: E:\bishe\1\AbstractNestedInvalidationListenerBuilderTest.java
#Comment:
	/**
	 * Tests whether building creates an instance.
	 */

#Code:
	@Test
	public void testBuildCreatesInstance() {
		NestedInvalidationListenerHandle listener = builder
				.withListener(observable -> {/* don't do anything */})
				.buildAttached();

		assertNotNull(listener);
	}

#No. 3647
#File: E:\bishe\1\AbstractNestedInvalidationListenerBuilderTest.java
#Comment:
	/**
	 * Tests whether building more than once throws an exceptions.
	 */

#Code:
	@Test(expected = IllegalStateException.class)
	public void testBuildSeveralInstances() {
		NestedInvalidationListenerBuilder.Buildable buildable =
				builder.withListener(observable -> {/* don't do anything */});

		// first build must work (see other tests)
		buildable.buildAttached();

		// second build must fail
		buildable.buildAttached();
	}

#No. 3648
#File: E:\bishe\1\AbstractNestedInvalidationListenerHandleTest.java
#Comment:
	/**
	 * Tests whether the properties the tested nested listener owns have the correct bean.
	 */

#Code:
	@Test
	public void testPropertyBean() {
		nestedListenerHandle = createDetachedNestedListenerHandle(nesting, listener);
		assertSame(nestedListenerHandle, nestedListenerHandle.innerObservablePresentProperty().getBean());
	}

#No. 3649
#File: E:\bishe\1\AbstractNestedInvalidationListenerHandleTest.java
#Comment:
	/**
	 * Tests whether the {@link #nestedListenerHandle} correctly reports whether the inner observable is present.
	 */

#Code:
	@Test
	public void testObservablePresentAfterConstruction() {
		nestedListenerHandle = createDetachedNestedListenerHandle(nesting, listener);
		assertTrue(nestedListenerHandle.isInnerObservablePresent());
	}

#No. 3650
#File: E:\bishe\1\AbstractNestedInvalidationListenerHandleTest.java
#Comment:
	/**
	 * Tests whether the construction does not call the {@link #listener}.
	 */

#Code:
	@Test
	public void testNoInteractionWithListenerDuringConstruction() {
		nestedListenerHandle = createDetachedNestedListenerHandle(nesting, listenerWhichFailsWhenCalled);
		nestedListenerHandle = createAttachedNestedListenerHandle(nesting, listenerWhichFailsWhenCalled);
	}

#No. 3651
#File: E:\bishe\1\AbstractNestedInvalidationListenerHandleTest.java
#Comment:
	/**
	 * Tests whether no listener invocation occurs when the nesting's observable changes its value and the listener is
	 * initially detached.
	 */

#Code:
	@Test
	public void testChangingValueWhenInitiallyDetached() {
		nestedListenerHandle = createDetachedNestedListenerHandle(nesting, listenerWhichFailsWhenCalled);
		innerObservable.set("new value");
	}

#No. 3652
#File: E:\bishe\1\AbstractNestedInvalidationListenerHandleTest.java
#Comment:
	/**
	 * Tests whether the listener is correctly invoked when the nesting's observable changes its value.
	 */

#Code:
	@Test
	public void testChangingValue() {
		nestedListenerHandle = createAttachedNestedListenerHandle(nesting, listener);
		innerObservable.set("new value");

		// assert that 'invalidated' was called once and with the right observable
		verify(listener, times(1)).invalidated(innerObservable);
		verifyNoMoreInteractions(listener);
	}

#No. 3653
#File: E:\bishe\1\AbstractNestedInvalidationListenerHandleTest.java
#Comment:
	/**
	 * Tests whether no listener invocation occurs when the nesting's inner observable is changed.
	 */

#Code:
	@Test
	public void testChangingObservable() {
		nestedListenerHandle = createAttachedNestedListenerHandle(nesting, listenerWhichFailsWhenCalled);
		StringProperty newObservable = new SimpleStringProperty();
		setNestingObservable(nesting, newObservable);

		assertTrue(nestedListenerHandle.isInnerObservablePresent());
	}

#No. 3654
#File: E:\bishe\1\AbstractNestedInvalidationListenerHandleTest.java
#Comment:
	/**
	 * Tests whether no listener invocation occurs when the nesting's inner observable is changed to null.
	 */

#Code:
	@Test
	public void testChangingObservableToNull() {
		nestedListenerHandle = createAttachedNestedListenerHandle(nesting, listenerWhichFailsWhenCalled);
		setNestingObservable(nesting, null);

		assertFalse(nestedListenerHandle.isInnerObservablePresent());
	}

#No. 3655
#File: E:\bishe\1\AbstractNestedInvalidationListenerHandleTest.java
#Comment:
	/**
	 * Tests whether the listener is correctly invoked when the nesting's new observable gets a new value.
	 */

#Code:
	@Test
	public void testChangingNewObservablesValue() {
		nestedListenerHandle = createAttachedNestedListenerHandle(nesting, listener);
		// set a new observable ...
		StringProperty newObservable = new SimpleStringProperty();
		setNestingObservable(nesting, newObservable);
		// (assert that setting the observable worked)
		assertEquals(newObservable, getNestingObservable(nesting));

		// ... and change its value
		newObservable.setValue("new observable's new value");

		// assert that the listener was invoked once and with the right observable
		verify(listener, times(1)).invalidated(newObservable);
		verifyNoMoreInteractions(listener);
	}

#No. 3656
#File: E:\bishe\1\AbstractNestedInvalidationListenerHandleTest.java
#Comment:
	/**
	 * Tests whether the listener is not invoked when the nesting's old observable gets a new value.
	 */

#Code:
	@Test
	public void testChangingOldObservablesValue() {
		nestedListenerHandle = createAttachedNestedListenerHandle(nesting, listenerWhichFailsWhenCalled);
		// set a new observable ...
		StringProperty newObservable = new SimpleStringProperty();
		setNestingObservable(nesting, newObservable);
		// (assert that setting the observable worked)
		assertEquals(newObservable, getNestingObservable(nesting));

		// ... and change the old observable's value
		innerObservable.setValue("intial observable's new value");
	}

#No. 3657
#File: E:\bishe\1\AbstractNestedInvalidationListenerHandleTest.java
#Comment:
	/**
	 * Tests whether no listener invocation occurs when the nesting's inner observable's value is changed after the
	 * listener was detached.
	 */

#Code:
	@Test
	public void testDetach() {
		nestedListenerHandle = createAttachedNestedListenerHandle(nesting, listenerWhichFailsWhenCalled);
		nestedListenerHandle.detach();

		innerObservable.set("new value while detached");
	}

#No. 3658
#File: E:\bishe\1\AbstractNestedInvalidationListenerHandleTest.java
#Comment:
	/**
	 * Tests whether the listener ignores values after it was detached repeatedly.
	 */

#Code:
	@Test
	public void testMultipleDetach() {
		nestedListenerHandle = createAttachedNestedListenerHandle(nesting, listenerWhichFailsWhenCalled);
		nestedListenerHandle.detach();
		nestedListenerHandle.detach();
		nestedListenerHandle.detach();

		innerObservable.set("new value while detached");
	}

#No. 3659
#File: E:\bishe\1\AbstractNestedInvalidationListenerHandleTest.java
#Comment:
	/**
	 * Tests whether the listener is correctly invoked when the nesting's observable changes its value after the
	 * listener was detached and reattached.
	 */

#Code:
	@Test
	public void testReattach() {
		nestedListenerHandle = createAttachedNestedListenerHandle(nesting, listener);
		nestedListenerHandle.detach();
		nestedListenerHandle.attach();
		innerObservable.set("new value");

		// assert that 'invalidated' was called once and with the right arguments
		verify(listener, times(1)).invalidated(innerObservable);
		verifyNoMoreInteractions(listener);
	}

#No. 3660
#File: E:\bishe\1\AbstractNestedInvalidationListenerHandleTest.java
#Comment:
	/**
	 * Tests whether the listener is only called once even when attached is called repeatedly.
	 */

#Code:
	@Test
	public void testMultipleAttach() {
		nestedListenerHandle = createAttachedNestedListenerHandle(nesting, listener);
		nestedListenerHandle.attach();
		nestedListenerHandle.attach();
		nestedListenerHandle.attach();
		innerObservable.set("new value");

		// assert that 'invalidated' was called only once
		verify(listener, times(1)).invalidated(innerObservable);
		verifyNoMoreInteractions(listener);
	}

#No. 3661
#File: E:\bishe\1\AbstractNestedLongPropertyTest.java
#Comment:
/**
 * Abstract superclass to tests for {@link NestedLongProperty NestedLongProperty} which only leaves the creation of the
 * tested properties (by {@link #createNestedPropertyFromNesting(Nesting, InnerObservableMissingBehavior)}) to the
 * subclasses.
 */

#Code:
public abstract class AbstractNestedLongPropertyTest extends
		AbstractNestedPropertyTest<Long, Number, LongProperty> {

	/**
	 * The last value returned by {@link #createNewValue()}.
	 */
	private long lastValue = 0;

	@Override
	protected boolean wrapsPrimitive() {
		return true;
	}

	@Override
	protected Long createNewValue() {
		lastValue += 1;
		return lastValue;
	}

	@Override
	protected LongProperty createNewObservableWithValue(Number value) {
		return new SimpleLongProperty(value.longValue());
	}

	@Override
	protected LongProperty createNewObservableWithSomeValue() {
		return createNewObservableWithValue(0);
	}

}

#No. 3662
#File: E:\bishe\1\AbstractNestedObjectPropertyTest.java
#Comment:
/**
 * Abstract superclass to tests for {@link NestedObjectProperty NestedObjectProperties} which only leaves the creation
 * of the tested properties (by {@link #createNestedPropertyFromNesting(Nesting, InnerObservableMissingBehavior)}) to
 * the subclasses.
 */

#Code:
public abstract class AbstractNestedObjectPropertyTest
		extends AbstractNestedPropertyTest<SomeValue, SomeValue, Property<SomeValue>> {

	@Override
	protected final boolean wrapsPrimitive() {
		return false;
	}

	@Override
	protected final SomeValue createNewValue() {
		return new SomeValue();
	}

	@Override
	protected final Property<SomeValue> createNewObservableWithValue(SomeValue value) {
		return new SimpleObjectProperty<>(value);
	}

	@Override
	protected final Property<SomeValue> createNewObservableWithSomeValue() {
		SomeValue someValue = new SomeValue();
		return createNewObservableWithValue(someValue);
	}

}

#No. 3663
#File: E:\bishe\1\AbstractNestedPropertyTest.java
#Comment:
	/**
	 * @return the nesting on which the tested property is based
	 */

#Code:
	protected final EditableNesting<P> getNesting() {
		return nesting;
	}

#No. 3664
#File: E:\bishe\1\AbstractNestedPropertyTest.java
#Comment:
	/**
	 * @return the tested property
	 */

#Code:
	protected final NestedProperty<T> getProperty() {
		return property;
	}

#No. 3665
#File: E:\bishe\1\AbstractNestedPropertyTest.java
#Comment:
	/**
	 * @return the {@link #getProperty tested property}'s current value
	 */

#Code:
	protected final T getPropertyValue() {
		return property.getValue();
	}

#No. 3666
#File: E:\bishe\1\AbstractNestedPropertyTest.java
#Comment:
	/**
	 * Sets the specified behavior for missing inner observables on the specified builder.
	 *
	 * @param behavior
	 *            the behavior to set on the builder
	 * @param builder
	 *            the mutated builder
	 */

#Code:
	protected final void setBehaviorOnBuilder(
			InnerObservableMissingBehavior<S> behavior, AbstractNestedPropertyBuilder<S, ?, ?, ?> builder) {
		// on goes missing
		switch (behavior.whenGoesMissing()) {
			case KEEP_VALUE:
				builder.onInnerObservableMissingKeepValue();
				break;
			case SET_DEFAULT_VALUE:
				builder.onInnerObservableMissingSetDefaultValue();
				break;
			case SET_VALUE_FROM_SUPPLIER:
				builder.onInnerObservableMissingComputeValue(behavior.valueForMissing().get());
				break;
			default:
				throw new IllegalArgumentException();
		}

		// on update
		switch (behavior.onUpdate()) {
			case ACCEPT_VALUE_UNTIL_NEXT_INNER_OBSERVABLE:
				builder.onUpdateWhenInnerObservableMissingAcceptValues();
				break;
			case THROW_EXCEPTION:
				builder.onUpdateWhenInnerObservableMissingThrowException();
				break;
			default:
				throw new IllegalArgumentException();
		}
	}

#No. 3667
#File: E:\bishe\1\AbstractNestedStringPropertyTest.java
#Comment:
/**
 * Abstract superclass to tests for {@link NestedStringProperty NestedStringProperty} which only leaves the creation of
 * the tested properties (by {@link #createNestedPropertyFromNesting(Nesting, InnerObservableMissingBehavior)}) to the
 * subclasses.
 */

#Code:
public abstract class AbstractNestedStringPropertyTest extends
		AbstractNestedPropertyTest<String, String, StringProperty> {

	/**
	 * The last value returned by {@link #createNewValue()}.
	 */
	private String lastValue = "";

	@Override
	protected boolean wrapsPrimitive() {
		return false;
	}

	@Override
	protected String createNewValue() {
		lastValue += "a";
		return lastValue;
	}

	@Override
	protected StringProperty createNewObservableWithValue(String value) {
		return new SimpleStringProperty(value);
	}

	@Override
	protected StringProperty createNewObservableWithSomeValue() {
		return createNewObservableWithValue("");
	}

}

#No. 3668
#File: E:\bishe\1\AbstractNestingBuilderOnObservable.java
#Comment:
		/*
		 * Uses recursion to move up the chain of 'previousNestedBuilder's until the outer builder is reached. This
		 * builder's 'outerObservable' is set to the specified 'kit'. The 'kit's list of nesting steps is then filled
		 * when the recursion is closed, i.e. top down from the outermost builder to the inner one.
		 */

#Code:

		if (isOuterBuilder())
			/*
			 * This class' contract states that nesting must not occur when the outerObservable's type O is not also an
			 * 'ObservableValue'.
			 */
			kit.setOuterObservable((ObservableValue) outerObservable);
		else {
			previousBuilder.fillNestingConstructionKit(kit);
			kit.getNestingSteps().add(nestingStep);
		}

#No. 3669
#File: E:\bishe\1\AbstractNestingBuilderOnObservable.java
#Comment:
	/**
	 * Adds the specified invalidation listener to the nesting hierarchy's inner {@link Observable}.
	 *
	 * @param listener
	 *            the added {@link InvalidationListener}
	 * @return the {@link NestedInvalidationListenerHandle} which can be used to check the nesting's state
	 */

#Code:
	public NestedInvalidationListenerHandle addListener(InvalidationListener listener) {
		Nesting<O> nesting = buildNesting();
		return NestedInvalidationListenerBuilder
				.forNesting(nesting)
				.withListener(listener)
				.buildAttached();
	}

#No. 3670
#File: E:\bishe\1\AbstractNestingBuilderOnObservable.java
#Comment:
		/**
		 * Creates a new empty construction kit.
		 */

#Code:
		public NestingConstructionKit() {
			nestingSteps = new ArrayList<>();
		}

#No. 3671
#File: E:\bishe\1\AbstractNestingBuilderOnObservable.java
#Comment:
		/**
		 * @return the outer {@link ObservableValue}
		 */

#Code:
		public ObservableValue getOuterObservable() {
			return outerObservable;
		}

#No. 3672
#File: E:\bishe\1\AbstractNestingBuilderOnObservable.java
#Comment:
		/**
		 * Sets the new outer observable value.
		 *
		 * @param outerObservable
		 *            the outer {@link ObservableValue} to set
		 */

#Code:
		public void setOuterObservable(ObservableValue outerObservable) {
			this.outerObservable = outerObservable;
		}

#No. 3673
#File: E:\bishe\1\AbstractNestingBuilderOnObservable.java
#Comment:
		/**
		 * @return the list of {@link Function Functions} which get the nested {@link ObservableValue observables}
		 */

#Code:
		public List<NestingStep> getNestingSteps() {
			return nestingSteps;
		}

#No. 3674
#File: E:\bishe\1\AbstractNestingBuilderOnProperty.java
#Comment:
/**
 * A nesting builder which allows bindings.
 *
 * @param <T>
 *            the type of the wrapped value
 * @param <O>
 *            the type of {@link Observable} this builder uses as an inner observable
 */

#Code:
abstract class AbstractNestingBuilderOnProperty<T, O extends Property<T>>
		extends AbstractNestingBuilderOnObservableValue<T, O> {

	// #begin CONSTRUCTION

	/**
	 * Creates a new nesting builder which acts as the outer builder.
	 *
	 * @param outerObservable
	 *            the outer observable upon which the constructed nesting depends
	 */
	protected AbstractNestingBuilderOnProperty(O outerObservable) {
		super(outerObservable);
	}

	/**
	 * Creates a new nesting builder which acts as a nested builder.
	 *
	 * @param <P>
	 *            the type the previous builder wraps
	 * @param previousNestedBuilder
	 *            the previous builder
	 * @param nestingStep
	 *            the function which performs the nesting step from one observable to the next
	 */
	protected <P> AbstractNestingBuilderOnProperty(
			AbstractNestingBuilderOnObservable<P, ?> previousNestedBuilder, NestingStep<P, O> nestingStep) {

		super(previousNestedBuilder, nestingStep);
	}

	//#end CONSTRUCTION

}

#No. 3675
#File: E:\bishe\1\AbstractNetconfConfigTest.java
#Comment:
    /**
     * @Before in subclasses is called after this method.
     */

#Code:
    @Before
    public void setUpAbstractNetconfConfigTest() throws Exception {
        super.initConfigTransactionManagerImpl(new HardcodedModuleFactoriesResolver(mockedContext, FACTORIES));

        nettyThreadgroup = new NioEventLoopGroup();
        hashedWheelTimer = new HashedWheelTimer();

        loadMessages();

        setUpTestInitial();

        final AggregatedNetconfOperationServiceFactory factoriesListener =
                new AggregatedNetconfOperationServiceFactory();
        final NetconfMonitoringService netconfMonitoringService = getNetconfMonitoringService(factoriesListener);
        configSubsystemFacadeFactory =
                new ConfigSubsystemFacadeFactory(configRegistryClient, configRegistryClient, getYangStore());
        factoriesListener.onAddNetconfOperationServiceFactory(
                new NetconfOperationServiceFactoryImpl(configSubsystemFacadeFactory));
        factoriesListener.onAddNetconfOperationServiceFactory(
                new NetconfMonitoringActivator.NetconfMonitoringOperationServiceFactory(
                        new NetconfMonitoringOperationService(netconfMonitoringService)));

        for (final NetconfOperationServiceFactory netconfOperationServiceFactory : getAdditionalServiceFactories(
                factoriesListener)) {
            factoriesListener.onAddNetconfOperationServiceFactory(netconfOperationServiceFactory);
        }

        serverTcpChannel = startNetconfTcpServer(factoriesListener, netconfMonitoringService);
        clientDispatcher =
                new NetconfClientDispatcherImpl(getNettyThreadgroup(), getNettyThreadgroup(), getHashedWheelTimer());
    }

#No. 3676
#File: E:\bishe\1\AbstractNetconfConfigTest.java
#Comment:
    /**
     * @After in subclasses is be called before this.
     */

#Code:
    @After
    public void cleanUpNetconf() throws Exception {
        serverTcpChannel.close().await(RESOURCE_TIMEOUT_MINUTES, TimeUnit.MINUTES);
        hashedWheelTimer.stop();
        nettyThreadgroup.shutdownGracefully().await(RESOURCE_TIMEOUT_MINUTES, TimeUnit.MINUTES);
    }

#No. 3677
#File: E:\bishe\1\AbstractNetconfSessionNegotiator.java
#Comment:
    /**
     * Possible states for Finite State Machine.
     */

#Code:
    protected enum State {
        IDLE, OPEN_WAIT, FAILED, ESTABLISHED
    }

#No. 3678
#File: E:\bishe\1\AbstractNetconfSessionNegotiator.java
#Comment:
    /**
     * Insert chunk framing handlers into the pipeline.
     */

#Code:
    private void insertChunkFramingToPipeline() {
        replaceChannelHandler(channel, AbstractChannelInitializer.NETCONF_MESSAGE_FRAME_ENCODER,
                FramingMechanismHandlerFactory.createHandler(FramingMechanism.CHUNK));
        replaceChannelHandler(channel, AbstractChannelInitializer.NETCONF_MESSAGE_AGGREGATOR,
                new NetconfChunkAggregator());
    }

#No. 3679
#File: E:\bishe\1\AbstractNetconfSessionNegotiator.java
#Comment:
    /**
     * Remove special inbound handler for hello message. Insert regular netconf xml message (en|de)coders.
     *
     * <p>
     * Inbound hello message handler should be kept until negotiation is successful
     * It caches any non-hello messages while negotiation is still in progress
     */

#Code:
    protected final void replaceHelloMessageInboundHandler(final S session) {
        ChannelHandler helloMessageHandler = replaceChannelHandler(channel,
                AbstractChannelInitializer.NETCONF_MESSAGE_DECODER, new NetconfXMLToMessageDecoder());

        Preconditions.checkState(helloMessageHandler instanceof NetconfXMLToHelloMessageDecoder,
                "Pipeline handlers misplaced on session: %s, pipeline: %s", session, channel.pipeline());
        Iterable<NetconfMessage> netconfMessagesFromNegotiation =
                ((NetconfXMLToHelloMessageDecoder) helloMessageHandler).getPostHelloNetconfMessages();

        // Process messages received during negotiation
        // The hello message handler does not have to be synchronized,
        // since it is always call from the same thread by netty.
        // It means, we are now using the thread now
        for (NetconfMessage message : netconfMessagesFromNegotiation) {
            session.handleMessage(message);
        }
    }

#No. 3680
#File: E:\bishe\1\AbstractNetconfSessionNegotiator.java
#Comment:
    /**
     * Remove special outbound handler for hello message. Insert regular netconf xml message (en|de)coders.
     */

#Code:
    private void replaceHelloMessageOutboundHandler() {
        replaceChannelHandler(channel, AbstractChannelInitializer.NETCONF_MESSAGE_ENCODER,
                new NetconfMessageToXMLEncoder());
    }

#No. 3681
#File: E:\bishe\1\AbstractNetconfTopology.java
#Comment:
    /**
     * Creates the backing Schema classes for a particular directory.
     *
     * @param moduleSchemaCacheDirectory The string directory relative to "cache"
     * @return A DTO containing the Schema classes for the Netconf mount.
     */

#Code:
    private NetconfDevice.SchemaResourcesDTO createSchemaResourcesDTO(final String moduleSchemaCacheDirectory) {
        final SharedSchemaRepository repository = new SharedSchemaRepository(moduleSchemaCacheDirectory);
        final SchemaContextFactory schemaContextFactory
                = repository.createSchemaContextFactory(SchemaSourceFilter.ALWAYS_ACCEPT);
        setSchemaRegistry(repository);
        setSchemaContextFactory(schemaContextFactory);
        final FilesystemSchemaSourceCache<YangTextSchemaSource> deviceCache =
                createDeviceFilesystemCache(moduleSchemaCacheDirectory);
        repository.registerSchemaSourceListener(deviceCache);
        return new NetconfDevice.SchemaResourcesDTO(repository, repository, schemaContextFactory,
                new NetconfStateSchemasResolverImpl());
    }

#No. 3682
#File: E:\bishe\1\AbstractNetconfTopology.java
#Comment:
    /**
     * Creates a <code>FilesystemSchemaSourceCache</code> for the custom schema cache directory.
     *
     * @param schemaCacheDirectory The custom cache directory relative to "cache"
     * @return A <code>FilesystemSchemaSourceCache</code> for the custom schema cache directory
     */

#Code:
    private FilesystemSchemaSourceCache<YangTextSchemaSource> createDeviceFilesystemCache(
            final String schemaCacheDirectory) {
        final String relativeSchemaCacheDirectory = CACHE_DIRECTORY + File.separator + schemaCacheDirectory;
        return new FilesystemSchemaSourceCache<>(schemaRegistry, YangTextSchemaSource.class,
                new File(relativeSchemaCacheDirectory));
    }

#No. 3683
#File: E:\bishe\1\AbstractNetDriver.java
#Comment:
    /**
     * If this method returns true, the rename of the device id will be set
     * to a devicePrefix with an auto-number, if false, the device id will be renamed
     * to devicePrefix "-" old-deviceid.
     *
     * @see #getDevicePrefix()
     */

#Code:
    protected boolean renameToDevicePrefixOnly() {
        return false;
    }

#No. 3684
#File: E:\bishe\1\AbstractNetDriver.java
#Comment:
    /**
     * Pass a received frame onto the PacketTypeManager.
     *
     * @param skbuf
     */

#Code:
    protected void onReceive(SocketBuffer skbuf)
        throws NetworkException {
        skbuf.setDevice(getDevice());
        rx_count += skbuf.getSize();
        NetUtils.sendToPTM(skbuf);
    }

#No. 3685
#File: E:\bishe\1\AbstractNetDriver.java
#Comment:
    /**
     * Gets the protocol address information for a given protocol.
     *
     * @param protocolID
     * @return The protocol address information, or null if not found.
     */

#Code:
    public ProtocolAddressInfo getProtocolAddressInfo(int protocolID) {
        return protocolAddresses.get(protocolID);
    }

#No. 3686
#File: E:\bishe\1\AbstractNetDriver.java
#Comment:
    /**
     * Sets the protocol address information for a given protocol.
     *
     * @param protocolID
     */

#Code:
    public void setProtocolAddressInfo(int protocolID, ProtocolAddressInfo addressInfo) {
        protocolAddresses.put(protocolID, addressInfo);
    }

#No. 3687
#File: E:\bishe\1\AbstractNetDriver.java
#Comment:
    /**
     * @see org.jnode.driver.DeviceInfoAPI#showInfo(java.io.PrintWriter)
     */

#Code:
    public void showInfo(PrintWriter out) {
        if (!protocolAddresses.isEmpty()) {
            out.println("Protocol addresses:");
            for (int protId : protocolAddresses.keySet()) {
                out.println("    0x" + NumberUtils.hex(protId, 4) + " "
                        + getProtocolAddressInfo(protId));
            }
        }
    }    

#No. 3688
#File: E:\bishe\1\AbstractNettyHandler.java
#Comment:
	/**
	 *  code from netty
	 *  
	 * @return
	 */

#Code:
	public boolean isSharable() {
		Class<?> clazz = getClass();
		Map<Class<?>, Boolean> cache = InternalThreadLocalMap.get()
				.handlerSharableCache();
		Boolean sharable = cache.get(clazz);
		if (sharable == null) {
			sharable = clazz.isAnnotationPresent(Sharable.class);
			cache.put(clazz, sharable);
		}
		return sharable;
	}

#No. 3689
#File: E:\bishe\1\AbstractNettyHandler.java
#Comment:
	/**
	 *  code from netty
	 */

#Code:
	
    @Override
    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
        // NOOP
    }

#No. 3690
#File: E:\bishe\1\AbstractNettyHandler.java
#Comment:
    /**
     * code from netty
     * 
     */

#Code:
    @Override
    public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {
        // NOOP
    }

#No. 3691
#File: E:\bishe\1\AbstractNetworkLink.java
#Comment:
	/**
	 * Creates new NetworkLink instance.
	 *
	 * @param title      title of the corresponding library item. Must be not <code>null</code>.
	 * @param summary    description of the corresponding library item. Can be <code>null</code>.
	 * @param language   language of the catalog. If <code>null</code> we assume this catalog is multilanguage.
	 * @param infos      collection of URL infos; must always contain one URL with <code>UrlInfo.Type.Catalog</code> identifier
	 */

#Code:
	public AbstractNetworkLink(int id, String title, String summary, String language, UrlInfoCollection<UrlInfoWithDate> infos) {
		myId = id;
		myTitle = title;
		mySummary = summary;
		myLanguage = language != null ? language : "multi";
		myInfos = new UrlInfoCollection<UrlInfoWithDate>(infos);
	}

#No. 3692
#File: E:\bishe\1\AbstractNeuralNetwork.java
#Comment:
  /**
   * Read the model meta-data from the specified location.
   * 
   * @throws IOException
   */

#Code:
  protected void readFromModel() throws IOException {
    Preconditions.checkArgument(this.modelPath != null,
        "Model path has not been set.");
    Configuration conf = new Configuration();
    FSDataInputStream is = null;
    try {
      URI uri = new URI(this.modelPath);
      FileSystem fs = FileSystem.get(uri, conf);
      is = new FSDataInputStream(fs.open(new Path(modelPath)));
      this.readFields(is);
    } catch (URISyntaxException e) {
      e.printStackTrace();
    } finally {
      Closeables.close(is, false);
    }
  }

#No. 3693
#File: E:\bishe\1\AbstractNeuralNetwork.java
#Comment:
  /**
   * Write the model data to specified location.
   * 
   * @throws IOException
   */

#Code:
  public void writeModelToFile() throws IOException {
    Preconditions.checkArgument(this.modelPath != null,
        "Model path has not been set.");
    Configuration conf = new Configuration();
    FSDataOutputStream is = null;
    try {
      URI uri = new URI(this.modelPath);
      FileSystem fs = FileSystem.get(uri, conf);
      is = fs.create(new Path(this.modelPath), true);
      this.write(is);
    } catch (URISyntaxException e) {
      e.printStackTrace();
    }

    Closeables.close(is, false);
  }

#No. 3694
#File: E:\bishe\1\AbstractNeuralNetwork.java
#Comment:
  /**
   * Set the model path.
   * 
   * @param modelPath
   */

#Code:
  public void setModelPath(String modelPath) {
    this.modelPath = modelPath;
  }

#No. 3695
#File: E:\bishe\1\AbstractNeuralNetwork.java
#Comment:
  /**
   * Get the model path.
   * 
   * @return the path to store the model.
   */

#Code:
  public String getModelPath() {
    return this.modelPath;
  }

#No. 3696
#File: E:\bishe\1\AbstractNeutronNorthbound.java
#Comment:
        /*
         * update the object and return it
         */

#Code:
        if (!neutronCRUD.update(uuid, delta)) {
            throw new ResourceNotFoundException(uuidNoExist());
        }

#No. 3697
#File: E:\bishe\1\AbstractNeutronNorthbound.java
#Comment:
        /*
         * remove it and return 204 status
         */

#Code:
        if (!neutronCRUD.remove(uuid)) {
            throw new ResourceNotFoundException(uuidNoExist());
        }

#No. 3698
#File: E:\bishe\1\AbstractNewResourceAction.java
#Comment:
    /**
     * Returns extension (without dot) for a new resource.
     * By default, returns an empty string.
     */

#Code:
    protected String getExtension() {
        return "";
    }

#No. 3699
#File: E:\bishe\1\AbstractNewResourceAction.java
#Comment:
    /**
     * Returns default content for a new resource.
     * By default, returns an empty string.
     */

#Code:
    protected String getDefaultContent() {
        return "";
    }

#No. 3700
#File: E:\bishe\1\AbstractNewResourceAction.java
#Comment:
    /**
     * Returns MIME-type for a new resource.
     * By default, returns {@code null}.
     */

#Code:
    protected String getMimeType() {
        return null;
    }

#No. 3701
#File: E:\bishe\1\AbstractNexusIndexerCliTest.java
#Comment:
    /*
     * private static final String DEST_DIR = new File( getBasedir(), "target/tests/clitest/output-"+rand
     * ).getAbsolutePath(); private static final String INDEX_DIR = new File( getBasedir(),
     * "target/tests/clitest/index-"+rand ).getAbsolutePath(); private static final String UNPACK_DIR = new File(
     * getBasedir(), "target/tests/clitest/unpack-"+rand ).getAbsolutePath(); private static final String TEST_REPO =
     * new File( getBasedir(), "src/test/repo" ).getAbsolutePath();
     */

#Code:
    private static final String DEST_DIR =
        new File( getBasedir(), "target/tests/clitest-" + rand + "/output" ).getAbsolutePath();

    private static final String INDEX_DIR =
        new File( getBasedir(), "target/tests/clitest-" + rand + "/index" ).getAbsolutePath();

    private static final String UNPACK_DIR =
        new File( getBasedir(), "target/tests/clitest-" + rand + "/unpack" ).getAbsolutePath();

    private static final String TEST_REPO = new File( getBasedir(), "src/test/repo" ).getAbsolutePath();

    protected OutputStream out;

    @Override
    protected void customizeContainerConfiguration( final ContainerConfiguration containerConfiguration )
    {
        super.customizeContainerConfiguration( containerConfiguration );
        containerConfiguration.setClassPathScanning( PlexusConstants.SCANNING_INDEX );
    }

#No. 3702
#File: E:\bishe\1\AbstractNfaGameAndMarketWriter.java
#Comment:
	/**
	 * 
	 * UI Methods
	 * 
	 **/

#Code:

	@Override
	public void onClick(View btn) {
		switch (btn.getId()) {
		case R.id.btn_init:
			btnInit.setEnabled(false);
			btnSkip.setEnabled(false);
			feedBack1.setVisibility(View.VISIBLE);
			break;
		case R.id.btn_next:
		case R.id.btn_skip:
			startActivity(new Intent(this, getClassIntent()));
			finish();
			break;

		default:
			break;
		}

	}

#No. 3703
#File: E:\bishe\1\AbstractNfcAsync.java
#Comment:
    /**
     * Constructor taking an AsyncUI-, AsyncOperationCallback and an {@link be.appfoundry.nfclibrary.utilities.interfaces.NfcWriteUtility}
     *
     * @param nfcWriteUtility
     *         implementation of {@link be.appfoundry.nfclibrary.utilities.interfaces.NfcWriteUtility} to use
     *
     * @see #AbstractNfcAsync(be.appfoundry.nfclibrary.tasks.interfaces.AsyncUiCallback, be.appfoundry.nfclibrary.tasks.interfaces.AsyncOperationCallback)
     */

#Code:
    public AbstractNfcAsync(final @Nullable AsyncUiCallback asyncUiCallback, final @NotNull AsyncOperationCallback asyncOperationCallback, final @NotNull NfcWriteUtility nfcWriteUtility) {
        this(asyncUiCallback, nfcWriteUtility);
        setAsyncOperationCallback(asyncOperationCallback);
    }

    protected AsyncUiCallback getAsyncUiCallback() {
        return mAsyncUiCallback;
    }

#No. 3704
#File: E:\bishe\1\AbstractNfcAsync.java
#Comment:
    /**
     * Creates an async task with the current {@link #getAsyncOperationCallback()} as action
     *
     * @throws java.lang.NullPointerException
     *         if {@link #getAsyncOperationCallback()} is null
     * @see AsyncNfcWriteOperation#executeWriteOperation()
     */

#Code:
    @Override
    public void executeWriteOperation() {
        if (getNfcWriteUtility() != null) {
            new GenericTask(mAsyncUiCallback, getAsyncOperationCallback(), getNfcWriteUtility()).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
        } else {
            new GenericTask(mAsyncUiCallback, getAsyncOperationCallback()).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
        }
    }

#No. 3705
#File: E:\bishe\1\AbstractNfcAsync.java
#Comment:
    /**
     * Convenience method making it possible not to define an {@link be.appfoundry.nfclibrary.tasks.interfaces.AsyncOperationCallback} at construction time but rather pass arguments and let the implementation handle it
     * Should set the AsyncOperationCallback, and then call {@link #executeWriteOperation()}
     *
     * @param intent
     *         to be passed to the write utility
     * @param args
     *         to be passed to the method
     *
     * @see #setAsyncOperationCallback(be.appfoundry.nfclibrary.tasks.interfaces.AsyncOperationCallback)
     * @see AsyncNfcWriteOperation#executeWriteOperation()
     */

#Code:
    @Override
    public abstract void executeWriteOperation(Intent intent, Object... args);

    /**
     * Used to check whether the passed type is equal to a String array
     *
     * @param type
     *         to compare with
     *
     * @return type.equals(String[].class)
     */
    protected boolean checkStringArguments(Class<?> type) {
        return (type.equals(String[].class));
    }

#No. 3706
#File: E:\bishe\1\AbstractNfcAsync.java
#Comment:
    /**
     * Used to check whether the passed type is equal to a Double array
     *
     * @param type
     *         to compare with
     *
     * @return type.equals(Double[].class)
     */

#Code:
    protected boolean checkDoubleArguments(Class<?> type) {
        return type.equals(Double[].class);
    }

#No. 3707
#File: E:\bishe\1\AbstractNfsStorage.java
#Comment:
    /**
     * Only constructor.
     */

#Code:
    @SuppressWarnings("rawtypes")
    public AbstractNfsStorage() {
        mimeMap = new MimetypesFileTypeMap();
        filter = new AbstractNfsStorage.SourceFilter();
    }

#No. 3708
#File: E:\bishe\1\AbstractNfsStorage.java
#Comment:
    /**
     * @return the sync path from the config, or the default path if the config is null
     */

#Code:
    protected String getSyncPath() {
        return (config.getPath() == null) ? NfsFile.separator : config.getPath();
    }

#No. 3709
#File: E:\bishe\1\AbstractNfsStorage.java
#Comment:
    /**
     * Return the path relative to the base, using NFS (Unix/Linux) path conventions.
     * 
     * @param path the path
     * @param pathBase the base
     * @return the relative path
     */

#Code:
    protected String getRelativePath(String path, String pathBase) {
        return path.startsWith(pathBase) ? path.substring(pathBase.length()) : path;
    }

#No. 3710
#File: E:\bishe\1\AbstractNfsStorage.java
#Comment:
    /**
     * Return the full path, using NFS (Unix/Linux) path conventions.
     * 
     * @param pathBase the base
     * @param relativePath the relative path
     * @return the full path
     */

#Code:
    protected String combineWithFileSeparator(String pathBase, String relativePath) {
        if ((pathBase == null) || (relativePath == null)) {
            return null;
        } else if (pathBase.endsWith(NfsFile.separator) || relativePath.startsWith(NfsFile.separator)) {
            return pathBase + relativePath;
        } else {
            return pathBase + NfsFile.separator + relativePath;
        }
    }

#No. 3711
#File: E:\bishe\1\AbstractNfsStorage.java
#Comment:
    /**
     * Create an ObjectSummary for the nfsFile.
     * 
     * @param nfsFile the nfsFile
     * @return the summary
     */

#Code:
    private ObjectSummary createSummary(F nfsFile) {
        try {
            if (!nfsFile.exists()) {
                throw new ObjectNotFoundException(nfsFile.getPath());
            }
            boolean link = isSymLink(nfsFile);
            boolean directory = nfsFile.isDirectory() && (config.isFollowLinks() || !link);
            long size = directory || link ? 0 : nfsFile.length();
            return new ObjectSummary(nfsFile.getPath(), directory, size);
        } catch (IOException e) {
            throw new ConfigurationException(e);
        }
    }

#No. 3712
#File: E:\bishe\1\AbstractNfsStorage.java
#Comment:
    /**
     * Return the ObjectMetadata, generating it if necessary.
     * 
     * @param nfsFile the nfsFile
     * @return the metadata
     * @throws IOException
     */

#Code:
    private ObjectMetadata readMetadata(F nfsFile) throws IOException {
        ObjectMetadata metadata;
        try {
            // first try to load the metadata file
            metadata = readMetadataFile(nfsFile);
        } catch (Throwable t) {
            // if that doesn't work, generate new metadata based on the file
            // attributes
            metadata = new ObjectMetadata();

            boolean isLink = !config.isFollowLinks() && isSymLink(nfsFile);
            boolean directory = nfsFile.isDirectory();

            metadata.setDirectory(directory);

            NfsGetAttributes basicAttr = nfsFile.getattr().getAttributes();
            NfsTime mtime = basicAttr.getMtime();
            long mtimeInMillis = (mtime == null) ? 0 : mtime.getTimeInMillis();
            metadata.setModificationTime(new Date(mtimeInMillis));

            metadata.setContentType(isLink ? TYPE_LINK : mimeMap.getContentType(nfsFile.getName()));
            if (isLink)
                metadata.setUserMetadataValue(META_LINK_TARGET, nfsFile.readlink().getData());

            // On OSX, directories have 'length'... ignore.
            if (nfsFile.isFile() && !isLink)
                metadata.setContentLength(nfsFile.length());
            else
                metadata.setContentLength(0);
        }

        return metadata;
    }

#No. 3713
#File: E:\bishe\1\AbstractNfsStorage.java
#Comment:
    /**
     * Get previously stored metadata.
     * 
     * @param nfsFile the nfsFile
     * @return the metadata from the nfsFile
     * @throws IOException
     */

#Code:
    private ObjectMetadata readMetadataFile(F nfsFile) throws IOException {
        try (InputStream is = new BufferedInputStream(createInputStream(getMetaFile(nfsFile)))) {
            return ObjectMetadata.fromJson(new Scanner(is).useDelimiter("\\A").next());
        }
    }

#No. 3714
#File: E:\bishe\1\AbstractNfsStorage.java
#Comment:
    /**
     * Get the data.
     * 
     * @param nfsFile the nfsFile
     * @return the stream
     */

#Code:
    private InputStream readDataStream(F nfsFile) {
        try {
            return createInputStream(nfsFile);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

#No. 3715
#File: E:\bishe\1\AbstractNfsStorage.java
#Comment:
    /**
     * Synchronized mkdirs to prevent conflicts in threaded environment.
     * 
     * @param dir the nfsFile for the directory
     * @throws IOException
     */

#Code:
    private synchronized void mkdirs(F dir) throws IOException {
        if (!dir.exists()) {
            dir.mkdirs();
        }
    }

#No. 3716
#File: E:\bishe\1\AbstractNfsStorage.java
#Comment:
    /**
     * Sync the nfsFile.
     * 
     * @param nfsFile the nfsFile
     * @param object the SyncObject
     * @param streamData whether to sync data after nfsFile creation
     * @throws IOException
     */

#Code:
    private void writeFile(F nfsFile, SyncObject object, boolean streamData) throws IOException {
        // make sure parent directory exists
        mkdirs(nfsFile.getParentFile());

        if (object.getMetadata().isDirectory()) {
            mkdirs(nfsFile);
        } else if (TYPE_LINK.equals(object.getMetadata().getContentType())) { // restore
                                                                              // a
                                                                              // sym
                                                                              // link
            String targetPath = object.getMetadata().getUserMetadataValue(META_LINK_TARGET);
            if (targetPath == null) {
                throw new RuntimeException("object appears to be a symbolic link, but no target path was found");
            }
            log.info("re-creating symbolic link {} -> {}", object.getRelativePath(), targetPath);
            createSymLink(nfsFile, targetPath);
        } else if (streamData) {
            copyData(object.getDataStream(), nfsFile);
        } else {
            nfsFile.createNewFile();
        }
    }

#No. 3717
#File: E:\bishe\1\AbstractNfsStorage.java
#Comment:
    /**
     * Create a symlink if needed.
     * 
     * @param nfsFile the nfsFile
     * @param targetPath the symlink target
     * @throws IOException
     */

#Code:
    private void createSymLink(F nfsFile, String targetPath) throws IOException {
        boolean needNewSymLink = true;
        try {
            if ((nfsFile.getAttributes().getType() == NfsType.NFS_LNK) && targetPath.equals(nfsFile.readlink().getData())) {
                needNewSymLink = false;
            } else {
                nfsFile.delete();
            }
        } catch (Throwable t) {
            // do nothing, this is normal if the nfsFile doesn't exist.
        }
        if (needNewSymLink) {
            nfsFile.symlink(targetPath, new NfsSetAttributes());
        }
    }

#No. 3718
#File: E:\bishe\1\AbstractNfsStorage.java
#Comment:
    /**
     * Write metadata as needed.
     * 
     * @param nfsFile the nfsFile
     * @param metadata the ObjectMetadata
     * @throws IOException
     */

#Code:
    private void writeMetadata(F nfsFile, ObjectMetadata metadata) throws IOException {
        if (config.isStoreMetadata()) {
            F metaFile = getMetaFile(nfsFile);
            F metaDir = metaFile.getParentFile();

            // create metadata directory if it doesn't already exist
            synchronized (this) {
                if (!metaDir.exists()) {
                    metaDir.mkdirs();
                }
            }

            String metaJson = metadata.toJson();
            copyData(new ByteArrayInputStream(metaJson.getBytes("UTF-8")), metaFile);
        }

        // write nfsFilesystem metadata (mtime)
        Date mtime = metadata.getModificationTime();
        if (mtime != null) {
            nfsFile.setLastModified(mtime.getTime());
        }
    }

#No. 3719
#File: E:\bishe\1\AbstractNfsStorage.java
#Comment:
    /**
     * Copy the data to the nfsFile.
     * 
     * @param inStream the data
     * @param nfsFile the nfsFile
     * @throws IOException
     */

#Code:
    private void copyData(InputStream inStream, F nfsFile) throws IOException {
        byte[] buffer = new byte[options.getBufferSize()];
        int c;
        try (InputStream input = inStream; OutputStream output = createOutputStream(nfsFile)) {
            while ((c = input.read(buffer)) != -1) {
                output.write(buffer, 0, c);
                if (options.isMonitorPerformance())
                    getWriteWindow().increment(c);
            }
        }
    }

#No. 3720
#File: E:\bishe\1\AbstractNfsStorage.java
#Comment:
    /**
     * Delete the nfsFile.
     * @param identifier the nfsFile identifier
     * @param deleteOlderThan the minimum age for deletion in milliseconds, or 0 if none.
     * @throws IOException
     */

#Code:
    public void delete(String identifier, long deleteOlderThan) throws IOException {
        F objectFile = createFile(identifier);
        F metaFile = getMetaFile(objectFile);
        if (metaFile.exists()) {
            delete(metaFile, deleteOlderThan);
        }
        delete(objectFile, deleteOlderThan);
    }

#No. 3721
#File: E:\bishe\1\AbstractNfsStorage.java
#Comment:
    /**
     * Get the nfsFile holding the metadata for this nfsFile.
     * 
     * @param nfsFile the nfsFile
     * @return the nfsFile holding the metadata
     * @throws IOException
     */

#Code:
    private F getMetaFile(F nfsFile) throws IOException {
        try {
            if (!nfsFile.isDirectory()) {
                return nfsFile.getParentFile().newChildFile(ObjectMetadata.METADATA_DIR).newChildFile(nfsFile.getName());
            } else {
                return nfsFile.newChildFile(ObjectMetadata.METADATA_DIR).newChildFile(ObjectMetadata.DIR_META_FILE);
            }
        } catch (IOException e) {
            throw new ConfigurationException(e);
        }
    }

#No. 3722
#File: E:\bishe\1\AbstractNfsStorage.java
#Comment:
    /**
     * Is the nfsFile a symbolic link?
     * 
     * @param nfsFile the nfsFile
     * @return true if it is, false if not
     * @throws IOException
     */

#Code:
    private boolean isSymLink(F nfsFile) throws IOException {
        return nfsFile.getattr().getAttributes().getType() == NfsType.NFS_LNK;
    }

#No. 3723
#File: E:\bishe\1\AbstractNfsStorage.java
#Comment:
    /**
     * Get the filter.
     * 
     * @return the filter
     */

#Code:
    public NfsFilenameFilter getFilter() {
        return filter;
    }

#No. 3724
#File: E:\bishe\1\AbstractNfsStorage.java
#Comment:
        /**
         * Read the attributes and determine whether the nfsFile has been modified since the indicated time.
         * 
         * @param attributes the attributes
         * @return true if it has, false otherwise.
         */

#Code:
        private boolean hasNotBeenModifiedSince(NfsGetAttributes attributes) {
            return attributes.getMtime().getTimeInMillis() <= modifiedSince.getTime();
        }

#No. 3725
#File: E:\bishe\1\AbstractNgramLanguageModel.java
#Comment:
	/**
	 * Fixed constant returned when computing the log probability for an n-gram
	 * whose last word is not in the vocabulary. Note that this is different
	 * from the log prob of the <code>unk</code> tag probability.
	 * 
	 */

#Code:
	protected float oovWordLogProb;

	public AbstractNgramLanguageModel(final int lmOrder, final WordIndexer<W> wordIndexer, final float oovWordLogProb) {
		this.lmOrder = lmOrder;
		this.wordIndexer = wordIndexer;
		this.oovWordLogProb = oovWordLogProb;
	}

#No. 3726
#File: E:\bishe\1\AbstractNgramMap.java
#Comment:
	/**
	 * @param key
	 * @return
	 */

#Code:
	protected final long contextOffsetOf(final long key) {
		return (key & SUFFIX_BIT_MASK);
	}

#No. 3727
#File: E:\bishe\1\AbstractNgramMap.java
#Comment:
	/**
	 * @param key
	 * @return
	 */

#Code:
	protected final int wordOf(final long key) {
		return (int) ((key & WORD_BIT_MASK) >>> (NUM_SUFFIX_BITS));
	}

#No. 3728
#File: E:\bishe\1\AbstractNgramMap.java
#Comment:
	/**
	 * @param word
	 * @param suffixIndex
	 * @return
	 */

#Code:
	protected final long combineToKey(final int word, final long suffixIndex) {
		final long key = (((long) word) << (NUM_SUFFIX_BITS)) | suffixIndex;
		assert key >= 0 : "Trouble creating key " + word + " :: " + suffixIndex + ". Might need to increase numWordBits.";
		return key;
	}

#No. 3729
#File: E:\bishe\1\AbstractNioBossPool.java
#Comment:
    /**
     * Create a new instance
     *
     * @param bossExecutor the {@link Executor} to use for the {@link Boss}'s
     * @param bossCount the count of {@link Boss}'s to create
     */

#Code:
    AbstractNioBossPool(Executor bossExecutor, int bossCount) {
        this(bossExecutor, bossCount, true);
    }

#No. 3730
#File: E:\bishe\1\AbstractNioChannel.java
#Comment:
    /**
     * Return the {@link AbstractNioWorker} that handle the IO of the
     * {@link AbstractNioChannel}
     *
     * @return worker
     */

#Code:
    public AbstractNioWorker getWorker() {
        return worker;
    }

#No. 3731
#File: E:\bishe\1\AbstractNioSelector.java
#Comment:
    /**
     * Internal Netty logger.
     */

#Code:
    protected static final InternalLogger logger = InternalLoggerFactory
            .getInstance(AbstractNioSelector.class);

    private static final int CLEANUP_INTERVAL = 256; // XXX Hard-coded value, but won't need customization.

    /**
     * Executor used to execute {@link Runnable}s such as channel registration
     * task.
     */
    private final Executor executor;

    /**
     * If this worker has been started thread will be a reference to the thread
     * used when starting. i.e. the current thread when the run method is executed.
     */
    protected volatile Thread thread;

    /**
     * The NIO {@link Selector}.
     */
    protected volatile Selector selector;

    /**
     * Boolean that controls determines if a blocked Selector.select should
     * break out of its selection process. In our case we use a timeone for
     * the select method and the select method will block for that time unless
     * waken up.
     */
    protected final AtomicBoolean wakenUp = new AtomicBoolean();

    private final Queue<Runnable> taskQueue = new ConcurrentLinkedQueue<Runnable>();

    private volatile int cancelledKeys; // should use AtomicInteger but we just need approximation

    private final CountDownLatch shutdownLatch = new CountDownLatch(1);
    private volatile boolean shutdown;

    AbstractNioSelector(Executor executor) {
        this(executor, null);
    }

#No. 3732
#File: E:\bishe\1\AbstractNioSelector.java
#Comment:
    /**
     * Start the {@link AbstractNioWorker} and return the {@link Selector} that will be used for
     * the {@link AbstractNioChannel}'s when they get registered
     */

#Code:
    private void openSelector(ThreadNameDeterminer determiner) {
        try {
            selector = SelectorUtil.open();
        } catch (Throwable t) {
            throw new ChannelException("Failed to create a selector.", t);
        }

        // Start the worker thread with the new Selector.
        boolean success = false;
        try {
            DeadLockProofWorker.start(executor, newThreadRenamingRunnable(id, determiner));
            success = true;
        } finally {
            if (!success) {
                // Release the Selector if the execution fails.
                try {
                    selector.close();
                } catch (Throwable t) {
                    logger.warn("Failed to close a selector.", t);
                }
                selector = null;
                // The method will return to the caller at this point.
            }
        }
        assert selector != null && selector.isOpen();
    }

#No. 3733
#File: E:\bishe\1\AbstractNioSession.java
#Comment:
	/**
	 * �ɷ�IO�¼�
	 */

#Code:
	public final void onEvent(EventType event, Selector selector) {
		if (isClosed()) {
			return;
		}
		SelectionKey key = selectableChannel.keyFor(selector);

		switch (event) {
		case EXPIRED:
			onExpired();
			break;
		case WRITEABLE:
			onWrite(key);
			break;
		case READABLE:
			onRead(key);
			break;
		case ENABLE_WRITE:
			enableWrite(selector);
			break;
		case ENABLE_READ:
			enableRead(selector);
			break;
		case IDLE:
			onIdle();
			break;
		case CONNECTED:
			onConnected();
			break;
		default:
			log.error("Unknown event:" + event.name());
			break;
		}
	}

#No. 3734
#File: E:\bishe\1\AbstractNioWorker.java
#Comment:
    /**
     * Execute the {@link Runnable} in a IO-Thread
     *
     * @param task
     *            the {@link Runnable} to execute
     * @param alwaysAsync
     *            {@code true} if the {@link Runnable} should be executed
     *            in an async fashion even if the current Thread == IO Thread
     */

#Code:
    public void executeInIoThread(Runnable task, boolean alwaysAsync) {
        if (!alwaysAsync && isIoThread()) {
            task.run();
        } else {
            registerTask(task);
        }
    }

#No. 3735
#File: E:\bishe\1\AbstractNonBlockingConnectionManager.java
#Comment:
		/**
		 * @see java.lang.Thread#run()
		 */

#Code:
		@Override
		public void run() {
			for (;;) {
				try {
					selector.select();
					for (SocketChannel client = newConnections.poll(); client != null; client = newConnections.poll()) {
						ChannelInfo info = new ChannelInfo();
						SelectionKey key = client.register(selector, SelectionKey.OP_READ, info);
						channelReady(key, info);
					}

					Set<SelectionKey> keys = selector.selectedKeys();
					for (SelectionKey key : keys) {
						handleKey(key);
					}

					keys.clear();
				} catch (Exception e) {
					System.err.println("IO Failure. Exiting...");
					e.printStackTrace();
					System.exit(1);
				}
			}
		}

#No. 3736
#File: E:\bishe\1\AbstractNormalizedNodeBodyReader.java
#Comment:
/**
 * Common superclass for readers producing {@link NormalizedNodeContext}.
 *
 * @author Robert Varga
 */

#Code:
@Beta
public abstract class AbstractNormalizedNodeBodyReader
        extends AbstractIdentifierAwareJaxRsProvider<NormalizedNodeContext> {

    public final void injectParams(final UriInfo uriInfo, final Request request) {
        setUriInfo(uriInfo);
        setRequest(request);
    }

    @Override
    protected final NormalizedNodeContext emptyBody(final InstanceIdentifierContext<?> path) {
        return new NormalizedNodeContext(path, null);
    }
}

#No. 3737
#File: E:\bishe\1\AbstractNotificationCheckReceiver.java
#Comment:
    /**
     * The preference wherein all notification services store their stuff.
     */

#Code:
    protected static final String PREFS_NOTIFICATIONS_SERVICE = "notification-service";

    /**
     * Number of notifications we display at most.
     */
    protected static final int MAX_DISPLAYED_NOTIFICATIONS = 5;

    public enum NotificationId {
        MESSAGES, WON, NO_TYPE
    }

#No. 3738
#File: E:\bishe\1\AbstractNotificationCheckReceiver.java
#Comment:
    /**
     * Check if we should run the network task.
     *
     * @param tag     tag to be used for logging
     * @param context context of the broadcast receiver's onReceive
     * @return true if we should execute the network task, false otherwise
     */

#Code:
    protected static boolean shouldRunNetworkTask(final String tag, final Context context) {
        boolean notificationsEnabled = PreferenceManager.getDefaultSharedPreferences(context).getBoolean(DEFAULT_PREF_NOTIFICATIONS_ENABLED, true);
        if (!notificationsEnabled) {
            Log.v(tag, "Notifications disabled");
            return false;
        }

        SteamGiftsUserData userData = SteamGiftsUserData.getCurrent(context);
        if (!userData.isLoggedIn()) {
            Log.v(tag, "Not checking for remote data, no session info available");
            return false;
        }

        ConnectivityManager cm = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
        NetworkInfo activeNetworkInfo = cm.getActiveNetworkInfo();
        if (activeNetworkInfo == null || !activeNetworkInfo.isConnected() || activeNetworkInfo.getType() != ConnectivityManager.TYPE_WIFI) {
            Log.v(tag, "Not checking for messages due to network info: " + activeNetworkInfo);
            return false;
        }

        return true;
    }

#No. 3739
#File: E:\bishe\1\AbstractNotificationCheckReceiver.java
#Comment:
    /**
     * Display a notification for a single item.
     *
     * @param context        receiver context
     * @param notificationId the notification id to replace (should be unique per class)
     * @param iconResource   icon to display along with the notification
     * @param title          title
     * @param content        text to display in the notification
     * @param viewIntent     what happens when clicking the notification
     * @param deleteIntent   what happens when dismissing the notification
     */

#Code:
    protected static void showNotification(Context context, NotificationId notificationId, @DrawableRes int iconResource, String title, CharSequence content, PendingIntent viewIntent, PendingIntent deleteIntent) {
        Notification notification = new NotificationCompat.Builder(context)
                .setSmallIcon(iconResource)
                .setPriority(NotificationCompat.PRIORITY_LOW)
                .setCategory(NotificationCompat.CATEGORY_SOCIAL)
                .setContentTitle(title)
                .setContentText(content)
                .setStyle(new NotificationCompat.BigTextStyle().bigText(content)) /* 4.1+ */
                .setContentIntent(viewIntent)
                .setDeleteIntent(deleteIntent)
                .setAutoCancel(true)
                .build();

        showNotification(context, notificationId, notification);
    }

#No. 3740
#File: E:\bishe\1\AbstractNotificationCheckReceiver.java
#Comment:
    /**
     * Display a notification for multiple items.
     *
     * @param context        receiver context
     * @param notificationId the notification id to replace (should be unique per class)
     * @param iconResource   icon to display along with the notification
     * @param title          title
     * @param content        texts to display in the notification
     * @param viewIntent     what happens when clicking the notification
     * @param deleteIntent   what happens when dismissing the notification
     */

#Code:

    protected static void showNotification(Context context, NotificationId notificationId, @DrawableRes int iconResource, String title, List<CharSequence> content, PendingIntent viewIntent, PendingIntent deleteIntent) {
        NotificationCompat.InboxStyle inboxStyle = new NotificationCompat.InboxStyle();
        for (CharSequence c : content)
            inboxStyle.addLine(c);

        Notification notification = new NotificationCompat.Builder(context)
                .setSmallIcon(iconResource)
                .setPriority(NotificationCompat.PRIORITY_LOW)
                .setCategory(NotificationCompat.CATEGORY_SOCIAL)
                .setContentTitle(title)
                .setContentText(content.get(0))
                .setStyle(inboxStyle) /* 4.1+ */
                .setNumber(SteamGiftsUserData.getCurrent(context).getMessageNotification())
                .setContentIntent(viewIntent)
                .setDeleteIntent(deleteIntent)
                .setAutoCancel(true)
                .build();

        showNotification(context, notificationId, notification);
    }

#No. 3741
#File: E:\bishe\1\AbstractNotificationCheckReceiver.java
#Comment:
    /**
     * Show the built notification in the systray.
     *
     * @param context        receiver context
     * @param notificationId notification id to use for this notification
     * @param notification   notification to display
     */

#Code:
    private static void showNotification(Context context, NotificationId notificationId, Notification notification) {
        ((NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE)).notify(notificationId.ordinal(), notification);
    }

#No. 3742
#File: E:\bishe\1\AbstractNotificationInterruptionFilterCommand.java
#Comment:
/*
    This file is part of Project MAXS.

    MAXS and its modules is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    MAXS is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with MAXS.  If not, see <http://www.gnu.org/licenses/>.
 */

#Code:

package org.projectmaxs.module.notificationpolicyaccess.commands;

import org.projectmaxs.module.notificationpolicyaccess.ModuleService;

public abstract class AbstractNotificationInterruptionFilterCommand
		extends AbstractNotificationManagerCommand {

	protected AbstractNotificationInterruptionFilterCommand(String name) {
		super(ModuleService.NOTIFICATION_INTERRUPTION_FILTER, name);
	}

	protected AbstractNotificationInterruptionFilterCommand(String name,
			boolean isDefaultWithoutArguments) {
		super(ModuleService.NOTIFICATION_INTERRUPTION_FILTER, name, isDefaultWithoutArguments);
	}

}

#No. 3743
#File: E:\bishe\1\AbstractNotificationInterruptionFilterSetCommand.java
#Comment:
/*
    This file is part of Project MAXS.

    MAXS and its modules is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    MAXS is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with MAXS.  If not, see <http://www.gnu.org/licenses/>.
 */

#Code:

package org.projectmaxs.module.notificationpolicyaccess.commands;

import org.projectmaxs.shared.global.Message;
import org.projectmaxs.shared.mainmodule.Command;
import org.projectmaxs.shared.module.MAXSModuleIntentService;

import android.app.NotificationManager;

public abstract class AbstractNotificationInterruptionFilterSetCommand
		extends AbstractNotificationInterruptionFilterCommand {

	private final int notificationInterruptionFilter;
	private final String notificationInterruptionFilterName;

	protected AbstractNotificationInterruptionFilterSetCommand(String name) {
		super(name);
		notificationInterruptionFilter = interruptionFilterToInt(name);
		notificationInterruptionFilterName = name;
	}

	@Override
	protected final Message execute(String arguments, Command command,
			MAXSModuleIntentService service, NotificationManager notificationManager) {
		notificationManager.setInterruptionFilter(notificationInterruptionFilter);

		return new Message("Notification interruption filter set to '"
				+ notificationInterruptionFilterName + '\'');
	}
}

#No. 3744
#File: E:\bishe\1\AbstractNPointCrossoverReproductionOperator.java
#Comment:
    /**
     * Prepares cut point flag array for determination whether to keep value of the first parent or the second.
     * @param numCrossings - number of cut points to generate
     * @param arrayLength - length of output array
     * @return array of flags describing whether the parent should keep his gene or not. (true means to keep it gene, false means to receive gene from second parent)
     */

#Code:
    protected boolean[] makeCutPointFlags(int numCrossings, int arrayLength){
        int[] indexes = new int[numCrossings];
        // trivial case when numCrossings is by one smaller than dimension count
        if ((numCrossings + 1) == arrayLength){
            for (int i = 0; i < numCrossings; i++){
                indexes[i] = i + 1;
            }
        } else {
            // generating of cross points into set which is ordered and then transform it into int[].
            Set<Integer> indexSet = new TreeSet<Integer>();
            while (indexSet.size() < numCrossings){
                indexSet.add(this.randomGenerator.nextInt(1, arrayLength));
            }

            // probably the best solution without creating temporary Integer[] array from indexSet
            int idx = 0;
            for (Integer integer : indexSet){
                indexes[idx++] = integer;
            }
        }
        // we have generated cross points and now can generate boolean flag array
        boolean[] flagArray = new boolean[arrayLength];
        boolean flag = true;
        int index = 0;
        for (int i = 0; i < arrayLength; i++){
            // if at inverting position then invert and shift index
            if (index < numCrossings && indexes[index] == i){
                flag = !flag;
                index++;
            }
            flagArray[i] = flag;
        }
        return flagArray;
    }

#No. 3745
#File: E:\bishe\1\AbstractNQLFunction.java
#Comment:
  /**
   * @param arguments
   * @param min
   * @param max
   */

#Code:
  protected void assertNumberOfArguments(List<NQLObject> arguments, int min, int max)
  {
    if (arguments == null || arguments.size() < min || arguments.size() > max)
    {
      if (min == max)
        throw new TypeError(getName() + " requires " + min + " arguments");
      else
        throw new TypeError(getName() + " requires at least " + min + " arguments, max "
            + max);
    }
  }

#No. 3746
#File: E:\bishe\1\AbstractNQLFunction.java
#Comment:
  /**
   * @param argument
   * @return
   */

#Code:
  protected int getAsInt(NQLObject argument)
  {
    if (!(argument instanceof Numeric))
      throw new TypeError(argument, "expected a number, not '%s'");

    return ((Numeric) argument).getAsInt();
  }

#No. 3747
#File: E:\bishe\1\AbstractNQLFunction.java
#Comment:
  /**
   * @param argument
   * @return
   */

#Code:
  protected Collection getAsCollection(NQLObject argument)
  {
    if (!(argument instanceof Collection))
      throw new TypeError(argument, "'%s' is not iterable");

    return ((Collection) argument);
  }

#No. 3748
#File: E:\bishe\1\AbstractNQLFunction.java
#Comment:
  /**
   * @param argument
   * @return
   */

#Code:
  protected boolean getAsBoolean(NQLObject argument)
  {
    return EvalHandler.isTrue(argument);
  }

#No. 3749
#File: E:\bishe\1\AbstractNQLFunction.java
#Comment:
  /**
   * @param argument
   * @return
   */

#Code:
  protected float getAsFloat(NQLObject argument)
  {
    if (!(argument instanceof Numeric))
      throw new TypeError(argument, "expected a number, not '%s'");

    return ((Numeric) argument).getAsFloat();
  }

#No. 3750
#File: E:\bishe\1\AbstractNQLFunction.java
#Comment:
  /**
   * @param argument
   * @return
   */

#Code:
  protected long getAsLong(NQLObject argument)
  {
    if (!(argument instanceof Numeric))
      throw new TypeError(argument, "expected a number, not '%s'");

    return ((Numeric) argument).getAsLong();
  }

#No. 3751
#File: E:\bishe\1\AbstractNQLFunction.java
#Comment:
  /**
   * @param argument
   * @return
   */

#Code:
  protected String getAsString(NQLObject argument)
  {
    return argument.str();
  }

#No. 3752
#File: E:\bishe\1\AbstractNQLQueryBuilder.java
#Comment:
  /**
   * @param e
   * @return
   */

#Code:
  public NQLObject eval(Expn e)
  {
    EvalVisitor eval = new EvalVisitor(_pool, ImmutableMap.copyOf(getSymbolMap()));
    ExpnVisitor<NQLObject> proxied = EvalVisitorErrorProxy.createProxiedEvalVisitor(eval);

    NQLObject result = e.accept(proxied);

    if (log.isDebugEnabled())
      log.debug("eval:" + eval.getEvalStack());

    return result;
  }

#No. 3753
#File: E:\bishe\1\AbstractNrsTestFixture.java
#Comment:
    /**
     * @return the configuration
     */

#Code:
    protected final MetaConfiguration getConfiguration() {
        return helper.getConfiguration();
    }

#No. 3754
#File: E:\bishe\1\AbstractNumberValidator.java
#Comment:
    /**
     * <p>Returns a <code>NumberFormat</code> for the specified <i>pattern</i>
     *    and/or <code>Locale</code>.</p>
     *
     * @param pattern The pattern used to validate the value against or
     *        <code>null</code> to use the default for the <code>Locale</code>.
     * @param locale The locale to use for the currency format, system default if null.
     * @return The <code>NumberFormat</code> to created.
     */

#Code:
    protected Format getFormat(String pattern, Locale locale) {

        NumberFormat formatter = null;
        boolean usePattern = (pattern != null && pattern.length() > 0);
        if (!usePattern) {
            formatter = (NumberFormat)getFormat(locale);
        } else if (locale == null) {
            formatter =  new DecimalFormat(pattern);
        } else {
            DecimalFormatSymbols symbols = new DecimalFormatSymbols(locale);
            formatter = new DecimalFormat(pattern, symbols);
        }

        if (determineScale(formatter) == 0) {
            formatter.setParseIntegerOnly(true);
        }
        return formatter;
    }

#No. 3755
#File: E:\bishe\1\AbstractNumberValidator.java
#Comment:
    /**
     * <p>Returns the <i>multiplier</i> of the <code>NumberFormat</code>.</p>
     *
     * @param format The <code>NumberFormat</code> to determine the
     *        multiplier of.
     * @return The multiplying factor for the format..
     */

#Code:
    protected int determineScale(NumberFormat format) {
        if (!isStrict()) {
            return -1;
        }
        if (!isAllowFractions() || format.isParseIntegerOnly()) {
            return 0;
        }
        int minimumFraction = format.getMinimumFractionDigits();
        int maximumFraction = format.getMaximumFractionDigits();
        if (minimumFraction != maximumFraction) {
            return -1;
        }
        int scale = minimumFraction;
        if (format instanceof DecimalFormat) {
            int multiplier = ((DecimalFormat)format).getMultiplier();
            if (multiplier == 100) {
                scale += 2;
            } else if (multiplier == 1000) {
                scale += 3;
            }
        } else if (formatType == PERCENT_FORMAT) {
            scale += 2;
        }
        return scale;
    }

#No. 3756
#File: E:\bishe\1\AbstractNumberValidator.java
#Comment:
    /**
     * <p>Returns a <code>NumberFormat</code> for the specified Locale.</p>
     *
     * @param locale The locale a <code>NumberFormat</code> is required for,
     *   system default if null.
     * @return The <code>NumberFormat</code> to created.
     */

#Code:
    protected Format getFormat(Locale locale) {
        NumberFormat formatter = null;
        switch (formatType) {
        case CURRENCY_FORMAT:
            if (locale == null) {
                formatter = NumberFormat.getCurrencyInstance();
            } else {
                formatter = NumberFormat.getCurrencyInstance(locale);
            }
            break;
        case PERCENT_FORMAT:
            if (locale == null) {
                formatter = NumberFormat.getPercentInstance();
            } else {
                formatter = NumberFormat.getPercentInstance(locale);
            }
            break;
        default:
            if (locale == null) {
                formatter = NumberFormat.getInstance();
            } else {
                formatter = NumberFormat.getInstance(locale);
            }
            break;
        }
        return formatter;
    }

#No. 3757
#File: E:\bishe\1\AbstractNumerical.java
#Comment:
    /**
     * Defined a common method use in sub class 
     * 
     * @param factor the operand
     */

#Code:
    protected void pushFactorToStack(MethodExecuteContext context, KernelParam factor) {

    	IClass factorCls = factor.getResultType();
        Instructions instructions = context.getInstructions();
        // factor to stack
        LOG.print("push the first arithmetic factor to stack");
        factor.push(context);

        IClass factorPrimitiveAClass = factorCls;
        // unbox if needs
        if (!factorCls.isPrimitive()) {
            LOG.print("unbox " + factorCls);
            instructions.unbox(factorCls.getType());
            factorPrimitiveAClass = IClassUtils.getPrimitiveAClass(factorCls);
        }

        // cast if needs
        if (factorPrimitiveAClass.getCastOrder() < targetClass.getCastOrder()
                && targetClass.getCastOrder() > getType(int.class).getCastOrder()) {
            LOG.print("cast factor from " + factorCls + " to " + targetClass);
            instructions.cast(factorPrimitiveAClass.getType(), targetClass.getType());
        }
    }

#No. 3758
#File: E:\bishe\1\AbstractOAuthConsumer.java
#Comment:
    /**
     * <p>
     * Helper method that adds any OAuth parameters to the given request
     * parameters which are missing from the current request but required for
     * signing. A good example is the oauth_nonce parameter, which is typically
     * not provided by the client in advance.
     * </p>
     * <p>
     * It's probably not a very good idea to override this method. If you want
     * to generate different nonces or timestamps, override
     * {@link #generateNonce()} or {@link #generateTimestamp()} instead.
     * </p>
     * 
     * @param out
     *        the request parameter which should be completed
     */

#Code:
    protected void completeOAuthParameters(HttpParameters out) {
        if (!out.containsKey(OAuth.OAUTH_CONSUMER_KEY)) {
            out.put(OAuth.OAUTH_CONSUMER_KEY, consumerKey, true);
        }
        if (!out.containsKey(OAuth.OAUTH_SIGNATURE_METHOD)) {
            out.put(OAuth.OAUTH_SIGNATURE_METHOD, messageSigner.getSignatureMethod(), true);
        }
        if (!out.containsKey(OAuth.OAUTH_TIMESTAMP)) {
            out.put(OAuth.OAUTH_TIMESTAMP, generateTimestamp(), true);
        }
        if (!out.containsKey(OAuth.OAUTH_NONCE)) {
            out.put(OAuth.OAUTH_NONCE, generateNonce(), true);
        }
        if (!out.containsKey(OAuth.OAUTH_VERSION)) {
            out.put(OAuth.OAUTH_VERSION, OAuth.VERSION_1_0, true);
        }
        if (!out.containsKey(OAuth.OAUTH_TOKEN)) {
            if (token != null && !token.equals("") || sendEmptyTokens) {
                out.put(OAuth.OAUTH_TOKEN, token, true);
            }
        }
    }

#No. 3759
#File: E:\bishe\1\AbstractOAuthConsumer.java
#Comment:
    /**
     * Collects OAuth Authorization header parameters as per OAuth Core 1.0 spec
     * section 9.1.1
     */

#Code:
    protected void collectHeaderParameters(HttpRequest request, HttpParameters out) {
        HttpParameters headerParams = OAuth.oauthHeaderToParamsMap(request.getHeader(OAuth.HTTP_AUTHORIZATION_HEADER));
        out.putAll(headerParams, false);
    }

#No. 3760
#File: E:\bishe\1\AbstractOAuthConsumer.java
#Comment:
    /**
     * Collects x-www-form-urlencoded body parameters as per OAuth Core 1.0 spec
     * section 9.1.1
     */

#Code:
    protected void collectBodyParameters(HttpRequest request, HttpParameters out)
            throws IOException {

        // collect x-www-form-urlencoded body params
        String contentType = request.getContentType();
        if (contentType != null && contentType.startsWith(OAuth.FORM_ENCODED)) {
            InputStream payload = request.getMessagePayload();
            out.putAll(OAuth.decodeForm(payload), true);
        }
    }

#No. 3761
#File: E:\bishe\1\AbstractOAuthConsumer.java
#Comment:
    /**
     * Collects HTTP GET query string parameters as per OAuth Core 1.0 spec
     * section 9.1.1
     */

#Code:
    protected void collectQueryParameters(HttpRequest request, HttpParameters out) {

        String url = request.getRequestUrl();
        int q = url.indexOf('?');
        if (q >= 0) {
            // Combine the URL query string with the other parameters:
            out.putAll(OAuth.decodeForm(url.substring(q + 1)), true);
        }
    }

#No. 3762
#File: E:\bishe\1\AbstractObjectInput.java
#Comment:
    /**
     * Read and return an object, cast to a specific type.
     *
     * @param type the object class
     * @param <T> the object type
     * @return the object read from the stream
     * @throws ClassNotFoundException if the class of a serialized object cannot be found
     * @throws InvalidObjectException if the object is not of the expected type
     * @throws IOException if an error occurs
     */

#Code:
    public <T> T readObject(final Class<T> type) throws ClassNotFoundException, IOException {
        final Object obj = doReadObject(false);
        try {
            return type.cast(obj);
        } catch (ClassCastException e) {
            throw wrongType(e, type, obj.getClass());
        }
    }

#No. 3763
#File: E:\bishe\1\AbstractObjectInput.java
#Comment:
    /**
     * Read and return an unshared object, cast to a specific type.
     *
     * @param type the object class
     * @param <T> the object type
     * @return an unshared object
     * @throws ClassNotFoundException if the class of a serialized object cannot be found
     * @throws InvalidObjectException if the object is not of the expected type
     * @throws IOException if an error occurs
     */

#Code:
    public <T> T readObjectUnshared(final Class<T> type) throws ClassNotFoundException, IOException {
        final Object obj = doReadObject(true);
        try {
            return type.cast(obj);
        } catch (ClassCastException e) {
            throw wrongType(e, type, obj.getClass());
        }
    }

#No. 3764
#File: E:\bishe\1\AbstractObjectOutput.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public void writeObjectUnshared(Object obj) throws IOException {
        doWriteObject(obj, true);
    }

#No. 3765
#File: E:\bishe\1\AbstractObjectOutput.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public void writeObject(Object obj) throws IOException {
        doWriteObject(obj, false);
    }

#No. 3766
#File: E:\bishe\1\AbstractObjectSet.java
#Comment:
 /** Returns a hash code for this set.
	 *
	 * The hash code of a set is computed by summing the hash codes of
	 * its elements.
	 *
	 * @return a hash code for this set.
	 */

#Code:
 public int hashCode() {
  int h = 0, n = size();
  ObjectIterator <K> i = iterator();
  K k;
  while( n-- != 0 ) {
   k = i.next(); // We need k because KEY2JAVAHASH() is a macro with repeated evaluation.
   h += ( (k) == null ? 0 : (k).hashCode() );
  }
  return h;
 }

#No. 3767
#File: E:\bishe\1\AbstractObjectTypeRegistryModule.java
#Comment:
    /**
     * Gets the {@link T} for the specified type class of the type {@link O}.
     *
     * @param clazz The value class
     * @return The object type
     */

#Code:
    public Optional<T> getByClass(Class<? extends O> clazz) {
        return Optional.ofNullable(this.byClass.get(checkNotNull(clazz, "clazz")));
    }

#No. 3768
#File: E:\bishe\1\AbstractOnDiskBinding.java
#Comment:
    /**
     * Writes credentials under a given temporary directory, and returns their path (will be bound to the variable).
     * @param credentials the credentials to bind
     * @param dir a temporary directory where credentials should be written. You can assume it has already been created,
     *            with secure permissions.
     * @return the path to the on-disk credentials, to be bound to the variable
     * @throws IOException
     * @throws InterruptedException
     */

#Code:
    abstract protected FilePath write(C credentials, FilePath dir) throws IOException, InterruptedException;

}
}

#No. 3769
#File: E:\bishe\1\AbstractOntologyEntryUnloader.java
#Comment:
	/**
	 * Unloads the source.
	 */

#Code:
	@Override
	public boolean queue ( OE oe ) 
	{
		if ( !super.queue ( oe ) ) return false;
		ReferenceSource source = oe.getSource ();
		unloadManager.queue ( source );
		return true;
	}

#No. 3770
#File: E:\bishe\1\AbstractOpenAction.java
#Comment:
    /**
     * @param viewer
     */

#Code:
    protected void runWithViewer(ITextViewer viewer) {
        if(viewer == null){
            return;
        }
        ISelectionProvider selProvider = viewer.getSelectionProvider();
        IDocument doc = viewer.getDocument();
        handleAction(doc, selProvider, null);
    }

#No. 3771
#File: E:\bishe\1\AbstractOpenAction.java
#Comment:
    /**
     * @param cv
     */

#Code:
    private void doPageBookViewAction(PageBookView cv){
        IPage page = cv.getCurrentPage();
        runWithViewer(EditorPropertyTester.getViewer(page));
    }

#No. 3772
#File: E:\bishe\1\AbstractOpenShiftBinaryCapability.java
#Comment:
	/**
	 * @return
	 */

#Code:
	protected String getServerFlag() {
		final StringBuilder argBuilder = new StringBuilder();
		argBuilder.append("--server=").append(client.getBaseURL()).append(" ");
		return argBuilder.toString();
	}

#No. 3773
#File: E:\bishe\1\AbstractOpenShiftBinaryCapability.java
#Comment:
	/**
	 * Adds the authentication token
	 * @return the command-line argument to use the current token 
	 */

#Code:
	protected String getTokenFlag() {
		return new StringBuilder("--token=")
			.append(client.getAuthorizationContext().getToken())
			.append(" ").toString();
	}

#No. 3774
#File: E:\bishe\1\AbstractOpenShiftBinaryCapability.java
#Comment:
	/**
	 * @return the command-line flag to use insecure connection (skip TLS verification)
	 */

#Code:
	protected String getSkipTlsVerifyFlag() {
		return "--insecure-skip-tls-verify=true ";
	}

#No. 3775
#File: E:\bishe\1\AbstractOpenShiftBinaryCapability.java
#Comment:
	/**
	 * @return the command-line flag to exclude some files/directories that do
	 *         not need to be synchronized between the remote pod and the local
	 *         deployment directory.
	 */

#Code:
	protected String getGitFolderExclusionFlag() {
		// no support for multiple exclusion, so excluding '.git' only for now
		// see https://github.com/openshift/origin/issues/8223
		return "--exclude='.git' ";
	}

#No. 3776
#File: E:\bishe\1\AbstractOpenShiftBinaryCapability.java
#Comment:
	/**
	 * @return the command-line flag to avoid transferring permissions.
	 */

#Code:
	protected String getNoPermsFlags() {
		return "--no-perms=true ";
	}

#No. 3777
#File: E:\bishe\1\AbstractOpenShiftBinaryCapability.java
#Comment:
	/**
	 * @return the command-line flag to delete extraneous file from destination directories.
	 */

#Code:
	protected String getDeleteFlags() {
		return "--delete ";
	}

#No. 3778
#File: E:\bishe\1\AbstractOpenShiftBinaryCapability.java
#Comment:
	/**
	 * Starts the {@link Process} to run the {@code oc} command.
	 * @param options the command line options
	 */

#Code:
	public final void start(final OpenShiftBinaryOption... options) {
		String location = getOpenShiftBinaryLocation();
		if(!validate()) {
			return;
		}
		ProcessBuilder processBuilder = initProcessBuilder(location, options);
		startProcess(processBuilder);
	}

#No. 3779
#File: E:\bishe\1\AbstractOpenShiftBinaryCapability.java
#Comment:
	/**
	 * Stops the {@link Process} running the {@code oc} command.
	 */

#Code:
	public final synchronized void stop() {
		if(process == null) return;
		cleanup();
		if(!process.isAlive()) {
			final int exitValue = process.exitValue();
			LOG.debug("OpenShiftBinaryCapability process exit code {}", exitValue);
			if(exitValue != 0) {
				try {
					LOG.debug("OpenShiftBinaryCapability process error stream", IOUtils.toString(process.getErrorStream()));
				} catch (IOException e) {
					LOG.debug("IOException trying to debug the process error stream", e);
				}
			}
			process = null;
			return;
		}
		process.destroyForcibly();
	}

#No. 3780
#File: E:\bishe\1\AbstractOperationCallStub.java
#Comment:
  /**
   * Returns the data captured by this stub as a {@link Data} instance which enables further sorting, filtering, and
   * transformation.
   */

#Code:
  public Data result() {
    List<Tuple> output = new ArrayList<Tuple>();
    for (TupleEntry entry : collected) {
      output.add(entry.getTupleCopy());
    }
    return new Data(declaredFields, Collections.unmodifiableList(output));
  }

#No. 3781
#File: E:\bishe\1\AbstractOperationInterceptor.java
#Comment:
    /**
     * 更新一下事务标记
     */

#Code:
    private void updateMark(DbLoadContext context, DbDialect dialect, int threadId, String sql) {
        String markTableName = ClaveConfig.SYSTEM_SCHEMA + "." + ClaveConfig.SYSTEM_MARK_TABLE;
        String markTableColumn = ClaveConfig.SYSTEM_TABLE_MARK_ID_COLUMN;
        synchronized (dialect.getJdbcTemplate()) {
            if (tableCheckStatus.contains(dialect.getJdbcTemplate()) == false) {
                init(dialect.getJdbcTemplate(), markTableName, markTableColumn);
                tableCheckStatus.add(dialect.getJdbcTemplate());
            }
        }

        int affectedCount = dialect.getJdbcTemplate().update(
                                                             MessageFormat.format(sql, new Object[] { markTableName,
                                                                     markTableColumn }),
                                                             new Object[] { threadId, serverId });
        if (affectedCount <= 0) {
            logger.warn("## update {} failed by [{}]", markTableName, threadId);
        }
    }

#No. 3782
#File: E:\bishe\1\AbstractOptimizer.java
#Comment:
    /**
     * Trim off any whitespace.
     */

#Code:
    return new String(expr, tkStart = trimRight(tkStart), trimLeft(cursor) - tkStart);
  }

  /**
   * Skip to the next non-whitespace position.
   */
  protected void whiteSpaceSkip() {
    if (cursor < length)
      //noinspection StatementWithEmptyBody
      while (isWhitespace(expr[cursor]) && ++cursor != length) ;
  }

#No. 3783
#File: E:\bishe\1\AbstractOptimizer.java
#Comment:
  /**
   * @param c - character to scan to.
   * @return - returns true is end of statement is hit, false if the scan scar is countered.
   */

#Code:
  protected boolean scanTo(char c) {
    for (; cursor < end; cursor++) {
      switch (expr[cursor]) {
        case '\'':
        case '"':
          cursor = captureStringLiteral(expr[cursor], expr, cursor, end);
        default:
          if (expr[cursor] == c) {
            return false;
          }
      }
    }
    return true;
  }

#No. 3784
#File: E:\bishe\1\AbstractOptionalValue.java
#Comment:
  /**
   * Override to define optional getter
   */

#Code:
  public abstract Optional<T> getMaybe();

  @Override
  public T get() {
    return getMaybe().get();
  }

#No. 3785
#File: E:\bishe\1\AbstractOptionPanel.java
#Comment:
	/**
	 * Instantiates a new abstract option panel.
	 * 
	 * @param context
	 *           the context
	 */

#Code:
	public AbstractOptionPanel( IAviaryController context, ToolEntry entry ) {
		super( context, entry );
	}

#No. 3786
#File: E:\bishe\1\AbstractOptionPanel.java
#Comment:
	/**
	 * Gets the panel option view.
	 * 
	 * @return the option view
	 */

#Code:
	public final ViewGroup getOptionView() {
		return mOptionView;
	}

#No. 3787
#File: E:\bishe\1\AbstractOptionPanel.java
#Comment:
	/**
	 * Disable vibration feedback for each view in the passed array if necessary
	 * 
	 * @param views
	 */

#Code:
	protected void disableHapticIsNecessary( VibrationWidget... views ) {
		boolean vibration = true;
		
		LocalDataService dataService = getContext().getService( LocalDataService.class );
		
		if ( dataService.getIntentContainsKey( Constants.EXTRA_TOOLS_DISABLE_VIBRATION ) ) {
			vibration = false;
		} else {
			PreferenceService pref_service = getContext().getService( PreferenceService.class );
			if ( null != pref_service ) {
				if ( pref_service.isStandalone() ) {
					vibration = pref_service.getStandaloneBoolean( "feather_app_vibration", true );
				}
			}
		}

		for ( VibrationWidget view : views ) {
			view.setVibrationEnabled( vibration );
		}
	}

#No. 3788
#File: E:\bishe\1\AbstractOptions.java
#Comment:
    /**
     * Resizes when the canvas container does.
     */

#Code:
    public T responsive(boolean responsive) {
        this.responsive = responsive;
        return getThis();
    }

#No. 3789
#File: E:\bishe\1\AbstractOptions.java
#Comment:
    /**
     * Maintain the original canvas aspect ratio (width / height) when resizing
     */

#Code:
    public T maintainAspectRatio(boolean maintainAspectRatio) {
        this.maintainAspectRatio = maintainAspectRatio;
        return getThis();
    }

#No. 3790
#File: E:\bishe\1\AbstractOptions.java
#Comment:
    /**
     * Duration in milliseconds it takes to animate to new size after a resize event.
     */

#Code:
    public T responsiveAnimationDuration(int responsiveAnimationDurationMs) {
        this.responsiveAnimationDuration = responsiveAnimationDurationMs;
        return getThis();
    }

#No. 3791
#File: E:\bishe\1\AbstractOptions.java
#Comment:
    /**
     * Events that the chart should listen to for tooltips and hovering
     */

#Code:
    public T events(String... events) {
        this.events = Arrays.asList(events);
        return getThis();
    }

#No. 3792
#File: E:\bishe\1\AbstractOptions.java
#Comment:
    /**
     * Step into the charts title configuration
     */

#Code:
    public Title<T> title() {
        if (title == null) {
            title = new Title<>(getThis());
        }
        return title;
    }

#No. 3793
#File: E:\bishe\1\AbstractOptions.java
#Comment:
    /**
     * Step into the charts animation configuration
     */

#Code:
    public Animation<T> animation() {
        if (animation == null) {
            animation = new Animation<>(getThis());
        }
        return animation;
    }

#No. 3794
#File: E:\bishe\1\AbstractOptions.java
#Comment:
    /**
     * Step into the charts hover configuration
     */

#Code:
    public Hover<T> hover() {
        if (hover == null) {
            hover = new Hover<>(getThis());
        }
        return hover;
    }

#No. 3795
#File: E:\bishe\1\AbstractOptions.java
#Comment:
    /**
     * Step into the charts tooltip configuration
     */

#Code:
    public Tooltips<T> tooltips() {
        if (tooltips == null) {
            tooltips = new Tooltips<>(getThis());
        }
        return tooltips;
    }

#No. 3796
#File: E:\bishe\1\AbstractOptions.java
#Comment:
    /**
     * Step into the charts legend configuration
     */

#Code:
    public Legend<T> legend() {
        if (legend == null) {
            legend = new Legend<>(getThis());
        }
        return legend;
    }

#No. 3797
#File: E:\bishe\1\AbstractOptions.java
#Comment:
    /**
     * Step into the charts elements configuration
     */

#Code:
    public Element<T> elements() {
        if (elements == null) {
            elements = new Element<>(getThis());
        }
        return elements;
    }

#No. 3798
#File: E:\bishe\1\AbstractOrderCallback.java
#Comment:
/**
 * An abstract implementation of the {@link HibernateCallback} interface which
 * is concerned with an ordered query callback. Means to order by a specific
 * property name and determine the order direction are provided as well as a
 * method to populate the underlying {@link GenericCriteria} as denoted by
 * implementing the {@link CriteriaCallback} interface.
 * 
 * @author Erez Mazor (erezmazor@gmail.com)
 * @param <T>
 *          the type of the entity supported by this callback
 */

#Code:

public abstract class AbstractOrderCallback<T> implements HibernateCallback<List<T>>,
    CriteriaCallback {

  private final String property;
  private final boolean isAscending;
  private final Class<T> clazz;

  public AbstractOrderCallback(final String property, final boolean isAscending,
      final Class<T> clazz) {
    Assert.hasText(property, "property must contain text");
    Assert.notNull(clazz, "clazz cannot be null");
    this.property = property;
    this.isAscending = isAscending;
    this.clazz = clazz;
  }

  @Override
  public List<T> doInHibernate(final Session session) throws HibernateException, SQLException {
    final GenericCriteria<T> criteria = new GenericCriteria<T>(session, clazz);
    final Order order = isAscending ? Order.asc(property) : Order.desc(property);
    criteria.addOrder(order);
    prepare(criteria);
    return criteria.list();
  }
}
#No. 3799
#File: E:\bishe\1\AbstractOrderedInputSpout.java
#Comment:
	/**
	 * Makes a new output tuple available.
	 * 
	 * Must be used by {@link #nextTuple()} instead of an {@link SpoutOutputCollector} to emit tuples. In each call, all
	 * tuples that are still buffered over all partitions are considered to be emitted to the default output stream.
	 * 
	 * @param index
	 *            The partition id the tuple belongs to.
	 * @param timestamp
	 *            The timestamp of the tuple.
	 * @param tuple
	 *            The tuple to be emitted.
	 * 
	 * @return A map of all tuple that got emitted during this call including the task IDs each emitted tuple was sent
	 *         to.
	 */

#Code:
	// TODO: add support for non-default and/or multiple output streams (what about directEmit(...)?)
	protected final Map<Values, List<Integer>> emitNextTuple(Integer index, Long timestamp, T tuple) {
		logger.trace("Received new output tuple (partitionId, ts, tuple): {}, {}, {}", index, timestamp, tuple);
		if(index != null && timestamp != null && tuple != null) {
			this.merger.addTuple(index, new Values(timestamp, tuple));
		}
		
		Values t;
		Map<Values, List<Integer>> emitted = new HashMap<Values, List<Integer>>();
		while((t = this.merger.getNextTuple()) != null) {
			logger.trace("Emitting tuple: {}", t);
			emitted.put(t, this.collector.emit(t));
		}
		
		return emitted;
	}

#No. 3800
#File: E:\bishe\1\AbstractOrderedInputSpout.java
#Comment:
	/**
	 * Closes an input partition. Closing a partition is only successful, if no tuples belonging to the partition are
	 * buffered internally any more. No more data can be emitted by this partition if closing was successful.
	 * 
	 * @param partitionId
	 *            The ID of the partition to be closed.
	 * 
	 * @return {@code true} if the partition was closed successfully -- {@code false} otherwise
	 */

#Code:
	protected boolean closePartition(Integer partitionId) {
		return this.merger.closePartition(partitionId);
	}

#No. 3801
#File: E:\bishe\1\AbstractOrderedInputSpout.java
#Comment:
	/**
	 * Declares the two fields necessary for transmitting tuples with a timestamp. Calling
	 * {@code super.declareOutputFields} in overriding methods is strongly recommended.
	 * 
	 * @param declarer
	 */

#Code:
	@Override
	public void declareOutputFields(OutputFieldsDeclarer declarer) {
		Fields fields = new Fields("ts", "rawTuple");
		if(this.streamID == null) {
			declarer.declare(fields);
		} else {
			declarer.declareStream(this.streamID, fields);
		}
	}

#No. 3802
#File: E:\bishe\1\AbstractOrientDatabaseFactory.java
#Comment:
    /**
     * Gets the database url.
     *
     * @return the url
     */

#Code:
    public String getUrl() {
        return url;
    }

#No. 3803
#File: E:\bishe\1\AbstractOrientDatabaseFactory.java
#Comment:
    /**
     * Sets the database url.
     *
     * @param url the new url
     */

#Code:
    public void setUrl(String url) {
        this.url = url;
    }

#No. 3804
#File: E:\bishe\1\AbstractOrientDatabaseFactory.java
#Comment:
    /**
     * Gets the username.
     *
     * @return the username
     */

#Code:
    public String getUsername() {
        return username;
    }

#No. 3805
#File: E:\bishe\1\AbstractOrientDatabaseFactory.java
#Comment:
    /**
     * Sets the username.
     *
     * @param username the new username
     */

#Code:
    public void setUsername(String username) {
        this.username = username;
    }

#No. 3806
#File: E:\bishe\1\AbstractOrientDatabaseFactory.java
#Comment:
    /**
     * Gets the password.
     *
     * @return the password
     */

#Code:
    public String getPassword() {
        return password;
    }

#No. 3807
#File: E:\bishe\1\AbstractOrientDatabaseFactory.java
#Comment:
    /**
     * Sets the password.
     *
     * @param password the new password
     */

#Code:
    public void setPassword(String password) {
        this.password = password;
    }

#No. 3808
#File: E:\bishe\1\AbstractOrientDatabaseFactory.java
#Comment:
    /**
     * Gets the min pool size.
     *
     * @return the min pool size
     */

#Code:
    public int getMinPoolSize() {
        return minPoolSize;
    }

#No. 3809
#File: E:\bishe\1\AbstractOrientDatabaseFactory.java
#Comment:
    /**
     * Sets the min pool size.
     *
     * @param minPoolSize the new min pool size
     */

#Code:
    public void setMinPoolSize(int minPoolSize) {
        this.minPoolSize = minPoolSize;
    }

#No. 3810
#File: E:\bishe\1\AbstractOrientDatabaseFactory.java
#Comment:
    /**
     * Gets the max pool size.
     *
     * @return the max pool size
     */

#Code:
    public int getMaxPoolSize() {
        return maxPoolSize;
    }

#No. 3811
#File: E:\bishe\1\AbstractOrientDatabaseFactory.java
#Comment:
    /**
     * Sets the max pool size.
     *
     * @param maxPoolSize the new max pool size
     */

#Code:
    public void setMaxPoolSize(int maxPoolSize) {
        this.maxPoolSize = maxPoolSize;
    }

#No. 3812
#File: E:\bishe\1\AbstractOrientQuery.java
#Comment:
    /**
     * Gets the execution for query.
     *
     * @return the execution
     */

#Code:
    protected OrientQueryExecution getExecution() {
        final OrientParameters parameters = method.getParameters();
        
        if (method.isCollectionQuery()) {
            return new CollectionExecution(operations, parameters);
        } else if (isCountQuery()) {
            return new CountExecution(operations, parameters);
        } else if (method.isPageQuery()) {
            return new PagedExecution(operations, parameters);
        } else if (method.isQueryForEntity()) {
            return new SingleEntityExecution(operations, parameters);
        } 
        
        throw new IllegalArgumentException();
    }

#No. 3813
#File: E:\bishe\1\AbstractOrionResponse.java
#Comment:
/**
 * Abstract response having an {@link StatusCode} object, common to all Orion
 * responses. The only exception is the {@link ContextUpdateResponse}, which
 * holds a list of objects, each one of them having its own status code.
 * 
 * @author Ivan Gracia (izanmail@gmail.com)
 *
 */

#Code:
class AbstractOrionResponse implements OrionResponse {

	@SerializedName("statusCode")
	private StatusCode statusCode;

	@Override
	public StatusCode getStatus() {
		return this.statusCode;
	}

	/**
	 * @param statusCode
	 *            the statusCode to set
	 */
	@Override
	public void setStatus(StatusCode statusCode) {
		this.statusCode = statusCode;
	}

	@Override
	public String toString() {
		return statusCode.toString();
	}
}

#No. 3814
#File: E:\bishe\1\AbstractORMHandle.java
#Comment:
	/**
	 * 符合当前Level，则执行DB操作，否则交由下个Handle去执行
	 */

#Code:
	public final Object handle(String level, ORMParamsDTO dto) throws Exception {
		if(this.level.equals(level)){
			return this.execute(dto);
		} else {
			this.setNextHandle();
			if(this.nextHandle != null){
				return this.nextHandle.handle(level, dto);
			} else {
				throw new Exception("必须设置ORMHandle处理当前请求");
			}
		}
	}

#No. 3815
#File: E:\bishe\1\AbstractORMHandle.java
#Comment:
	/**
	 * 设置下个Handle，子类设置，如果是最后一个Handle，不设置
	 */

#Code:
	public abstract void setNextHandle();

	protected SqlSessionTemplate getMybatisSessionTemplate() {
		return mybatisSessionTemplate;
	}

#No. 3816
#File: E:\bishe\1\AbstractorRecipes.java
#Comment:
    /**
     * Used to call methods addSmelting and getSmeltingResult.
     */

#Code:
    public static final AbstractorRecipes essence()
    {
        return smeltingBase;
    }

#No. 3817
#File: E:\bishe\1\AbstractorRecipes.java
#Comment:
    /**
     * Adds a smelting recipe.
     */

#Code:
    public void addEssenceAmount(int itemID, int amount)
    {
        this.smeltingList.put(Integer.valueOf(itemID), amount);
    }

#No. 3818
#File: E:\bishe\1\AbstractorRecipes.java
#Comment:
    /**
     * Returns the smelting result of an item.
     * Deprecated in favor of a metadata sensitive version
     */

#Code:
    @Deprecated
    public int getEssenceResuly(int par1)
    {
        return (Integer)this.smeltingList.get(Integer.valueOf(par1));
    }

#No. 3819
#File: E:\bishe\1\AbstractorRecipes.java
#Comment:
    /**
     * Add a metadata-sensitive furnace recipe
     * @param itemID The Item ID
     * @param metadata The Item Metadata
     * @param itemstack The ItemStack for the result
     */

#Code:
    public static void addEssence(int itemID, int metadata, int amount)
    {
        metaSmeltingList.put(Arrays.asList(itemID, metadata), amount);
    }

#No. 3820
#File: E:\bishe\1\AbstractorRecipes.java
#Comment:
    /**
     * Used to get the resulting ItemStack form a source ItemStack
     * @param item The Source ItemStack
     * @return The result ItemStack
     */

#Code:
    public int getEssenceResult(ItemStack item) 
    {
        if (item == null)
        {
            return 0;
        }
        Integer ret = (Integer)metaSmeltingList.get(Arrays.asList(item.itemID, item.getItemDamage()));
        if (ret != null) 
        {
            return ret;
        }
        ret = (Integer)smeltingList.get(Integer.valueOf(item.itemID));
        if(ret != null)
        {
        	return ret;
        }
        
        return 0;
    }

#No. 3821
#File: E:\bishe\1\AbstractOsPreferences.java
#Comment:
  /**
   * Sets each value to its default.
   */

#Code:
  public void reset() {
    useDefaultCommand = true;
    setCommand("cmake");
    setGenerator(CmakeGenerator.UnixMakefiles);
    setBuildscriptProcessorCommand(null);
    defines.clear();
    undefines.clear();
  }

#No. 3822
#File: E:\bishe\1\AbstractOsPreferences.java
#Comment:
  /**
   * Gets the platform specific preferences object from the specified
   * preferences for the current operating system (the OS we are running under).
   * If the OS cannot be determined or its specific preferences are not
   * implemented, the platform specific preferences for Linux are returned as a
   * fall-back.
   *
   * @return the platform specific or fall-back preferences
   */

#Code:
  public static AbstractOsPreferences extractOsPreferences(
      CMakePreferences prefs) {
    final String os = Platform.getOS();
    if (Platform.OS_WIN32.equals(os)) {
      return prefs.getWindowsPreferences();
    } else {
      // fall back to linux, if OS is unknown
      return prefs.getLinuxPreferences();
    }
  }

#No. 3823
#File: E:\bishe\1\AbstractOsPreferences.java
#Comment:
  /**
   * Gets whether to use the default cmake command.
   */

#Code:
  public final boolean getUseDefaultCommand() {
    return useDefaultCommand;
  }

#No. 3824
#File: E:\bishe\1\AbstractOsPreferences.java
#Comment:
  /**
   * Sets whether to use the default cmake command.
   */

#Code:
  public void setUseDefaultCommand(boolean useDefaultCommand) {
    this.useDefaultCommand = useDefaultCommand;
  }

#No. 3825
#File: E:\bishe\1\AbstractOsPreferences.java
#Comment:
  /**
   * Gets the cmake command.
   */

#Code:
  public final String getCommand() {
    return command;
  }

#No. 3826
#File: E:\bishe\1\AbstractOsPreferences.java
#Comment:
  /**
   * Sets the cmake command.
   */

#Code:
  public void setCommand(String command) {
    if (command == null) {
      throw new NullPointerException("command");
    }
    this.command = command;
  }

#No. 3827
#File: E:\bishe\1\AbstractOsPreferences.java
#Comment:
  /**
   * Gets the cmake buildscript generator.
   */

#Code:
  public final CmakeGenerator getGenerator() {
    return generator;
  }

#No. 3828
#File: E:\bishe\1\AbstractOsPreferences.java
#Comment:
  /**
   * Sets the cmake build-script generator.
   */

#Code:
  public void setGenerator(CmakeGenerator generator) {
    if (generator == null) {
      throw new NullPointerException("generator");
    }
    this.generator = generator;
  }

#No. 3829
#File: E:\bishe\1\AbstractOsPreferences.java
#Comment:
  /**
   * Gets the buildscript processor name.
   *
   * @return the buildscript processor or {@code null} if the build command
   *         matching the chosen generator should be used.
   */

#Code:
  public String getBuildscriptProcessorCommand() {
    return buildscriptProcessorCmd;
  }

#No. 3830
#File: E:\bishe\1\AbstractOsPreferences.java
#Comment:
  /**
   * Sets the buildscript processor name.
   *
   * @param buildscriptProcessorCommand
   *        the buildscript processor. If {@code null} or an empty string, the
   *        build command matching the chosen generator should be used.
   */

#Code:
  public void setBuildscriptProcessorCommand(String buildscriptProcessorCommand) {
    if ("".equals(buildscriptProcessorCommand))
      buildscriptProcessorCommand = null;
    this.buildscriptProcessorCmd = buildscriptProcessorCommand;
  }

#No. 3831
#File: E:\bishe\1\AbstractOsPreferences.java
#Comment:
  /**
   * Gets the list of cmake variable to define on the cmake command-line.
   *
   * @return a mutable list, never {@code null}
   */

#Code:
  public final List<CmakeDefine> getDefines() {
    return defines;
  }

#No. 3832
#File: E:\bishe\1\AbstractOsPreferences.java
#Comment:
  /**
   * Gets the list of cmake variable to undefine on the cmake command-line.
   *
   * @return a mutable list, never {@code null}
   */

#Code:
  public final List<CmakeUnDefine> getUndefines() {
    return undefines;
  }

#No. 3833
#File: E:\bishe\1\AbstractOsPreferences.java
#Comment:
  /**
   * Initializes the configuration information from the storage element
   * specified in the argument.
   *
   * @param parent
   *        A storage element containing the configuration information. If
   *        {@code null}, nothing is loaded from storage.
   */

#Code:
  public void loadFromStorage(ICStorageElement parent) {
    if (parent == null)
      return;
    // loop to merge multiple children of the same name
    final ICStorageElement[] children = parent
        .getChildrenByName(getStorageElementName());
    for (ICStorageElement child : children) {
      loadChildFromStorage(child);
    }
  }

#No. 3834
#File: E:\bishe\1\AbstractOsPreferences.java
#Comment:
  /**
   * Persists this configuration to the project file.
   */

#Code:
  public void saveToStorage(ICStorageElement parent) {
    final String storageElementName = getStorageElementName();

    final ICStorageElement[] children = parent
        .getChildrenByName(storageElementName);
    if (children.length == 0) {
      parent = parent.createChild(storageElementName);
    } else {
      // take first child
      parent = children[0];
    }

    // use default command
    if (useDefaultCommand) {
      parent.setAttribute(ATTR_USE_DEFAULT_COMMAND,
          String.valueOf(useDefaultCommand));
    } else {
      parent.removeAttribute(ATTR_USE_DEFAULT_COMMAND);
    }
    parent.setAttribute(ATTR_COMMAND, command);
    // generator
    parent.setAttribute(ATTR_GENERATOR, generator.name());
    if (buildscriptProcessorCmd != null) {
      parent.setAttribute(ATTR_BUILD_COMMAND, buildscriptProcessorCmd);
    } else {
      parent.removeAttribute(ATTR_BUILD_COMMAND);
    }
    // defines...
    Util.serializeCollection(CMakePreferences.ELEM_DEFINES, parent,
        new CmakeDefineSerializer(), defines);
    // undefines...
    Util.serializeCollection(CMakePreferences.ELEM_UNDEFINES, parent,
        new CmakeUndefineSerializer(), undefines);
  }

#No. 3835
#File: E:\bishe\1\AbstractOsPreferences.java
#Comment:
  /**
   * Gets the generator that was used to generate the CMake cache file and the
   * makefiles. This property is not persisted.
   */

#Code:
  public CmakeGenerator getGeneratedWith() {
    return this.generatedWith;
  }

#No. 3836
#File: E:\bishe\1\AbstractOsPreferences.java
#Comment:
  /**
   * Sets the generator that was used to generate the CMake cache file and the
   * makefiles.
   */

#Code:
  public void setGeneratedWith(CmakeGenerator generator) {
    this.generatedWith = generator;
  }

#No. 3837
#File: E:\bishe\1\AbstractOsPropertyTab.java
#Comment:
  /**
   * Updates displayed values according to the preferences edited by this tab.
   */

#Code:
  private void updateDisplay() {
    t_cmd.setText(prefs.getCommand());
    b_cmdFromPath.setSelection(prefs.getUseDefaultCommand());
    // adjust sensitivity...
    handleCommandEnabled(!prefs.getUseDefaultCommand());

    CmakeGenerator generator = prefs.getGenerator();
    c_generator.setSelection(new StructuredSelection(generator));

    definesViewer.setInput(prefs.getDefines());
    undefinesViewer.setInput(prefs.getUndefines());
  }

#No. 3838
#File: E:\bishe\1\AbstractOsPropertyTab.java
#Comment:
  /**
   * Stores displayed values to the preferences edited by this tab.
   *
   * @see #updateDisplay()
   */

#Code:
  private void saveToModel() {
    if (prefs == null)
      return;
    prefs.setUseDefaultCommand(b_cmdFromPath.getSelection());
    String command = t_cmd.getText().trim();
    prefs.setCommand(command);

    final IStructuredSelection sel = (IStructuredSelection) c_generator
        .getSelection();
    prefs.setGenerator((CmakeGenerator) sel.getFirstElement());
    // NB: defines & undefines are modified by the widget listeners directly
  }

#No. 3839
#File: E:\bishe\1\AbstractOsPropertyTab.java
#Comment:
  /**
   * Changes sensitivity of controls to enter the cmake command. Necessary since
   * Button.setSelection does not fire events.
   *
   * @param enabled
   *        the new enabled state
   */

#Code:
  private void handleCommandEnabled(boolean enabled) {
    t_cmd.setEnabled(enabled);
    b_cmdBrowseFiles.setEnabled(enabled);
    b_cmdVariables.setEnabled(enabled);
  }

#No. 3840
#File: E:\bishe\1\AbstractOsPropertyTab.java
#Comment:
  /**
   * Invoked when project configuration changes?? At least when apply button is
   * pressed.
   *
   * @see org.eclipse.cdt.ui.newui.AbstractCPropertyTab#performApply(org.eclipse.cdt.core.settings.model.ICResourceDescription,
   *      org.eclipse.cdt.core.settings.model.ICResourceDescription)
   */

#Code:
  @Override
  protected void performApply(ICResourceDescription src,
      ICResourceDescription dst) {
    // make sure the displayed values get applied
    saveToModel();

    ICConfigurationDescription srcCfg = src.getConfiguration();
    ICConfigurationDescription dstCfg = dst.getConfiguration();
    final ConfigurationManager configMgr = ConfigurationManager.getInstance();

    try {
      P srcPrefs = getOsPreferences(configMgr.getOrLoad(srcCfg));
      P dstPrefs = getOsPreferences(configMgr.getOrCreate(dstCfg));
      if (srcPrefs != dstPrefs) {
        dstPrefs.setUseDefaultCommand(srcPrefs.getUseDefaultCommand());
        dstPrefs.setCommand(srcPrefs.getCommand());
        dstPrefs.setGenerator(srcPrefs.getGenerator());

        final List<CmakeDefine> defines = dstPrefs.getDefines();
        defines.clear();
        for (CmakeDefine def : srcPrefs.getDefines()) {
          defines.add(def.clone());
        }

        final List<CmakeUnDefine> undefines = dstPrefs.getUndefines();
        undefines.clear();
        for (CmakeUnDefine undef : srcPrefs.getUndefines()) {
          undefines.add(undef.clone());
        }
      }
    } catch (CoreException ex) {
      log.log(new Status(IStatus.ERROR, CdtPlugin.PLUGIN_ID, null, ex));
    }
  }

#No. 3841
#File: E:\bishe\1\AbstractOutboundVariable.java
#Comment:
    /**
     * A helper struct to pass a build code and define code together
     */

#Code:
    protected class NotInlineDefinition
    {
        protected NotInlineDefinition(String declareCode, String buildCode)
        {
            this.declareCode = declareCode;
            this.buildCode = buildCode;
        }

        /**
         * The code to be executed to do basic initialization
         */
        String declareCode;

        /**
         * The code to be executed to setup the data structure
         */
        String buildCode;
    }

#No. 3842
#File: E:\bishe\1\AbstractOutboundVariable.java
#Comment:
    /**
     * A helper to children get have definition info in {@link #toString()}
     * @return For children to use in {@link #toString()}
     */

#Code:
    protected String toStringDefinitionHint()
    {
        if (inline)
        {
            return "inline";
        }
        else
        {
            if (varName != null)
            {
                return varName;
            }
            else
            {
                return "?";
            }
        }
    }

#No. 3843
#File: E:\bishe\1\AbstractOutboundVariable.java
#Comment:
    /**
     * @param isInline The new inline status
     */

#Code:
    private void setInline(boolean isInline)
    {
        if (calculated)
        {
            throw new IllegalStateException("Attempt to change inline status after calculation");
        }

        this.inline = isInline;
    }

#No. 3844
#File: E:\bishe\1\AbstractOutlineConfiguration.java
#Comment:
  /**
   * Adds a series of components in a horizontal manner. This method may not be
   * called outside the constructor.
   * 
   * @param comps The components.
   */

#Code:
  protected void addHor(final JComponent... comps) {
    final JPanel hor = new JPanel();
    hor.setLayout(new BoxLayout(hor, BoxLayout.X_AXIS));
    boolean first = true;
    for(final JComponent c : comps) {
      if(first) {
        first = false;
      } else {
        hor.add(Box.createRigidArea(new Dimension(5, 5)));
      }
      hor.add(c);
    }
    add(hor);
  }

#No. 3845
#File: E:\bishe\1\AbstractOutlineConfiguration.java
#Comment:
  /**
   * Propagates to the canvas that something regarding the outline generator has
   * changed.
   */

#Code:
  public void changed() {
    canvas.fireCanvasChange(CanvasListener.GENERATORS);
  }

#No. 3846
#File: E:\bishe\1\AbstractOutlineConfiguration.java
#Comment:
  /**
   * Setter.
   * 
   * @param outline Sets the outline generator to configure.
   */

#Code:
  public void setOutline(final SetOutline outline) {
    this.outline = outline;
  }

#No. 3847
#File: E:\bishe\1\AbstractOutlineConfiguration.java
#Comment:
  /**
   * Getter.
   * 
   * @return The current outline generator.
   */

#Code:
  public SetOutline getOutline() {
    return outline;
  }

#No. 3848
#File: E:\bishe\1\AbstractOutlineConfiguration.java
#Comment:
  /**
   * Getter.
   * 
   * @return The associated type.
   */

#Code:
  public OutlineType getType() {
    return type;
  }

#No. 3849
#File: E:\bishe\1\AbstractOutlineConfiguration.java
#Comment:
  /**
   * Is called when something has changed from the outside.
   */

#Code:
  public abstract void somethingChanged();

}
}

#No. 3850
#File: E:\bishe\1\AbstractOutputter.java
#Comment:
    /**
     * @return True if the file should be written.
     */

#Code:
    private boolean checkChanges() {
        return storage.getChangeCount() >= maxChanges;
    }

#No. 3851
#File: E:\bishe\1\AbstractOverride.java
#Comment:
/*
 * @test
 * @bug 4929736
 * @summary Overload resolution when an abstract method overrides a concrete one
 * @author gafter
 *
 * @compile AbstractOverride.java
 */

#Code:

class AbstractOverride {
    static class Ex extends Exception {}
    static class A {
	void f() throws Ex {}
    }
    static abstract class B extends A {
	abstract void f();
    }
    static class C extends B {
	void f() {}
    }
    public static void main(String[] args) {
	B b = new C();
	b.f();
    }
}

#No. 3852
#File: E:\bishe\1\AbstractPackageFragment.java
#Comment:
	/**
	 * Destination, queue = 0, collector = 1, same as in pyLoad Core
	 */

#Code:
	final static int FILEINFO_DIALOG = 0;
	private final Runnable mUpdateResults = new Runnable() {

		public void run() {
			onDataReceived();
		}
	};

#No. 3853
#File: E:\bishe\1\AbstractPackageGolangMojo.java
#Comment:
  /**
   * List of packages.
   */

#Code:
  @Parameter(name = "packages")
  private String[] packages;

  @Nullable
  @MustNotContainNull
  protected String [] getDefaultPackages() {
    return null;
  }

#No. 3854
#File: E:\bishe\1\AbstractPackageIndexWriter.java
#Comment:
    /**
     * Generate the contants in the package index file. Call appropriate
     * methods from the sub-class in order to generate Frame or Non
     * Frame format.
     * @param title the title of the window.
     * @param includeScript boolean set true if windowtitle script is to be included
     */ 

#Code:
    protected void generatePackageIndexFile(String title, boolean includeScript) throws IOException {
        String windowOverview = configuration.getText(title);
        printHtmlHeader(windowOverview, 
            configuration.metakeywords.getOverviewMetaKeywords(title, 
                configuration.doctitle), 
            includeScript);
        printNavigationBarHeader();
        printOverviewHeader();

        generateIndex();

        printOverview();

        printNavigationBarFooter();
        printBodyHtmlEnd();
    }

#No. 3855
#File: E:\bishe\1\AbstractPackageIndexWriter.java
#Comment:
    /**
     * Generate the frame or non-frame package index.
     */

#Code:
    protected void generateIndex() {
        printIndexContents(packages, "doclet.Package_Summary");
    }

#No. 3856
#File: E:\bishe\1\AbstractPackageIndexWriter.java
#Comment:
    /**
     * Generate code for package index contents. Call appropriate methods from
     * the sub-classes.
     *
     * @param packages Array of packages to be documented.
     * @param text     String which will be used as the heading.
     */

#Code:
    protected void printIndexContents(PackageDoc[] packages, String text) {
        if (packages.length > 0) {
            Arrays.sort(packages);
            printIndexHeader(text);
            printAllClassesPackagesLink();
            for(int i = 0; i < packages.length; i++) {
                if (packages[i] != null) {
                    printIndexRow(packages[i]);
                }
            }
            printIndexFooter();
        }
    }

#No. 3857
#File: E:\bishe\1\AbstractPackageIndexWriter.java
#Comment:
    /**
     * Print the doctitle, if it is specified on the command line.
     */

#Code:
    protected void printConfigurationTitle() {
        if (configuration.doctitle.length() > 0) {
            center();
            h1(configuration.doctitle);
            centerEnd();
        }
    }

#No. 3858
#File: E:\bishe\1\AbstractPackageIndexWriter.java
#Comment:
    /**
     * Highlight "Overview" in the bold format, in the navigation bar as this
     * is the overview page.
     */

#Code:
    protected void navLinkContents() {
        navCellRevStart();
        fontStyle("NavBarFont1Rev");
        boldText("doclet.Overview");
        fontEnd();
        navCellEnd();
    }

#No. 3859
#File: E:\bishe\1\AbstractPacketExtension.java
#Comment:
    /**
     * Gets the names of the attributes which currently have associated values
     * in this extension.
     *
     * @return the names of the attributes which currently have associated
     * values in this extension
     */

#Code:
    public List<String> getAttributeNames()
    {
        synchronized (attributes)
        {
            return new ArrayList<String>(attributes.keySet());
        }
    }

#No. 3860
#File: E:\bishe\1\AbstractPacketExtension.java
#Comment:
    /**
     * Specifies the text content of this extension.
     *
     * @param text the text content of this extension.
     */

#Code:
    public void setText(String text)
    {
        this.textContent = text;
    }

#No. 3861
#File: E:\bishe\1\AbstractPacketExtension.java
#Comment:
    /**
     * Returns the text content of this extension or <tt>null</tt> if no text
     * content has been specified so far.
     *
     * @return the text content of this extension or <tt>null</tt> if no text
     * content has been specified so far.
     */

#Code:
    public String getText()
    {
        return textContent;
    }

#No. 3862
#File: E:\bishe\1\AbstractPacketExtension.java
#Comment:
    /**
     * Returns this packet's first direct child extension that matches the
     * specified <tt>type</tt>.
     *
     * @param <T> the specific type of <tt>PacketExtension</tt> to be returned
     *
     * @param type the <tt>Class</tt> of the extension we are looking for.
     *
     * @return this packet's first direct child extension that matches specified
     * <tt>type</tt> or <tt>null</tt> if no such child extension was found.
     */

#Code:
    public <T extends PacketExtension> T getFirstChildOfType(Class<T> type)
    {
        List<? extends PacketExtension> childExtensions = getChildExtensions();

        synchronized (childExtensions)
        {
            for(PacketExtension extension : childExtensions)
            {
                if(type.isInstance(extension))
                {
                    @SuppressWarnings("unchecked")
                    T extensionAsType = (T) extension;

                    return extensionAsType;
                }
            }
        }
        return null;
    }

#No. 3863
#File: E:\bishe\1\AbstractPacketExtension.java
#Comment:
    /**
     * Returns this packet's direct child extensions that match the
     * specified <tt>type</tt>.
     *
     * @param <T> the specific <tt>PacketExtension</tt> type of child extensions
     * to be returned
     *
     * @param type the <tt>Class</tt> of the extension we are looking for.
     *
     * @return a (possibly empty) list containing all of this packet's direct
     * child extensions that match the specified <tt>type</tt>
     */

#Code:
    public <T extends PacketExtension> List<T> getChildExtensionsOfType(
            Class<T> type)
    {
        List<? extends PacketExtension> childExtensions = getChildExtensions();
        List<T> result = new ArrayList<T>();

        if (childExtensions == null)
            return result;

        synchronized (childExtensions)
        {
            for(PacketExtension extension : childExtensions)
            {
                if(type.isInstance(extension))
                {
                    @SuppressWarnings("unchecked")
                    T extensionAsType = (T) extension;

                    result.add(extensionAsType);
                }
            }
        }

        return result;
    }

#No. 3864
#File: E:\bishe\1\AbstractPacketHandler.java
#Comment:
	/**
	 * Sends the provided packet to all players.
	 * 
	 * @param packet The packet to be sent.
	 */

#Code:
	public void sendPacketToAllPlayers(IMessage packet)
	{
		wrapper.sendToAll(packet);
	}

#No. 3865
#File: E:\bishe\1\AbstractPacketHandler.java
#Comment:
	/**
	 * Sends the provided packet to all players except the provided player.
	 * 
	 * @param packet The packet to be sent.
	 * @param player The player that will not receive the packet.
	 */

#Code:
	public void sendPacketToAllPlayersExcept(IMessage packet, EntityPlayerMP player)
	{
		final MinecraftServer server = FMLCommonHandler.instance().getMinecraftServerInstance();
		final ServerConfigurationManager serverConfiguration = server.getConfigurationManager();

		for (int index = 0; index < serverConfiguration.playerEntityList.size(); ++index)
		{
			final EntityPlayerMP playerInList = (EntityPlayerMP) serverConfiguration.playerEntityList.get(index);

			if (!playerInList.getCommandSenderName().equals(player.getCommandSenderName()))
			{
				wrapper.sendTo(packet, playerInList);
			}
		}
	}

#No. 3866
#File: E:\bishe\1\AbstractPacketHandler.java
#Comment:
	/**
	 * Sends the provided packet to the provided player.
	 * 
	 * @param packet The packet to be sent.
	 * @param player The player that will receive the packet.
	 */

#Code:
	public void sendPacketToPlayer(IMessage packet, EntityPlayerMP player)
	{
		if (player != null)
		{
			wrapper.sendTo(packet, player);
		}
	}

#No. 3867
#File: E:\bishe\1\AbstractPacketHandler.java
#Comment:
	/**
	 * Sends the provided packet to everyone within a certain range of the provided point.
	 * 
	 * @param packet The packet to be sent.
	 * @param point The point around which to send the packet.
	 */

#Code:
	public void sendPacketToAllAround(IMessage packet, NetworkRegistry.TargetPoint point)
	{
		wrapper.sendToAllAround(packet, point);
	}

#No. 3868
#File: E:\bishe\1\AbstractPacketHandler.java
#Comment:
	/**
	 * Sends the provided packet to everyone within the supplied dimension.
	 * 
	 * @param packet The packet to be sent.
	 * @param dimensionId The dimension id.
	 */

#Code:
	public void sendPacketToDimension(IMessage packet, int dimensionId)
	{
		wrapper.sendToDimension(packet, dimensionId);
	}

#No. 3869
#File: E:\bishe\1\AbstractPacketHandler.java
#Comment:
	/**
	 * Sends this message to the server.
	 * 
	 * @param packet The packet to be sent.
	 */

#Code:
	public void sendPacketToServer(IMessage packet)
	{
		wrapper.sendToServer(packet);
	}

#No. 3870
#File: E:\bishe\1\AbstractPageable.java
#Comment:
    // /**
    // * calculate page count in previous
    // * @param pageIndex
    // * @return
    // */

#Code:
    // protected static long calculatePrePageCount(long pageIndex) {
    // long ret = pageIndex - 1L;
    // ret = ret < 0 ? 0 : ret;
    // return ret;
    // }

#No. 3871
#File: E:\bishe\1\AbstractPageable.java
#Comment:
    // /**
    // * calculate page count in rear(suffix) (计算后面还有多少页)
    // * @param pageCount
    // * @param pageIndex
    // * @return
    // */

#Code:
    // protected static long calculateSufPageCount(long pageCount, long
    // pageIndex) {
    // long ret = pageCount - pageIndex;
    // ret = ret < 0 ? 0 : ret;
    // return ret;
    // }

#No. 3872
#File: E:\bishe\1\AbstractPageable.java
#Comment:
    /**
     * calculate page count(计算总页数)
     * 
     * @param pageSize
     * @param recoreCount
     * @return
     */

#Code:
    protected static long calculatePageCount(int pageSize, long recoreCount)
    {
        if (pageSize == Integer.MAX_VALUE)
        {
            log.debug("pagesize = Integer.MAX_VALUE");
            if (recoreCount >= 1)
            {
                return 1;
            } else
            {
                return 0;
            }
        } else
        {
            return (recoreCount + pageSize - 1) / pageSize;
        }
    }

#No. 3873
#File: E:\bishe\1\AbstractPageable.java
#Comment:
    /**
     * @return the data
     */

#Code:
    @Override
    public Object getData()
    {
        return data;
    }

#No. 3874
#File: E:\bishe\1\AbstractPageable.java
#Comment:
    // /**
    // * @return the pageCount
    // */

#Code:
    // public long getPageCount() {
    // return pageCount;
    // }

#No. 3875
#File: E:\bishe\1\AbstractPageable.java
#Comment:
    /**
     * @return the recordCount
     */

#Code:
    @Override
    public long getRecordCount()
    {
        return recordCount;
    }

#No. 3876
#File: E:\bishe\1\AbstractPageable.java
#Comment:
    // /**
    // * @return the sufPageCount
    // */

#Code:
    // public long getSufPageCount() {
    // return sufPageCount;
    // }

#No. 3877
#File: E:\bishe\1\AbstractPageable.java
#Comment:
    // /**
    // * @return the prePageCount
    // */

#Code:
    // public long getPrePageCount() {
    // return prePageCount;
    // }

#No. 3878
#File: E:\bishe\1\AbstractPageable.java
#Comment:
    /**
     * @return the isPagination
     */

#Code:
    @Override
    public boolean isPagination()
    {
        return isPagination;
    }

#No. 3879
#File: E:\bishe\1\AbstractPageable.java
#Comment:
    /**
     * @param isPagination
     *            the isPagination to set
     */

#Code:
    @Override
    public void setPagination(boolean isPagination)
    {
        this.isPagination = isPagination;
        if (!isPagination)
        {
            this.pageIndex = 0;
            this.pageSize = Integer.MAX_VALUE;
        }
    }

#No. 3880
#File: E:\bishe\1\AbstractPageable.java
#Comment:
    /**
     * @param args
     */

#Code:
    public static void main(String[] args)
    {

    }

#No. 3881
#File: E:\bishe\1\AbstractPageFactory.java
#Comment:
    /**
     * While this constructor does not require a pageClass it will NOT analyse the loaded classes automatically for the
     * {@link org.ops4j.pax.wicket.api.PaxWicketMountPoint} annotation.
     *
     * @param bundleContext a {@link org.osgi.framework.BundleContext} object.
     * @param pageId a {@link java.lang.String} object.
     * @param applicationName a {@link java.lang.String} object.
     * @param pageName a {@link java.lang.String} object.
     * @throws java.lang.IllegalArgumentException if any.
     */

#Code:
    protected AbstractPageFactory(BundleContext bundleContext, String pageId, String applicationName, String pageName)
        throws IllegalArgumentException {
        this(bundleContext, pageId, applicationName, pageName, null);
    }

#No. 3882
#File: E:\bishe\1\AbstractPageFactory.java
#Comment:
    /**
     * This constructor expects an {@link #pageClass}. This class is expected to be the exported page and is
     * automatically scanned for the {@link org.ops4j.pax.wicket.api.PaxWicketMountPoint} annotation. The found page is automatically exported as
     * service mounting the page on the defined place.
     *
     * @param bundleContext a {@link org.osgi.framework.BundleContext} object.
     * @param pageId a {@link java.lang.String} object.
     * @param applicationName a {@link java.lang.String} object.
     * @param pageName a {@link java.lang.String} object.
     * @param pageClass a {@link java.lang.Class} object.
     * @throws java.lang.IllegalArgumentException if any.
     */

#Code:
    protected AbstractPageFactory(BundleContext bundleContext, String pageId, String applicationName, String pageName,
            Class<? extends WebPage> pageClass) throws IllegalArgumentException {
        // bundle context could be temporary null; some situations only allow to retrieve it lazy
        validateNotEmpty(pageId, "pageId");
        validateNotEmpty(applicationName, "applicationName");
        validateNotEmpty(pageName, "pageName");

        this.pageClass = pageClass;
        setInternalBundleContext(bundleContext);
        setPageId(pageId);
        setApplicationName(applicationName);
        setPageName(pageName);
    }

#No. 3883
#File: E:\bishe\1\AbstractPageFactory.java
#Comment:
    /**
     * <p>register.</p>
     *
     * @throws java.lang.IllegalStateException if any.
     */

#Code:
    public final void register() throws IllegalStateException {
        validateNotNull(bundleContext, "bundleContext");

        synchronized (this) {
            if (pageServiceRegistration != null) {
                throw new IllegalStateException(String.format("%s [%s] has been registered.", getClass()
                    .getSimpleName(), this));
            }
            if (pageClass != null) {
                PaxWicketMountPoint mountPoint = pageClass.getAnnotation(PaxWicketMountPoint.class);
                if (mountPoint != null) {
                    mountPointRegistration = new DefaultPageMounter(getApplicationName(), bundleContext);
                    mountPointRegistration.addMountPoint(mountPoint.mountPoint(), pageClass);
                    mountPointRegistration.register();
                }
            }
            pageServiceRegistration = bundleContext.registerService(SERVICE_CLASSES, this, properties);
        }
    }

#No. 3884
#File: E:\bishe\1\AbstractPageFactory.java
#Comment:
    /**
     * <p>dispose.</p>
     *
     * @throws java.lang.IllegalStateException if any.
     */

#Code:
    public final void dispose() throws IllegalStateException {
        synchronized (this) {
            if (pageServiceRegistration == null) {
                throw new IllegalStateException(String.format("%s [%s] has not been registered.", getClass()
                    .getSimpleName(), this));
            }
            pageServiceRegistration.unregister();
            pageServiceRegistration = null;
            if (mountPointRegistration != null) {
                mountPointRegistration.dispose();
                mountPointRegistration = null;
            }
        }
    }

#No. 3885
#File: E:\bishe\1\AbstractPageFactory.java
#Comment:
    /**
     * Returns the application name.
     *
     * @return The application name.
     * @since 1.0.0
     */

#Code:
    public final String getApplicationName() {
        synchronized (this) {
            return properties.get(APPLICATION_NAME);
        }
    }

#No. 3886
#File: E:\bishe\1\AbstractPageFactory.java
#Comment:
    /**
     * Returns the page name.
     *
     * @return The page name.
     * @since 1.0.0
     */

#Code:
    public final String getPageName() {
        synchronized (this) {
            return properties.get(PAGE_NAME);
        }
    }

#No. 3887
#File: E:\bishe\1\AbstractPageFactory.java
#Comment:
    /**
     * Sets the application name.
     *
     * @param applicationName The application name. This argument must not be {@code null} or empty.
     * @throws java.lang.IllegalArgumentException Thrown if the specified {@code applicationName} is {@code null}.
     * @since 1.0.0
     */

#Code:
    protected final void setApplicationName(String applicationName) throws IllegalArgumentException {
        validateNotEmpty(applicationName, "applicationName");
        synchronized (this) {
            properties.put(APPLICATION_NAME, applicationName);
        }
    }

#No. 3888
#File: E:\bishe\1\AbstractPageFactory.java
#Comment:
    /**
     * <p>setPageId.</p>
     *
     * @param pageId a {@link java.lang.String} object.
     * @throws java.lang.IllegalArgumentException if any.
     */

#Code:
    protected final void setPageId(String pageId) throws IllegalArgumentException {
        validateNotEmpty(pageId, "pageId");
        synchronized (this) {
            properties.put(Constants.SERVICE_PID, PAGE_ID + "/" + pageId);
        }
    }

#No. 3889
#File: E:\bishe\1\AbstractPageFactory.java
#Comment:
    /**
     * Set the page name.
     *
     * @param pageName The page name. This argument must not be {@code null} or empty.
     * @throws java.lang.IllegalArgumentException Thrown if the specified {@code pageName} arguments are {@code null}.
     * @since 1.0.0
     */

#Code:
    protected final void setPageName(String pageName) throws IllegalArgumentException {
        validateNotEmpty(pageName, "pageName");
        synchronized (this) {
            properties.put(PAGE_NAME, pageName);
        }
    }

#No. 3890
#File: E:\bishe\1\AbstractPageFactory.java
#Comment:
    /**
     * <p>setInternalBundleContext.</p>
     *
     * @param bundleContext a {@link org.osgi.framework.BundleContext} object.
     * @throws java.lang.IllegalArgumentException if any.
     */

#Code:
    protected final void setInternalBundleContext(BundleContext bundleContext) throws IllegalArgumentException {
        this.bundleContext = bundleContext;
    }

#No. 3891
#File: E:\bishe\1\AbstractPair.java
#Comment:
    /**
     * The first component of the pair.
     */

#Code:
    public Object component1;
    /**
     * The second component of the pair.
     */
    public Object component2;

    /**
     * Constructs an AbstractPair object.
     */
    public AbstractPair () {
    }

#No. 3892
#File: E:\bishe\1\AbstractPair.java
#Comment:
    /**
     * Constructs a new pair, with <code>component1</code> as its first and
     * <code>component2</code> as its second component.
     */

#Code:
    public AbstractPair (Object component1, Object component2) {
        this.component1 = component1;
        this.component2 = component2;
    }

#No. 3893
#File: E:\bishe\1\AbstractPair.java
#Comment:
    /**
     * Compares the specified object with this <code>AbstractPair</code> for
     * equality.
     * <p>
     * Returns <code>true</code> if the given object is also a pair with the same
     * components, <code>false</code> otherwise.
     *
     * @return <code>true</code> if the given object is also a pair with the same
     * components, <code>false</code> otherwise.
     */

#Code:
    public boolean equals (Object o) {
        return  (o.getClass().equals(this.getClass()) && (((((AbstractPair)o).component1 == null) &&
                (this.component1 == null)) || ((this.component1 != null) && ((AbstractPair)o).component1.equals(this.component1)))
                && (((((AbstractPair)o).component2 == null) && (this.component2 == null)) || ((this.component2
                != null) && ((AbstractPair)o).component2.equals(this.component2))));
    }

#No. 3894
#File: E:\bishe\1\AbstractPair.java
#Comment:
    /**
     * Returns a hash code value of this pair.
     *
     * @return a hash code value of this pair.
     */

#Code:
    public int hashCode () {
        return  (component1 == null ? 0 : component1.hashCode()) + (component2 == null ? 1 : component2.hashCode());
    }

#No. 3895
#File: E:\bishe\1\AbstractPair.java
#Comment:
    /**
     * Returns a string representation of this pair.
     *
     * @return a string representation of this pair.
     */

#Code:
    public String toString () {
        return  beginChar + component1 + separatorChar + component2 + endChar;
    }

#No. 3896
#File: E:\bishe\1\AbstractParallelRenderer.java
#Comment:
    /*
     * { for (int i = 0; i < NUMMASKEDTHREADS; i++) { // Each masked executor
     * gets its own set of column functions. RMIExec[i] = new
     * RenderMaskedExecutor(SCREENWIDTH, SCREENHEIGHT, columnofs, ylookup,
     * screen, RMI, maskedbarrier, // Regular masked columns new
     * R_DrawColumnBoom
     * (SCREENWIDTH,SCREENHEIGHT,ylookup,columnofs,maskedcvars,screen,I), new
     * R_DrawColumnBoomLow
     * (SCREENWIDTH,SCREENHEIGHT,ylookup,columnofs,maskedcvars,screen,I), //
     * Fuzzy columns new
     * R_DrawFuzzColumn.HiColor(SCREENWIDTH,SCREENHEIGHT,ylookup
     * ,columnofs,maskedcvars,screen,I), new
     * R_DrawFuzzColumnLow.HiColor(SCREENWIDTH
     * ,SCREENHEIGHT,ylookup,columnofs,maskedcvars,screen,I), // Translated
     * columns new
     * R_DrawTranslatedColumn(SCREENWIDTH,SCREENHEIGHT,ylookup,columnofs
     * ,maskedcvars,screen,I), new
     * R_DrawTranslatedColumnLow(SCREENWIDTH,SCREENHEIGHT
     * ,ylookup,columnofs,maskedcvars,screen,I) ); detailaware.add(RMIExec[i]);
     * } }
     */

#Code:

    public void Init(){
    	super.Init();
    	InitParallelStuff();
    }

#No. 3897
#File: E:\bishe\1\AbstractParam.java
#Comment:
	/**
	 * Returns a 400 Bad Request response describing the invalid parameter.
	 *
	 * @param param the invalid parameter
	 * @param e the type of exception thrown by {@link #parse(String)}
	 * @return a {@link Response} describing the problem parsing {@code param}
	 */

#Code:
	protected Response onError(String param, Throwable e) {
		return Response
				.status(Status.BAD_REQUEST)
				.entity(getErrorMessage(param, e))
				.build();
	}

#No. 3898
#File: E:\bishe\1\AbstractParam.java
#Comment:
	/**
	 * Returns an error message describing the invalid parameter.
	 * 
	 * @param param the invalid parameter
	 * @param e the type of exception thrown by {@link #parse(String)}
	 * @return a string describing the problem parsing {@code param}
	 */

#Code:
	protected String getErrorMessage(String param, Throwable e) {
		return new StringBuilder()
					.append("Invalid parameter: ")
					.append(param)
					.append(" (")
					.append(e.getMessage())
					.append(").")
					.toString();
	}

#No. 3899
#File: E:\bishe\1\AbstractParameterList.java
#Comment:
    /**
     * Writes the {@link ParameterList} to the {@link ByteBuffer}.
     *
     * @param byteBuffer The byte buffer
     */

#Code:
    public abstract void write(ByteBuffer byteBuffer);
}
}

#No. 3900
#File: E:\bishe\1\AbstractParameterParser.java
#Comment:
  /**
   * Set parameters from a string, like
   * "msg.sender.as2_id=ME,msg.headers.content-type=application/X12"
   *
   * @param sEncodedParams
   *        string to parse
   * @throws InvalidParameterException
   *         In case the string is incorrect
   */

#Code:
  public void setParameters (@Nonnull final String sEncodedParams) throws InvalidParameterException
  {
    final StringTokenizer aParams = new StringTokenizer (sEncodedParams, "=,", false);
    while (aParams.hasMoreTokens ())
    {
      final String sKey = aParams.nextToken ().trim ();
      if (!aParams.hasMoreTokens ())
        throw new InvalidParameterException ("Invalid value", this, sKey, null);

      final String sValue = aParams.nextToken ();
      setParameter (sKey, sValue);
    }
  }

#No. 3901
#File: E:\bishe\1\AbstractParameterParser.java
#Comment:
  /**
   * Set parameters from a string separated by delimiters.
   *
   * @param sFormat
   *        Comma separated list of parameters to set, like
   *        <code>msg.sender.as2_id,msg.receiver.as2_id,msg.header.content-type</code>
   * @param sDelimiters
   *        delimiters in string to parse, like "-."
   * @param sValue
   *        string to parse, like <code>"NORINCO-WALMART.application/X12"</code>
   * @throws OpenAS2Exception
   *         In case the string is incorrect
   */

#Code:
  public void setParameters (@Nullable final String sFormat,
                             @Nullable final String sDelimiters,
                             @Nonnull final String sValue) throws OpenAS2Exception
  {
    final ICommonsList <String> aKeys = StringHelper.getExploded (',', sFormat);

    final StringTokenizer aValueTokens = new StringTokenizer (sValue, sDelimiters, false);
    for (final String sKey : aKeys)
    {
      if (!aValueTokens.hasMoreTokens ())
        throw new OpenAS2Exception ("Invalid value: Format=" + sFormat + ", value=" + sValue);

      if (sKey.length () > 0)
        setParameter (sKey, aValueTokens.nextToken ());
    }
  }

#No. 3902
#File: E:\bishe\1\AbstractParkingListFragment.java
#Comment:
		/**
		 * {@inheritDoc}
		 */

#Code:
		public void onSharedPreferenceChanged(
				SharedPreferences sharedPreferences, String key) {

			if ((Preference.DEFAULT_SORT.getKey()).equals(key)) {
				String value = MainApplication.getDefaultSort();
				Log.d(TAG, "onSharedPreferenceChanged: " + key + "/value:"
						+ value);
				getLoaderManager().restartLoader(0, null,
						AbstractParkingListFragment.this);
			}

		}

#No. 3903
#File: E:\bishe\1\AbstractParserTestCase.java
#Comment:
    /**
     * Sink to write the output of the parsing
     *
     * @return a SinkAdapter if not overridden
     */

#Code:
    protected Sink getSink()
    {
        return new SinkAdapter();
    }

#No. 3904
#File: E:\bishe\1\AbstractParserTestCase.java
#Comment:
    /**
     * Parse the model in the path specified by {@link #getDocument()},
     * with parser from {@link #getParser()}, and output to sink from {@link #getSink()}
     *
     * @throws Exception if any.
     */

#Code:
    public void testParser()
        throws Exception
    {
        Reader reader = new FileReader( getTestFile( getBasedir(), getDocument() ) );

        getParser().parse( reader, getSink() );
    }

#No. 3905
#File: E:\bishe\1\AbstractPartition.java
#Comment:
    /**
     * Calls {@link #doDestroy()} where you have to put your destroy code in,
     * and clears default properties.  Once this method is invoked, {@link #isInitialized()}
     * will return <tt>false</tt>.
     */

#Code:
    public final void destroy() throws Exception
    {
        try
        {
            doDestroy();
        }
        finally
        {
            initialized = false;
        }
    }

#No. 3906
#File: E:\bishe\1\AbstractPartition.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public final boolean isInitialized()
    {
        return initialized;
    }

#No. 3907
#File: E:\bishe\1\AbstractPartition.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public void setSchemaManager( SchemaManager schemaManager )
    {
        this.schemaManager = schemaManager;
    }

#No. 3908
#File: E:\bishe\1\AbstractPartition.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public final SchemaManager getSchemaManager()
    {
        return schemaManager;
    }

#No. 3909
#File: E:\bishe\1\AbstractPartition.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public final String getId()
    {
        return id;
    }

#No. 3910
#File: E:\bishe\1\AbstractPartition.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public void setId( String id )
    {
        checkInitialized( "id" );
        this.id = id;
    }

#No. 3911
#File: E:\bishe\1\AbstractPartition.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public final Dn getSuffixDn()
    {
        return suffixDn;
    }

#No. 3912
#File: E:\bishe\1\AbstractPartition.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public void setSuffixDn( Dn suffixDn ) throws LdapInvalidDnException
    {
        checkInitialized( "suffixDn" );

        this.suffixDn = suffixDn;

        this.suffixDn.apply( schemaManager );
    }

#No. 3913
#File: E:\bishe\1\AbstractPartition.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public void dumpIndex( OutputStream stream, String name ) throws IOException
    {
        stream.write( Strings.getBytesUtf8( "Nothing to dump for index " + name ) );
    }

#No. 3914
#File: E:\bishe\1\AbstractPartition.java
#Comment:
    /**
     * Check that the operation is done on an initialized store
     * @param property
     */

#Code:
    protected void checkInitialized( String property )
    {
        if ( initialized )
        {
            throw new IllegalStateException( I18n.err( I18n.ERR_576, property ) );
        }
    }

#No. 3915
#File: E:\bishe\1\AbstractPartition.java
#Comment:
    /**
     * @return the contextEntry
     */

#Code:
    public Entry getContextEntry()
    {
        return contextEntry;
    }

#No. 3916
#File: E:\bishe\1\AbstractPartition.java
#Comment:
    /**
     * @param contextEntry the contextEntry to set
     */

#Code:
    public void setContextEntry( Entry contextEntry )
    {
        this.contextEntry = contextEntry;
    }

#No. 3917
#File: E:\bishe\1\AbstractPartition.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public void setCacheService( CacheService cacheService )
    {
        this.cacheService = cacheService;
    }

#No. 3918
#File: E:\bishe\1\AbstractPartition.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public String getContextCsn()
    {
        return contextCsn;
    }

#No. 3919
#File: E:\bishe\1\AbstractPartition.java
#Comment:
    /**
     * Replaces the current context CSN with the given CSN value if they are not same and
     * sets the ctxCsnChanged flag to true.
     * 
     * @param csn the CSN value
     */

#Code:
    protected void setContextCsn( String csn )
    {
        if ( !csn.equals( contextCsn ) )
        {
            contextCsn = csn;
            ctxCsnChanged = true;
        }
    }

#No. 3920
#File: E:\bishe\1\AbstractPartPainter.java
#Comment:
	/**
	 *  Optional Argument the DrawingContext can be overriden as this point if not
	 *  this will come via the Paint method call.
	 */

#Code:
	public void setContext(DrawingContext context)
	{
		this.context = context;
	}

#No. 3921
#File: E:\bishe\1\AbstractPartPainter.java
#Comment:
	/**
	 *  Implementation in paintProtected
	 */

#Code:
	public final void paint(Component c, DrawingPart part, GraphicsState graphics, CellState cellState, DrawingContext context)
	{
		paintProtected(c, part, graphics, cellState, this.context != null ? this.context : context);
	}

#No. 3922
#File: E:\bishe\1\AbstractPartPresenter.java
#Comment:
    /**
     * Fires a property changed event.
     *
     * @param propId
     *         the id of the property that changed
     */

#Code:
    protected void firePropertyChange(final int propId) {
        manager.dispatch(new Dispatcher<PropertyListener>() {
            @Override
            public void dispatch(PropertyListener listener) {
                listener.propertyChanged(AbstractPartPresenter.this, propId);
            }
        });
    }

#No. 3923
#File: E:\bishe\1\AbstractPartPresenter.java
#Comment:
    /**
     * Sets the Selection of the Part. It later can be accessible using {@link AbstractPartPresenter#getSelection()}
     *
     * @param selection
     *         instance of Selection
     */

#Code:
    public void setSelection(@Nonnull Selection<?> selection) {
        this.selection = selection;
        firePropertyChange(SELECTION_PROPERTY);
    }

    /** {@inheritDoc} */
    @Override
    public int getSize() {
        return 285;
    }

#No. 3924
#File: E:\bishe\1\AbstractPasswordMessage.java
#Comment:
    /**
     * ChangePassword protocol version number.
     */

#Code:
    public static final short PVNO = ( short ) 0xFF80;

    public static final short OLD_PVNO = 1;

    static final int HEADER_LENGTH = 6;

    private short versionNumber;


    protected AbstractPasswordMessage( short versionNumber )
    {
        this.versionNumber = versionNumber;
    }

#No. 3925
#File: E:\bishe\1\AbstractPasswordMessage.java
#Comment:
    /**
     * Returns the version number.
     *
     * @return The version number.
     */

#Code:
    public short getVersionNumber()
    {
        return versionNumber;
    }

#No. 3926
#File: E:\bishe\1\AbstractPasswordMessageModifier.java
#Comment:
    /**
     * Sets the protocol version number.
     *
     * @param versionNumber
     */

#Code:
    public void setProtocolVersionNumber( short versionNumber )
    {
        this.versionNumber = versionNumber;
    }

#No. 3927
#File: E:\bishe\1\AbstractPath.java
#Comment:
    /**
     * @parameter dependency
     */

#Code:
    private Collection<String> dependencies;

    public void setDependencies( Collection<String> deps )
    {
        this.dependencies = deps;
    }

#No. 3928
#File: E:\bishe\1\AbstractPathMatcherTest.java
#Comment:
  /**
   * Override to return a real matcher for the given pattern.
   */

#Code:
  @Nullable
  protected PathMatcher realMatcher(String pattern) {
    return null;
  }

#No. 3929
#File: E:\bishe\1\AbstractPatternDependencyFilter.java
#Comment:
    /**
     * Creates a new filter using the specified patterns.
     * 
     * @param patterns The include patterns, may be {@code null} or empty to include no artifacts.
     */

#Code:
    public AbstractPatternDependencyFilter( final String... patterns )
    {
        this( null, patterns );
    }

#No. 3930
#File: E:\bishe\1\AbstractPatternDependencyFilter.java
#Comment:
    /**
     * Creates a new filter using the specified patterns.
     * 
     * @param versionScheme To be used for parsing versions/version ranges. If {@code null} and pattern specifies a
     *            range no artifact will be included.
     * @param patterns The include patterns, may be {@code null} or empty to include no artifacts.
     */

#Code:
    public AbstractPatternDependencyFilter( final VersionScheme versionScheme, final String... patterns )
    {
        this( versionScheme, patterns == null ? null : Arrays.asList( patterns ) );
    }

#No. 3931
#File: E:\bishe\1\AbstractPatternDependencyFilter.java
#Comment:
    /**
     * Creates a new filter using the specified patterns.
     * 
     * @param patterns The include patterns, may be {@code null} or empty to include no artifacts.
     */

#Code:
    public AbstractPatternDependencyFilter( final Collection<String> patterns )
    {
        this( null, patterns );
    }

#No. 3932
#File: E:\bishe\1\AbstractPatternDependencyFilter.java
#Comment:
    /**
     * Creates a new filter using the specified patterns and {@link VersionScheme} .
     * 
     * @param versionScheme To be used for parsing versions/version ranges. If {@code null} and pattern specifies a
     *            range no artifact will be included.
     * @param patterns The include patterns, may be {@code null} or empty to include no artifacts.
     */

#Code:
    public AbstractPatternDependencyFilter( final VersionScheme versionScheme, final Collection<String> patterns )
    {
        if ( patterns != null )
        {
            this.patterns.addAll( patterns );
        }
        this.versionScheme = versionScheme;
    }

#No. 3933
#File: E:\bishe\1\AbstractPaxArchetypeMojo.java
#Comment:
    /**
     * Gives sub-classes the chance to cache the original files before custom archetypes run
     * 
     * @param baseDir project base directory
     */

#Code:
    protected void cacheOriginalFiles( File baseDir )
    {
        // for sub-classes to override if they need to
    }

#No. 3934
#File: E:\bishe\1\AbstractPaxArchetypeMojo.java
#Comment:
    /**
     * Sub-class specific post-processing, which runs *after* custom archetypes are added
     * 
     * @param pom working copy of Maven POM
     * @param bnd working copy of Bnd instructions
     * @throws MojoExecutionException
     */

#Code:
    protected void postProcess( Pom pom, Bnd bnd )
        throws MojoExecutionException
    {
        // for sub-classes to override if they need to
    }

#No. 3935
#File: E:\bishe\1\AbstractPaxArchetypeMojo.java
#Comment:
    /**
     * @return true to continue creating more projects, otherwise false
     */

#Code:
    protected boolean createMoreArtifacts()
    {
        return false;
    }

#No. 3936
#File: E:\bishe\1\AbstractPaxArchetypeMojo.java
#Comment:
    /**
     * @return acceptable version range of Pax-Construct archetypes
     */

#Code:
    private VersionRange getArchetypeVersionRange()
    {
        ArtifactVersion version = new DefaultArtifactVersion( pluginVersion );
        int thisRelease = version.getMajorVersion();

        int prevRelease = thisRelease - 1;
        int nextRelease = thisRelease + 1;

        String spec;
        if( false == ArtifactUtils.isSnapshot( pluginVersion ) )
        {
            // keep to same release to avoid potential borkage
            spec = "[" + thisRelease + ',' + nextRelease + ')';
        }
        else
        {
            // allow use of previous release during development
            spec = "[" + prevRelease + ',' + nextRelease + ')';
        }

        try
        {
            return VersionRange.createFromVersionSpec( spec );
        }
        catch( InvalidVersionSpecificationException e )
        {
            return null;
        }
    }

#No. 3937
#File: E:\bishe\1\AbstractPaxArchetypeMojo.java
#Comment:
    /**
     * Attempts to find the latest released (or snapshot) archetype that's compatible with this plugin
     * 
     * @param groupId archetype group id
     * @param artifactId archetype artifact id
     * @return compatible archetype version
     */

#Code:
    private String getArchetypeVersion( String groupId, String artifactId )
    {
        // special case when plugin is a snapshot - use the local archetype snapshot, if available
        Artifact artifact = m_factory.createBuildArtifact( groupId, artifactId, pluginVersion, "jar" );
        if( artifact.isSnapshot() && PomUtils.getFile( artifact, m_resolver, m_localRepo ) )
        {
            return pluginVersion;
        }

        // select archetypes based on the plugin version
        VersionRange range = getArchetypeVersionRange();

        try
        {
            getLog().info( "Selecting latest archetype release within version range " + range );
            return PomUtils.getReleaseVersion( artifact, m_source, m_remoteRepos, m_localRepo, range );
        }
        catch( MojoExecutionException e )
        {
            return pluginVersion;
        }
    }

#No. 3938
#File: E:\bishe\1\AbstractPaxArchetypeMojo.java
#Comment:
    /**
     * Fill in archetype details for the selected Pax-Construct archetype
     * 
     * @param archetypeArtifactId selected OSGi archetype
     */

#Code:
    protected final void setMainArchetype( String archetypeArtifactId )
    {
        if( PomUtils.isEmpty( archetypeVersion ) )
        {
            archetypeVersion = getArchetypeVersion( PAX_CONSTRUCT_GROUP_ID, archetypeArtifactId );
        }

        setArchetypeProperty( "archetypeGroupId", PAX_CONSTRUCT_GROUP_ID );
        setArchetypeProperty( "archetypeArtifactId", archetypeArtifactId );
        setArchetypeProperty( "archetypeVersion", archetypeVersion );
    }

#No. 3939
#File: E:\bishe\1\AbstractPaxArchetypeMojo.java
#Comment:
    /**
     * @param baseDir project base directory
     * @throws MojoExecutionException
     */

#Code:
    private void preserveExistingFiles( File baseDir )
        throws MojoExecutionException
    {
        try
        {
            // exclude existing files, so we don't accidentally trash them later
            List excludes = FileUtils.getFileNames( baseDir, null, null, false );
            for( Iterator i = excludes.iterator(); i.hasNext(); )
            {
                getLog().debug( "Preserving " + i.next() );
            }
            m_tempFiles.setExcludes( excludes );
        }
        catch( IOException e )
        {
            throw new MojoExecutionException( "I/O error while protecting existing files from deletion", e );
        }
    }

#No. 3940
#File: E:\bishe\1\AbstractPaxArchetypeMojo.java
#Comment:
    /**
     * Apply selected custom archetypes to the directory, which may add to the original archetype content
     * 
     * @throws MojoExecutionException
     */

#Code:
    private void runCustomArchetypes()
        throws MojoExecutionException
    {
        for( Iterator i = m_customArchetypeIds.iterator(); i.hasNext(); )
        {
            String[] fields = ( (String) i.next() ).split( ":" );

            setArchetypeProperty( "archetypeGroupId", fields[0] );
            setArchetypeProperty( "archetypeArtifactId", fields[1] );
            setArchetypeProperty( "archetypeVersion", fields[2] );

            generateArchetype();
        }
    }

#No. 3941
#File: E:\bishe\1\AbstractPaxArchetypeMojo.java
#Comment:
    /**
     * Perform any necessary post-processing and write Maven POM and optional Bnd instructions back to disk
     * 
     * @throws MojoExecutionException
     */

#Code:
    private void postProcess()
        throws MojoExecutionException
    {
        // sub-class processing
        postProcess( m_pom, m_bnd );

        try
        {
            /*
             * merge customized files with the original Pax-Construct generated templates
             */
            saveProjectModel( m_pom );
            saveBndInstructions( m_bnd );
        }
        catch( IOException e )
        {
            getLog().error( "Unable to save customized settings" );
        }
    }

#No. 3942
#File: E:\bishe\1\AbstractPaxArchetypeMojo.java
#Comment:
    /**
     * @param pom Maven project to merge with the latest file copy
     * @throws IOException
     */

#Code:
    protected final void saveProjectModel( Pom pom )
        throws IOException
    {
        if( hasCustomContent() && pom.getFile().exists() )
        {
            Pom customPom = PomUtils.readPom( pom.getBasedir() );
            pom.overlayDetails( customPom );
        }
        pom.write();
    }

#No. 3943
#File: E:\bishe\1\AbstractPaxArchetypeMojo.java
#Comment:
    /**
     * @param bnd Bnd instructions to merge with the latest file copy
     * @throws IOException
     */

#Code:
    protected final void saveBndInstructions( Bnd bnd )
        throws IOException
    {
        if( hasCustomContent() && bnd.getFile().exists() )
        {
            Bnd customBnd = BndUtils.readBnd( bnd.getBasedir() );
            bnd.overlayInstructions( customBnd );
        }
        bnd.write();
    }

#No. 3944
#File: E:\bishe\1\AbstractPaxArchetypeMojo.java
#Comment:
    /**
     * Combine the groupId and artifactId, eliminating duplicate elements if compactNames is true
     * 
     * @param groupId project group id
     * @param artifactId project artifact id
     * @return the combined group and artifact sequence
     */

#Code:
    protected final String getCompoundId( String groupId, String artifactId )
    {
        if( compactIds )
        {
            return PomUtils.getCompoundId( groupId, artifactId );
        }

        return groupId + '.' + artifactId;
    }

#No. 3945
#File: E:\bishe\1\AbstractPaxArchetypeMojo.java
#Comment:
    /**
     * Add custom Maven archetypes, to be used after the main archetype has finished
     */

#Code:
    private void scheduleCustomArchetypes()
    {
        m_customArchetypeIds = new ArrayList();

        // use default content
        if( !hasCustomContent() )
        {
            return;
        }

        String[] ids = contents.split( "," );
        for( int i = 0; i < ids.length; i++ )
        {
            String id = ids[i].trim();

            // handle groupId:artifactId:other:stuff
            String[] fields = id.split( ":" );
            if( fields.length > 2 )
            {
                // fully-qualified external archetype
                scheduleArchetype( fields[0], fields[1], fields[2] );
            }
            else if( fields.length > 1 )
            {
                // semi-qualified external archetype (assume groupId same as artifactId)
                scheduleArchetype( fields[0], fields[0], fields[1] );
            }
            else
            {
                // internal Pax-Construct archetype (assume same version as archetype template)
                scheduleArchetype( PAX_CONSTRUCT_GROUP_ID, fields[0], null );
            }
        }
    }

#No. 3946
#File: E:\bishe\1\AbstractPaxArchetypeMojo.java
#Comment:
    /**
     * Add a custom archetype to the list of archetypes to merge in once the main archetype has been applied
     * 
     * @param groupId archetype group id
     * @param artifactId archetype atifact id
     * @param version archetype version
     */

#Code:
    protected final void scheduleArchetype( String groupId, String artifactId, String version )
    {
        if( PomUtils.isEmpty( version ) )
        {
            m_customArchetypeIds.add( groupId + ':' + artifactId + ':' + archetypeVersion );
        }
        else
        {
            m_customArchetypeIds.add( groupId + ':' + artifactId + ':' + version );
        }
    }

#No. 3947
#File: E:\bishe\1\AbstractPaxArchetypeMojo.java
#Comment:
    /**
     * @return set of filenames that will be left at the end of this archetype cycle
     */

#Code:
    protected final Set getFinalFilenames()
    {
        Set finalFiles = new HashSet();

        DirectoryScanner scanner = new DirectoryScanner();
        scanner.setBasedir( m_tempFiles.getDirectory() );
        scanner.setFollowSymlinks( false );

        scanner.addDefaultExcludes();
        scanner.setExcludes( m_tempFiles.getExcludesArray() );
        scanner.setIncludes( m_tempFiles.getIncludesArray() );

        scanner.scan();

        finalFiles.addAll( Arrays.asList( scanner.getNotIncludedFiles() ) );
        finalFiles.addAll( Arrays.asList( scanner.getExcludedFiles() ) );

        return finalFiles;
    }

#No. 3948
#File: E:\bishe\1\AbstractPaxArchetypeMojo.java
#Comment:
    /**
     * Clean up any temporary or unnecessary files, including empty directories
     */

#Code:
    private void cleanUp()
    {
        DirectoryScanner scanner = new DirectoryScanner();
        scanner.setBasedir( m_tempFiles.getDirectory() );
        scanner.setFollowSymlinks( false );

        scanner.addDefaultExcludes();
        scanner.setExcludes( m_tempFiles.getExcludesArray() );
        scanner.setIncludes( m_tempFiles.getIncludesArray() );

        scanner.scan();

        String[] discardedFiles = scanner.getIncludedFiles();
        for( int i = 0; i < discardedFiles.length; i++ )
        {
            String filename = discardedFiles[i];
            getLog().debug( "Discarding " + filename );
            new File( scanner.getBasedir(), filename ).delete();
        }

        // remove any empty directories after the cleanup
        DirUtils.pruneEmptyFolders( scanner.getBasedir() );
    }

#No. 3949
#File: E:\bishe\1\AbstractPaxArchetypeMojo.java
#Comment:
    /**
     * @param name property name
     * @param value property value
     */

#Code:
    protected final void setArchetypeProperty( String name, String value )
    {
        if( null != value )
        {
            m_archetypeProperties.setProperty( name, value );
        }
        else
        {
            m_archetypeProperties.remove( name );
        }

        if( "packageName".equals( name ) )
        {
            m_archetypeProperties.setProperty( "package", value );
        }
    }

#No. 3950
#File: E:\bishe\1\AbstractPaxArchetypeMojo.java
#Comment:
    /**
     * @param name property name
     * @return property value
     */

#Code:
    protected final String getArchetypeProperty( String name )
    {
        return m_archetypeProperties.getProperty( name );
    }

#No. 3951
#File: E:\bishe\1\AbstractPaxArchetypeMojo.java
#Comment:
    /**
     * Generate Pax-Construct archetype (derived from classic archetype plugin)
     * 
     * @throws MojoExecutionException
     */

#Code:
    private void generateArchetype()
        throws MojoExecutionException
    {
        try
        {
            String groupId = getArchetypeProperty( "archetypeGroupId" );
            String artifactId = getArchetypeProperty( "archetypeArtifactId" );
            String version = getArchetypeProperty( "archetypeVersion" );

            m_archetype.createArchetype( groupId, artifactId, version, m_localRepo, m_remoteRepos,
                m_archetypeProperties );
        }
        catch( ArchetypeNotFoundException e )
        {
            throw new MojoExecutionException( "Error creating from archetype", e );
        }
        catch( ArchetypeDescriptorException e )
        {
            throw new MojoExecutionException( "Error creating from archetype", e );
        }
        catch( ArchetypeTemplateProcessingException e )
        {
            throw new MojoExecutionException( "Error creating from archetype", e );
        }
    }

#No. 3952
#File: E:\bishe\1\AbstractPaxArchetypeMojo.java
#Comment:
    /**
     * @param id repository id
     * @param url repository url
     * @return repository instance
     */

#Code:
    private ArtifactRepository createRemoteRepository( String id, String url )
    {
        ArtifactRepositoryPolicy snapshots = new ArtifactRepositoryPolicy( true,
            ArtifactRepositoryPolicy.UPDATE_POLICY_ALWAYS, null );
        ArtifactRepositoryPolicy releases = new ArtifactRepositoryPolicy( true,
            ArtifactRepositoryPolicy.UPDATE_POLICY_ALWAYS, null );

        return m_repoFactory.createArtifactRepository( id, url, m_defaultLayout, snapshots, releases );
    }

#No. 3953
#File: E:\bishe\1\AbstractPaxWicketInjector.java
#Comment:
    /**
     * <p>getSingleLevelOfFields.</p>
     *
     * @param clazz a {@link java.lang.Class} object.
     * @return a {@link java.util.List} object.
     */

#Code:
    protected List<Field> getSingleLevelOfFields(Class<?> clazz) {
        List<Field> fields = new ArrayList<Field>();
        for (Field field : clazz.getDeclaredFields()) {
            if (!field.isAnnotationPresent(Inject.class)) {
                continue;
            }
            fields.add(field);
        }
        return fields;
    }

#No. 3954
#File: E:\bishe\1\AbstractPaxWicketInjector.java
#Comment:
    /**
     * <p>getFields.</p>
     *
     * @param clazz a {@link java.lang.Class} object.
     * @return a {@link java.util.List} object.
     */

#Code:
    protected List<Field> getFields(Class<?> clazz) {
        List<Field> fields = new ArrayList<Field>();

        while (clazz != null && !isBoundaryClass(clazz)) {
            for (Field field : clazz.getDeclaredFields()) {
                if (!field.isAnnotationPresent(Inject.class)) {
                    continue;
                }
                fields.add(field);
            }
            clazz = clazz.getSuperclass();
        }
        return fields;
    }

#No. 3955
#File: E:\bishe\1\AbstractPaxWicketInjector.java
#Comment:
    /**
     * <p>isBoundaryClass.</p>
     *
     * @param clazz a {@link java.lang.Class} object.
     * @return a boolean.
     */

#Code:
    protected boolean isBoundaryClass(Class<?> clazz) {
        if (clazz.equals(WebPage.class) || clazz.equals(Page.class) || clazz.equals(Panel.class)
                || clazz.equals(MarkupContainer.class) || clazz.equals(Component.class)
                || clazz.equals(AuthenticatedWebSession.class) || clazz.equals(WebSession.class)
                || clazz.equals(Session.class) || clazz.equals(Object.class)) {
            return true;
        }
        return false;
    }

#No. 3956
#File: E:\bishe\1\AbstractPaxWicketInjector.java
#Comment:
    /**
     * <p>setField.</p>
     *
     * @param component a {@link java.lang.Object} object.
     * @param field a {@link java.lang.reflect.Field} object.
     * @param proxy a {@link java.lang.Object} object.
     */

#Code:
    protected void setField(Object component, Field field, Object proxy) {
        try {
            checkAccessabilityOfField(field);
            field.set(component, proxy);
        } catch (Exception e) {
            throw new RuntimeException("Bumm", e);
        }
    }

#No. 3957
#File: E:\bishe\1\AbstractPaxWicketInjector.java
#Comment:
    /**
     * <p>getBeanType.</p>
     *
     * @param field a {@link java.lang.reflect.Field} object.
     * @return a {@link java.lang.Class} object.
     */

#Code:
    protected Class<?> getBeanType(Field field) {
        Class<?> beanType = field.getType();
        return beanType;
    }

#No. 3958
#File: E:\bishe\1\AbstractPaxWicketInjector.java
#Comment:
    /**
     * <p>countComponentContainPaxWicketBeanAnnotatedFieldsHierachical.</p>
     *
     * @param component a {@link java.lang.Class} object.
     * @return a int.
     */

#Code:
    protected int countComponentContainPaxWicketBeanAnnotatedFieldsHierachical(Class<?> component) {
        Class<?> clazz = component;
        int numberOfInjectionFields = 0;
        while (clazz != null && !isBoundaryClass(clazz)) {
            for (Field field : clazz.getDeclaredFields()) {
                if (field.isAnnotationPresent(Inject.class)) {
                    numberOfInjectionFields++;
                }
            }
            clazz = clazz.getSuperclass();
        }
        return numberOfInjectionFields;
    }

#No. 3959
#File: E:\bishe\1\AbstractPaxWicketInjector.java
#Comment:
    /**
     * <p>countComponentContainPaxWicketBeanAnnotatedOneLevel.</p>
     *
     * @param component a {@link java.lang.Class} object.
     * @return a int.
     */

#Code:
    protected int countComponentContainPaxWicketBeanAnnotatedOneLevel(Class<?> component) {
        Class<?> clazz = component;
        int numberOfInjectionFields = 0;
        for (Field field : clazz.getDeclaredFields()) {
            if (field.isAnnotationPresent(Inject.class)) {
                numberOfInjectionFields++;
            }
        }
        return numberOfInjectionFields;
    }

#No. 3960
#File: E:\bishe\1\AbstractPayload.java
#Comment:
	/**
	 * {@inheritDoc}
	 */

#Code:
	@Override
	public String toString() {
		return ToStringBuilder.reflectionToString(this);
	}

#No. 3961
#File: E:\bishe\1\AbstractPayTributeHandler.java
#Comment:
		/*
		for(int i = 0; i < nPlayerListNum; ++i){
			GamePlayer player = playerList.get(i);
			if(null == player){
				logger.error("AbstractPayTributeHandler::recordPayTributeAndNotifyClient player Null Error");
				continue;
			}
			
			player.processPayTribute();
		}
		*/

#Code:
		
		int nPayTributeTimeSec = GDPropertiesUtils.getPropertyAsInteger(GDPropertiesUtils.PAY_TRIBUTE_TIMER);
		int nSecsDiff = GDPropertiesUtils.getPropertyAsInteger(GDPropertiesUtils.SERVER_CLIENTSECS, 2);
		
		SServerNotifyPayTribute.Builder payTributeBuilder = SServerNotifyPayTribute.newBuilder();
		for(int i = 0; i < nPlayerListNum; ++i){
			GamePlayer player = playerList.get(i);
			if(null == player){
				logger.error("AbstractPayTributeHandler::recordPayTributeAndNotifyClient player Null Error");
				continue;
			}
			
			payTributeBuilder.addStrPayTributerId(player.getGamePlayerId());
		}

#No. 3962
#File: E:\bishe\1\AbstractPDFExportHandler.java
#Comment:
		/*
		 * .toPlainString() document.getAmountWithTax() .setScale(2,
		 * this.mc.getRoundingMode()) .toPlainString());
		 */

#Code:
		return;
	}

	protected <T extends BillyTemplateBundle> String getPaymentMechanismTranslation(
			Enum<?> pmc, T bundle) {
		return bundle.getPaymentMechanismTranslation(pmc);
	}

#No. 3963
#File: E:\bishe\1\AbstractPedanticDependencyOrderEnforcer.java
#Comment:
  /**
   * Comma-separated list of dependency elements that defines the ordering.
   * @param dependencyElements Comma-separated list of dependency elements that defines the ordering.
   * @configParam
   * @default scope,groupId,artifactId
   * @since 1.0.0
   */

#Code:
  public void setOrderBy(String dependencyElements) {
    Set<DependencyElement> orderBy = new LinkedHashSet<>();
    CommaSeparatorUtils.splitAndAddToCollection(dependencyElements, orderBy, stringToDependencyElement());
    this.artifactOrdering.redefineOrderBy(orderBy);
  }

#No. 3964
#File: E:\bishe\1\AbstractPedanticDependencyOrderEnforcer.java
#Comment:
  /**
   * Comma-separated list of group IDs that should be listed first in the
   * dependencies declaration. All group IDs that <strong>start with</strong>
   * any of the prioritized group IDs in the given list, are required to be
   * located first in the dependencies section.
   *
   * @param groupIds Comma separated list of group IDs.
   * @configParam
   * @default n/a
   * @since 1.0.0
   */

#Code:
  public void setGroupIdPriorities(String groupIds) {
    LinkedHashSet<String> groupIdPriorities = Sets.newLinkedHashSet();
    CommaSeparatorUtils.splitAndAddToCollection(groupIds, groupIdPriorities);
    this.artifactOrdering.setPriorities(DependencyElement.GROUP_ID, groupIdPriorities);
  }

#No. 3965
#File: E:\bishe\1\AbstractPedanticDependencyOrderEnforcer.java
#Comment:
  /**
   * Comma-separated list of artifact IDs that should be listed first in the
   * dependencies declaration. All artifact IDs that <strong>start with</strong>
   * any of the prioritized IDs in the given list, are required to be located
   * first in the dependencies section.
   *
   * @param artifactIds Comma separated list of artifact IDs.
   * @configParam
   * @default n/a
   * @since 1.0.0
   */

#Code:
  public void setArtifactIdPriorities(String artifactIds) {
    LinkedHashSet<String> artifactIdPriorities = Sets.newLinkedHashSet();
    CommaSeparatorUtils.splitAndAddToCollection(artifactIds, artifactIdPriorities);
    this.artifactOrdering.setPriorities(DependencyElement.ARTIFACT_ID, artifactIdPriorities);
  }

#No. 3966
#File: E:\bishe\1\AbstractPedanticDependencyOrderEnforcer.java
#Comment:
  /**
   * Comma-separated list of scopes that should be listed first in the
   * dependencies declaration. All scopes that equal any of the scopes in the
   * given list, are required to be located first in the dependencies section.
   *
   * @param scopes Comma separated list of scopes.
   * @configParam
   * @default n/a
   * @since 1.0.0
   */

#Code:
  public void setScopePriorities(String scopes) {
    LinkedHashSet<String> scopePriorities = Sets.newLinkedHashSet();
    CommaSeparatorUtils.splitAndAddToCollection(scopes, scopePriorities);
    this.artifactOrdering.setPriorities(DependencyElement.SCOPE, scopePriorities);
  }

#No. 3967
#File: E:\bishe\1\AbstractPedanticEnforcer.java
#Comment:
  /**
   * Initialization method. Use this method when the enforcer rule is not instantiated by the
   * maven-enforcer-plugin.
   * @param helper Enforcer rule helper.
   * @param pom POM Document.
   * @param projectModel Project model.
   */

#Code:
  void initialize(EnforcerRuleHelper helper, Document pom, ProjectModel projectModel) {
    this.helper = helper;
    this.log = helper.getLog();
    this.pom = pom;
    this.projectModel = projectModel;
  }

#No. 3968
#File: E:\bishe\1\AbstractPen.java
#Comment:
    /**
     * logger for all instances
     */

#Code:
    private static final Logger logger = Logger.getLogger("org.freehep.graphicsio.emf");

    /**
     * returns a BasicStroke JOIN for an EMF pen style
     * @param penStyle penstyle
     * @return e.g. {@link com.google.code.appengine.awt.BasicStroke#JOIN_MITER}
     */
    protected int getJoin(int penStyle) {
        switch (penStyle & 0xF000) {
            case EMFConstants.PS_JOIN_ROUND:
                return BasicStroke.JOIN_ROUND;
            case EMFConstants.PS_JOIN_BEVEL:
                return BasicStroke.JOIN_BEVEL;
            case EMFConstants.PS_JOIN_MITER:
                return BasicStroke.JOIN_MITER;
            default:
                logger.warning("got unsupported pen style " + penStyle);
                return BasicStroke.JOIN_ROUND;
        }
    }

#No. 3969
#File: E:\bishe\1\AbstractPen.java
#Comment:
    /**
     * returns a BasicStroke JOIN for an EMF pen style
     * @param penStyle Style to convert
     * @return asicStroke.CAP_ROUND, BasicStroke.CAP_SQUARE, BasicStroke.CAP_BUTT
     */

#Code:
    protected int getCap(int penStyle) {
        switch (penStyle & 0xF00) {
            case EMFConstants.PS_ENDCAP_ROUND:
                return BasicStroke.CAP_ROUND;
            case EMFConstants.PS_ENDCAP_SQUARE:
                return BasicStroke.CAP_SQUARE;
            case EMFConstants.PS_ENDCAP_FLAT:
                return BasicStroke.CAP_BUTT;
            default:
                logger.warning("got unsupported pen style " + penStyle);
                return BasicStroke.CAP_ROUND;
        }
    }

#No. 3970
#File: E:\bishe\1\AbstractPen.java
#Comment:
    /**
     * returns a Dash for an EMF pen style
     * @param penStyle Style to convert
     * @param style used if EMFConstants#PS_USERSTYLE is set
     * @return float[] representing a dash
     */

#Code:
    protected float[] getDash(int penStyle, int[] style) {
        switch (penStyle & 0xFF) {
            case EMFConstants.PS_SOLID:
                // do not use float[] { 1 }
                // it's _slow_
                return null;
            case EMFConstants.PS_DASH:
                return new float[] { 5, 5 };
            case EMFConstants.PS_DOT:
                return new float[] { 1, 2 };
            case EMFConstants.PS_DASHDOT:
                return new float[] { 5, 2, 1, 2 };
            case EMFConstants.PS_DASHDOTDOT:
                return new float[] { 5, 2, 1, 2, 1, 2 };
            case EMFConstants.PS_INSIDEFRAME:
                // Represents a pen style that consists of a solid
                // pen that is drawn from within any given bounding rectangle
                return null;
            case EMFConstants.PS_NULL:
                // do not use float[] { 1 }
                // it's _slow_
                return null;
            case EMFConstants.PS_USERSTYLE:
                if (style != null && style.length > 0) {
                    float[] result = new float[style.length];
                    for (int i = 0; i < style.length; i++) {
                        result[i] = style[i];
                    }
                    return result;
                } else {
                    return null;
                }
            default:
                logger.warning("got unsupported pen style " + penStyle);
                // do not use float[] { 1 }
                // it's _slow_
                return null;
        }
    }

#No. 3971
#File: E:\bishe\1\AbstractPen.java
#Comment:
    /**
     * @param penStyle stored pen style
     * @return true if PS_INSIDEFRAME is set
     */

#Code:
    private boolean isInsideFrameStroke(int penStyle) {
        return (penStyle & 0xFF) == EMFConstants.PS_INSIDEFRAME;
    }

#No. 3972
#File: E:\bishe\1\AbstractPerfMonMetricTest.java
#Comment:
    /**
     * Test of getValue method, of class AbstractPerfMonMetric.
     */

#Code:
    public void testGetValue() throws Exception {
        System.out.println("getValue");
        StringBuffer res = null;
        AbstractPerfMonMetric instance = new AbstractPerfMonMetricImpl();
        instance.getValue(res);
    }

#No. 3973
#File: E:\bishe\1\AbstractPerfMonMetricTest.java
#Comment:
    /**
     * Test of createMetric method, of class AbstractPerfMonMetric.
     */

#Code:
    public void testCreateMetric() {
        System.out.println("createMetric");
        String metricType = "cpu";
        String metricParams = "idle";
        SigarProxy sigarProxy = SigarProxyCache.newInstance(new Sigar(), 500);
        Class expResult = CPUTotalMetric.class;
        AbstractPerfMonMetric result = AbstractPerfMonMetric.createMetric(metricType, metricParams, sigarProxy);
        assertNotNull(result);
        assertEquals(expResult, result.getClass());
    }

#No. 3974
#File: E:\bishe\1\AbstractPeriodicSyncManager.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Nonnull
    @Override
    public Account getAccount() {
        return mAccount;
    }

#No. 3975
#File: E:\bishe\1\AbstractPeriodicSyncManager.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Nonnull
    @Override
    public String getAuthority() {
        return mAuthority;
    }

#No. 3976
#File: E:\bishe\1\AbstractPersistenceFactory.java
#Comment:
    /**
     * Loads a mapped entity out of a column value
     *
     * @param columnValue the column value
     * @return the loaded mapped entity
     */

#Code:
    protected Object loadMappedEntity(String columnValue) throws ClassNotFoundException, InvocationTargetException, NoSuchMethodException, IllegalAccessException {
        if (!columnValue.contains(MAPPED_ENTITY_VALUE_SEPARATOR))
            throw new IllegalStateException(String.format("%s does not contain the appropriate tokens or separators", columnValue));
        String[] parts = columnValue.split(MAPPED_ENTITY_VALUE_SEPARATOR);
        Class<?> mappedEntityClass = Class.forName(parts[0]);
        String mappedEntityKey = parts[1];
        return get(mappedEntityClass, mappedEntityKey);
    }

#No. 3977
#File: E:\bishe\1\AbstractPersistenceFactory.java
#Comment:
    /**
     * Loads a simple, mapped or collection entity property
     *
     * @param metadata the entity property
     * @param name     the property name
     * @param column   the column object
     * @return the property value
     */

#Code:
    protected Object loadProperty(ClassMetadata<?> metadata, String name, HColumn<String, Object> column) throws Exception {
        Object value;
        if (metadata.isMappedContainer(name)) {
            value = loadMappedEntity(column);
        } else if (metadata.isMappedCollection(name)) {
            value = loadMappedCollection(column);
        } else {
            value = convertRead(metadata.getColumnClass(name), column.getValueBytes());
        }
        return value;
    }

#No. 3978
#File: E:\bishe\1\AbstractPersistenceFactory.java
#Comment:
    /**
     * Loads a mapped entity
     *
     * @param column the column object
     * @return the mapped entity
     */

#Code:
    protected Object loadMappedEntity(HColumn<String, Object> column) throws Exception {
        Object value = convertRead(String.class, column.getValueBytes());
        return loadMappedEntity(value.toString());
    }

#No. 3979
#File: E:\bishe\1\AbstractPersistenceFactory.java
#Comment:
    /**
     * Loads a mapped collection out of a column
     *
     * @param column the column
     * @return the loaded mapped collection
     */

#Code:
    protected Object loadMappedCollection(HColumn<String, Object> column) throws Exception {
        Object value = convertRead(String.class, column.getValueBytes());
        Object retVal = null;
        String[] tokens = value.toString().split(COLLECTION_VALUE_SEPARATOR);
        Map<Class<?>, List<String>> loadBatch = new HashMap<Class<?>, List<String>>();
        if (tokens != null) {
            List<Object> entities = new ArrayList<Object>(tokens.length);
            for (String tokenValue : tokens) {
                String[] parts = tokenValue.split(MAPPED_ENTITY_VALUE_SEPARATOR);
                Class<?> mappedEntityClass = Class.forName(parts[0]);
                String mappedEntityKey = parts[1];
                List<String> collectedIds = loadBatch.get(mappedEntityClass);
                if (collectedIds == null) {
                    collectedIds = new ArrayList<String>();
                    loadBatch.put(mappedEntityClass, collectedIds);
                }
                collectedIds.add(mappedEntityKey);
            }
            for (Map.Entry<Class<?>, List<String>> entry : loadBatch.entrySet()) {
                List<?> batchedEntities = getResultList(entry.getKey(), Query.get(select(allColumns(), from(entry.getKey()), where(keyIn(entry.getValue().toArray(new String[entry.getValue().size()]))))));
                entities.addAll(batchedEntities);
            }
            retVal = entities;
        }
        return retVal;
    }

#No. 3980
#File: E:\bishe\1\AbstractPersistenceFactory.java
#Comment:
    /**
     * Converts ByteBuffer to an object value
     *
     * @param value the object value
     * @return the ByteBuffer
     */

#Code:
    @SuppressWarnings("unchecked")
    protected Object convertRead(Class<?> type, ByteBuffer value) throws Exception {
        TypeConverter<Object> converter = (TypeConverter<Object>) getTypeConverter(type);
        deffenseConverter(converter, type);
        return converter.fromValue(value, (Class<Object>) type);
    }

#No. 3981
#File: E:\bishe\1\AbstractPersistenceIntegrationTest.java
#Comment:
    /**
     * - can also be the ConstraintViolationException which now occurs on the
     * update operation will not be translated; as a consequence, it will be a
     * TransactionSystemException
     */

#Code:
    @Test(expected = RuntimeException.class)
    public void whenEntityIsUpdatedWithFailedConstraints_thenException() {
        final T existingEntity = persistNewEntity();
        invalidate(existingEntity);

        getApi().save(existingEntity);
    }

#No. 3982
#File: E:\bishe\1\AbstractPersistentObjectProcessTest.java
#Comment:
  /**
   * Test of getObject method, of class AbstractPersistentObjectProcess.
   */

#Code:
  @Test
  public void testGetObject() {
    System.out.println("getObject");
    String ObjectKey = "testkey1";
    String expResult = "1235";
    String result;
    
    // Good retieval
    instance.putObject(ObjectKey, expResult);
    result = (String) instance.getObject(ObjectKey);
    assertEquals(expResult, result);
    
    result = (String) instance.getObject(ObjectKey+"not there");
    assertEquals(null, result);
    
    // Clean up to make tests order independent
    instance.deleteObject(ObjectKey);
  }

#No. 3983
#File: E:\bishe\1\AbstractPersistentObjectProcessTest.java
#Comment:
  /**
   * Test of deleteObject method, of class AbstractPersistentObjectProcess.
   */

#Code:
  @Test
  public void testDeleteObject() {
    System.out.println("deleteObject");
    
    String ObjectKey = "testkey2";
    String expResult = "1235";
    String result;
    
    // Good retieval
    instance.putObject(ObjectKey, expResult);
    result = (String) instance.getObject(ObjectKey);
    assertEquals(expResult, result);

    // Do the deletion
    instance.deleteObject(ObjectKey);
    
    // See if it is still there
    result = (String) instance.getObject(ObjectKey+"not there");
    assertEquals(null, result);
  }

#No. 3984
#File: E:\bishe\1\AbstractPersistentObjectProcessTest.java
#Comment:
  /**
   * Test of containsObjectKey method, of class AbstractPersistentObjectProcess.
   */

#Code:
  @Test
  public void testContainsObjectKey() {
    System.out.println("containsObjectKey");
    
    String ObjectKey = "testkey3";
    boolean result;
    
    // Good retieval
    instance.putObject(ObjectKey, "test");
    result = instance.containsObjectKey(ObjectKey);
    assertEquals(true, result);

    // Do the deletion
    instance.deleteObject(ObjectKey);
    
    // See if it is still there
    result = instance.containsObjectKey(ObjectKey);
    assertEquals(false, result);
  }

#No. 3985
#File: E:\bishe\1\AbstractPersistentObjectProcessTest.java
#Comment:
  /**
   * Test of getObjectKeySet method, of class AbstractPersistentObjectProcess.
   */

#Code:
  @Test
  public void testGetObjectKeySet() {
    System.out.println("getObjectKeySet");
    instance.putObject("1", "test");
    instance.putObject("2", "test");
    instance.putObject("3", "test");
    
    Set result = instance.getObjectKeySet();
    assertEquals(3, result.size());
  }

#No. 3986
#File: E:\bishe\1\AbstractPersistentObjectProcessTest.java
#Comment:
 /**
  * Method to get an instance of the implementation. Done this way to allow
  * tests to be executed individually.
  *
  * @throws InitializationException
  */

#Code:
  private void getInstance()
  {
    if (instance == null)
    {
      // Get an initialise the cache
      instance = new AbstractPersistentObjectProcessTest.AbstractPersistentObjectProcessImpl();
      
      try
      {
        // Get the instance
        instance.init("DBTestPipe", "AbstractPersistentObjectProcessTest");
      }
      catch (InitializationException ex)
      {
        org.junit.Assert.fail();
      }

    }
    else
    {
      org.junit.Assert.fail("Instance already allocated");
    }
  }

#No. 3987
#File: E:\bishe\1\AbstractPersistentObjectProcessTest.java
#Comment:
 /**
  * Method to release an instance of the implementation.
  */

#Code:
  private void releaseInstance()
  {
    instance = null;
  }

#No. 3988
#File: E:\bishe\1\AbstractPersonService.java
#Comment:
    /**
     * Default Constructor. Only used inside ServiceRegistry.
     * 
     * @param repositorySession : Repository Session.
     */

#Code:
    public AbstractPersonService(AlfrescoSession repositorySession)
    {
        super(repositorySession);
    }

#No. 3989
#File: E:\bishe\1\AbstractPersonService.java
#Comment:
    /**
     * Retrieves the avatar rendition for the specified username.
     * 
     * @param personIdentifier : Username of person
     * @return Returns the ContentStream associated to the avatar picture.
     */

#Code:
    public ContentStream getAvatarStream(String personIdentifier)
    {
        // Implemented by child
        return null;
    }

#No. 3990
#File: E:\bishe\1\AbstractPersonService.java
#Comment:
    /**
     * Retrieves the avatar rendition for the specified username.
     * 
     * @param personIdentifier : Username of person
     * @return Returns the contentContentFileFile associated to the avatar
     *         picture.
     */

#Code:
    public ContentFile getAvatar(String personIdentifier)
    {
        if (isStringNull(personIdentifier)) { throw new IllegalArgumentException(String.format(
                Messagesl18n.getString("ErrorCodeRegistry.GENERAL_INVALID_ARG_NULL"), "personIdentifier")); }
        
        return saveContentStream(getAvatarStream(personIdentifier), personIdentifier, RENDITION_CACHE);
    }

#No. 3991
#File: E:\bishe\1\AbstractPersonService.java
#Comment:
    /**
     * Retrieves the avatar rendition for the specified username.
     * 
     * @param person : Person object
     * @return Returns the contentFile associated to the avatar picture. @ : if
     *         network or internal problems occur during the process.
     */

#Code:
    public ContentFile getAvatar(Person person)
    {
        if (isObjectNull(person) || isStringNull(person.getIdentifier())) { throw new IllegalArgumentException(
                String.format(Messagesl18n.getString("ErrorCodeRegistry.GENERAL_INVALID_ARG_NULL"), "person")); }
        
        return saveContentStream(getAvatarStream(person.getIdentifier()), person.getIdentifier(), RENDITION_CACHE);
    }

#No. 3992
#File: E:\bishe\1\AbstractPhaseEngine.java
#Comment:
    /**
     * Log exceptions that happened during a phase failure.
     * @param ex the phase exception.
     */

#Code:
    protected void logFailedResources(PhaseException ex) {
        List<Exception> exceptions = ex.getExceptions();
        List<XAResourceHolderState> resources = ex.getResourceStates();

        for (int i = 0; i < exceptions.size(); i++) {
            Exception e = exceptions.get(i);
            XAResourceHolderState holderState = resources.get(i);
            log.error("resource " + holderState.getUniqueName() + " failed on " + holderState.getXid(), e);
        }
    }

#No. 3993
#File: E:\bishe\1\AbstractPinyinSegmenter.java
#Comment:
    /**
     * 分词，获取下一个词元
     *
     * @return Lexeme 词元对象
     * @throws java.io.IOException
     */

#Code:
    public final Lexeme next() throws IOException {
        if (hasMoreLexemeInCache()) {
            return nextCacheLexeme();
        }
        StringBuilder lexemeBuilder = new StringBuilder();
        Character curChar = readChar();
        if (curChar == null) {
            return null;
        }
        lexemeBuilder.append(curChar);
        previousChar = curChar;
        previousCharType = CharacterUtil.identifyCharType(CharacterUtil.regularize(curChar));

        while (true) {
            curChar = seekChar();
            if (curChar == null || breakProcess(previousChar, previousCharType, curChar)) {
                break;
            }
            lexemeBuilder.append(readChar());
        }
        if (lexemeBuilder.length() > 0) {
            List<Lexeme> lexemeList = processTokenToLexeme(lexemeBuilder.toString());
            if (lexemeList != null && lexemeList.size() > 0) {
                Iterator<Lexeme> it = lexemeList.iterator();
                Lexeme retLexeme = it.next();
                while (it.hasNext()) {
                    addLexemeToCache(it.next());
                }
                return retLexeme;
            }
        }
        return null;
    }

#No. 3994
#File: E:\bishe\1\AbstractPlaces.java
#Comment:
    /**
     * Exception to return in callback
     */

#Code:
    private PlacesException exception;

    /**
     * listener callback for sending back response
     */

    private List<PlacesListener> listeners;

    protected AbstractPlaces(PlacesListener listener) {
        this.listeners = new ArrayList<>();
        registerListener(listener);
    }

#No. 3995
#File: E:\bishe\1\AbstractPlainDatagramSocketImpl.java
#Comment:
    /**
     * Connects a datagram socket to a remote destination. This associates the remote
     * address with the local socket so that datagrams may only be sent to this destination
     * and received from this destination.
     * @param address the remote InetAddress to connect to
     * @param port the remote port number
     */

#Code:
    protected void connect(InetAddress address, int port) throws SocketException {
        connect0(address, port);
        connectedAddress = address;
        connectedPort = port;
        connected = true;
    }

#No. 3996
#File: E:\bishe\1\AbstractPlainDatagramSocketImpl.java
#Comment:
    /**
     * Disconnects a previously connected socket. Does nothing if the socket was
     * not connected already.
     */

#Code:
    protected void disconnect() {
        disconnect0(connectedAddress.holder().getFamily());
        connected = false;
        connectedAddress = null;
        connectedPort = -1;
    }

#No. 3997
#File: E:\bishe\1\AbstractPlainDatagramSocketImpl.java
#Comment:
    /**
     * Receive the datagram packet.
     * @param Packet Received.
     */

#Code:
    protected synchronized void receive(DatagramPacket p)
        throws IOException {
        receive0(p);
    }

#No. 3998
#File: E:\bishe\1\AbstractPlainDatagramSocketImpl.java
#Comment:
    /**
     * Join the multicast group.
     * @param multicast address to join.
     */

#Code:
    protected void join(InetAddress inetaddr) throws IOException {
        join(inetaddr, null);
    }

#No. 3999
#File: E:\bishe\1\AbstractPlainDatagramSocketImpl.java
#Comment:
    /**
     * Leave the multicast group.
     * @param multicast address to leave.
     */

#Code:
    protected void leave(InetAddress inetaddr) throws IOException {
        leave(inetaddr, null);
    }

#No. 4000
#File: E:\bishe\1\AbstractPlainDatagramSocketImpl.java
#Comment:
    /**
     * Join the multicast group.
     * @param multicast address to join.
     * @param netIf specifies the local interface to receive multicast
     *        datagram packets
     * @throws  IllegalArgumentException if mcastaddr is null or is a
     *          SocketAddress subclass not supported by this socket
     * @since 1.4
     */

#Code:

    protected void joinGroup(SocketAddress mcastaddr, NetworkInterface netIf)
        throws IOException {
        if (mcastaddr == null || !(mcastaddr instanceof InetSocketAddress))
            throw new IllegalArgumentException("Unsupported address type");
        join(((InetSocketAddress)mcastaddr).getAddress(), netIf);
    }

#No. 4001
#File: E:\bishe\1\AbstractPlainDatagramSocketImpl.java
#Comment:
    /**
     * Leave the multicast group.
     * @param multicast address to leave.
     * @param netIf specified the local interface to leave the group at
     * @throws  IllegalArgumentException if mcastaddr is null or is a
     *          SocketAddress subclass not supported by this socket
     * @since 1.4
     */

#Code:
    protected void leaveGroup(SocketAddress mcastaddr, NetworkInterface netIf)
        throws IOException {
        if (mcastaddr == null || !(mcastaddr instanceof InetSocketAddress))
            throw new IllegalArgumentException("Unsupported address type");
        leave(((InetSocketAddress)mcastaddr).getAddress(), netIf);
    }

#No. 4002
#File: E:\bishe\1\AbstractPlainDatagramSocketImpl.java
#Comment:
    /**
     * Close the socket.
     */

#Code:
    protected void close() {
        if (fd != null) {
            datagramSocketClose();
            ResourceManager.afterUdpClose();
            fd = null;
        }
    }

#No. 4003
#File: E:\bishe\1\AbstractPlainDatagramSocketImpl.java
#Comment:
    /*
     * get option's state - set or not
     */

#Code:

    public Object getOption(int optID) throws SocketException {
        if (isClosed()) {
            throw new SocketException("Socket Closed");
        }

        Object result;

        switch (optID) {
            case SO_TIMEOUT:
                result = new Integer(timeout);
                break;

            case IP_TOS:
                result = socketGetOption(optID);
                if ( ((Integer)result).intValue() == -1) {
                    result = new Integer(trafficClass);
                }
                break;

            case SO_BINDADDR:
            case IP_MULTICAST_IF:
            case IP_MULTICAST_IF2:
            case SO_RCVBUF:
            case SO_SNDBUF:
            case IP_MULTICAST_LOOP:
            case SO_REUSEADDR:
            case SO_BROADCAST:
                result = socketGetOption(optID);
                break;

            default:
                throw new SocketException("invalid option: " + optID);
        }

        return result;
    }

#No. 4004
#File: E:\bishe\1\AbstractPlainTextMethodSynthesizer.java
#Comment:
	/**
	 * Generates plain text source code for data writer methods.
	 * 
	 * @param writeMethodCode writer method code
	 * @param getParameterTypeMethodCode parameter type getter code
	 * @param writerClassName name of the reader class
	 * @param sourceClassNameFull name of the class of source object (i.e. whose setter will be invoked)
	 * @param sourceClassSetterMethodName  name of the setter method to be invoked on the source object
	 * @param sourceClassSetterMethodArgumentClass  class name of the argument type passed to setter
	 */

#Code:
	protected final void generateWriterMethods(
			final StringBuilder writeMethodCode,
			final StringBuilder getParameterTypeMethodCode,
			final String writerClassName, 
			final String sourceClassNameFull,
			final String sourceClassSetterMethodName, 
			final Class< ? > sourceClassSetterMethodArgumentClass) {
		
		final ArgumentTypeContext argType = getArgumentTypeContext(sourceClassSetterMethodArgumentClass);
		
		writeMethodCode
			.append("public void write(Object source, Object value) {\n")
			.append("final ").append(sourceClassNameFull).append(" clazz = (").append(sourceClassNameFull).append(") source;\n")
			.append("clazz.").append(sourceClassSetterMethodName).append("(");
		if (!argType.isPrimitive()) {
			writeMethodCode
			.append("(").append(argType.getMethodArgType()).append(") value");
		} else {
			appendPrimitiveValue(argType.getMethodArgPrimitiveName(), writeMethodCode, "value");
		}
		writeMethodCode.append(");\n}");
	
		getParameterTypeMethodCode
			.append("public Class getParameterType() {\n")
			.append("return ").append(argType.getMethodArgType()).append(".class;\n")
			.append("}");

        LOG.debug("Creating DataWriter Class: \n{}\n{}\n", writeMethodCode, getParameterTypeMethodCode);

	}

#No. 4005
#File: E:\bishe\1\AbstractPlayAuthenticationProcessingFilter.java
#Comment:
    /**
     * @param context
     * @return
     * @throws AuthenticationException
     * @throws IOException
     */

#Code:
    public abstract Authentication attemptAuthentication(Http.Context context) throws AuthenticationException, IOException;


    /**
     * @param context
     * @param failureUrl
     * @return
     */
    protected WrappedResult unsuccessfulAuthentication(Http.Context context, final String failureUrl)
    {
        SecurityContextHolder.clearContext();

        Logger.debug("unsuccessful authentication!");

        Action.Simple delegate = new Action.Simple()
        {
            @Override
            public Result call(Http.Context context) throws Throwable
            {
                return redirect(failureUrl);
            }
        };

        WrappedResult result = null;
        try {
            result = new DefaultWrappedResult(PlayFilterChainActionType.RETURN_RESULT, delegate.call(context));
        } catch (Throwable throwable) {
        }

        return result;
    }

#No. 4006
#File: E:\bishe\1\AbstractPlayAuthenticationProcessingFilter.java
#Comment:
    /**
     * @param context
     * @param authentication
     * @return
     */

#Code:
    protected WrappedResult successfulAuthentication(Http.Context context, Authentication authentication, final String successUrl)
    {
        Logger.debug("Authentication success. Updating SecurityContextHolder...");

        SecurityContextHolder.getContext().setAuthentication(authentication);

        Action.Simple delegate = new Action.Simple()
        {
            @Override
            public Result call(Http.Context context) throws Throwable
            {
                return redirect(successUrl);
            }
        };

        WrappedResult result = null;
        try {
            result = new DefaultWrappedResult(PlayFilterChainActionType.RETURN_RESULT, delegate.call(context));
        } catch (Throwable throwable) {
        }

        return result;
    }

#No. 4007
#File: E:\bishe\1\AbstractPlayerData.java
#Comment:
	/**
	 * Class constructor. 
	 * <b>Do not</b> assign default data values here, only instantiate objects if necessary.</b> 
	 * <p>
	 * Use <code>initializeNewData()</code> to set default values.
	 */

#Code:
	public AbstractPlayerData(EntityPlayer player, String modId)
	{
		owner = player;
		ownerIdentifier = player.getUniqueID().toString();
		dataWatcher = new DataWatcherEx(this, modId);
		
		instantiateData();
		
		final File dataFolder = new File(playerDataPath
				.replace("%WorldDir%", player.worldObj.getSaveHandler().getWorldDirectory().getAbsolutePath())
				.replace("%ModID%", getModMetadata().modId.toLowerCase()));
		
		dataFolder.mkdirs();
	}

#No. 4008
#File: E:\bishe\1\AbstractPluginComponent.java
#Comment:
/**
 * {@link AbstractPluginComponent} provides an abstract base class for implementing
 * {@link PluginComponent}s.
 */

#Code:
public class AbstractPluginComponent extends ScopedObject
        implements PluginComponent {

    protected AbstractPluginComponent() {
    }

    @Override
    public void onPlugged(final PluginBus bus) {
        // By default do nothing
    }

    @Override
    public void onUnplugged(final PluginBus bus) {
        // By default do nothing
    }

    @Override
    public void onPluginPlugged(final Object plugin) {
        // By default do nothing
    }

    @Override
    public void onPluginUnplugged(final Object plugin) {
        // By default do nothing
    }
}

#No. 4009
#File: E:\bishe\1\AbstractPluginSpreadsheetWidget.java
#Comment:
    /**
     * Add a CellEditorListener to the list of CelleEditorListeners available
     *
     * @param cel - A CellEditorListener to add
     */

#Code:
    public void addCellEditorListener(CellEditorListener cel) {
        listeners.add(cel);
    }

#No. 4010
#File: E:\bishe\1\AbstractPluginSpreadsheetWidget.java
#Comment:
    /**
     * CancelCellEditing method is required by the TableCellEditor interface.
     * Stops editing of the cell and hides the OntologySelectionTool.
     */

#Code:
    public void cancelCellEditing() {
        fireEditingCanceled();
    }

#No. 4011
#File: E:\bishe\1\AbstractPluginSpreadsheetWidget.java
#Comment:
    /**
     * Stops editing on a cell. Called when the user wants to commit the change rather than reverting to the
     * previous value entered.
     */

#Code:
    protected void fireEditingStopped() {
        ChangeEvent ce = new ChangeEvent(this);

        for (int i = listeners.size() - 1; i >= 0; i--) {
            (listeners.get(i)).editingStopped(ce);
        }
    }

#No. 4012
#File: E:\bishe\1\AbstractPluginSpreadsheetWidget.java
#Comment:
    /**
     * Return the value in the editor
     *
     * @return An object representing the value in the editor.
     */

#Code:
    public Object getCellEditorValue() {
        return getText();
    }

#No. 4013
#File: E:\bishe\1\AbstractPluginSpreadsheetWidget.java
#Comment:
    /**
     * Return the value in the editor
     *
     * @return An object representing the value in the editor.
     */

#Code:
    public String getOriginalValue() {
        return originalValue;
    }

#No. 4014
#File: E:\bishe\1\AbstractPluginSpreadsheetWidget.java
#Comment:
    /**
     * FireEditingCanceled method sets text back to its original value, and cancels editing
     * by referring to the list of CellEditorListener objects and calling the editingStopped method with
     * a ChangeEvent defined using the OntologyCellEditor as a reference.
     */

#Code:
    protected void fireEditingCanceled() {
        setText(getCellValue());

        ChangeEvent ce = new ChangeEvent(this);

        for (int i = listeners.size() - 1; i >= 0; i--) {
            (listeners.get(i)).editingCanceled(ce);
        }
    }

#No. 4015
#File: E:\bishe\1\AbstractPluginSpreadsheetWidget.java
#Comment:
    /**
     * Always returns true since the date field should always be editable.
     *
     * @param eo EventObject
     * @return true, always.
     */

#Code:
    public boolean isCellEditable(EventObject eo) {
        return true;
    }

#No. 4016
#File: E:\bishe\1\AbstractPluginSpreadsheetWidget.java
#Comment:
    /**
     * Removes a CellEditorListener from the list of listeners.
     *
     * @param cel - CellEditorListener to remove
     */

#Code:
    public void removeCellEditorListener(CellEditorListener cel) {
        listeners.remove(cel);
    }

#No. 4017
#File: E:\bishe\1\AbstractPluginSpreadsheetWidget.java
#Comment:
    /**
     * Always returns true. Method indicates whether a user should be able to to select a cell.
     *
     * @param eo - EventObject.
     * @return true
     */

#Code:
    public boolean shouldSelectCell(EventObject eo) {
        return true;
    }

#No. 4018
#File: E:\bishe\1\AbstractPluginSpreadsheetWidget.java
#Comment:
    /**
     * Stop Editing of a cell component and set the cell value to be the term(s) selected in the OntologySelectionTool.
     *
     * @return true
     */

#Code:
    public boolean stopCellEditing() {
        fireEditingStopped();
        setText(getCellValue());
        return true;
    }

#No. 4019
#File: E:\bishe\1\AbstractPluginSpreadsheetWidget.java
#Comment:
    /**
     * Gets the component used to edit a cell - in this case, the OntologyCellEditor.
     *
     * @param table      - JTable being edited.
     * @param value      - /
     * @param isSelected - is the cell currently selected
     * @param row        - the row identifier for the cell
     * @param column     - the column identifier for the cell
     * @return The editing component. A OntologyCellEditor.
     */

#Code:
    public Component getTableCellEditorComponent(JTable table, Object value,
                                                 boolean isSelected, int row, int column) {
        currentTable = table;
        currentRow = row;
        currentColumn = column;

        table.setRowSelectionInterval(row, row);
        table.setColumnSelectionInterval(column, column);

        if (table.getValueAt(row, column) != null) {
            originalValue = table.getValueAt(row, column).toString();
        } else {
            originalValue = "";
        }

        Point p = table.getLocationOnScreen();
        Rectangle r = table.getCellRect(row, column, true);
        int proposedX = r.x + p.x + getWidth();
        int proposedY = r.y + p.y + getHeight();

        setOnScreenLocation(new Point(proposedX, proposedY));
        showComponent();

        return this;
    }

#No. 4020
#File: E:\bishe\1\AbstractPofSerializer.java
#Comment:
    /**
     * Deserialize object attributes.
     *
     * @param obj     object instance to set attributes on
     * @param reader  PofReader to use
     *
     * @throws IOException  if an error occurs during deserialization
     */

#Code:
    @SuppressWarnings("UnusedDeclaration")
    protected void deserializeAttributes(T obj, PofReader reader)
            throws IOException
        {
        // default empty implementation
        }

#No. 4021
#File: E:\bishe\1\AbstractPofSerializer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public void serialize(PofWriter writer, Object obj)
            throws IOException
        {
        T         instance    = (T) obj;
        boolean   isEvolvable = obj instanceof Evolvable;
        Evolvable evolvable   = null;

        if (isEvolvable)
            {
            evolvable = (Evolvable) obj;
            int dataVersion = Math.max(
                    evolvable.getImplVersion(),
                    evolvable.getDataVersion());
            writer.setVersionId(dataVersion);
            }

        serializeAttributes(instance, writer);

        Binary futureData = isEvolvable
                            ? evolvable.getFutureData()
                            : null;
        writer.writeRemainder(futureData);
        }

#No. 4022
#File: E:\bishe\1\AbstractPofSerializer.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public Object deserialize(PofReader reader)
            throws IOException
        {
        T         instance    = createInstance(reader);
        boolean   isEvolvable = instance instanceof Evolvable;
        Evolvable evolvable   = null;

        if (isEvolvable)
            {
            evolvable = (Evolvable) instance;
            evolvable.setDataVersion(reader.getVersionId());
            }

        deserializeAttributes(instance, reader);

        Binary futureData = reader.readRemainder();
        if (isEvolvable)
            {
            evolvable.setFutureData(futureData);
            }

        return instance;
        }

#No. 4023
#File: E:\bishe\1\AbstractPointEventDetectorVO.java
#Comment:
	/**
	 * What data types are supported
	 * @param dataType
	 * @return
	 */

#Code:
    public boolean supports(int dataType) {
        return ArrayUtils.contains(supportedDataTypes, dataType);
    }

#No. 4024
#File: E:\bishe\1\AbstractPointLocatorVO.java
#Comment:
    /**
     * Defaults to returning null. Override to return something else.
     */

#Code:
    @Override
    public DataPointSaveHandler getDataPointSaveHandler() {
        return null;
    }

#No. 4025
#File: E:\bishe\1\AbstractPointLocatorVO.java
#Comment:
    /**
     * Defaults to returning false. Override to return something else.
     */

#Code:
    @Override
    public boolean isRelinquishable() {
        return false;
    }

#No. 4026
#File: E:\bishe\1\AbstractPointLocatorVO.java
#Comment:
    /**
     * Defaults to calling the response only version of the method so that subclasses are not forced to implement.
     */

#Code:
    @Override
    public void validate(ProcessResult response, DataPointVO dpvo) {
        validate(response);
    }

#No. 4027
#File: E:\bishe\1\AbstractPointWrapper.java
#Comment:
    /**
     * Get point values between the times.  
     * Inclusive of the value at from, exclusive of the value at to
     * @param from
     * @param to
     * @return List of PointValueTime objects or empty list
     */

#Code:
    public List<PointValueTime> pointValuesBetween(long from, long to){
    	return point.getPointValuesBetween(from, to);
    }

#No. 4028
#File: E:\bishe\1\AbstractPointWrapper.java
#Comment:
    /**
     * Get point values since timestamp
     * @param since
     * @return List of PointValueTime objects or empty list
     */

#Code:
    public List<PointValueTime> pointValuesSince(long since){
    	return point.getPointValues(since);
    	
    }

#No. 4029
#File: E:\bishe\1\AbstractPointWrapper.java
#Comment:
    /**
     * Get the nearest point value before the timestamp
     * @param timestamp
     * @return nearest value OR null
     */

#Code:
    public PointValueTime pointValueBefore(long timestamp){
    	return point.getPointValueBefore(timestamp);
    }

#No. 4030
#File: E:\bishe\1\AbstractPointWrapper.java
#Comment:
    /**
     * Get the nearest point value after the timestamp
     * @param timestamp
     * @return nearest value OR null
     */

#Code:
    public PointValueTime pointValueAfter(long timestamp){
    	return point.getPointValueAfter(timestamp);
    }    

#No. 4031
#File: E:\bishe\1\AbstractPointWrapper.java
#Comment:
    /**
     * Get the point value AT this time
     * @param timestamp
     * @return value at exactly this time OR null
     */

#Code:
    public PointValueTime pointValueAt(long timestamp){
    	return point.getPointValueAt(timestamp);
    }

#No. 4032
#File: E:\bishe\1\AbstractPointWrapper.java
#Comment:
    /**
     * Get the wrapper for the data point's vo
     * @param
     * @return vo of wrapper data point, as DataPointWrapper
     */

#Code:
    public DataPointWrapper getDataPointWrapper(){
    	if(voWrapper == null)
    		voWrapper = point.getDataPointWrapper(this);
    	return voWrapper;
    }

#No. 4033
#File: E:\bishe\1\AbstractPoliciesTest.java
#Comment:
    /**
     * Create schemas for the policy tests, depending on replication factors/strategies.
     */

#Code:
    public static void createSchema(Session session) {
        createSchema(session, 1);
    }

#No. 4034
#File: E:\bishe\1\AbstractPoliciesTest.java
#Comment:
    /**
     * Coordinator management/count
     */

#Code:
    protected void addCoordinator(ResultSet rs) {
        InetAddress coordinator = rs.getExecutionInfo().getQueriedHost().getAddress();
        Integer n = coordinators.get(coordinator);
        coordinators.put(coordinator, n == null ? 1 : n + 1);
    }

#No. 4035
#File: E:\bishe\1\AbstractPoliciesTest.java
#Comment:
    /**
     * Helper test methods
     */

#Code:
    protected void assertQueried(String host, int n) {
        try {
            Integer queried = coordinators.get(InetAddress.getByName(host));
            if (DEBUG)
                System.out.println(String.format("Expected: %s\tReceived: %s", n, queried));
            else {
                assertEquals(queried == null ? 0 : queried, n, queriedMapString());
            }
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

#No. 4036
#File: E:\bishe\1\AbstractPoliciesTest.java
#Comment:
    /**
     * Init methods that handle writes using batch and consistency options.
     */

#Code:
    protected void init(CCMBridge.CCMCluster c, int n) {
        write(c, n, false, ConsistencyLevel.ONE);
        prepared = c.session.prepare("SELECT * FROM " + SIMPLE_TABLE + " WHERE k = ?").setConsistencyLevel(ConsistencyLevel.ONE);
    }

#No. 4037
#File: E:\bishe\1\AbstractPoliciesTest.java
#Comment:
    /**
     * Query methods that handle reads based on PreparedStatements and/or ConsistencyLevels.
     */

#Code:
    protected void query(CCMBridge.CCMCluster c, int n) {
        query(c, n, false, ConsistencyLevel.ONE);
    }

#No. 4038
#File: E:\bishe\1\AbstractPollingScheduler.java
#Comment:
    /**
     * Stop the scheduler
     */

#Code:
    public abstract void stop();

    /**
     * @return if the scheduler ignores deletes from source
     */
    public final boolean isIgnoreDeletesFromSource() {
        return ignoreDeletesFromSource;
    }

#No. 4039
#File: E:\bishe\1\AbstractPollingScheduler.java
#Comment:
    /**
     * Set if the scheduler should ignore deletes from source when applying property changes
     */

#Code:
    public final void setIgnoreDeletesFromSource(boolean ignoreDeletesFromSource) {
        this.ignoreDeletesFromSource = ignoreDeletesFromSource;
    } 

#No. 4040
#File: E:\bishe\1\AbstractPool.java
#Comment:
	/**
	 * Constructor for non-spring environments.
	 * 
	 * @param apiConfig
	 *            configuration object
	 */

#Code:
	public AbstractPool(ThriftInterfaceConfiguration apiConfig) {
		this.apiConfig = apiConfig;
	}

#No. 4041
#File: E:\bishe\1\AbstractPoolEntry.java
#Comment:
    /**
     * Layers a protocol on top of an established tunnel.
     *
     * @param context   the context for layering
     * @param params    the parameters for layering
     *
     * @throws IOException  in case of a problem
     */

#Code:
    public void layerProtocol(HttpContext context, HttpParams params)
        throws IOException {

        //@@@ is context allowed to be null? depends on operator?
        if (params == null) {
            throw new IllegalArgumentException
                ("Parameters must not be null.");
        }

        if ((this.tracker == null) || !this.tracker.isConnected()) {
            throw new IllegalStateException("Connection not open.");
        }
        if (!this.tracker.isTunnelled()) {
            //@@@ allow this?
            throw new IllegalStateException
                ("Protocol layering without a tunnel not supported.");
        }
        if (this.tracker.isLayered()) {
            throw new IllegalStateException
                ("Multiple protocol layering not supported.");
        }

        // - collect the arguments
        // - call the operator
        // - update the tracking data
        // In this order, we can be sure that only a successful
        // layering on top of the connection will be tracked.

        final HttpHost target = tracker.getTargetHost();

        connOperator.updateSecureConnection(this.connection, target,
                                             context, params);

        this.tracker.layerProtocol(this.connection.isSecure());

    }

#No. 4042
#File: E:\bishe\1\AbstractPoolEntry.java
#Comment:
    /**
     * Shuts down the entry.
     *
     * If {@link #open(HttpRoute, HttpContext, HttpParams)} is in progress,
     * this will cause that open to possibly throw an {@link IOException}.
     */

#Code:
    protected void shutdownEntry() {
        tracker = null;
        state = null;
    }

#No. 4043
#File: E:\bishe\1\AbstractPopulateActionForm.java
#Comment:
    /**
     * <p>For a given request parameter name, trim off any prefix and/or
     * suffix which are defined in <code>actionConfig</code> and return what
     * remains. If either prefix or suffix is defined, then return null for
     * <code>name</code> values which do not begin or end accordingly.</p>
     *
     * @param actionConfig The ActionConfig we are processing
     * @param name         The request parameter name to proceess
     * @return The request parameter name trimmed of any suffix or prefix
     */

#Code:
    protected String trimParameterName(ActionConfig actionConfig, String name) {
        String stripped = name;
        String prefix = actionConfig.getPrefix();
        String suffix = actionConfig.getSuffix();

        if (prefix != null) {
            if (!stripped.startsWith(prefix)) {
                return null;
            }

            stripped = stripped.substring(prefix.length());
        }

        if (suffix != null) {
            if (!stripped.endsWith(suffix)) {
                return null;
            }

            stripped =
                stripped.substring(0, stripped.length() - suffix.length());
        }

        return stripped;
    }

#No. 4044
#File: E:\bishe\1\AbstractPopulateActionForm.java
#Comment:
    /**
     * <p>Take into account whether the request includes any defined value for
     * the global "cancel" parameter.</p> <p> An issue was raised (but I don't
     * think a Bugzilla ticket created) about the security implications of
     * using a well-known cancel property which skips form validation, as you
     * may not write your actions to deal with the cancellation case. </p>
     *
     * @param context      The ActionContext we are processing
     * @param actionConfig The ActionConfig we are processing
     * @param actionForm   The ActionForm we are processing
     * @throws Exception On an unexpected error
     * @see Globals.CANCEL_PROPERTY
     * @see Globals.CANCEL_PROPERTY_X
     */

#Code:
    protected void handleCancel(ActionContext context,
        ActionConfig actionConfig, ActionForm actionForm)
        throws Exception {
        Map paramValues = context.getParameterMap();

        // Set the cancellation attribute if appropriate
        if ((paramValues.get(Globals.CANCEL_PROPERTY) != null)
            || (paramValues.get(Globals.CANCEL_PROPERTY_X) != null)) {
            context.setCancelled(Boolean.TRUE);
        } else {
            context.setCancelled(Boolean.FALSE);
        }
    }

#No. 4045
#File: E:\bishe\1\AbstractPositionFinder.java
#Comment:
    /**
     * Returns true if game says it's possible to build given building at this position.
     */

#Code:
    public static boolean isForbiddenByStreetBlock(AUnit builder, AUnitType building, APosition position) {
        
        // Special buildings can be build anywhere
        if (building.isBase() || building.isGasBuilding() || building.isBunker()) {
            return false;
        }
        
        // =========================================================
        
        // Leave entire vertical (same tileX) corridor free for units
        if (position.getTileX() % 7 == 1 || position.getTileX() % 8 == 1) {
            _CONDITION_THAT_FAILED = "LEAVE_PLACE_VERTICALLY";
            return true;
        }
        
        // Leave entire horizontal (same tileY) corridor free for units
        if (position.getTileY() % 5 == 0 || position.getTileY() % 6 == 0) {
            _CONDITION_THAT_FAILED = "LEAVE_PLACE_HORIZONTALLY";
            return true;
        }
        
        // Position okay
        return false;
    }

#No. 4046
#File: E:\bishe\1\AbstractPositionFinder.java
#Comment:
    /**
     * Returns true if game says it's possible to build given building at this position.
     */

#Code:
    public static boolean canPhysicallyBuildHere(AUnit builder, AUnitType building, APosition position) {
        if (position == null) {
            _CONDITION_THAT_FAILED = "POSITION IS NULL";
            return false;
        }
        if (builder == null) {
            _CONDITION_THAT_FAILED = "BUILDER IS NULL";
            return false;
        }
        
        return Atlantis.getBwapi().canBuildHere(position.toTilePosition(), building.ut(), builder.u());
//        return Atlantis.getBwapi().canBuildHere(position.toTilePosition(), building.ut(), builder.u(), false);
    }

#No. 4047
#File: E:\bishe\1\AbstractPositionFinder.java
#Comment:
    /**
     * Returns true if any other building is too close to this building or if two buildings would overlap
     * add-on place of another. Buildings can be stacked, but it needs to be done properly e.g. Supply Depots
     * could be stacked.
     */

#Code:
    protected static boolean isOtherConstructionTooClose(AUnit builder, AUnitType building, Position position) {
        
        // Compare against planned construction places
        for (ConstructionOrder constructionOrder : AConstructionManager.getAllConstructionOrders()) {
            if (ConstructionOrderStatus.CONSTRUCTION_NOT_STARTED.equals(constructionOrder.getStatus())
                    && !builder.equals(constructionOrder.getBuilder())) {
                if (constructionOrder.getPositionToBuild() != null) {
                    double distance = PositionUtil.distanceTo(constructionOrder.getPositionToBuild(), position);
                    boolean areBasesTooCloseOneToAnother = (distance <= 8 && !AGame.playsAsZerg()
                            && building.isBase() && constructionOrder.getBuildingType().isBase());
                    
                    // Look for two bases that would be built too close one to another
                    if (distance <= 4 || areBasesTooCloseOneToAnother) {
                        _CONDITION_THAT_FAILED = "PLANNED BUILDING TOO CLOSE (" 
                                + constructionOrder.getBuildingType() + ", DIST: " + distance + ")";
                        return true;
                    }
                }
            }
        }

        // No collisions detected
        return false;
    }

#No. 4048
#File: E:\bishe\1\AbstractPostEditor.java
#Comment:
    /**
     * Adds more specific properties before sending.
     *
     * @param post post.
     */

#Code:
    protected void addProperties(WeblogPost post)
    {
    }

#No. 4049
#File: E:\bishe\1\AbstractPostEditor.java
#Comment:
        /**
         * Create titled and iconed wrapper.
         *
         * @param target    target action.
         * @param titleID   resource ID of the title.
         * @param icon      icon.
         */

#Code:
        public ActionWrapper(Action target, String titleID, Icon icon)
        {
            super(Strings.message(titleID), icon);
            this.target = target;
        }

#No. 4050
#File: E:\bishe\1\AbstractPostEditor.java
#Comment:
        /**
         * Executes target action.
         *
         * @param e event.
         */

#Code:
        public void actionPerformed(ActionEvent e)
        {
            target.actionPerformed(e);
        }

#No. 4051
#File: E:\bishe\1\AbstractPostEditor.java
#Comment:
    /**
     * Handler of UNDO / REDO operations.
     */

#Code:
    class UndoHandler implements UndoableEditListener
    {
        /**
         * Messaged when the Document has created an edit, the edit is
         * added to <code>undo</code>, an instance of UndoManager.
         */
        public void undoableEditHappened(UndoableEditEvent e)
        {
            undo.addEdit(e.getEdit());
            undoAction.update();
            redoAction.update();
        }
    }

#No. 4052
#File: E:\bishe\1\AbstractPostEditor.java
#Comment:
    /**
     * UNDO action.
     */

#Code:
    class UndoAction extends AbstractAction
    {
        /** Constructor. */
        public UndoAction()
        {
            super("Undo");
            setEnabled(false);
        }

        /**
         * Invoked when a user presses ctrl-z or clicks undo button.
         *
         * @param e even.
         */
        public void actionPerformed(ActionEvent e)
        {
            try
            {
                undo.undo();
            } catch (CannotUndoException ex)
            {
                System.out.println("Unable to undo: " + ex);
                ex.printStackTrace();
            }

            update();
            redoAction.update();
        }

        /** Updates the state. */
        protected void update()
        {
            setEnabled(undo.canUndo());
        }
    }

#No. 4053
#File: E:\bishe\1\AbstractPostEditor.java
#Comment:
        /**
         * Invoked when a user presses ctrl-shift-z or clicks redo button.
         *
         * @param e event.
         */

#Code:
        public void actionPerformed(ActionEvent e)
        {
            try
            {
                undo.redo();
            } catch (CannotRedoException ex)
            {
                System.err.println("Unable to redo: " + ex);
                ex.printStackTrace();
            }
            update();
            undoAction.update();
        }

#No. 4054
#File: E:\bishe\1\AbstractPostprocessorPlugin.java
#Comment:
/**
 * Abstract base class for plugin postprocessors.
 * 
 * @author Curtis Rueden
 */

#Code:
public abstract class AbstractPostprocessorPlugin extends AbstractContextual
	implements PostprocessorPlugin
{
	// NB: No implementation needed.
}

#No. 4055
#File: E:\bishe\1\AbstractPreAuthFederationFilter.java
#Comment:
  /**
   * 
   */

#Code:
  public AbstractPreAuthFederationFilter() {
    super();
  }

#No. 4056
#File: E:\bishe\1\AbstractPreAuthFederationFilter.java
#Comment:
  /**
   * @param httpRequest
   */

#Code:
  abstract protected String getPrimaryPrincipal(HttpServletRequest httpRequest);

  /**
   * @param principals
   */
  abstract protected void addGroupPrincipals(HttpServletRequest request, Set<Principal> principals);
}
#No. 4057
#File: E:\bishe\1\AbstractPreferencePage.java
#Comment:
	/**
	 * only when used as property page
	 */

#Code:
	private IAdaptable element;

	public AbstractPreferencePage(PrefPage page) {
		super(page);
	}

#No. 4058
#File: E:\bishe\1\AbstractPreferencePage.java
#Comment:
	/**
	 * only when used as property page
	 * @see org.eclipse.ui.IWorkbenchPropertyPage#getElement()
	 */

#Code:
	public IAdaptable getElement() {
		return element;
	}

#No. 4059
#File: E:\bishe\1\AbstractPreferencePage.java
#Comment:
	/**
	 * only when used as property page
	 * @see org.eclipse.ui.IWorkbenchPropertyPage#setElement(org.eclipse.core.runtime.IAdaptable)
	 */

#Code:
	public void setElement(IAdaptable element) {
		this.element = element;
		setPreferenceStore(retrievePreferenceStore(page.getPreferences()));
	}

#No. 4060
#File: E:\bishe\1\AbstractPreferences.java
#Comment:
    /**
     * Implements the <tt>remove(String)</tt> method as per the specification
     * in {@link Preferences#remove(String)}.
     *
     * <p>This implementation obtains this preference node's lock,
     * checks that the node has not been removed, invokes
     * {@link #removeSpi(String)} and if there are any preference
     * change listeners, enqueues a notification event for processing by the
     * event dispatch thread.
     *
     * @param key key whose mapping is to be removed from the preference node.
     * @throws IllegalStateException if this node (or an ancestor) has been
     *         removed with the {@link #removeNode()} method.
     */

#Code:
    public void remove(String key) {
        synchronized(lock) {
            if (removed)
                throw new IllegalStateException("Node has been removed.");

            removeSpi(key);
            enqueuePreferenceChangeEvent(key, null);
        }
    }

#No. 4061
#File: E:\bishe\1\AbstractPreferences.java
#Comment:
    /**
     * Implements the <tt>clear</tt> method as per the specification in
     * {@link Preferences#clear()}.
     *
     * <p>This implementation obtains this preference node's lock,
     * invokes {@link #keys()} to obtain an array of keys, and
     * iterates over the array invoking {@link #remove(String)} on each key.
     *
     * @throws BackingStoreException if this operation cannot be completed
     *         due to a failure in the backing store, or inability to
     *         communicate with it.
     * @throws IllegalStateException if this node (or an ancestor) has been
     *         removed with the {@link #removeNode()} method.
     */

#Code:
    public void clear() throws BackingStoreException {
        synchronized(lock) {
            String[] keys = keys();
            for (int i=0; i<keys.length; i++)
                remove(keys[i]);
        }
    }

#No. 4062
#File: E:\bishe\1\AbstractPreferences.java
#Comment:
    /**
     * Implements the <tt>putInt</tt> method as per the specification in
     * {@link Preferences#putInt(String,int)}.
     *
     * <p>This implementation translates <tt>value</tt> to a string with
     * {@link Integer#toString(int)} and invokes {@link #put(String,String)}
     * on the result.
     *
     * @param key key with which the string form of value is to be associated.
     * @param value value whose string form is to be associated with key.
     * @throws NullPointerException if key is <tt>null</tt>.
     * @throws IllegalArgumentException if <tt>key.length()</tt> exceeds
     *         <tt>MAX_KEY_LENGTH</tt>.
     * @throws IllegalStateException if this node (or an ancestor) has been
     *         removed with the {@link #removeNode()} method.
     */

#Code:
    public void putInt(String key, int value) {
        put(key, Integer.toString(value));
    }

#No. 4063
#File: E:\bishe\1\AbstractPreferences.java
#Comment:
    /**
     * Implements the <tt>getInt</tt> method as per the specification in
     * {@link Preferences#getInt(String,int)}.
     *
     * <p>This implementation invokes {@link #get(String,String) <tt>get(key,
     * null)</tt>}.  If the return value is non-null, the implementation
     * attempts to translate it to an <tt>int</tt> with
     * {@link Integer#parseInt(String)}.  If the attempt succeeds, the return
     * value is returned by this method.  Otherwise, <tt>def</tt> is returned.
     *
     * @param key key whose associated value is to be returned as an int.
     * @param def the value to be returned in the event that this
     *        preference node has no value associated with <tt>key</tt>
     *        or the associated value cannot be interpreted as an int.
     * @return the int value represented by the string associated with
     *         <tt>key</tt> in this preference node, or <tt>def</tt> if the
     *         associated value does not exist or cannot be interpreted as
     *         an int.
     * @throws IllegalStateException if this node (or an ancestor) has been
     *         removed with the {@link #removeNode()} method.
     * @throws NullPointerException if <tt>key</tt> is <tt>null</tt>.
     */

#Code:
    public int getInt(String key, int def) {
        int result = def;
        try {
            String value = get(key, null);
            if (value != null)
                result = Integer.parseInt(value);
        } catch (NumberFormatException e) {
            // Ignoring exception causes specified default to be returned
        }

        return result;
    }

#No. 4064
#File: E:\bishe\1\AbstractPreferences.java
#Comment:
    /**
     * Implements the <tt>putLong</tt> method as per the specification in
     * {@link Preferences#putLong(String,long)}.
     *
     * <p>This implementation translates <tt>value</tt> to a string with
     * {@link Long#toString(long)} and invokes {@link #put(String,String)}
     * on the result.
     *
     * @param key key with which the string form of value is to be associated.
     * @param value value whose string form is to be associated with key.
     * @throws NullPointerException if key is <tt>null</tt>.
     * @throws IllegalArgumentException if <tt>key.length()</tt> exceeds
     *         <tt>MAX_KEY_LENGTH</tt>.
     * @throws IllegalStateException if this node (or an ancestor) has been
     *         removed with the {@link #removeNode()} method.
     */

#Code:
    public void putLong(String key, long value) {
        put(key, Long.toString(value));
    }

#No. 4065
#File: E:\bishe\1\AbstractPreferences.java
#Comment:
    /**
     * Implements the <tt>getLong</tt> method as per the specification in
     * {@link Preferences#getLong(String,long)}.
     *
     * <p>This implementation invokes {@link #get(String,String) <tt>get(key,
     * null)</tt>}.  If the return value is non-null, the implementation
     * attempts to translate it to a <tt>long</tt> with
     * {@link Long#parseLong(String)}.  If the attempt succeeds, the return
     * value is returned by this method.  Otherwise, <tt>def</tt> is returned.
     *
     * @param key key whose associated value is to be returned as a long.
     * @param def the value to be returned in the event that this
     *        preference node has no value associated with <tt>key</tt>
     *        or the associated value cannot be interpreted as a long.
     * @return the long value represented by the string associated with
     *         <tt>key</tt> in this preference node, or <tt>def</tt> if the
     *         associated value does not exist or cannot be interpreted as
     *         a long.
     * @throws IllegalStateException if this node (or an ancestor) has been
     *         removed with the {@link #removeNode()} method.
     * @throws NullPointerException if <tt>key</tt> is <tt>null</tt>.
     */

#Code:
    public long getLong(String key, long def) {
        long result = def;
        try {
            String value = get(key, null);
            if (value != null)
                result = Long.parseLong(value);
        } catch (NumberFormatException e) {
            // Ignoring exception causes specified default to be returned
        }

        return result;
    }

#No. 4066
#File: E:\bishe\1\AbstractPreferences.java
#Comment:
    /**
     * Implements the <tt>putBoolean</tt> method as per the specification in
     * {@link Preferences#putBoolean(String,boolean)}.
     *
     * <p>This implementation translates <tt>value</tt> to a string with
     * {@link String#valueOf(boolean)} and invokes {@link #put(String,String)}
     * on the result.
     *
     * @param key key with which the string form of value is to be associated.
     * @param value value whose string form is to be associated with key.
     * @throws NullPointerException if key is <tt>null</tt>.
     * @throws IllegalArgumentException if <tt>key.length()</tt> exceeds
     *         <tt>MAX_KEY_LENGTH</tt>.
     * @throws IllegalStateException if this node (or an ancestor) has been
     *         removed with the {@link #removeNode()} method.
     */

#Code:
    public void putBoolean(String key, boolean value) {
        put(key, String.valueOf(value));
    }

#No. 4067
#File: E:\bishe\1\AbstractPreferences.java
#Comment:
    /**
     * Implements the <tt>getBoolean</tt> method as per the specification in
     * {@link Preferences#getBoolean(String,boolean)}.
     *
     * <p>This implementation invokes {@link #get(String,String) <tt>get(key,
     * null)</tt>}.  If the return value is non-null, it is compared with
     * <tt>"true"</tt> using {@link String#equalsIgnoreCase(String)}.  If the
     * comparison returns <tt>true</tt>, this invocation returns
     * <tt>true</tt>.  Otherwise, the original return value is compared with
     * <tt>"false"</tt>, again using {@link String#equalsIgnoreCase(String)}.
     * If the comparison returns <tt>true</tt>, this invocation returns
     * <tt>false</tt>.  Otherwise, this invocation returns <tt>def</tt>.
     *
     * @param key key whose associated value is to be returned as a boolean.
     * @param def the value to be returned in the event that this
     *        preference node has no value associated with <tt>key</tt>
     *        or the associated value cannot be interpreted as a boolean.
     * @return the boolean value represented by the string associated with
     *         <tt>key</tt> in this preference node, or <tt>def</tt> if the
     *         associated value does not exist or cannot be interpreted as
     *         a boolean.
     * @throws IllegalStateException if this node (or an ancestor) has been
     *         removed with the {@link #removeNode()} method.
     * @throws NullPointerException if <tt>key</tt> is <tt>null</tt>.
     */

#Code:
    public boolean getBoolean(String key, boolean def) {
        boolean result = def;
        String value = get(key, null);
        if (value != null) {
            if (value.equalsIgnoreCase("true"))
                result = true;
            else if (value.equalsIgnoreCase("false"))
                result = false;
        }

        return result;
    }

#No. 4068
#File: E:\bishe\1\AbstractPreferences.java
#Comment:
    /**
     * Implements the <tt>putFloat</tt> method as per the specification in
     * {@link Preferences#putFloat(String,float)}.
     *
     * <p>This implementation translates <tt>value</tt> to a string with
     * {@link Float#toString(float)} and invokes {@link #put(String,String)}
     * on the result.
     *
     * @param key key with which the string form of value is to be associated.
     * @param value value whose string form is to be associated with key.
     * @throws NullPointerException if key is <tt>null</tt>.
     * @throws IllegalArgumentException if <tt>key.length()</tt> exceeds
     *         <tt>MAX_KEY_LENGTH</tt>.
     * @throws IllegalStateException if this node (or an ancestor) has been
     *         removed with the {@link #removeNode()} method.
     */

#Code:
    public void putFloat(String key, float value) {
        put(key, Float.toString(value));
    }

#No. 4069
#File: E:\bishe\1\AbstractPreferences.java
#Comment:
    /**
     * Implements the <tt>getFloat</tt> method as per the specification in
     * {@link Preferences#getFloat(String,float)}.
     *
     * <p>This implementation invokes {@link #get(String,String) <tt>get(key,
     * null)</tt>}.  If the return value is non-null, the implementation
     * attempts to translate it to an <tt>float</tt> with
     * {@link Float#parseFloat(String)}.  If the attempt succeeds, the return
     * value is returned by this method.  Otherwise, <tt>def</tt> is returned.
     *
     * @param key key whose associated value is to be returned as a float.
     * @param def the value to be returned in the event that this
     *        preference node has no value associated with <tt>key</tt>
     *        or the associated value cannot be interpreted as a float.
     * @return the float value represented by the string associated with
     *         <tt>key</tt> in this preference node, or <tt>def</tt> if the
     *         associated value does not exist or cannot be interpreted as
     *         a float.
     * @throws IllegalStateException if this node (or an ancestor) has been
     *         removed with the {@link #removeNode()} method.
     * @throws NullPointerException if <tt>key</tt> is <tt>null</tt>.
     */

#Code:
    public float getFloat(String key, float def) {
        float result = def;
        try {
            String value = get(key, null);
            if (value != null)
                result = Float.parseFloat(value);
        } catch (NumberFormatException e) {
            // Ignoring exception causes specified default to be returned
        }

        return result;
    }

#No. 4070
#File: E:\bishe\1\AbstractPreferences.java
#Comment:
    /**
     * Implements the <tt>putDouble</tt> method as per the specification in
     * {@link Preferences#putDouble(String,double)}.
     *
     * <p>This implementation translates <tt>value</tt> to a string with
     * {@link Double#toString(double)} and invokes {@link #put(String,String)}
     * on the result.
     *
     * @param key key with which the string form of value is to be associated.
     * @param value value whose string form is to be associated with key.
     * @throws NullPointerException if key is <tt>null</tt>.
     * @throws IllegalArgumentException if <tt>key.length()</tt> exceeds
     *         <tt>MAX_KEY_LENGTH</tt>.
     * @throws IllegalStateException if this node (or an ancestor) has been
     *         removed with the {@link #removeNode()} method.
     */

#Code:
    public void putDouble(String key, double value) {
        put(key, Double.toString(value));
    }

#No. 4071
#File: E:\bishe\1\AbstractPreferences.java
#Comment:
    /**
     * Implements the <tt>getDouble</tt> method as per the specification in
     * {@link Preferences#getDouble(String,double)}.
     *
     * <p>This implementation invokes {@link #get(String,String) <tt>get(key,
     * null)</tt>}.  If the return value is non-null, the implementation
     * attempts to translate it to an <tt>double</tt> with
     * {@link Double#parseDouble(String)}.  If the attempt succeeds, the return
     * value is returned by this method.  Otherwise, <tt>def</tt> is returned.
     *
     * @param key key whose associated value is to be returned as a double.
     * @param def the value to be returned in the event that this
     *        preference node has no value associated with <tt>key</tt>
     *        or the associated value cannot be interpreted as a double.
     * @return the double value represented by the string associated with
     *         <tt>key</tt> in this preference node, or <tt>def</tt> if the
     *         associated value does not exist or cannot be interpreted as
     *         a double.
     * @throws IllegalStateException if this node (or an ancestor) has been
     *         removed with the {@link #removeNode()} method.
     * @throws NullPointerException if <tt>key</tt> is <tt>null</tt>.
     */

#Code:
    public double getDouble(String key, double def) {
        double result = def;
        try {
            String value = get(key, null);
            if (value != null)
                result = Double.parseDouble(value);
        } catch (NumberFormatException e) {
            // Ignoring exception causes specified default to be returned
        }

        return result;
    }

#No. 4072
#File: E:\bishe\1\AbstractPreferences.java
#Comment:
    /**
     * Implements the <tt>putByteArray</tt> method as per the specification in
     * {@link Preferences#putByteArray(String,byte[])}.
     *
     * @param key key with which the string form of value is to be associated.
     * @param value value whose string form is to be associated with key.
     * @throws NullPointerException if key or value is <tt>null</tt>.
     * @throws IllegalArgumentException if key.length() exceeds MAX_KEY_LENGTH
     *         or if value.length exceeds MAX_VALUE_LENGTH*3/4.
     * @throws IllegalStateException if this node (or an ancestor) has been
     *         removed with the {@link #removeNode()} method.
     */

#Code:
    public void putByteArray(String key, byte[] value) {
        put(key, Base64.byteArrayToBase64(value));
    }

#No. 4073
#File: E:\bishe\1\AbstractPreferences.java
#Comment:
    /**
     * Implements the <tt>getByteArray</tt> method as per the specification in
     * {@link Preferences#getByteArray(String,byte[])}.
     *
     * @param key key whose associated value is to be returned as a byte array.
     * @param def the value to be returned in the event that this
     *        preference node has no value associated with <tt>key</tt>
     *        or the associated value cannot be interpreted as a byte array.
     * @return the byte array value represented by the string associated with
     *         <tt>key</tt> in this preference node, or <tt>def</tt> if the
     *         associated value does not exist or cannot be interpreted as
     *         a byte array.
     * @throws IllegalStateException if this node (or an ancestor) has been
     *         removed with the {@link #removeNode()} method.
     * @throws NullPointerException if <tt>key</tt> is <tt>null</tt>.  (A
     *         <tt>null</tt> value for <tt>def</tt> <i>is</i> permitted.)
     */

#Code:
    public byte[] getByteArray(String key, byte[] def) {
        byte[] result = def;
        String value = get(key, null);
        try {
            if (value != null)
                result = Base64.base64ToByteArray(value);
        }
        catch (RuntimeException e) {
            // Ignoring exception causes specified default to be returned
        }

        return result;
    }

#No. 4074
#File: E:\bishe\1\AbstractPreferences.java
#Comment:
    /**
     * Implements the <tt>keys</tt> method as per the specification in
     * {@link Preferences#keys()}.
     *
     * <p>This implementation obtains this preference node's lock, checks that
     * the node has not been removed and invokes {@link #keysSpi()}.
     *
     * @return an array of the keys that have an associated value in this
     *         preference node.
     * @throws BackingStoreException if this operation cannot be completed
     *         due to a failure in the backing store, or inability to
     *         communicate with it.
     * @throws IllegalStateException if this node (or an ancestor) has been
     *         removed with the {@link #removeNode()} method.
     */

#Code:
    public String[] keys() throws BackingStoreException {
        synchronized(lock) {
            if (removed)
                throw new IllegalStateException("Node has been removed.");

            return keysSpi();
        }
    }

#No. 4075
#File: E:\bishe\1\AbstractPreferences.java
#Comment:
    /**
     * Implements the <tt>children</tt> method as per the specification in
     * {@link Preferences#childrenNames()}.
     *
     * <p>This implementation obtains this preference node's lock, checks that
     * the node has not been removed, constructs a <tt>TreeSet</tt> initialized
     * to the names of children already cached (the children in this node's
     * "child-cache"), invokes {@link #childrenNamesSpi()}, and adds all of the
     * returned child-names into the set.  The elements of the tree set are
     * dumped into a <tt>String</tt> array using the <tt>toArray</tt> method,
     * and this array is returned.
     *
     * @return the names of the children of this preference node.
     * @throws BackingStoreException if this operation cannot be completed
     *         due to a failure in the backing store, or inability to
     *         communicate with it.
     * @throws IllegalStateException if this node (or an ancestor) has been
     *         removed with the {@link #removeNode()} method.
     * @see #cachedChildren()
     */

#Code:
    public String[] childrenNames() throws BackingStoreException {
        synchronized(lock) {
            if (removed)
                throw new IllegalStateException("Node has been removed.");

            Set<String> s = new TreeSet<>(kidCache.keySet());
            for (String kid : childrenNamesSpi())
                s.add(kid);
            return s.toArray(EMPTY_STRING_ARRAY);
        }
    }

#No. 4076
#File: E:\bishe\1\AbstractPreferences.java
#Comment:
    /**
     * Returns all known unremoved children of this node.
     *
     * @return all known unremoved children of this node.
     */

#Code:
    protected final AbstractPreferences[] cachedChildren() {
        return kidCache.values().toArray(EMPTY_ABSTRACT_PREFS_ARRAY);
    }

#No. 4077
#File: E:\bishe\1\AbstractPreferences.java
#Comment:
    /**
     * Implements the <tt>parent</tt> method as per the specification in
     * {@link Preferences#parent()}.
     *
     * <p>This implementation obtains this preference node's lock, checks that
     * the node has not been removed and returns the parent value that was
     * passed to this node's constructor.
     *
     * @return the parent of this preference node.
     * @throws IllegalStateException if this node (or an ancestor) has been
     *         removed with the {@link #removeNode()} method.
     */

#Code:
    public Preferences parent() {
        synchronized(lock) {
            if (removed)
                throw new IllegalStateException("Node has been removed.");

            return parent;
        }
    }

#No. 4078
#File: E:\bishe\1\AbstractPreferences.java
#Comment:
    /**
     * Implements the <tt>node</tt> method as per the specification in
     * {@link Preferences#node(String)}.
     *
     * <p>This implementation obtains this preference node's lock and checks
     * that the node has not been removed.  If <tt>path</tt> is <tt>""</tt>,
     * this node is returned; if <tt>path</tt> is <tt>"/"</tt>, this node's
     * root is returned.  If the first character in <tt>path</tt> is
     * not <tt>'/'</tt>, the implementation breaks <tt>path</tt> into
     * tokens and recursively traverses the path from this node to the
     * named node, "consuming" a name and a slash from <tt>path</tt> at
     * each step of the traversal.  At each step, the current node is locked
     * and the node's child-cache is checked for the named node.  If it is
     * not found, the name is checked to make sure its length does not
     * exceed <tt>MAX_NAME_LENGTH</tt>.  Then the {@link #childSpi(String)}
     * method is invoked, and the result stored in this node's child-cache.
     * If the newly created <tt>Preferences</tt> object's {@link #newNode}
     * field is <tt>true</tt> and there are any node change listeners,
     * a notification event is enqueued for processing by the event dispatch
     * thread.
     *
     * <p>When there are no more tokens, the last value found in the
     * child-cache or returned by <tt>childSpi</tt> is returned by this
     * method.  If during the traversal, two <tt>"/"</tt> tokens occur
     * consecutively, or the final token is <tt>"/"</tt> (rather than a name),
     * an appropriate <tt>IllegalArgumentException</tt> is thrown.
     *
     * <p> If the first character of <tt>path</tt> is <tt>'/'</tt>
     * (indicating an absolute path name) this preference node's
     * lock is dropped prior to breaking <tt>path</tt> into tokens, and
     * this method recursively traverses the path starting from the root
     * (rather than starting from this node).  The traversal is otherwise
     * identical to the one described for relative path names.  Dropping
     * the lock on this node prior to commencing the traversal at the root
     * node is essential to avoid the possibility of deadlock, as per the
     * {@link #lock locking invariant}.
     *
     * @param path the path name of the preference node to return.
     * @return the specified preference node.
     * @throws IllegalArgumentException if the path name is invalid (i.e.,
     *         it contains multiple consecutive slash characters, or ends
     *         with a slash character and is more than one character long).
     * @throws IllegalStateException if this node (or an ancestor) has been
     *         removed with the {@link #removeNode()} method.
     */

#Code:
    public Preferences node(String path) {
        synchronized(lock) {
            if (removed)
                throw new IllegalStateException("Node has been removed.");
            if (path.equals(""))
                return this;
            if (path.equals("/"))
                return root;
            if (path.charAt(0) != '/')
                return node(new StringTokenizer(path, "/", true));
        }

        // Absolute path.  Note that we've dropped our lock to avoid deadlock
        return root.node(new StringTokenizer(path.substring(1), "/", true));
    }

#No. 4079
#File: E:\bishe\1\AbstractPreferences.java
#Comment:
    /**
     * tokenizer contains <name> {'/' <name>}*
     */

#Code:
    private Preferences node(StringTokenizer path) {
        String token = path.nextToken();
        if (token.equals("/"))  // Check for consecutive slashes
            throw new IllegalArgumentException("Consecutive slashes in path");
        synchronized(lock) {
            AbstractPreferences child = kidCache.get(token);
            if (child == null) {
                if (token.length() > MAX_NAME_LENGTH)
                    throw new IllegalArgumentException(
                        "Node name " + token + " too long");
                child = childSpi(token);
                if (child.newNode)
                    enqueueNodeAddedEvent(child);
                kidCache.put(token, child);
            }
            if (!path.hasMoreTokens())
                return child;
            path.nextToken();  // Consume slash
            if (!path.hasMoreTokens())
                throw new IllegalArgumentException("Path ends with slash");
            return child.node(path);
        }
    }

#No. 4080
#File: E:\bishe\1\AbstractPreferences.java
#Comment:
    /**
     * Implements the <tt>nodeExists</tt> method as per the specification in
     * {@link Preferences#nodeExists(String)}.
     *
     * <p>This implementation is very similar to {@link #node(String)},
     * except that {@link #getChild(String)} is used instead of {@link
     * #childSpi(String)}.
     *
     * @param path the path name of the node whose existence is to be checked.
     * @return true if the specified node exists.
     * @throws BackingStoreException if this operation cannot be completed
     *         due to a failure in the backing store, or inability to
     *         communicate with it.
     * @throws IllegalArgumentException if the path name is invalid (i.e.,
     *         it contains multiple consecutive slash characters, or ends
     *         with a slash character and is more than one character long).
     * @throws IllegalStateException if this node (or an ancestor) has been
     *         removed with the {@link #removeNode()} method and
     *         <tt>pathname</tt> is not the empty string (<tt>""</tt>).
     */

#Code:
    public boolean nodeExists(String path)
        throws BackingStoreException
    {
        synchronized(lock) {
            if (path.equals(""))
                return !removed;
            if (removed)
                throw new IllegalStateException("Node has been removed.");
            if (path.equals("/"))
                return true;
            if (path.charAt(0) != '/')
                return nodeExists(new StringTokenizer(path, "/", true));
        }

        // Absolute path.  Note that we've dropped our lock to avoid deadlock
        return root.nodeExists(new StringTokenizer(path.substring(1), "/",
                                                   true));
    }

#No. 4081
#File: E:\bishe\1\AbstractPreferences.java
#Comment:
    /**
     * tokenizer contains <name> {'/' <name>}*
     */

#Code:
    private boolean nodeExists(StringTokenizer path)
        throws BackingStoreException
    {
        String token = path.nextToken();
        if (token.equals("/"))  // Check for consecutive slashes
            throw new IllegalArgumentException("Consecutive slashes in path");
        synchronized(lock) {
            AbstractPreferences child = kidCache.get(token);
            if (child == null)
                child = getChild(token);
            if (child==null)
                return false;
            if (!path.hasMoreTokens())
                return true;
            path.nextToken();  // Consume slash
            if (!path.hasMoreTokens())
                throw new IllegalArgumentException("Path ends with slash");
            return child.nodeExists(path);
        }
    }

#No. 4082
#File: E:\bishe\1\AbstractPreferences.java
#Comment:
    /**

     * Implements the <tt>removeNode()</tt> method as per the specification in
     * {@link Preferences#removeNode()}.
     *
     * <p>This implementation checks to see that this node is the root; if so,
     * it throws an appropriate exception.  Then, it locks this node's parent,
     * and calls a recursive helper method that traverses the subtree rooted at
     * this node.  The recursive method locks the node on which it was called,
     * checks that it has not already been removed, and then ensures that all
     * of its children are cached: The {@link #childrenNamesSpi()} method is
     * invoked and each returned child name is checked for containment in the
     * child-cache.  If a child is not already cached, the {@link
     * #childSpi(String)} method is invoked to create a <tt>Preferences</tt>
     * instance for it, and this instance is put into the child-cache.  Then
     * the helper method calls itself recursively on each node contained in its
     * child-cache.  Next, it invokes {@link #removeNodeSpi()}, marks itself
     * as removed, and removes itself from its parent's child-cache.  Finally,
     * if there are any node change listeners, it enqueues a notification
     * event for processing by the event dispatch thread.
     *
     * <p>Note that the helper method is always invoked with all ancestors up
     * to the "closest non-removed ancestor" locked.
     *
     * @throws IllegalStateException if this node (or an ancestor) has already
     *         been removed with the {@link #removeNode()} method.
     * @throws UnsupportedOperationException if this method is invoked on
     *         the root node.
     * @throws BackingStoreException if this operation cannot be completed
     *         due to a failure in the backing store, or inability to
     *         communicate with it.
     */

#Code:
    public void removeNode() throws BackingStoreException {
        if (this==root)
            throw new UnsupportedOperationException("Can't remove the root!");
        synchronized(parent.lock) {
            removeNode2();
            parent.kidCache.remove(name);
        }
    }

#No. 4083
#File: E:\bishe\1\AbstractPreferences.java
#Comment:
    /*
     * Called with locks on all nodes on path from parent of "removal root"
     * to this (including the former but excluding the latter).
     */

#Code:
    private void removeNode2() throws BackingStoreException {
        synchronized(lock) {
            if (removed)
                throw new IllegalStateException("Node already removed.");

            // Ensure that all children are cached
            String[] kidNames = childrenNamesSpi();
            for (int i=0; i<kidNames.length; i++)
                if (!kidCache.containsKey(kidNames[i]))
                    kidCache.put(kidNames[i], childSpi(kidNames[i]));

            // Recursively remove all cached children
            for (Iterator<AbstractPreferences> i = kidCache.values().iterator();
                 i.hasNext();) {
                try {
                    i.next().removeNode2();
                    i.remove();
                } catch (BackingStoreException x) { }
            }

            // Now we have no descendants - it's time to die!
            removeNodeSpi();
            removed = true;
            parent.enqueueNodeRemovedEvent(this);
        }
    }

#No. 4084
#File: E:\bishe\1\AbstractPreferences.java
#Comment:
    /**
     * Implements the <tt>name</tt> method as per the specification in
     * {@link Preferences#name()}.
     *
     * <p>This implementation merely returns the name that was
     * passed to this node's constructor.
     *
     * @return this preference node's name, relative to its parent.
     */

#Code:
    public String name() {
        return name;
    }

#No. 4085
#File: E:\bishe\1\AbstractPreferences.java
#Comment:
    /**
     * Implements the <tt>absolutePath</tt> method as per the specification in
     * {@link Preferences#absolutePath()}.
     *
     * <p>This implementation merely returns the absolute path name that
     * was computed at the time that this node was constructed (based on
     * the name that was passed to this node's constructor, and the names
     * that were passed to this node's ancestors' constructors).
     *
     * @return this preference node's absolute path name.
     */

#Code:
    public String absolutePath() {
        return absolutePath;
    }

#No. 4086
#File: E:\bishe\1\AbstractPreferences.java
#Comment:
    /**
     * Implements the <tt>isUserNode</tt> method as per the specification in
     * {@link Preferences#isUserNode()}.
     *
     * <p>This implementation compares this node's root node (which is stored
     * in a private field) with the value returned by
     * {@link Preferences#userRoot()}.  If the two object references are
     * identical, this method returns true.
     *
     * @return <tt>true</tt> if this preference node is in the user
     *         preference tree, <tt>false</tt> if it's in the system
     *         preference tree.
     */

#Code:
    public boolean isUserNode() {
        return AccessController.doPrivileged(
            new PrivilegedAction<Boolean>() {
                public Boolean run() {
                    return root == Preferences.userRoot();
            }
            }).booleanValue();
    }

#No. 4087
#File: E:\bishe\1\AbstractPreferences.java
#Comment:
    /**
     * Returns the named child if it exists, or <tt>null</tt> if it does not.
     * It is guaranteed that <tt>nodeName</tt> is non-null, non-empty,
     * does not contain the slash character ('/'), and is no longer than
     * {@link #MAX_NAME_LENGTH} characters.  Also, it is guaranteed
     * that this node has not been removed.  (The implementor needn't check
     * for any of these things if he chooses to override this method.)
     *
     * <p>Finally, it is guaranteed that the named node has not been returned
     * by a previous invocation of this method or {@link #childSpi} after the
     * last time that it was removed.  In other words, a cached value will
     * always be used in preference to invoking this method.  (The implementor
     * needn't maintain his own cache of previously returned children if he
     * chooses to override this method.)
     *
     * <p>This implementation obtains this preference node's lock, invokes
     * {@link #childrenNames()} to get an array of the names of this node's
     * children, and iterates over the array comparing the name of each child
     * with the specified node name.  If a child node has the correct name,
     * the {@link #childSpi(String)} method is invoked and the resulting
     * node is returned.  If the iteration completes without finding the
     * specified name, <tt>null</tt> is returned.
     *
     * @param nodeName name of the child to be searched for.
     * @return the named child if it exists, or null if it does not.
     * @throws BackingStoreException if this operation cannot be completed
     *         due to a failure in the backing store, or inability to
     *         communicate with it.
     */

#Code:
    protected AbstractPreferences getChild(String nodeName)
            throws BackingStoreException {
        synchronized(lock) {
            // assert kidCache.get(nodeName)==null;
            String[] kidNames = childrenNames();
            for (int i=0; i<kidNames.length; i++)
                if (kidNames[i].equals(nodeName))
                    return childSpi(kidNames[i]);
        }
        return null;
    }

#No. 4088
#File: E:\bishe\1\AbstractPreferences.java
#Comment:
    /**
     * Returns the absolute path name of this preferences node.
     */

#Code:
    public String toString() {
        return (this.isUserNode() ? "User" : "System") +
               " Preference Node: " + this.absolutePath();
    }

#No. 4089
#File: E:\bishe\1\AbstractPreferences.java
#Comment:
    /**
     * Implements the <tt>sync</tt> method as per the specification in
     * {@link Preferences#sync()}.
     *
     * <p>This implementation calls a recursive helper method that locks this
     * node, invokes syncSpi() on it, unlocks this node, and recursively
     * invokes this method on each "cached child."  A cached child is a child
     * of this node that has been created in this VM and not subsequently
     * removed.  In effect, this method does a depth first traversal of the
     * "cached subtree" rooted at this node, calling syncSpi() on each node in
     * the subTree while only that node is locked. Note that syncSpi() is
     * invoked top-down.
     *
     * @throws BackingStoreException if this operation cannot be completed
     *         due to a failure in the backing store, or inability to
     *         communicate with it.
     * @throws IllegalStateException if this node (or an ancestor) has been
     *         removed with the {@link #removeNode()} method.
     * @see #flush()
     */

#Code:
    public void sync() throws BackingStoreException {
        sync2();
    }

#No. 4090
#File: E:\bishe\1\AbstractPreferences.java
#Comment:
    /**
     * Implements the <tt>flush</tt> method as per the specification in
     * {@link Preferences#flush()}.
     *
     * <p>This implementation calls a recursive helper method that locks this
     * node, invokes flushSpi() on it, unlocks this node, and recursively
     * invokes this method on each "cached child."  A cached child is a child
     * of this node that has been created in this VM and not subsequently
     * removed.  In effect, this method does a depth first traversal of the
     * "cached subtree" rooted at this node, calling flushSpi() on each node in
     * the subTree while only that node is locked. Note that flushSpi() is
     * invoked top-down.
     *
     * <p> If this method is invoked on a node that has been removed with
     * the {@link #removeNode()} method, flushSpi() is invoked on this node,
     * but not on others.
     *
     * @throws BackingStoreException if this operation cannot be completed
     *         due to a failure in the backing store, or inability to
     *         communicate with it.
     * @see #flush()
     */

#Code:
    public void flush() throws BackingStoreException {
        flush2();
    }

#No. 4091
#File: E:\bishe\1\AbstractPreferences.java
#Comment:
    /**
     * Returns <tt>true</tt> iff this node (or an ancestor) has been
     * removed with the {@link #removeNode()} method.  This method
     * locks this node prior to returning the contents of the private
     * field used to track this state.
     *
     * @return <tt>true</tt> iff this node (or an ancestor) has been
     *       removed with the {@link #removeNode()} method.
     */

#Code:
    protected boolean isRemoved() {
        synchronized(lock) {
            return removed;
        }
    }

#No. 4092
#File: E:\bishe\1\AbstractPreferences.java
#Comment:
    /**
     * This method starts the event dispatch thread the first time it
     * is called.  The event dispatch thread will be started only
     * if someone registers a listener.
     */

#Code:
    private static synchronized void startEventDispatchThreadIfNecessary() {
        if (eventDispatchThread == null) {
            // XXX Log "Starting event dispatch thread"
            eventDispatchThread = new EventDispatchThread();
            eventDispatchThread.setDaemon(true);
            eventDispatchThread.start();
        }
    }

#No. 4093
#File: E:\bishe\1\AbstractPreferences.java
#Comment:
    /**
     * Return this node's preference/node change listeners.  Even though
     * we're using a copy-on-write lists, we use synchronized accessors to
     * ensure information transmission from the writing thread to the
     * reading thread.
     */

#Code:
    PreferenceChangeListener[] prefListeners() {
        synchronized(lock) {
            return prefListeners;
        }
    }

#No. 4094
#File: E:\bishe\1\AbstractPreferences.java
#Comment:
    /**
     * Enqueue a preference change event for delivery to registered
     * preference change listeners unless there are no registered
     * listeners.  Invoked with this.lock held.
     */

#Code:
    private void enqueuePreferenceChangeEvent(String key, String newValue) {
        if (prefListeners.length != 0) {
            synchronized(eventQueue) {
                eventQueue.add(new PreferenceChangeEvent(this, key, newValue));
                eventQueue.notify();
            }
        }
    }

#No. 4095
#File: E:\bishe\1\AbstractPreferences.java
#Comment:
    /**
     * Enqueue a "node added" event for delivery to registered node change
     * listeners unless there are no registered listeners.  Invoked with
     * this.lock held.
     */

#Code:
    private void enqueueNodeAddedEvent(Preferences child) {
        if (nodeListeners.length != 0) {
            synchronized(eventQueue) {
                eventQueue.add(new NodeAddedEvent(this, child));
                eventQueue.notify();
            }
        }
    }

#No. 4096
#File: E:\bishe\1\AbstractPreferences.java
#Comment:
    /**
     * Enqueue a "node removed" event for delivery to registered node change
     * listeners unless there are no registered listeners.  Invoked with
     * this.lock held.
     */

#Code:
    private void enqueueNodeRemovedEvent(Preferences child) {
        if (nodeListeners.length != 0) {
            synchronized(eventQueue) {
                eventQueue.add(new NodeRemovedEvent(this, child));
                eventQueue.notify();
            }
        }
    }

#No. 4097
#File: E:\bishe\1\AbstractPreferences.java
#Comment:
    /**
     * Implements the <tt>exportNode</tt> method as per the specification in
     * {@link Preferences#exportNode(OutputStream)}.
     *
     * @param os the output stream on which to emit the XML document.
     * @throws IOException if writing to the specified output stream
     *         results in an <tt>IOException</tt>.
     * @throws BackingStoreException if preference data cannot be read from
     *         backing store.
     */

#Code:
    public void exportNode(OutputStream os)
        throws IOException, BackingStoreException
    {
        XmlSupport.export(os, this, false);
    }

#No. 4098
#File: E:\bishe\1\AbstractPreferences.java
#Comment:
    /**
     * Implements the <tt>exportSubtree</tt> method as per the specification in
     * {@link Preferences#exportSubtree(OutputStream)}.
     *
     * @param os the output stream on which to emit the XML document.
     * @throws IOException if writing to the specified output stream
     *         results in an <tt>IOException</tt>.
     * @throws BackingStoreException if preference data cannot be read from
     *         backing store.
     */

#Code:
    public void exportSubtree(OutputStream os)
        throws IOException, BackingStoreException
    {
        XmlSupport.export(os, this, true);
    }

#No. 4099
#File: E:\bishe\1\AbstractPrefixOperator.java
#Comment:
	/**
	 * <p>Constructor for AbstractPrefixOperator.</p>
	 */

#Code:
	public AbstractPrefixOperator(){
		super();
	}

#No. 4100
#File: E:\bishe\1\AbstractPrefixOperator.java
#Comment:
	/**
	 * <p>Constructor for AbstractPrefixOperator.</p>
	 *
	 * @param name a {@link java.lang.String} object.
	 */

#Code:
	public AbstractPrefixOperator(final String name){
		this.setName(name);
	}

#No. 4101
#File: E:\bishe\1\AbstractPrefixOperator.java
#Comment:
	/**
	 * <p>Constructor for AbstractPrefixOperator.</p>
	 *
	 * @param name a {@link java.lang.String} object.
	 * @param loadObject a {@link org.json.JSONObject} object.
	 * @throws org.json.JSONException if any.
	 */

#Code:
	public AbstractPrefixOperator(final String name, final JSONObject loadObject) throws JSONException {
		this.name = name;
	}

#No. 4102
#File: E:\bishe\1\AbstractPrefixOperator.java
#Comment:
	/**
	 * <p>determineNameForDrawing.</p>
	 *
	 * @return a {@link java.lang.String} object.
	 */

#Code:
	protected String determineNameForDrawing() {
		if(this.name.matches(AbstractPrefixOperator.internal_name + "\\d+")) {
			return "";
		}
		else {
			return this.name;
		}
	}

#No. 4103
#File: E:\bishe\1\AbstractPrefixOperator.java
#Comment:
	/**
	 * <p>Getter for the field <code>name</code>.</p>
	 *
	 * @return a {@link java.lang.String} object.
	 */

#Code:
	public String getName() {
		return this.name;
	}

#No. 4104
#File: E:\bishe\1\AbstractPrefixOperator.java
#Comment:
	/**
	 * <p>Setter for the field <code>name</code>.</p>
	 *
	 * @param name a {@link java.lang.String} object.
	 */

#Code:
	public void setName(final String name) {
		this.name = name;
	}

#No. 4105
#File: E:\bishe\1\AbstractPrefixOperator.java
#Comment:
	/**
	 * <p>applyChange.</p>
	 *
	 * @param value a {@link java.lang.String} object.
	 * @throws lupos.gui.operatorgraph.visualeditor.util.ModificationException if any.
	 */

#Code:
	public void applyChange(final String value) throws ModificationException {
		if(!value.equals("")) {
			if(AbstractPrefixOperator.reservedKeyWords.contains(value)) {
				throw new ModificationException("Operator name can not be a java keyword!", this);
			}
			final Pattern p = Pattern.compile("^[a-z]\\w*$", Pattern.CASE_INSENSITIVE);
			if(!p.matcher(value).matches()) {
				throw new ModificationException("Invalid operator name! Operator name must match /^[a-z]\\w*$/", this);
			}
		}
		this.name = value;
	}

#No. 4106
#File: E:\bishe\1\AbstractPrefixOperator.java
#Comment:
	/**
	 * <p>Getter for the field <code>internal_global_id</code>.</p>
	 *
	 * @return a int.
	 */

#Code:
	public static int getInternal_global_id() {
		return internal_global_id;
	}

#No. 4107
#File: E:\bishe\1\AbstractPrefixOperator.java
#Comment:
	/**
	 * <p>Setter for the field <code>internal_global_id</code>.</p>
	 *
	 * @param internal_global_id a int.
	 */

#Code:
	public static void setInternal_global_id(final int internal_global_id) {
		AbstractPrefixOperator.internal_global_id = internal_global_id;
	}

#No. 4108
#File: E:\bishe\1\AbstractPrefixOperator.java
#Comment:
	/**
	 * <p>Getter for the field <code>internal_id</code>.</p>
	 *
	 * @return a int.
	 */

#Code:
	public int getInternal_id() {
		return this.internal_id;
	}

#No. 4109
#File: E:\bishe\1\AbstractPrefixOperator.java
#Comment:
	/**
	 * <p>Setter for the field <code>internal_id</code>.</p>
	 *
	 * @param internal_id a int.
	 */

#Code:
	public void setInternal_id(final int internal_id) {
		this.internal_id = internal_id;
	}

#No. 4110
#File: E:\bishe\1\AbstractPrefService.java
#Comment:
/**
 * Abstract {@link PrefService} implementation. Calls
 * {@link Prefs#setDelegateService(PrefService, double)} on this {@code Service}
 * during initialization.
 *
 * @author Mark Hiner
 */

#Code:
@SuppressWarnings({ "javadoc", "deprecation" })
public abstract class AbstractPrefService extends AbstractService implements
	PrefService
{

	@Override
	public void initialize() {
		Prefs.setDelegateService(this, getPriority());
	}
}

#No. 4111
#File: E:\bishe\1\AbstractPrefsManager.java
#Comment:
    /**
     * Sets the prefs for the specified user account.
     *
     * @param attribs prefs.
     * @param account UserAccount instance.
     */

#Code:
    public void setPrefs(JSONObject attribs, UserAccount account) {
        if (attribs != null) {
            final SharedPreferences sp = getSharedPreferences(account);
            final Editor e = sp.edit();
            final Iterator<String> keys = attribs.keys();
            while (keys.hasNext()) {
                final String currentKey = keys.next();
                final String currentValue = attribs.optString(currentKey);
                e.putString(currentKey, currentValue);
            }
            e.commit();
        }
    }

#No. 4112
#File: E:\bishe\1\AbstractPrefsManager.java
#Comment:
    /**
     * Sets the prefs for the specified user account.
     *
     * @param attribs prefs.
     * @param account UserAccount instance.
     */

#Code:
    public void setPrefs(Map<String, String> attribs, UserAccount account) {
        setPrefs(new JSONObject(attribs), account);
    }

#No. 4113
#File: E:\bishe\1\AbstractPrefsManager.java
#Comment:
    /**
     * Returns the pref value for the specified key, for a user account.
     *
     * @param key Key.
     * @param account UserAccount instance.
     * @return Corresponding value.
     */

#Code:
    @SuppressWarnings("unchecked")
    public String getPref(String key, UserAccount account) {
        final SharedPreferences sp = getSharedPreferences(account);
        final Map<String, String> customAttributes = (Map<String, String>) sp.getAll();
        if (customAttributes != null) {
            return customAttributes.get(key);
        }
        return null;
    }

#No. 4114
#File: E:\bishe\1\AbstractPrefsManager.java
#Comment:
    /**
     * Returns all the prefs for a user account.
     *
     * @param account UserAccount instance.
     * @return Corresponding value.
     */

#Code:
    @SuppressWarnings("unchecked")
    public Map<String, String> getPrefs(UserAccount account) {
        final SharedPreferences sp = getSharedPreferences(account);
        return (Map<String, String>) sp.getAll();
    }

#No. 4115
#File: E:\bishe\1\AbstractPrefsManager.java
#Comment:
    /**
     * Clears the stored prefs for the specified user.
     *
     * @param account UserAccount instance.
     */

#Code:
    public void reset(UserAccount account) {
        final SharedPreferences sp = getSharedPreferences(account);
        final Editor editor = sp.edit();
        editor.clear();
        editor.commit();
    }

#No. 4116
#File: E:\bishe\1\AbstractPrefsManager.java
#Comment:
    /**
     * Clears the stored prefs for all users.
     */

#Code:
    public void resetAll() {
        final String sharedPrefPath = SalesforceSDKManager.getInstance().getAppContext().getApplicationInfo().dataDir + "/shared_prefs";
        final File dir = new File(sharedPrefPath);
        final FilenameFilter fileFilter = new FilenameFilter() {
            @Override
            public boolean accept(File dir, String filename) {
                return filename != null && filename.startsWith(getFilenameRoot());
            }
        };
        for (final File file : dir.listFiles()) {
            if (file != null && fileFilter.accept(dir, file.getName())) {
                file.delete();
            }
        }
    }

#No. 4117
#File: E:\bishe\1\AbstractPreparedTag.java
#Comment:
	/**
	 * The constructor
	 *
	 * @param pattern the pattern
	 * @param guild   the guild
	 */

#Code:
	public AbstractPreparedTag(ConfigWrapper pattern, NovaGuild guild) {
		this.pattern = pattern;
		this.guild = guild;
	}

#No. 4118
#File: E:\bishe\1\AbstractPreparedTag.java
#Comment:
	/**
	 * The constructor
	 *
	 * @param pattern             the pattern
	 * @param guild               the guild
	 * @param leaderPrefixEnabled leader prefix enabled
	 */

#Code:
	public AbstractPreparedTag(ConfigWrapper pattern, NovaGuild guild, boolean leaderPrefixEnabled) {
		this.pattern = pattern;
		this.guild = guild;
		this.leaderPrefixEnabled = leaderPrefixEnabled;
	}

#No. 4119
#File: E:\bishe\1\AbstractPreprocessorPlugin.java
#Comment:
/**
 * Abstract base class for plugin preprocessors.
 * 
 * @author Curtis Rueden
 */

#Code:
public abstract class AbstractPreprocessorPlugin extends AbstractContextual
	implements PreprocessorPlugin
{

	private String cancelReason;

	// -- Cancelable methods --

	@Override
	public boolean isCanceled() {
		return cancelReason != null;
	}

	@Override
	public void cancel(final String reason) {
		cancelReason = reason == null ? "" : reason;
	}

	@Override
	public String getCancelReason() {
		return cancelReason;
	}

}

#No. 4120
#File: E:\bishe\1\AbstractPresenterFactory.java
#Comment:
  /**
   * Utility method to create/register an event bus.
   * 
   * @param presenterClass
   * @param presenter
   * @return
   */

#Code:
  protected EventBus createEventBus(Class<IPresenter> presenterClass, IPresenter presenter, EventBus parentEventBus) {
    Type gsc = presenterClass.getGenericSuperclass();
    logger.debug("Generic super class: {}", gsc);
    ParameterizedType pt = (ParameterizedType) gsc;
    Type[] typeArgs = pt.getActualTypeArguments();
    for (Type type : typeArgs) {
      logger.debug("Type arg: {}", type);
    }

    EventBus eb = null;
    Type ebt = typeArgs[1];
    if (EventBus.class.isAssignableFrom((Class<?>) ebt)) {
      Class<? extends EventBus> eventBusType = (Class<? extends EventBus>) ebt;
      logger.debug("EventBus class: {}", eventBusType.getName());
      eb = this.eventBusManager.register(eventBusType, presenter,parentEventBus);
    }
    return eb;
  }

#No. 4121
#File: E:\bishe\1\AbstractPriorityQueue.java
#Comment:
	/**
	 * @return the key with the highest priority.
	 * @throws NoSuchElementException if the queue is empty.
	 */

#Code:
	abstract protected T removeAux();
	
	/** @return the size of this queue. */
	abstract public int size();
	
	/** @return {@code true} if the queue is empty; otherwise, {@code false}. */
	public boolean isEmpty()
	{
		return size() == 0;
	}

#No. 4122
#File: E:\bishe\1\AbstractPrivilegedAPIsWtiter.java
#Comment:
        /*if (method.useParceledListSlice()) {
            writeLine("@SuppressWarnings(\"unchecked\")");
            writeLine(String.format(Locale.ENGLISH,
                    "public static %s %s throws RemoteException {",
                    "ParceledListSlice",
                    method.toString().substring(method.toString().indexOf(' ') + 1)));
        } else */{

#Code:
            writeLine("@CallSuper");
            writeLine(String.format(Locale.ENGLISH, "public %s {", method.toString()));
        }

#No. 4123
#File: E:\bishe\1\AbstractProcessEngineGraphGenerator.java
#Comment:
	/**
	 * Generate report about executions for the process instances driven by
	 * processDefinitionId. Report contains counts of tokens and node
	 * highlighting where tokens are located
	 * 
	 * @param processDefinitionId
	 * @param finishDate 
	 * @param startDate 
	 * @param fileName
	 * @throws IOException
	 */

#Code:
	public void generateReport(String processDefinitionId, Date startDate, Date finishDate, String fileName)
			throws IOException {
		log.debug(" generating report");

		Map<Color, List<String>> highLightedActivitiesMap = new HashMap<Color,List<String>>();
		Map<String, String> counts = new HashMap<String, String>();

		ProcessDefinitionEntity pde = getProcessData(processDefinitionId, startDate, finishDate,
				highLightedActivitiesMap, counts);

		reportGraph(fileName, pde.getKey(), highLightedActivitiesMap, counts);
		log.debug(" generating report done");
	}

#No. 4124
#File: E:\bishe\1\AbstractProcessing.java
#Comment:
    /**
     * @return true if element processed with success, false otherwise and it will stop
     * the processing
     */

#Code:
    public abstract boolean processElement(Element element, Errors.ElementErrors elementErrors);

    public abstract AbstractComposer<T_Model> createComposer();
}
}

#No. 4125
#File: E:\bishe\1\AbstractProcessorBindingObserver.java
#Comment:
/**
 * Define the shared code between all {@link Binding} processors 
 * (@see org.ow2.frascati.assembly.factory.api.Processor) observers
 * 
 * @param <T>
 *      the object type handled by the targeted processor which have to extend 
 *      {@link EObject} - Here T extends EObject instead of {@link Binding} to 
 *      be able to extend the {@link AbstractProcessorObserver} class
 */

#Code:
public abstract class AbstractProcessorBindingObserver<T extends EObject> 
extends AbstractProcessorObserver<T>
{   
    /**
     * {@inheritDoc}
     * 
     * @see org.easysoa.frascati.api.observer.ProcessorObserverItf#checkDo(
     * java.lang.Object)
     */
    public void checkDo(T t)
    {
        log.info("checkDo ["+t.getClass()+"]");
    }
    
    /**
     * {@inheritDoc}
     * 
     * @see org.easysoa.frascati.api.observer.ProcessorObserverItf#checkDone(
     * java.lang.Object)
     */
    public void checkDone(T t)
    {
        log.info("checkDone ["+t.getClass()+"]");
        scaImporter.pushBinding((Binding) t);
    }
}

#No. 4126
#File: E:\bishe\1\AbstractProcessorNotBindingObserver.java
#Comment:
    /**
     * {@inheritDoc}
     * 
     * @see org.easysoa.frascati.api.observer.ProcessorObserverItf#checkDo(
     * java.lang.Object)
     */

#Code:
    public void checkDo(T t)
    {
        String name = getName(t);
        log.info("checkDo [" + t.getClass() + ":" + name + "]");
        scaImporter.pushArchi(name, t);
    }

#No. 4127
#File: E:\bishe\1\AbstractProcessorNotBindingObserver.java
#Comment:
    /**
     * {@inheritDoc}
     * 
     * @see org.easysoa.frascati.api.observer.ProcessorObserverItf#checkDone(
     * java.lang.Object)
     */

#Code:
    public void checkDone(T t)
    {
        String name = getName(t);
        log.info("checkDone [" + t.getClass() + ":" + name + "]");
        scaImporter.popArchi(name);
    }

#No. 4128
#File: E:\bishe\1\AbstractProcessorObserver.java
#Comment:
/**
 * Define the shared code between all processors 
 * (@see org.ow2.frascati.assembly.factory.api.Processor) observers
 * 
 * @param <T>
 *      the object type handled by the targeted processor which have to extend 
 *      {@link EObject}
 */

#Code:
@Scope("COMPOSITE")
@Service(ProcessorObserverItf.class)
public abstract class AbstractProcessorObserver<T extends EObject> 
extends AbstractLoggeable implements ProcessorObserverItf<T>
{
    /**
     * In charge of gathering and dispatch outside of the FraSCAti's scope of 
     * all observers data
     */
    @Reference(name = "runtime-sca-importer")
    protected ScaImporterIntermediaryItf scaImporter;
}

#No. 4129
#File: E:\bishe\1\AbstractProcessorTestCase.java
#Comment:
      /*if (built.contains(name)) {
        continue;
      }*/

#Code:


      URL url = Thread.currentThread().getContextClassLoader().getResource("model/" + name + ".java");
      try {
        files.add(new File(url.toURI()));
      }

#No. 4130
#File: E:\bishe\1\AbstractProfile.java
#Comment:
	/**
	 * Set the refers to date
	 * @param refersToDate Must be a string representation of a data conforming to 
	 *    W3C/ISO8601 format, assuming UTC. Format is yyyy-MM-dd'T'HH:mm:ss'Z'
	 *    
	 * @see ArchiveUtils#getLog14Date(java.util.Date)
	 */

#Code:
	public void setRefersToDate(String refersToDate) {
		this.refersToDate = refersToDate;
	}

#No. 4131
#File: E:\bishe\1\AbstractProfile.java
#Comment:
	/**
	 * Set the refers to date
	 * @param refersToDate 
	 */

#Code:
	public void setRefersToDate(long refersToDate) {
		this.refersToDate = ArchiveUtils.getLog14Date(refersToDate);
	}

#No. 4132
#File: E:\bishe\1\AbstractProgressableAsyncTask.java
#Comment:
    /**
     * @param result
     *            to be sent back to the observer (typically an {@link Activity} running on the UI Thread). This can be <code>null</code> if
     *            an error occurs while attempting to invoke the web service (e.g. web service was unreachable, or network I/O issue etc.)
     */

#Code:
    @Override
    protected final void onPostExecute(R result) {
        if (progressTracker != null) {
            progressTracker.onStopProgress();
        }

        if (taskCompletionListener != null) {
            if (result == null || mostRecentException != null) {
                taskCompletionListener.onTaskFailed(mostRecentException);

            } else {
                taskCompletionListener.onTaskCompleteSuccess(result);
            }
        }

        // clean up listeners since we are done with this task
        progressTracker = null;
        taskCompletionListener = null;
    }

#No. 4133
#File: E:\bishe\1\AbstractProjectAction.java
#Comment:
	/**
	 * @see IActionDelegate#selectionChanged(IAction, ISelection)
	 */

#Code:
	public void selectionChanged(IAction action, ISelection selection) {
		this.selection = selection;
	}

#No. 4134
#File: E:\bishe\1\AbstractProjectAction.java
#Comment:
	/**
	 * @see IActionDelegate#run(IAction)
	 */

#Code:
	public void run(IAction action) {
		if (selection instanceof IStructuredSelection) {
			Iterator<?> iterator = ((IStructuredSelection) selection).iterator();
			while (iterator.hasNext()) {
				Object value = iterator.next();
				IProject project = null;
				if (value instanceof IProject) {
					project = (IProject) value;
				} else if (value instanceof IAdaptable) {
					IAdaptable adaptable = (IAdaptable) value;
					project = (IProject) adaptable.getAdapter(IProject.class);
				}
				try {
					run(action, project);
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
		}
	}

#No. 4135
#File: E:\bishe\1\AbstractProjectGeneratorDelegate.java
#Comment:
	/**
	 * Returns the short name to be used for defining the target platform 
	 * such as <i>ios, android</i> etc.
	 * @return
	 */

#Code:
	protected String getTargetShortName(){
		return platform;
	}

#No. 4136
#File: E:\bishe\1\AbstractProjectGeneratorDelegate.java
#Comment:
	/**
	 * The destination folder where the generated files are replaced. This is 
	 * usually a directory named the short name for a target platform under a 
	 * a root folder for project.
	 * @return
	 */

#Code:
	public File getDestination(){
		return new File(generationRoot,getTargetShortName());
	}

#No. 4137
#File: E:\bishe\1\AbstractProjectHostingConnectionProvider.java
#Comment:
/**
 * Abstract class to be extended by all {@link ConnectionProvider} objects of type
 * {@link com.streamreduce.connections.ProjectHostingProvider.TYPE}.
 */

#Code:
public abstract class AbstractProjectHostingConnectionProvider extends AbstractConnectionProvider
    implements ProjectHostingProvider {

    AbstractProjectHostingConnectionProvider() {}

    /**
     * {@inheritDoc}
     */
    @Override
    public String getType() {
        return ProjectHostingProvider.TYPE;
    }

}

#No. 4138
#File: E:\bishe\1\AbstractProjectReference.java
#Comment:
	/**
	 * Cache for the name<->project lookup. Useful, since many reference objects
	 * might look up the same project and the weak value references make it
	 * so a reference does not block cleanup of projects.
	 * <p>
	 * Also, the timeout avoids that rarely referenced objects pollute the
	 * map.
	 */

#Code:
	private static final Cache<String, InheritanceProject> nameLookup =
			CacheBuilder.newBuilder()
					.expireAfterAccess(5, TimeUnit.MINUTES)
					.weakValues()
					.build();
	
	
	public AbstractProjectReference(String targetJob) {
		this.name = targetJob;
	}

#No. 4139
#File: E:\bishe\1\AbstractProjectReference.java
#Comment:
	/**
	 * Returns the project associated with this reference. In contrast to the
	 * public field {@link AbstractProjectReference#project}, this will try to make
	 * sure that the object is actually assigned.
	 * 
	 * @return the associated {@link InheritanceProject}, or null in case the
	 * name could not be resolved at this moment.
	 */

#Code:
	public InheritanceProject getProject() {
		InheritanceProject ip = nameLookup.getIfPresent(this.name);
		if (ip == null) {
			ip = InheritanceProject.getProjectByName(this.name);
			if (ip != null) {
				nameLookup.put(this.name, ip);
			}
		}
		return ip;
	}

#No. 4140
#File: E:\bishe\1\AbstractProjectReference.java
#Comment:
	/**
	 * Returns all the registered {@link ParameterDefinition} descriptors that
	 * construct classes derived from this abstract base class.
	 */

#Code:
	public static DescriptorExtensionList<AbstractProjectReference,ProjectReferenceDescriptor> all() {
		return Jenkins
				.getInstance()
				.<AbstractProjectReference,ProjectReferenceDescriptor>
				getDescriptorList(AbstractProjectReference.class);
	}

#No. 4141
#File: E:\bishe\1\AbstractProjectReference.java
#Comment:
	/**
	 * Returns all the registered {@link ParameterDefinition} descriptors that
	 * construct classes derived from this abstract base class.
	 */

#Code:
	public static DescriptorExtensionList<AbstractProjectReference,ProjectReferenceDescriptor> all(
			Class<AbstractProjectReference> clazz
	) {
		if (clazz == null) { clazz = AbstractProjectReference.class; }
		Jenkins j = Jenkins.getInstance();
		
		DescriptorExtensionList<AbstractProjectReference, ProjectReferenceDescriptor>
			dList, ret;
		
		//The following list might be empty, if clazz is not an ExtensionPoint
		ret = j.<AbstractProjectReference,ProjectReferenceDescriptor>
			getDescriptorList(clazz);
		
		if (!ret.isEmpty()) {
			return ret;
		}
		
		//The list was empty; we need to fill it manually
		//Do note, that this changes the list in-place; so the command above
		//will actually contain the modified data on the next invocation!
		dList = j.<AbstractProjectReference,ProjectReferenceDescriptor>
				getDescriptorList(AbstractProjectReference.class);
		
		Descriptor<?> clazzDesc = j.getDescriptor(clazz);
		if (clazzDesc == null) {
			return dList;
		}
		
		for (ProjectReferenceDescriptor prd : dList) {
			if (clazzDesc.getClass().isAssignableFrom(prd.getClass())) {
				ret.add(prd);
			}
		}
		return ret;
	}

#No. 4142
#File: E:\bishe\1\AbstractProjectResource.java
#Comment:
	/**
	 * Used to display different types of alerts on a branch view.
	 */

#Code:
	public enum DeletionStatus {
		/**
		 * Deletion of a branch was successful.
		 */
		SUCCESS,
		/**
		 * Prompt the user for confirmation before deleting the branch. This is
		 * used on branches that are ahead of master to prevent accidental deletion. The
		 * confirmation requires the user to type in the branch name.
		 */
		CONFIRM,
		/**
		 * The user entered the confirmation wrong. Tell him and prompt
		 * again for confirmation.
		 */
		CONFIRM_AGAIN,
		/**
		 * Something has gone wrong wile attempting to delete the branch. Either
		 * one of the parameters did not get sent correctly, or the user attempted to remove the
		 * master branch.
		 */
		ERROR

	}

#No. 4143
#File: E:\bishe\1\AbstractProjectResource.java
#Comment:
	/**
	 * Generates the parameters for the branch overview.
	 * @param branchName Name of the branch
	 * @param page Page number to display
     * @return A map containing the response parameters.
     */

#Code:
	protected Map<String, Object> getBranchOverviewParameters(String branchName, int page) {
        RepositoryEntity repositoryEntity = getRepositoryEntity();
		RepositoryApi repositoryApi = repositoriesApi.getRepository(repositoryEntity.getRepositoryName());
		Map<String, Object> parameters = getBaseParameters();
		parameters.put("repository", repositoryApi.getRepositoryModel());

		try {
			BranchApi branchApi = repositoryApi.getBranch(branchName);
			BranchModel branch = branchApi.get();
			CommitSubList commits = branchApi.retrieveCommitsInBranch((page - 1) * PAGE_SIZE, PAGE_SIZE);

			Collection<String> commitIds = getCommitIds(commits);
			List<Commit> commitEntities = commitIds.stream()
				.map(commitId -> this.commits.ensureExists(repositoryEntity, commitId))
				.collect(Collectors.toList());
			Map<String, Commit> commitEntitiesByCommitId = Maps.uniqueIndex(commitEntities, Commit::getCommitId);

			parameters.put("commits", commits);
			parameters.put("branch", branch);
			parameters.put("commitEntities", commitEntitiesByCommitId);
			parameters.put("pagination", new Pagination(page, commits.getTotal()));

			parameters.put("warnings", warnings.commitsWithWarningsFor(repositoryEntity, commitIds));
			parameters.put("comments", comments.commentsFor(repositoryEntity, commitIds));
			parameters.put("builds", buildResults.findBuildResults(repositoryEntity, commitIds));

			pullRequests.findOpenPullRequest(repositoryEntity, branch.getName()).ifPresent(pullRequest ->
					parameters.put("pullRequest", pullRequest));
		}
		catch (NotFoundException e) {
			if (branchName.equals("master")) {
				// Swallow exception for master, so an overview page can be generated for bare empty repositories
				log.debug("Master branch is empty for {}", repositoryEntity);
			} else throw e;
		}

		return parameters;
	}

#No. 4144
#File: E:\bishe\1\AbstractProjectResource.java
#Comment:
	/**
	 * The maximal number of collaborators.
	 * @return maximal number of collaborators.
	 * @see AbstractProjectResource#editContributors(HttpServletRequest, String, int)
	 */

#Code:
	protected int getMaxGroupSize() {
		return MAX_GROUP_SIZE;
	}

#No. 4145
#File: E:\bishe\1\AbstractProjectResource.java
#Comment:
	/**
	 * The minimal number of collaborators.
	 * @return minimal number of collaborators.
	 * @see AbstractProjectResource#editContributors(HttpServletRequest, String, int)
	 */

#Code:
	protected int getMinGroupSize() {
		return MIN_GROUP_SIZE;
	}

#No. 4146
#File: E:\bishe\1\AbstractProjectResourceTest.java
#Comment:
    /*
     * TODO: Implement this after next seminar, git-server needs an update.
    @Test
    public void testDeleteBehindBranch() throws Throwable {
        cloneStepDefinitions.isAheadOf(BRANCH_NAME, "master");

        Response response = projectResource.deleteBehindBranch(request, BRANCH_NAME, "");
        verify(templateEngine).process(anyString(), any(), argumentCaptor.capture());
        System.out.println("\n\n\n\n\n=======1:\n" + argumentCaptor.getValue());

    }*/

#Code:

    @Test
    public void testEmojiParsing() throws IOException, ApiError {
        String message = ":grinning:";
        String wrongMessage = ":blah :grinning";
        String formattedMessage = "<p>\uD83D\uDE00</p>";
        String wrongFormattedMessage = "<p>:blah :grinning</p>";

        CommentResponse expected = new CommentResponse();
        expected.setName(REPOSITORY_NAME);
        expected.setDate(commentDate.toString());
        expected.setContent(message);
        expected.setFormattedContent(formattedMessage);

        CommentResponse resp = projectResource.commentOnPull(request, COMMIT_ID, message, null,
                null, null, null);
        assertEquals(expected, resp);

        expected.setContent(wrongMessage);
        expected.setFormattedContent(wrongFormattedMessage);
        resp = projectResource.commentOnPull(request, COMMIT_ID, wrongMessage, null, null, null,
                null);
        assertEquals(expected, resp);
    }

#No. 4147
#File: E:\bishe\1\AbstractPropertiesCacheLoader.java
#Comment:
    /**
     * Event store.
     */

#Code:
    private final EventStore store;

    /**
     * Nb events before store cache.
     */
    private final long nbEventBeforePersiste;

    public AbstractPropertiesCacheLoader(final EventStore store, final long nbEventBeforePersiste) {
        this.store = store;
        this.nbEventBeforePersiste = nbEventBeforePersiste;
    }

#No. 4148
#File: E:\bishe\1\AbstractPropertiesCacheLoader.java
#Comment:
    /**
     * Update properties container.
     *
     * @param propertiesBuilder
     * @param virtualApplicationsAggregate
     */

#Code:
    private void updatePropertiesContainer(
                                           final PlatformContainer propertiesBuilder,
                                           final VirtualApplicationsAggregate virtualApplicationsAggregate) {
        final Optional<PlatformData> platform = virtualApplicationsAggregate.getPlatform();

        if (platform.isPresent()) {
            propertiesBuilder.setPlatform(
                    platform.get());

            propertiesBuilder.addProperties(
                    virtualApplicationsAggregate.getProperties());
        }
    }

#No. 4149
#File: E:\bishe\1\AbstractPropertiesCacheLoader.java
#Comment:
    /**
     * Return all plaform key for application.
     *
     * @param applicationName applicationName or null
     *
     * @return list of platform key
     */

#Code:
    public List<PlatformKey> getAllPlatformKeyFromApplication(final String applicationName) {
        final List<PlatformKey> listPlatformKey;
        // Redis key pattern to search all application platform
        final String redisKey;

        if (applicationName == null) {
            getLogger().debug("Load all platforms keys for all application.");

            redisKey = String.format("%s-*",
                    getStreamPrefix());
        } else {
            getLogger().debug("Load all platforms keys for application '{}' from store.", applicationName);

            redisKey = String.format("%s-%s-*",
                    getStreamPrefix(), applicationName);
        }

        // All application platform redis key.
        final Set<String> platforms = this.store.getStreamsLike(redisKey);

        listPlatformKey = new ArrayList<>(platforms.size());

        for (String platformRedisKey : platforms) {
            listPlatformKey.add(
                    new PlatformKey(
                            entityNameFormRedisKey(platformRedisKey)));
        }


        if (applicationName == null) {
            getLogger().debug("All platform keys for all application are loaded.");
        } else {
            getLogger().debug("All platform keys for application '{}' are loaded.", applicationName);
        }

        return listPlatformKey;
    }

#No. 4150
#File: E:\bishe\1\AbstractPropertiesCacheLoader.java
#Comment:
    /**
     * Return list from application name.
     *
     * @param platformKey list of key
     *
     * @return list of application (never return null. Maybe return empty list)
     */

#Code:
    public Map<PlatformKey, PlatformContainer> getPlatformFromApplication(final List<PlatformKey> platformKey) {
        getLogger().debug("Load platform for {} keys.", platformKey.size());

        // List of platform return by method
        final Map<PlatformKey, PlatformContainer> listPlatform = new HashMap<>(platformKey.size());
        // Current platform
        PlatformContainer currentPlatform;
        // Key of redis
        String platformRedisKey;

        for (PlatformKey ptfKey : platformKey) {
            platformRedisKey = generateDbKey(ptfKey);

            getLogger().debug("Load platform from store associate with key '{}'.", platformRedisKey);

            try {
                currentPlatform = loadProperties(ptfKey, Long.MAX_VALUE);
            } catch (Exception e) {
                e.printStackTrace();
                currentPlatform = null;
            }

            // Platform can be remove at last event
            if (currentPlatform != null) {
                listPlatform.put(ptfKey, currentPlatform);
            }
        }

        getLogger().debug("{} platforms loaded.", listPlatform.size());

        return listPlatform;
    }

#No. 4151
#File: E:\bishe\1\AbstractPropertiesCacheLoader.java
#Comment:
    /**
     * Generate name of entity.
     *
     * @param redisKey
     * @return
     */

#Code:
    private String entityNameFormRedisKey(final String redisKey) {
        return redisKey.substring(getStreamPrefix().length() + 1);
    }

#No. 4152
#File: E:\bishe\1\AbstractPropertiesCacheLoader.java
#Comment:
    /**
     * Generate key to search in database.
     *
     * @param ptfKey namespace of module
     *
     * @return db key
     */

#Code:
    private String generateDbKey(final PlatformKey ptfKey) {
        return String.format("%s-%s",
                getStreamPrefix(), ptfKey.getEntityName());
    }

#No. 4153
#File: E:\bishe\1\AbstractPropertiesCacheLoader.java
#Comment:
    /**
     * Store object in snapshot.
     *
     * @param platformKey key of cache (same as cache.get(K))
     * @param object object
     */

#Code:
    public void saveSnapshot(final PlatformKey platformKey, final PlatformContainer object) {
        final String redisKey = generateDbKey(platformKey);

        // Now store snapshot
        store.storeSnapshot(redisKey, object, nbEventBeforePersiste);
    }

#No. 4154
#File: E:\bishe\1\AbstractPropertiesCacheLoader.java
#Comment:
    /**
     * Store object in snapshot.
     *
     * @param platformKey key of cache (same as cache.get(K))
     * @param object object
     */

#Code:
    public void forceSaveSnapshot(final PlatformKey platformKey, final PlatformContainer object, final long nbEvent) {
        final String redisKey = generateDbKey(platformKey);

        // Now store snapshot
        store.createSnapshot(redisKey, object, nbEvent);
    }

#No. 4155
#File: E:\bishe\1\AbstractPropertyAndPreferencesPage.java
#Comment:
	/**
	 * {@inheritDoc}
	 */

#Code:
	@Override
	public IAdaptable getElement() {
		return _project;
	}

#No. 4156
#File: E:\bishe\1\AbstractPropertyAndPreferencesPage.java
#Comment:
	/**
	 * {@inheritDoc}
	 */

#Code:
	@Override
	public void setElement(IAdaptable element) {
		_project = (IProject) element.getAdapter(IResource.class);
	}

#No. 4157
#File: E:\bishe\1\AbstractPropertyAndPreferencesPage.java
#Comment:
	/**
	 * <p>
	 * </p>
	 * 
	 * @return
	 */

#Code:
	public boolean isProjectPreferencePage() {
		return _project != null;
	}

#No. 4158
#File: E:\bishe\1\AbstractPropertyAndPreferencesPage.java
#Comment:
	/**
	 * <p>
	 * </p>
	 * 
	 * @return
	 */

#Code:
	protected boolean supportsProjectSpecificOptions() {
		return getPropertyPageID() != null;
	}

#No. 4159
#File: E:\bishe\1\AbstractPropertyAndPreferencesPage.java
#Comment:
	/**
	 * <p>
	 * </p>
	 * 
	 * @return
	 */

#Code:
	public IProject getProject() {
		return _project;
	}

#No. 4160
#File: E:\bishe\1\AbstractPropertyAndPreferencesPage.java
#Comment:
	/**
	 * <p>
	 * </p>
	 * 
	 * @param data
	 */

#Code:
	protected final void openWorkspacePreferences(Object data) {
		String id = getPreferencePageID();
		PreferencesUtil.createPreferenceDialogOn(getShell(), id,
				new String[] { id }, data).open();
	}

#No. 4161
#File: E:\bishe\1\AbstractPropertyAndPreferencesPage.java
#Comment:
	/**
	 * <p>
	 * </p>
	 * 
	 * @param project
	 * @param data
	 */

#Code:
	protected final void openProjectProperties(IProject project, Object data) {
		String id = getPropertyPageID();
		if (id != null) {
			PreferencesUtil.createPropertyDialogOn(getShell(), project, id,
					new String[] { id }, data).open();
		}
	}

#No. 4162
#File: E:\bishe\1\AbstractPropertyAndPreferencesPage.java
#Comment:
	/**
	 * <p>
	 * </p>
	 * 
	 * @return
	 */

#Code:
	public ConfigurationBlock getConfigurationBlock() {
		return _configurationBlock;
	}

#No. 4163
#File: E:\bishe\1\AbstractPropertyAndPreferencesPage.java
#Comment:
	/**
	 * <p>
	 * </p>
	 * 
	 */

#Code:
	private void updateLinkVisibility() {
		if (_changeSettings == null || _changeSettings.isDisposed()) {
			return;
		}

		if (isProjectPreferencePage()) {
			_changeSettings.setEnabled(!useProjectSettings());
		}
	}

#No. 4164
#File: E:\bishe\1\AbstractPropertyAndPreferencesPage.java
#Comment:
	/**
	 * {@inheritDoc}
	 */

#Code:
	@Override
	public void init(IWorkbench workbench) {
		//
	}

#No. 4165
#File: E:\bishe\1\AbstractPropertyAndPreferencesPage.java
#Comment:
	/**
	 * {@inheritDoc}
	 */

#Code:
	@Override
	protected IPreferenceStore doGetPreferenceStore() {

		//
		if (isProjectPreferencePage()) {

			// speichern von Werten unter
			// '${workspace}\${projectname}\.settings\com.wuetherich.eclipse.propsprefs.prefs'
			return new ScopedPreferenceStore(new ProjectScope(getProject()),
					getStoreIdentifier());

		} else {

			// speichern von Werten unter
			// '${workspace}\.metadata\.plugins\org.eclipse.core.runtime\.settings\com.wuetherich.eclipse.propsprefs.prefs'
			return new ScopedPreferenceStore(InstanceScope.INSTANCE,
					getStoreIdentifier());
		}
	}

#No. 4166
#File: E:\bishe\1\AbstractPropertyAndPreferencesPage.java
#Comment:
	/**
	 * {@inheritDoc}
	 */

#Code:
	@Override
	protected Control createContents(Composite parent) {
		Composite composite = new Composite(parent, SWT.NONE);
		GridLayout layout = new GridLayout();
		layout.marginHeight = 0;
		layout.marginWidth = 0;
		composite.setLayout(layout);
		composite.setFont(parent.getFont());

		GridData data = new GridData(GridData.FILL, GridData.BEGINNING, true,
				true);
		_configurationBlock = createPreferenceContent(composite);
		_configurationBlock.setLayoutData(data);

		//
		_configurationBlock.initialize();

		//
		if (isProjectPreferencePage()) {
			boolean useProjectSettings = hasProjectSpecificOptions(getProject());
			enableProjectSpecificSettings(useProjectSettings);
		}

		Dialog.applyDialogFont(composite);
		return composite;
	}

#No. 4167
#File: E:\bishe\1\AbstractPropertySource.java
#Comment:
    /**
     * <p>Gets the value of the property whose name is defined by the <code>name</code> argument, transforming
     * it to the type of the class passed as second argument.</p>
     *
     * <p>If the requested type cannot be converted, it will throw a {@link ConfiguratorException}. Other
     * exceptions may raise, e.g. {@link NumberFormatException} when trying to convert an alphanumeric property
     * into an <code>int</code>.</p>
     *
     * @param name The name of the property to return
     * @param type The class object of the property to return
     * @param <T> The returned type
     * @return The property stored for the given name, as an instance of the given type, <code>null</code> if a property
     * with such name does not exist
     * @throws ConfiguratorException if an invalid type conversion has been intended (for example,
     *         trying to return a non-basic, non-String type)
     * @throws NumberFormatException or trying to convert an alphanumeric property value to a Number
     */

#Code:
    @Override
    public <T> T get(String name, Class<T> type) {
        String strVal = get(name);
        if(strVal == null) {
            return null;
        }
        @SuppressWarnings("unchecked")
        Converter<T> converter = converters.get(type);
        if(converter == null) {
            throw new ConfiguratorException("Cannot convert to type: " + type.getName());
        }
        return converter.convert(strVal);
    }

#No. 4168
#File: E:\bishe\1\AbstractProRationTest.java
#Comment:
  /**
   * Test of calculateProRatedMonth method, of class AbstractProRation.
   * @throws ParseException
   * @throws InitializationException
   */

#Code:
  @Test
  public void testCalculateProRatedMonth() throws ParseException, InitializationException
  {
    ProRatingResult result;
    int expResultDays;
    int expResultMonths;
    double expResultFactor;
    Date StartDate;
    Date EndDate;
    boolean useCalendarDays;
    SimpleDateFormat sdfIn = new SimpleDateFormat("yyyyMMddhhmmss");

    System.out.println("calculateProRatedMonth");

    // Simple good case, with 30 day months
    StartDate = sdfIn.parse("20120103000000");
    EndDate = sdfIn.parse("20120303000000");
    useCalendarDays = false;

    expResultDays = 1;
    expResultMonths = 2;
    expResultFactor = 2.0333;
    result = instance.calculateProRatedMonth(StartDate, EndDate, useCalendarDays);
    Assert.assertEquals(expResultDays, result.getDaysInPeriod());
    Assert.assertEquals(expResultMonths, result.getMonthsInPeriod());
    Assert.assertEquals(Math.round(expResultFactor * 10000), Math.round(result.getProRationFactor() * 10000));

    // Simple good case, with variable day months
    StartDate = sdfIn.parse("20120103000000");
    EndDate = sdfIn.parse("20120303000000");
    useCalendarDays = true;

    expResultDays = 1;
    expResultMonths = 2;
    expResultFactor = 2.0323;
    result = instance.calculateProRatedMonth(StartDate, EndDate, useCalendarDays);
    Assert.assertEquals(expResultDays, result.getDaysInPeriod());
    Assert.assertEquals(expResultMonths, result.getMonthsInPeriod());
    Assert.assertEquals(Math.round(expResultFactor * 10000), Math.round(result.getProRationFactor() * 10000));
  }

#No. 4169
#File: E:\bishe\1\AbstractProRationTest.java
#Comment:
  /**
   * Test of getDaysBetweenDates method, of class AbstractProRation.
   * @throws InitializationException
   * @throws ParseException
   */

#Code:
  @Test
  public void testGetDaysBetweenDates() throws InitializationException, ParseException
  {
    System.out.println("getDaysBetweenDates");

    SimpleDateFormat sdfIn = new SimpleDateFormat("yyyyMMddhhmmss");

    // Simple good case
    Date StartDate = sdfIn.parse("20120103000000");
    Date EndDate = sdfIn.parse("20120303000000");

    int result = instance.getDaysBetweenDates(StartDate, EndDate);
    int expResult = 60;

    Assert.assertEquals(expResult, result);
  }

#No. 4170
#File: E:\bishe\1\AbstractProRationTest.java
#Comment:
   /**
    * Override the unused event handling routines.
    *
    * @param r input record
    * @return return record
    * @throws ProcessingException
    */

#Code:
    @Override
    public IRecord procValidRecord(IRecord r) throws ProcessingException
    {
      return r;
    }

#No. 4171
#File: E:\bishe\1\AbstractProRationTest.java
#Comment:
   /**
    * Override the unused event handling routines.
    *
    * @param r input record
    * @return return record
    * @throws ProcessingException
    */

#Code:
    @Override
    public IRecord procErrorRecord(IRecord r) throws ProcessingException
    {
      return r;
    }

#No. 4172
#File: E:\bishe\1\AbstractProRationTest.java
#Comment:
 /**
  * Method to get an instance of the implementation. Done this way to allow
  * tests to be executed individually.
  *
  * @throws InitializationException
  */

#Code:
  private void getInstance()
  {
    if (instance == null)
    {
      // Get an initialise the cache
      instance = new AbstractProRationTest.AbstractProRationImpl();
      
      try
      {
        // Get the instance
        instance.init("DBTestPipe", "AbstractProRationTest");
      }
      catch (InitializationException ex)
      {
        org.junit.Assert.fail();
      }

    }
    else
    {
      org.junit.Assert.fail("Instance already allocated");
    }
  }

#No. 4173
#File: E:\bishe\1\AbstractProRationTest.java
#Comment:
 /**
  * Method to release an instance of the implementation.
  */

#Code:
  private void releaseInstance()
  {
    instance = null;
  }

#No. 4174
#File: E:\bishe\1\AbstractProtectionDatabase.java
#Comment:
    /**
     * Load the list of regions into a region manager.
     * 
     * @throws IOException
     */

#Code:
    public void load(RegionManager manager) throws IOException {
        load();
        manager.setRegions(getRegions());
    }

#No. 4175
#File: E:\bishe\1\AbstractProtectionDatabase.java
#Comment:
    /**
     * Save the list of regions from a region manager.
     * 
     * @throws IOException
     */

#Code:
    public void save(RegionManager manager) throws IOException {
        setRegions(manager.getRegions());
        save();
    }

#No. 4176
#File: E:\bishe\1\AbstractProtocMojo.java
#Comment:
    /**
     * Gets the {@link File} for each dependency artifact.
     *
     * @return A set of all dependency artifacts.
     */

#Code:
    private ImmutableSet<File> getDependencyArtifactFiles() {
        Set<File> dependencyArtifactFiles = newHashSet();
        for (Artifact artifact : getDependencyArtifacts()) {
            dependencyArtifactFiles.add(artifact.getFile());
        }
        return ImmutableSet.copyOf(dependencyArtifactFiles);
    }

#No. 4177
#File: E:\bishe\1\AbstractProtocMojo.java
#Comment:
    /**
     * Truncates the path of jar files so that they are relative to the local repository.
     *
     * @param jarPath the full path of a jar file.
     * @return the truncated path relative to the local repository or root of the drive.
     */

#Code:
    String truncatePath(final String jarPath) throws MojoExecutionException {

        if (hashDependentPaths) {
            try {
                return toHexString(MessageDigest.getInstance("MD5").digest(jarPath.getBytes()));
            } catch (NoSuchAlgorithmException e) {
                throw new MojoExecutionException("Failed to expand dependent jar", e);
            }
        }

        String repository = localRepository.getBasedir().replace('\\', '/');
        if (!repository.endsWith("/")) {
            repository += "/";
        }

        String path = jarPath.replace('\\', '/');
        int repositoryIndex = path.indexOf(repository);
        if (repositoryIndex != -1) {
            path = path.substring(repositoryIndex + repository.length());
        }

        // By now the path should be good, but do a final check to fix windows machines.
        int colonIndex = path.indexOf(':');
        if (colonIndex != -1) {
            // 2 = :\ in C:\
            path = path.substring(colonIndex + 2);
        }

        return path;
    }

#No. 4178
#File: E:\bishe\1\AbstractProtocolApplicationTabMapper.java
#Comment:
/**
 * An abstract template for mapping a protocol application. This is declared as abstract so that custom implementations
 * are possible (outside this package).
 * <p/>
 * <p><b>date</b>: Feb 11, 2008</p>
 *
 * @author brandizi
 * @param <PAT> the type of protocol application returned by this mapper
 */

#Code:
public abstract class AbstractProtocolApplicationTabMapper<PAT extends ProtocolApplication>
        extends ProcessingEntityTabMapper<PAT> {

    public AbstractProtocolApplicationTabMapper(BIIObjectStore store, SectionInstance formatSet, int fieldIndex, int endField) {
        super(store, formatSet, fieldIndex, endField);
        this.mappingHelpersConfig.put("Parameter Value",
                new MappingHelperConfig<ParameterValueMappingHelper>(ParameterValueMappingHelper.class)
        );
        this.mappingHelpersConfig.put("Performer",
                new MappingHelperConfig<PerformerMappingAttribue>(PerformerMappingAttribue.class)
        );
        this.mappingHelpersConfig.put("Date",
                new MappingHelperConfig<ProtocolAppDateMappingAttribue>(ProtocolAppDateMappingAttribue.class)
        );
    }

}
#No. 4179
#File: E:\bishe\1\AbstractProtoParserListener.java
#Comment:
    /**
     * Remove common leading whitespaces from all strings in the list.
     * Returns new list instance.
     */

#Code:
    protected List<String> trim(List<String> comments) {
        List<String> trimComments = new ArrayList<>();
        int n = 0;
        boolean tryRemoveWhitespace = true;
        while (tryRemoveWhitespace) {
            boolean allLinesAreShorter = true;
            for (String comment : comments) {
                if (comment.length() <= n) {
                    continue;
                }
                if (comment.charAt(n) != ' ') {
                    tryRemoveWhitespace = false;
                }
                allLinesAreShorter = false;
            }
            if (allLinesAreShorter) {
                break;
            }
            if (tryRemoveWhitespace) {
                n++;
            }
        }
        for (String comment : comments) {
            if (comment.length() > n) {
                String substring = comment.substring(n);
                trimComments.add(substring);
            } else {
                trimComments.add("");
            }
        }
        return trimComments;
    }

#No. 4180
#File: E:\bishe\1\AbstractPrototyper.java
#Comment:
	/**
	 * @return additional interfaces for the instance if they are required
	 */

#Code:
	protected Class<?>[] getAdditionalInterfaces()
	{
		return null;
	}

#No. 4181
#File: E:\bishe\1\AbstractPrototyper.java
#Comment:
	/**
	 * Method for obtaining default value of required property
	 * @param propName name of a property
	 * @param returnType type of a property
	 * @return default value for particular property
	 */

#Code:
	protected Object getDefaultValue(String propName, Class<?> returnType)
	{
		Object ret = null;
		if(returnType.isPrimitive())
		{
			if(returnType.equals(boolean.class))
			{
				return false;
			}
			else if(returnType.equals(char.class))
			{
				return '\0';
			}
			else
			{
				try
				{
					Class<?> wrapperClass = Primitives.wrap(returnType);
					return wrapperClass.getMethod("valueOf", String.class).invoke(null, "0");
				} catch (Throwable e)
				{
					throw new WicketRuntimeException("Can't create default value for '"+propName+"' which should have type '"+returnType.getName()+"'");
				} 
			}
		}
		return ret;
	}

#No. 4182
#File: E:\bishe\1\AbstractProviderService.java
#Comment:
    /**
     * @return the current authentication context for any calls through this support object
     * @throws InternalException no context was set
     */

#Code:
    protected final @Nonnull ProviderContext getContext() throws InternalException {
        ProviderContext ctx = getProvider().getContext();
        if( ctx == null ) {
            throw new InternalException("No context was specified for this request");
        }

#No. 4183
#File: E:\bishe\1\AbstractProxyCallable.java
#Comment:
/**
 * All abstract proxy callables inherit from this class - this class will store
 * the ProxyRequest that we're making and pass it to the remote machine.
 */

#Code:
abstract class AbstractProxyCallable implements
		Callable<Object, RuntimeException>, Serializable {
	private static final long serialVersionUID = 1L;

	protected final ProxyRequest request;

	protected AbstractProxyCallable(ProxyRequest request) {
		this.request = request;
	}

	protected AbstractProxyCallable() {
		this.request = null;
	}

	@Override
	public void checkRoles(RoleChecker checker) throws SecurityException {
	}

	abstract public Object call();
}

#No. 4184
#File: E:\bishe\1\AbstractProxyEditActivity.java
#Comment:
    /**
     * 
     * @param requestContext
     * @return
     */

#Code:
    protected P createProxy(final RequestContext requestContext) {
        return (P) requestContext.create(getProxyClass());
    }

#No. 4185
#File: E:\bishe\1\AbstractProxyEditActivity.java
#Comment:
    /**
     * @param currentPlace
     * @param view
     */

#Code:
    public AbstractProxyEditActivity(final Application application, final ProxyEditView<P, ?> view) {
        super(application);
        this.view = view;
    }

#No. 4186
#File: E:\bishe\1\AbstractProxyEditActivity.java
#Comment:
    /**
     * 
     */

#Code:
    @Override
    public void start(final AcceptsOneWidget display, final EventBus eventBus) {
        view.setDelegate(this);
        editorDriver = view.createEditorDriver();

        doLoadEntityProxy(new Receiver<P>() {
            @Override
            public void onSuccess(final P response) {
                entityProxy = response;
                display.setWidget(view);
                setDocumentTitleAndBodyAttributtes();
            }
        });
    }

#No. 4187
#File: E:\bishe\1\AbstractProxyEditActivity.java
#Comment:
    /**
     * 
     */

#Code:
    protected void doLoadEntityProxy(final Receiver<P> onloadCallback) {
        final String proxyId = getEntityId();
        if (proxyId == null) {
            // create a brand new proxy entity
            final RequestContext requestContext = createProxyRequest();
            final P proxy = createProxy(requestContext);
            // edit this entity proxy on the same request it was created
            editorDriver.edit(proxy, saveOrUpdateRequest(requestContext, proxy));
            // finish loading
            onloadCallback.onSuccess(proxy);
        } else {
            // find this entity proxy on the server
            loadProxyRequest(createProxyRequest(), proxyId)
                    .with(editorDriver.getPaths())
                    .fire(new Receiver<P>() {
                        @Override
                        public void onSuccess(final P response) {
                            if (editorDriver != null) {
                                // edit this entity proxy on a new request
                                editorDriver.edit(response, saveOrUpdateRequest(createProxyRequest(), response));
                                // finish loading
                                onloadCallback.onSuccess(response);
                            }
                        }
                    });
        }
    }

#No. 4188
#File: E:\bishe\1\AbstractProxyEditActivity.java
#Comment:
    /**
     * 
     * @see org.appfuse.tutorial.webapp.client.application.base.view.ProxyEditView.Delegate#saveClicked()
     */

#Code:
    @Override
    public void saveClicked() {

        setWaiting(true);
        editorDriver.flush().fire(new Receiver<Void>() {
            /*
             * Callbacks do nothing if editorDriver is null, we were stopped in
             * midflight
             */
            @Override
            public void onFailure(final ServerFailure error) {
                if (editorDriver != null) {
                    setWaiting(false);
                    throw new RuntimeException(error.getMessage());// FIXME
                }
            }

            @Override
            public void onSuccess(final Void ignore) {
                if (editorDriver != null) {
                    editorDriver = null;
                    setWaiting(false);
                    placeController.goTo(nextPlace(true));
                    addMessage(getSavedMessage(), AlertType.SUCCESS);
                }
            }

            @Override
            public void onConstraintViolation(final Set<ConstraintViolation<?>> violations) {
                if (editorDriver != null) {
                    setWaiting(false);
                    editorDriver.setConstraintViolations(violations);
                }
            }

        });
    }

#No. 4189
#File: E:\bishe\1\AbstractProxyEditActivity.java
#Comment:
    /**
     * 
     * @see org.appfuse.tutorial.webapp.client.application.base.view.ProxyEditView.Delegate#deleteClicked()
     */

#Code:
    @Override
    public void deleteClicked() {
        if (!Window.confirm(getDeleteConfirmation())) {
            return;
        }
        deleteRequest(createProxyRequest(), entityProxy).fire(new Receiver<Void>() {
            @Override
            public void onSuccess(final Void response) {
                placeController.goTo(nextPlace(false));
                addMessage(getDeletedMessage(), AlertType.SUCCESS);
            }
        });
    }

#No. 4190
#File: E:\bishe\1\AbstractProxyEditActivity.java
#Comment:
    /**
     * 
     * @see org.appfuse.tutorial.webapp.client.application.base.view.ProxyEditView.Delegate#cancelClicked()
     */

#Code:
    @Override
    public void cancelClicked() {
        final String unsavedChangesWarning = mayStop();
        if ((unsavedChangesWarning == null)
                || Window.confirm(unsavedChangesWarning)) {
            editorDriver = null;
            placeController.goTo(previousPlace());
        }
    }

#No. 4191
#File: E:\bishe\1\AbstractProxyEditActivity.java
#Comment:
    /**
     * Creates the {@link Place} to go when this activity is canceled.
     * 
     * @param saved
     * @return
     */

#Code:
    protected Place previousPlace() {
        return new EntitySearchPlace(getProxyClass());
    }

#No. 4192
#File: E:\bishe\1\AbstractProxyEditActivity.java
#Comment:
    /**
     * Creates the {@link Place} to go after successfully saved or deleted this
     * entity.
     * 
     * @param saved
     * @return
     */

#Code:
    protected Place nextPlace(final boolean saved) {
        if (saved) {
            return new EntitySearchPlace(getProxyClass());
        } else { // deleted
            return new HomePlace();
        }
    }

#No. 4193
#File: E:\bishe\1\AbstractProxyEditActivity.java
#Comment:
    /**
     * 
     * @see com.google.gwt.activity.shared.AbstractActivity#mayStop()
     */

#Code:
    @Override
    public String mayStop() {
        if (isWaiting() || changed()) {
            return getAbandonChangesMessage();
        }

        return null;
    }

#No. 4194
#File: E:\bishe\1\AbstractProxyEditActivity.java
#Comment:
    /**
     * 
     * @see com.google.gwt.activity.shared.AbstractActivity#onCancel()
     */

#Code:
    @Override
    public void onCancel() {
        onStop();
    }

#No. 4195
#File: E:\bishe\1\AbstractProxyEditActivity.java
#Comment:
    /**
     * 
     * @see com.google.gwt.activity.shared.AbstractActivity#onStop()
     */

#Code:
    @Override
    public void onStop() {
        view.setDelegate(null);
        editorDriver = null;
    }

#No. 4196
#File: E:\bishe\1\AbstractProxyEditActivity.java
#Comment:
    /**
     * 
     * @return
     */

#Code:
    private boolean changed() {
        try {
            return editorDriver != null && editorDriver.isDirty();
        } catch (final Exception e) {
            Logger.getLogger("").log(Level.SEVERE, e.getMessage(), e);
            return false;
        }
    }

#No. 4197
#File: E:\bishe\1\AbstractProxyEditActivity.java
#Comment:
    /**
     * @return true if we're waiting for an rpc response.
     */

#Code:
    protected boolean isWaiting() {
        return waiting;
    }

#No. 4198
#File: E:\bishe\1\AbstractProxyEditActivity.java
#Comment:
    /**
     * While we are waiting for a response, we cannot poke setters on the proxy
     * (that is, we cannot call editorDriver.flush). So we set the waiting flag
     * to warn ourselves not to, and to disable the view.
     */

#Code:
    protected void setWaiting(final boolean wait) {
        this.waiting = wait;
        view.setEnabled(!wait);
    }

#No. 4199
#File: E:\bishe\1\AbstractProxySearchActivity.java
#Comment:
    /**
     * Load items on start.
     */

#Code:
    protected void loadItems(final S searchCriteria, final Range range) {
        if (searchCriteria instanceof BaseProxy) {
            proxyFactory.setFrozen((BaseProxy) searchCriteria, true);
        }
        final RequestContext requestContext = createRequestContext();
        createCountRequest(requestContext, searchCriteria).fire(new Receiver<Long>() {
            @Override
            public void onSuccess(final Long response) {
                if (view == null) {
                    // This activity is dead
                    return;
                }
                view.asHasData().setRowCount(response.intValue(), true);
                onRangeChanged(view.asHasData(), range, view.getColumnSortList());
            }
        });
    }

#No. 4200
#File: E:\bishe\1\AbstractProxySearchActivity.java
#Comment:
    /**
     * Called by the table as it needs data.
     */

#Code:
    protected void onRangeChanged(final HasData<P> hasData, final Range range, final ColumnSortList columnSortList) {
        final RequestContext requestContext = createRequestContext();
        createSearchRequest(requestContext, searchCriteria, range, columnSortList)
                .with(view.getPaths()).fire(new Receiver<List<P>>() {
                    @Override
                    public void onSuccess(final List<P> results) {
                        if (view == null) {
                            // This activity is dead
                            return;
                        }
                        hasData.setRowData(range.getStart(), results);
                        newHistoryToken(searchCriteria, range.getStart(), range.getLength());
                    }
                });
    }

#No. 4201
#File: E:\bishe\1\AbstractProxySearchActivity.java
#Comment:
    /**
     * Validates given searchCriteria.
     * 
     * Override if you want to apply validation, example: <code><pre>
     * protected Set<ConstraintViolation<S>> validate(S searchCriteria){
     * 	return getValidator().validate(searchCriteria);
     * }
     * </pre></code>
     * 
     * @param searchCriteria
     * @return
     */

#Code:
    protected Set<ConstraintViolation<S>> validate(final S searchCriteria) {
        return null;//
    }

#No. 4202
#File: E:\bishe\1\AbstractProxyTargetLocator.java
#Comment:
    /**
     * <p>Constructor for AbstractProxyTargetLocator.</p>
     *
     * @param bundleContext a {@link org.osgi.framework.BundleContext} object.
     * @param beanType a {@link java.lang.Class} object.
     * @param parent a {@link java.lang.Class} object.
     * @param overwrites a {@link java.util.Map} object.
     */

#Code:
    public AbstractProxyTargetLocator(BundleContext bundleContext, Class<?> beanType,
            Class<?> parent, Map<String, String> overwrites) {
        this.bundleContext = bundleContext;
        this.beanType = beanType;
        this.parent = parent;
        this.overwrites = overwrites;
    }

#No. 4203
#File: E:\bishe\1\AbstractProxyTargetLocator.java
#Comment:
    /**
     * <p>hasApplicationContext.</p>
     *
     * @return a boolean.
     */

#Code:
    public boolean hasApplicationContext() {
        String filter = getApplicationContextFilter(bundleContext.getBundle().getSymbolicName());
        ServiceReference<?>[] references = null;
        try {
            references = bundleContext.getServiceReferences(getContainerClass().getName(), filter);
        } catch (InvalidSyntaxException e) {
            throw new IllegalStateException("not possible", e);
        }
        return references != null && references.length != 0;
    }

#No. 4204
#File: E:\bishe\1\AbstractProxyTargetLocator.java
#Comment:
    /**
     * <p>Getter for the field <code>parent</code>.</p>
     *
     * @return a {@link java.lang.Class} object.
     */

#Code:
    public Class<?> getParent() {
        return parent;
    }

#No. 4205
#File: E:\bishe\1\AbstractPTService.java
#Comment:
/**
 * Abstract base class for {@link PTService}s.
 * 
 * @author Curtis Rueden
 * @param <PT> Plugin type of the {@link SciJavaPlugin}s being managed.
 */

#Code:
public abstract class AbstractPTService<PT extends SciJavaPlugin> extends
	AbstractService implements PTService<PT>
{

	@Parameter
	private PluginService pluginService;

	// -- PTService methods --

	@Override
	public PluginService pluginService() {
		return pluginService;
	}
}

#No. 4206
#File: E:\bishe\1\AbstractPublishedPointModel.java
#Comment:
	/**
	 * @param data
	 */

#Code:
	public AbstractPublishedPointModel(T data) {
		super(data);
	}

#No. 4207
#File: E:\bishe\1\AbstractPublishedPointModel.java
#Comment:
	/**
	 * Get the sub type name for the model.  
	 * Published Points are based on the model type name
	 * PUB-POINT-{Publisher Type Name}
	 * @return
	 */

#Code:
	@JsonIgnore
	public abstract String getPublisherTypeName();
}
}

#No. 4208
#File: E:\bishe\1\AbstractPublisher.java
#Comment:
	/**
	 * Utility method for getting the Workspace
	 *
	 * @return
	 */

#Code:
	public String getWorkspaceLocation(HttpServletRequest request) {
		return CommonIDEParameters.getWorkspace(request);
	}

#No. 4209
#File: E:\bishe\1\AbstractPublisher.java
#Comment:
	/**
	 * Retrieve the project's repository representation as {@link ICollection}
	 *
	 * @param project
	 * @return
	 */

#Code:
	public ICollection getSourceProjectContainer(IProject project, HttpServletRequest request) {
		final IRepository repository = RepositoryFacade.getInstance().getRepository(request);
		final ICollection workspaceContainer = repository.getCollection(getWorkspaceLocation(request));
		final ICollection projectContainer = workspaceContainer.getCollection(project.getName());
		return projectContainer;
	}

#No. 4210
#File: E:\bishe\1\AbstractPublisherModel.java
#Comment:
	/**
	 * @param data
	 */

#Code:
	public AbstractPublisherModel(T data) {
		super(data);
	}

#No. 4211
#File: E:\bishe\1\AbstractPullSensorExampleActivity.java
#Comment:
		/*
		 * Additional UI button for pull sensor
		 */

#Code:
		enableSenseOnceButton();
		enableUpdateConfigButton();
	}

	protected int getInterfaceLayout()
	{
		return R.layout.pull_sensor_layout;
	}

#No. 4212
#File: E:\bishe\1\AbstractPullSensorExampleActivity.java
#Comment:
	/*
	 * UI Components (Buttons, Text Fields)
	 */

#Code:
	private void enableSenseOnceButton()
	{
		Button button = (Button) findViewById(R.id.pullOnceButton);
		button.setOnClickListener(new OnClickListener()
		{
			@Override
			public void onClick(View v)
			{
				pullDataOnce();
			}
		});
	}

#No. 4213
#File: E:\bishe\1\AbstractPushEvent.java
#Comment:
    /**
     * Gets the branch name from the ref. Will return null if the ref does not start with "refs/heads/".
     * 
     * @return the branch name from the ref
     */

#Code:
    @JsonIgnore
    public String getBranch() {

        String ref = getRef();
        if (ref == null || ref.trim().length() == 0) {
            return (null);
        }

        ref = ref.trim();
        int refsHeadsIndex = ref.indexOf(REFS_HEADS);
        if (refsHeadsIndex != 0) {
            return (null);
        }

        return (ref.substring(REFS_HEADS.length()));
    }

#No. 4214
#File: E:\bishe\1\AbstractPutRemoveCacheListener.java
#Comment:
    /**
     * Post remove.
     *
     * @param key the trigger key
     */

#Code:
    @SuppressWarnings("UnusedParameters")
    protected void onPostRemove(Key key) {
        // do nothing by default
    }

#No. 4215
#File: E:\bishe\1\AbstractQuadTree.java
#Comment:
	/**
	 * Returns the size
	 * 
	 * @return
	 */

#Code:
	public Dimension getSize() {
		return this.size;
	}

#No. 4216
#File: E:\bishe\1\AbstractQuadTree.java
#Comment:
	/**
	 * Returns the startCoordinates
	 * 
	 * @return
	 */

#Code:
	public Point getStartCoordinates() {
		return this.startCoordinates;
	}

#No. 4217
#File: E:\bishe\1\AbstractQuadTree.java
#Comment:
	/**
	 * Clear the QuadTree
	 */

#Code:
	public abstract void clear();

	/**
	 * Return the root node of this quad tree
	 * 
	 * @return
	 */
	public abstract AbstractNode<T> getRootNode();

}
}

#No. 4218
#File: E:\bishe\1\AbstractQuerqyDismaxQParserPlugin.java
#Comment:
   /**
    * Loads the whole {@link RewriteChain}s from the args and returns a list of
    * them.
    */

#Code:
   private RewriteChain loadRewriteChain(ResourceLoader loader) throws IOException {

      NamedList<?> chainConfig = (NamedList<?>) initArgs.get("rewriteChain");
      List<RewriterFactory> factories = new LinkedList<>();

      if (chainConfig != null) {

         @SuppressWarnings("unchecked")
         List<NamedList<?>> rewriterConfigs = (List<NamedList<?>>) chainConfig.getAll("rewriter");
         if (rewriterConfigs != null) {
            for (NamedList<?> config : rewriterConfigs) {
               RewriterFactoryAdapter factory = loader.newInstance((String) config.get("class"),
                     RewriterFactoryAdapter.class);
               factories.add(factory.createRewriterFactory(config, loader));
            }
         }
      }
      
      return new RewriteChain(factories);
      
   }

#No. 4219
#File: E:\bishe\1\AbstractQueryData.java
#Comment:
    /**
     * Just an optimized version, which performs faster if the current thread is already the query's owner thread.
     * Note: all parameters are reset to their initial values specified in {@link QueryBuilder}.
     */

#Code:
    Q forCurrentThread(Q query) {
        if (Thread.currentThread() == query.ownerThread) {
            System.arraycopy(initialValues, 0, query.parameters, 0, initialValues.length);
            return query;
        } else {
            return forCurrentThread();
        }
    }

#No. 4220
#File: E:\bishe\1\AbstractQueryData.java
#Comment:
    /**
     * Note: all parameters are reset to their initial values specified in {@link QueryBuilder}.
     */

#Code:
    Q forCurrentThread() {
        // Process.myTid() seems to have issues on some devices (see Github #376) and Robolectric (#171):
        // We use currentThread().getId() instead (unfortunately return a long, can not use SparseArray).
        // PS.: thread ID may be reused, which should be fine because old thread will be gone anyway.
        long threadId = Thread.currentThread().getId();
        synchronized (queriesForThreads) {
            WeakReference<Q> queryRef = queriesForThreads.get(threadId);
            Q query = queryRef != null ? queryRef.get() : null;
            if (query == null) {
                gc();
                query = createQuery();
                queriesForThreads.put(threadId, new WeakReference<Q>(query));
            } else {
                System.arraycopy(initialValues, 0, query.parameters, 0, initialValues.length);
            }
            return query;
        }
    }

#No. 4221
#File: E:\bishe\1\AbstractQueryFactory.java
#Comment:
    /**
     *
     * @param pQuery The query to add in background
     * @return <code>true</code> if query has been added to JobManager (if network is available, or if query is persistent),
     * else <code>false</code> (if network is unavailable and query is not persistent).
     */

#Code:
    protected boolean startQuery(@NonNull final AbstractQuery<?> pQuery) {
        if (mMerlinsBeard.isConnected() || pQuery.isPersistent()) {
            mJobManager.addJobInBackground(pQuery);
            return true;
        }

#No. 4222
#File: E:\bishe\1\AbstractQueryWithLimit.java
#Comment:
    /**
     * Sets the offset for results returned by this Query. {@link org.greenrobot.greendao.query.QueryBuilder#offset(int)} must
     * have been called on
     * the QueryBuilder that created this Query object.
     */

#Code:
    public void setOffset(int offset) {
        checkThread();
        if (offsetPosition == -1) {
            throw new IllegalStateException("Offset must be set with QueryBuilder before it can be used here");
        }
        parameters[offsetPosition] = Integer.toString(offset);
    }

#No. 4223
#File: E:\bishe\1\AbstractQueuedExecutionThreadService.java
#Comment:
    /**
     * Allow service to run non-asynchronously to allow unit testing of concrete implementations, without needing to
     * deal with timing issues.
     *
     * @return true if the service is asynchronous
     */

#Code:
    protected boolean isAsync() {
        return true;
    }

#No. 4224
#File: E:\bishe\1\AbstractQueuedLongSynchronizer.java
#Comment:
    /**
     * Attempts to set the state to reflect a release in shared mode.
     *
     * <p>This method is always invoked by the thread performing release.
     *
     * <p>The default implementation throws
     * {@link UnsupportedOperationException}.
     *
     * @param arg the release argument. This value is always the one
     *        passed to a release method, or the current state value upon
     *        entry to a condition wait.  The value is otherwise
     *        uninterpreted and can represent anything you like.
     * @return {@code true} if this release of shared mode may permit a
     *         waiting acquire (shared or exclusive) to succeed; and
     *         {@code false} otherwise
     * @throws IllegalMonitorStateException if releasing would place this
     *         synchronizer in an illegal state. This exception must be
     *         thrown in a consistent fashion for synchronization to work
     *         correctly.
     * @throws UnsupportedOperationException if shared mode is not supported
     */

#Code:
    protected boolean tryReleaseShared(long arg) {
        throw new UnsupportedOperationException();
    }

#No. 4225
#File: E:\bishe\1\AbstractQueuedLongSynchronizer.java
#Comment:
    /**
     * Returns {@code true} if synchronization is held exclusively with
     * respect to the current (calling) thread.  This method is invoked
     * upon each call to a non-waiting {@link ConditionObject} method.
     * (Waiting methods instead invoke {@link #release}.)
     *
     * <p>The default implementation throws {@link
     * UnsupportedOperationException}. This method is invoked
     * internally only within {@link ConditionObject} methods, so need
     * not be defined if conditions are not used.
     *
     * @return {@code true} if synchronization is held exclusively;
     *         {@code false} otherwise
     * @throws UnsupportedOperationException if conditions are not supported
     */

#Code:
    protected boolean isHeldExclusively() {
        throw new UnsupportedOperationException();
    }

#No. 4226
#File: E:\bishe\1\AbstractQueuedLongSynchronizer.java
#Comment:
    /**
     * Acquires in exclusive mode, ignoring interrupts.  Implemented
     * by invoking at least once {@link #tryAcquire},
     * returning on success.  Otherwise the thread is queued, possibly
     * repeatedly blocking and unblocking, invoking {@link
     * #tryAcquire} until success.  This method can be used
     * to implement method {@link Lock#lock}.
     *
     * @param arg the acquire argument.  This value is conveyed to
     *        {@link #tryAcquire} but is otherwise uninterpreted and
     *        can represent anything you like.
     */

#Code:
    public final void acquire(long arg) {
        if (!tryAcquire(arg) &&
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    }

#No. 4227
#File: E:\bishe\1\AbstractQueuedLongSynchronizer.java
#Comment:
    /**
     * Acquires in exclusive mode, aborting if interrupted.
     * Implemented by first checking interrupt status, then invoking
     * at least once {@link #tryAcquire}, returning on
     * success.  Otherwise the thread is queued, possibly repeatedly
     * blocking and unblocking, invoking {@link #tryAcquire}
     * until success or the thread is interrupted.  This method can be
     * used to implement method {@link Lock#lockInterruptibly}.
     *
     * @param arg the acquire argument.  This value is conveyed to
     *        {@link #tryAcquire} but is otherwise uninterpreted and
     *        can represent anything you like.
     * @throws InterruptedException if the current thread is interrupted
     */

#Code:
    public final void acquireInterruptibly(long arg)
            throws InterruptedException {
        if (Thread.interrupted())
            throw new InterruptedException();
        if (!tryAcquire(arg))
            doAcquireInterruptibly(arg);
    }

#No. 4228
#File: E:\bishe\1\AbstractQueuedLongSynchronizer.java
#Comment:
    /**
     * Attempts to acquire in exclusive mode, aborting if interrupted,
     * and failing if the given timeout elapses.  Implemented by first
     * checking interrupt status, then invoking at least once {@link
     * #tryAcquire}, returning on success.  Otherwise, the thread is
     * queued, possibly repeatedly blocking and unblocking, invoking
     * {@link #tryAcquire} until success or the thread is interrupted
     * or the timeout elapses.  This method can be used to implement
     * method {@link Lock#tryLock(long, TimeUnit)}.
     *
     * @param arg the acquire argument.  This value is conveyed to
     *        {@link #tryAcquire} but is otherwise uninterpreted and
     *        can represent anything you like.
     * @param nanosTimeout the maximum number of nanoseconds to wait
     * @return {@code true} if acquired; {@code false} if timed out
     * @throws InterruptedException if the current thread is interrupted
     */

#Code:
    public final boolean tryAcquireNanos(long arg, long nanosTimeout)
            throws InterruptedException {
        if (Thread.interrupted())
            throw new InterruptedException();
        return tryAcquire(arg) ||
            doAcquireNanos(arg, nanosTimeout);
    }

#No. 4229
#File: E:\bishe\1\AbstractQueuedLongSynchronizer.java
#Comment:
    /**
     * Releases in exclusive mode.  Implemented by unblocking one or
     * more threads if {@link #tryRelease} returns true.
     * This method can be used to implement method {@link Lock#unlock}.
     *
     * @param arg the release argument.  This value is conveyed to
     *        {@link #tryRelease} but is otherwise uninterpreted and
     *        can represent anything you like.
     * @return the value returned from {@link #tryRelease}
     */

#Code:
    public final boolean release(long arg) {
        if (tryRelease(arg)) {
            Node h = head;
            if (h != null && h.waitStatus != 0)
                unparkSuccessor(h);
            return true;
        }
        return false;
    }

#No. 4230
#File: E:\bishe\1\AbstractQueuedLongSynchronizer.java
#Comment:
    /**
     * Acquires in shared mode, ignoring interrupts.  Implemented by
     * first invoking at least once {@link #tryAcquireShared},
     * returning on success.  Otherwise the thread is queued, possibly
     * repeatedly blocking and unblocking, invoking {@link
     * #tryAcquireShared} until success.
     *
     * @param arg the acquire argument.  This value is conveyed to
     *        {@link #tryAcquireShared} but is otherwise uninterpreted
     *        and can represent anything you like.
     */

#Code:
    public final void acquireShared(long arg) {
        if (tryAcquireShared(arg) < 0)
            doAcquireShared(arg);
    }

#No. 4231
#File: E:\bishe\1\AbstractQueuedLongSynchronizer.java
#Comment:
    /**
     * Acquires in shared mode, aborting if interrupted.  Implemented
     * by first checking interrupt status, then invoking at least once
     * {@link #tryAcquireShared}, returning on success.  Otherwise the
     * thread is queued, possibly repeatedly blocking and unblocking,
     * invoking {@link #tryAcquireShared} until success or the thread
     * is interrupted.
     * @param arg the acquire argument
     * This value is conveyed to {@link #tryAcquireShared} but is
     * otherwise uninterpreted and can represent anything
     * you like.
     * @throws InterruptedException if the current thread is interrupted
     */

#Code:
    public final void acquireSharedInterruptibly(long arg)
            throws InterruptedException {
        if (Thread.interrupted())
            throw new InterruptedException();
        if (tryAcquireShared(arg) < 0)
            doAcquireSharedInterruptibly(arg);
    }

#No. 4232
#File: E:\bishe\1\AbstractQueuedLongSynchronizer.java
#Comment:
    /**
     * Attempts to acquire in shared mode, aborting if interrupted, and
     * failing if the given timeout elapses.  Implemented by first
     * checking interrupt status, then invoking at least once {@link
     * #tryAcquireShared}, returning on success.  Otherwise, the
     * thread is queued, possibly repeatedly blocking and unblocking,
     * invoking {@link #tryAcquireShared} until success or the thread
     * is interrupted or the timeout elapses.
     *
     * @param arg the acquire argument.  This value is conveyed to
     *        {@link #tryAcquireShared} but is otherwise uninterpreted
     *        and can represent anything you like.
     * @param nanosTimeout the maximum number of nanoseconds to wait
     * @return {@code true} if acquired; {@code false} if timed out
     * @throws InterruptedException if the current thread is interrupted
     */

#Code:
    public final boolean tryAcquireSharedNanos(long arg, long nanosTimeout)
            throws InterruptedException {
        if (Thread.interrupted())
            throw new InterruptedException();
        return tryAcquireShared(arg) >= 0 ||
            doAcquireSharedNanos(arg, nanosTimeout);
    }

#No. 4233
#File: E:\bishe\1\AbstractQueuedLongSynchronizer.java
#Comment:
    /**
     * Releases in shared mode.  Implemented by unblocking one or more
     * threads if {@link #tryReleaseShared} returns true.
     *
     * @param arg the release argument.  This value is conveyed to
     *        {@link #tryReleaseShared} but is otherwise uninterpreted
     *        and can represent anything you like.
     * @return the value returned from {@link #tryReleaseShared}
     */

#Code:
    public final boolean releaseShared(long arg) {
        if (tryReleaseShared(arg)) {
            doReleaseShared();
            return true;
        }
        return false;
    }

#No. 4234
#File: E:\bishe\1\AbstractQueuedLongSynchronizer.java
#Comment:
    /**
     * Queries whether any threads are waiting to acquire. Note that
     * because cancellations due to interrupts and timeouts may occur
     * at any time, a {@code true} return does not guarantee that any
     * other thread will ever acquire.
     *
     * <p>In this implementation, this operation returns in
     * constant time.
     *
     * @return {@code true} if there may be other threads waiting to acquire
     */

#Code:
    public final boolean hasQueuedThreads() {
        return head != tail;
    }

#No. 4235
#File: E:\bishe\1\AbstractQueuedLongSynchronizer.java
#Comment:
    /**
     * Queries whether any threads have ever contended to acquire this
     * synchronizer; that is if an acquire method has ever blocked.
     *
     * <p>In this implementation, this operation returns in
     * constant time.
     *
     * @return {@code true} if there has ever been contention
     */

#Code:
    public final boolean hasContended() {
        return head != null;
    }

#No. 4236
#File: E:\bishe\1\AbstractQueuedLongSynchronizer.java
#Comment:
    /**
     * Returns the first (longest-waiting) thread in the queue, or
     * {@code null} if no threads are currently queued.
     *
     * <p>In this implementation, this operation normally returns in
     * constant time, but may iterate upon contention if other threads are
     * concurrently modifying the queue.
     *
     * @return the first (longest-waiting) thread in the queue, or
     *         {@code null} if no threads are currently queued
     */

#Code:
    public final Thread getFirstQueuedThread() {
        // handle only fast path, else relay
        return (head == tail) ? null : fullGetFirstQueuedThread();
    }

#No. 4237
#File: E:\bishe\1\AbstractQueuedLongSynchronizer.java
#Comment:
    /**
     * Version of getFirstQueuedThread called when fastpath fails
     */

#Code:
    private Thread fullGetFirstQueuedThread() {
        /*
         * The first node is normally head.next. Try to get its
         * thread field, ensuring consistent reads: If thread
         * field is nulled out or s.prev is no longer head, then
         * some other thread(s) concurrently performed setHead in
         * between some of our reads. We try this twice before
         * resorting to traversal.
         */
        Node h, s;
        Thread st;
        if (((h = head) != null && (s = h.next) != null &&
             s.prev == head && (st = s.thread) != null) ||
            ((h = head) != null && (s = h.next) != null &&
             s.prev == head && (st = s.thread) != null))
            return st;

        /*
         * Head's next field might not have been set yet, or may have
         * been unset after setHead. So we must check to see if tail
         * is actually first node. If not, we continue on, safely
         * traversing from tail back to head to find first,
         * guaranteeing termination.
         */

        Node t = tail;
        Thread firstThread = null;
        while (t != null && t != head) {
            Thread tt = t.thread;
            if (tt != null)
                firstThread = tt;
            t = t.prev;
        }
        return firstThread;
    }

#No. 4238
#File: E:\bishe\1\AbstractQueuedLongSynchronizer.java
#Comment:
    /**
     * Returns true if the given thread is currently queued.
     *
     * <p>This implementation traverses the queue to determine
     * presence of the given thread.
     *
     * @param thread the thread
     * @return {@code true} if the given thread is on the queue
     * @throws NullPointerException if the thread is null
     */

#Code:
    public final boolean isQueued(Thread thread) {
        if (thread == null)
            throw new NullPointerException();
        for (Node p = tail; p != null; p = p.prev)
            if (p.thread == thread)
                return true;
        return false;
    }

#No. 4239
#File: E:\bishe\1\AbstractQueuedLongSynchronizer.java
#Comment:
    /**
     * Returns {@code true} if the apparent first queued thread, if one
     * exists, is waiting in exclusive mode.  If this method returns
     * {@code true}, and the current thread is attempting to acquire in
     * shared mode (that is, this method is invoked from {@link
     * #tryAcquireShared}) then it is guaranteed that the current thread
     * is not the first queued thread.  Used only as a heuristic in
     * ReentrantReadWriteLock.
     */

#Code:
    final boolean apparentlyFirstQueuedIsExclusive() {
        Node h, s;
        return (h = head) != null &&
            (s = h.next)  != null &&
            !s.isShared()         &&
            s.thread != null;
    }

#No. 4240
#File: E:\bishe\1\AbstractQueuedLongSynchronizer.java
#Comment:
    /**
     * Queries whether any threads have been waiting to acquire longer
     * than the current thread.
     *
     * <p>An invocation of this method is equivalent to (but may be
     * more efficient than):
     *  <pre> {@code
     * getFirstQueuedThread() != Thread.currentThread() &&
     * hasQueuedThreads()}</pre>
     *
     * <p>Note that because cancellations due to interrupts and
     * timeouts may occur at any time, a {@code true} return does not
     * guarantee that some other thread will acquire before the current
     * thread.  Likewise, it is possible for another thread to win a
     * race to enqueue after this method has returned {@code false},
     * due to the queue being empty.
     *
     * <p>This method is designed to be used by a fair synchronizer to
     * avoid <a href="AbstractQueuedSynchronizer#barging">barging</a>.
     * Such a synchronizer's {@link #tryAcquire} method should return
     * {@code false}, and its {@link #tryAcquireShared} method should
     * return a negative value, if this method returns {@code true}
     * (unless this is a reentrant acquire).  For example, the {@code
     * tryAcquire} method for a fair, reentrant, exclusive mode
     * synchronizer might look like this:
     *
     *  <pre> {@code
     * protected boolean tryAcquire(int arg) {
     *   if (isHeldExclusively()) {
     *     // A reentrant acquire; increment hold count
     *     return true;
     *   } else if (hasQueuedPredecessors()) {
     *     return false;
     *   } else {
     *     // try to acquire normally
     *   }
     * }}</pre>
     *
     * @return {@code true} if there is a queued thread preceding the
     *         current thread, and {@code false} if the current thread
     *         is at the head of the queue or the queue is empty
     * @since 1.7
     */

#Code:
    public final boolean hasQueuedPredecessors() {
        // The correctness of this depends on head being initialized
        // before tail and on head.next being accurate if the current
        // thread is first in queue.
        Node t = tail; // Read fields in reverse initialization order
        Node h = head;
        Node s;
        return h != t &&
            ((s = h.next) == null || s.thread != Thread.currentThread());
    }

#No. 4241
#File: E:\bishe\1\AbstractQueuedLongSynchronizer.java
#Comment:
    /**
     * Returns an estimate of the number of threads waiting to
     * acquire.  The value is only an estimate because the number of
     * threads may change dynamically while this method traverses
     * internal data structures.  This method is designed for use in
     * monitoring system state, not for synchronization
     * control.
     *
     * @return the estimated number of threads waiting to acquire
     */

#Code:
    public final int getQueueLength() {
        int n = 0;
        for (Node p = tail; p != null; p = p.prev) {
            if (p.thread != null)
                ++n;
        }
        return n;
    }

#No. 4242
#File: E:\bishe\1\AbstractQueuedLongSynchronizer.java
#Comment:
    /**
     * Returns a collection containing threads that may be waiting to
     * acquire.  Because the actual set of threads may change
     * dynamically while constructing this result, the returned
     * collection is only a best-effort estimate.  The elements of the
     * returned collection are in no particular order.  This method is
     * designed to facilitate construction of subclasses that provide
     * more extensive monitoring facilities.
     *
     * @return the collection of threads
     */

#Code:
    public final Collection<Thread> getQueuedThreads() {
        ArrayList<Thread> list = new ArrayList<Thread>();
        for (Node p = tail; p != null; p = p.prev) {
            Thread t = p.thread;
            if (t != null)
                list.add(t);
        }
        return list;
    }

#No. 4243
#File: E:\bishe\1\AbstractQueuedLongSynchronizer.java
#Comment:
    /**
     * Returns a collection containing threads that may be waiting to
     * acquire in exclusive mode. This has the same properties
     * as {@link #getQueuedThreads} except that it only returns
     * those threads waiting due to an exclusive acquire.
     *
     * @return the collection of threads
     */

#Code:
    public final Collection<Thread> getExclusiveQueuedThreads() {
        ArrayList<Thread> list = new ArrayList<Thread>();
        for (Node p = tail; p != null; p = p.prev) {
            if (!p.isShared()) {
                Thread t = p.thread;
                if (t != null)
                    list.add(t);
            }
        }
        return list;
    }

#No. 4244
#File: E:\bishe\1\AbstractQueuedLongSynchronizer.java
#Comment:
    /**
     * Returns a collection containing threads that may be waiting to
     * acquire in shared mode. This has the same properties
     * as {@link #getQueuedThreads} except that it only returns
     * those threads waiting due to a shared acquire.
     *
     * @return the collection of threads
     */

#Code:
    public final Collection<Thread> getSharedQueuedThreads() {
        ArrayList<Thread> list = new ArrayList<Thread>();
        for (Node p = tail; p != null; p = p.prev) {
            if (p.isShared()) {
                Thread t = p.thread;
                if (t != null)
                    list.add(t);
            }
        }
        return list;
    }

#No. 4245
#File: E:\bishe\1\AbstractQueuedLongSynchronizer.java
#Comment:
    /**
     * Returns a string identifying this synchronizer, as well as its state.
     * The state, in brackets, includes the String {@code "State ="}
     * followed by the current value of {@link #getState}, and either
     * {@code "nonempty"} or {@code "empty"} depending on whether the
     * queue is empty.
     *
     * @return a string identifying this synchronizer, as well as its state
     */

#Code:
    public String toString() {
        long s = getState();
        String q  = hasQueuedThreads() ? "non" : "";
        return super.toString() +
            "[State = " + s + ", " + q + "empty queue]";
    }

#No. 4246
#File: E:\bishe\1\AbstractQueuedLongSynchronizer.java
#Comment:
    /**
     * Returns true if a node, always one that was initially placed on
     * a condition queue, is now waiting to reacquire on sync queue.
     * @param node the node
     * @return true if is reacquiring
     */

#Code:
    final boolean isOnSyncQueue(Node node) {
        if (node.waitStatus == Node.CONDITION || node.prev == null)
            return false;
        if (node.next != null) // If has successor, it must be on queue
            return true;
        /*
         * node.prev can be non-null, but not yet on queue because
         * the CAS to place it on queue can fail. So we have to
         * traverse from tail to make sure it actually made it.  It
         * will always be near the tail in calls to this method, and
         * unless the CAS failed (which is unlikely), it will be
         * there, so we hardly ever traverse much.
         */
        return findNodeFromTail(node);
    }

#No. 4247
#File: E:\bishe\1\AbstractQueuedLongSynchronizer.java
#Comment:
    /**
     * Returns true if node is on sync queue by searching backwards from tail.
     * Called only when needed by isOnSyncQueue.
     * @return true if present
     */

#Code:
    private boolean findNodeFromTail(Node node) {
        Node t = tail;
        for (;;) {
            if (t == node)
                return true;
            if (t == null)
                return false;
            t = t.prev;
        }
    }

#No. 4248
#File: E:\bishe\1\AbstractQueuedLongSynchronizer.java
#Comment:
    /**
     * Transfers a node from a condition queue onto sync queue.
     * Returns true if successful.
     * @param node the node
     * @return true if successfully transferred (else the node was
     * cancelled before signal).
     */

#Code:
    final boolean transferForSignal(Node node) {
        /*
         * If cannot change waitStatus, the node has been cancelled.
         */
        if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))
            return false;

        /*
         * Splice onto queue and try to set waitStatus of predecessor to
         * indicate that thread is (probably) waiting. If cancelled or
         * attempt to set waitStatus fails, wake up to resync (in which
         * case the waitStatus can be transiently and harmlessly wrong).
         */
        Node p = enq(node);
        int ws = p.waitStatus;
        if (ws > 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))
            LockSupport.unpark(node.thread);
        return true;
    }

#No. 4249
#File: E:\bishe\1\AbstractQueuedLongSynchronizer.java
#Comment:
    /**
     * Transfers node, if necessary, to sync queue after a cancelled
     * wait. Returns true if thread was cancelled before being
     * signalled.
     * @param current the waiting thread
     * @param node its node
     * @return true if cancelled before the node was signalled
     */

#Code:
    final boolean transferAfterCancelledWait(Node node) {
        if (compareAndSetWaitStatus(node, Node.CONDITION, 0)) {
            enq(node);
            return true;
        }
        /*
         * If we lost out to a signal(), then we can't proceed
         * until it finishes its enq().  Cancelling during an
         * incomplete transfer is both rare and transient, so just
         * spin.
         */
        while (!isOnSyncQueue(node))
            Thread.yield();
        return false;
    }

#No. 4250
#File: E:\bishe\1\AbstractQueuedLongSynchronizer.java
#Comment:
    /**
     * Invokes release with current state value; returns saved state.
     * Cancels node and throws exception on failure.
     * @param node the condition node for this wait
     * @return previous sync state
     */

#Code:
    final long fullyRelease(Node node) {
        boolean failed = true;
        try {
            long savedState = getState();
            if (release(savedState)) {
                failed = false;
                return savedState;
            } else {
                throw new IllegalMonitorStateException();
            }
        } finally {
            if (failed)
                node.waitStatus = Node.CANCELLED;
        }
    }

#No. 4251
#File: E:\bishe\1\AbstractQueuedLongSynchronizer.java
#Comment:
    /**
     * Queries whether the given ConditionObject
     * uses this synchronizer as its lock.
     *
     * @param condition the condition
     * @return <tt>true</tt> if owned
     * @throws NullPointerException if the condition is null
     */

#Code:
    public final boolean owns(ConditionObject condition) {
        if (condition == null)
            throw new NullPointerException();
        return condition.isOwnedBy(this);
    }

#No. 4252
#File: E:\bishe\1\AbstractQueuedLongSynchronizer.java
#Comment:
    /**
     * Queries whether any threads are waiting on the given condition
     * associated with this synchronizer. Note that because timeouts
     * and interrupts may occur at any time, a <tt>true</tt> return
     * does not guarantee that a future <tt>signal</tt> will awaken
     * any threads.  This method is designed primarily for use in
     * monitoring of the system state.
     *
     * @param condition the condition
     * @return <tt>true</tt> if there are any waiting threads
     * @throws IllegalMonitorStateException if exclusive synchronization
     *         is not held
     * @throws IllegalArgumentException if the given condition is
     *         not associated with this synchronizer
     * @throws NullPointerException if the condition is null
     */

#Code:
    public final boolean hasWaiters(ConditionObject condition) {
        if (!owns(condition))
            throw new IllegalArgumentException("Not owner");
        return condition.hasWaiters();
    }

#No. 4253
#File: E:\bishe\1\AbstractQueuedLongSynchronizer.java
#Comment:
    /**
     * Returns an estimate of the number of threads waiting on the
     * given condition associated with this synchronizer. Note that
     * because timeouts and interrupts may occur at any time, the
     * estimate serves only as an upper bound on the actual number of
     * waiters.  This method is designed for use in monitoring of the
     * system state, not for synchronization control.
     *
     * @param condition the condition
     * @return the estimated number of waiting threads
     * @throws IllegalMonitorStateException if exclusive synchronization
     *         is not held
     * @throws IllegalArgumentException if the given condition is
     *         not associated with this synchronizer
     * @throws NullPointerException if the condition is null
     */

#Code:
    public final int getWaitQueueLength(ConditionObject condition) {
        if (!owns(condition))
            throw new IllegalArgumentException("Not owner");
        return condition.getWaitQueueLength();
    }

#No. 4254
#File: E:\bishe\1\AbstractQueuedLongSynchronizer.java
#Comment:
    /**
     * Returns a collection containing those threads that may be
     * waiting on the given condition associated with this
     * synchronizer.  Because the actual set of threads may change
     * dynamically while constructing this result, the returned
     * collection is only a best-effort estimate. The elements of the
     * returned collection are in no particular order.
     *
     * @param condition the condition
     * @return the collection of threads
     * @throws IllegalMonitorStateException if exclusive synchronization
     *         is not held
     * @throws IllegalArgumentException if the given condition is
     *         not associated with this synchronizer
     * @throws NullPointerException if the condition is null
     */

#Code:
    public final Collection<Thread> getWaitingThreads(ConditionObject condition) {
        if (!owns(condition))
            throw new IllegalArgumentException("Not owner");
        return condition.getWaitingThreads();
    }

#No. 4255
#File: E:\bishe\1\AbstractQueuedLongSynchronizer.java
#Comment:
    /**
     * Setup to support compareAndSet. We need to natively implement
     * this here: For the sake of permitting future enhancements, we
     * cannot explicitly subclass AtomicLong, which would be
     * efficient and useful otherwise. So, as the lesser of evils, we
     * natively implement using hotspot intrinsics API. And while we
     * are at it, we do the same for other CASable fields (which could
     * otherwise be done with atomic field updaters).
     */

#Code:
    private static final Unsafe unsafe = Unsafe.getUnsafe();
    private static final long stateOffset;
    private static final long headOffset;
    private static final long tailOffset;
    private static final long waitStatusOffset;
    private static final long nextOffset;

    static {
        try {
            stateOffset = unsafe.objectFieldOffset
                (AbstractQueuedLongSynchronizer.class.getDeclaredField("state"));
            headOffset = unsafe.objectFieldOffset
                (AbstractQueuedLongSynchronizer.class.getDeclaredField("head"));
            tailOffset = unsafe.objectFieldOffset
                (AbstractQueuedLongSynchronizer.class.getDeclaredField("tail"));
            waitStatusOffset = unsafe.objectFieldOffset
                (Node.class.getDeclaredField("waitStatus"));
            nextOffset = unsafe.objectFieldOffset
                (Node.class.getDeclaredField("next"));

        } catch (Exception ex) { throw new Error(ex); }
    }

#No. 4256
#File: E:\bishe\1\AbstractQueuedLongSynchronizer.java
#Comment:
    /**
     * CAS head field. Used only by enq.
     */

#Code:
    private final boolean compareAndSetHead(Node update) {
        return unsafe.compareAndSwapObject(this, headOffset, null, update);
    }

#No. 4257
#File: E:\bishe\1\AbstractQueuedLongSynchronizer.java
#Comment:
    /**
     * CAS tail field. Used only by enq.
     */

#Code:
    private final boolean compareAndSetTail(Node expect, Node update) {
        return unsafe.compareAndSwapObject(this, tailOffset, expect, update);
    }

#No. 4258
#File: E:\bishe\1\AbstractQueuedLongSynchronizer.java
#Comment:
    /**
     * CAS waitStatus field of a node.
     */

#Code:
    private static final boolean compareAndSetWaitStatus(Node node,
                                                         int expect,
                                                         int update) {
        return unsafe.compareAndSwapInt(node, waitStatusOffset,
                                        expect, update);
    }

#No. 4259
#File: E:\bishe\1\AbstractQueuedLongSynchronizer.java
#Comment:
    /**
     * CAS next field of a node.
     */

#Code:
    private static final boolean compareAndSetNext(Node node,
                                                   Node expect,
                                                   Node update) {
        return unsafe.compareAndSwapObject(node, nextOffset, expect, update);
    }

#No. 4260
#File: E:\bishe\1\AbstractQueuedSynchronizer.java
#Comment:
    /**
     * Attempts to set the state to reflect a release in shared mode.
     *
     * <p>This method is always invoked by the thread performing release.
     *
     * <p>The default implementation throws
     * {@link UnsupportedOperationException}.
     *
     * @param arg the release argument. This value is always the one
     *        passed to a release method, or the current state value upon
     *        entry to a condition wait.  The value is otherwise
     *        uninterpreted and can represent anything you like.
     * @return {@code true} if this release of shared mode may permit a
     *         waiting acquire (shared or exclusive) to succeed; and
     *         {@code false} otherwise
     * @throws IllegalMonitorStateException if releasing would place this
     *         synchronizer in an illegal state. This exception must be
     *         thrown in a consistent fashion for synchronization to work
     *         correctly.
     * @throws UnsupportedOperationException if shared mode is not supported
     */

#Code:
    protected boolean tryReleaseShared(int arg) {
        throw new UnsupportedOperationException();
    }

#No. 4261
#File: E:\bishe\1\AbstractQueuedSynchronizer.java
#Comment:
    /**
     * Returns {@code true} if synchronization is held exclusively with
     * respect to the current (calling) thread.  This method is invoked
     * upon each call to a non-waiting {@link ConditionObject} method.
     * (Waiting methods instead invoke {@link #release}.)
     *
     * <p>The default implementation throws {@link
     * UnsupportedOperationException}. This method is invoked
     * internally only within {@link ConditionObject} methods, so need
     * not be defined if conditions are not used.
     *
     * @return {@code true} if synchronization is held exclusively;
     *         {@code false} otherwise
     * @throws UnsupportedOperationException if conditions are not supported
     */

#Code:
    protected boolean isHeldExclusively() {
        throw new UnsupportedOperationException();
    }

#No. 4262
#File: E:\bishe\1\AbstractQueuedSynchronizer.java
#Comment:
    /**
     * Acquires in exclusive mode, ignoring interrupts.  Implemented
     * by invoking at least once {@link #tryAcquire},
     * returning on success.  Otherwise the thread is queued, possibly
     * repeatedly blocking and unblocking, invoking {@link
     * #tryAcquire} until success.  This method can be used
     * to implement method {@link Lock#lock}.
     *
     * @param arg the acquire argument.  This value is conveyed to
     *        {@link #tryAcquire} but is otherwise uninterpreted and
     *        can represent anything you like.
     */

#Code:
    public final void acquire(int arg) {
        if (!tryAcquire(arg) &&
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    }

#No. 4263
#File: E:\bishe\1\AbstractQueuedSynchronizer.java
#Comment:
    /**
     * Acquires in exclusive mode, aborting if interrupted.
     * Implemented by first checking interrupt status, then invoking
     * at least once {@link #tryAcquire}, returning on
     * success.  Otherwise the thread is queued, possibly repeatedly
     * blocking and unblocking, invoking {@link #tryAcquire}
     * until success or the thread is interrupted.  This method can be
     * used to implement method {@link Lock#lockInterruptibly}.
     *
     * @param arg the acquire argument.  This value is conveyed to
     *        {@link #tryAcquire} but is otherwise uninterpreted and
     *        can represent anything you like.
     * @throws InterruptedException if the current thread is interrupted
     */

#Code:
    public final void acquireInterruptibly(int arg)
            throws InterruptedException {
        if (Thread.interrupted())
            throw new InterruptedException();
        if (!tryAcquire(arg))
            doAcquireInterruptibly(arg);
    }

#No. 4264
#File: E:\bishe\1\AbstractQueuedSynchronizer.java
#Comment:
    /**
     * Attempts to acquire in exclusive mode, aborting if interrupted,
     * and failing if the given timeout elapses.  Implemented by first
     * checking interrupt status, then invoking at least once {@link
     * #tryAcquire}, returning on success.  Otherwise, the thread is
     * queued, possibly repeatedly blocking and unblocking, invoking
     * {@link #tryAcquire} until success or the thread is interrupted
     * or the timeout elapses.  This method can be used to implement
     * method {@link Lock#tryLock(long, TimeUnit)}.
     *
     * @param arg the acquire argument.  This value is conveyed to
     *        {@link #tryAcquire} but is otherwise uninterpreted and
     *        can represent anything you like.
     * @param nanosTimeout the maximum number of nanoseconds to wait
     * @return {@code true} if acquired; {@code false} if timed out
     * @throws InterruptedException if the current thread is interrupted
     */

#Code:
    public final boolean tryAcquireNanos(int arg, long nanosTimeout)
            throws InterruptedException {
        if (Thread.interrupted())
            throw new InterruptedException();
        return tryAcquire(arg) ||
            doAcquireNanos(arg, nanosTimeout);
    }

#No. 4265
#File: E:\bishe\1\AbstractQueuedSynchronizer.java
#Comment:
    /**
     * Releases in exclusive mode.  Implemented by unblocking one or
     * more threads if {@link #tryRelease} returns true.
     * This method can be used to implement method {@link Lock#unlock}.
     *
     * @param arg the release argument.  This value is conveyed to
     *        {@link #tryRelease} but is otherwise uninterpreted and
     *        can represent anything you like.
     * @return the value returned from {@link #tryRelease}
     */

#Code:
    public final boolean release(int arg) {
        if (tryRelease(arg)) {
            Node h = head;
            if (h != null && h.waitStatus != 0)
                unparkSuccessor(h);
            return true;
        }
        return false;
    }

#No. 4266
#File: E:\bishe\1\AbstractQueuedSynchronizer.java
#Comment:
    /**
     * Acquires in shared mode, ignoring interrupts.  Implemented by
     * first invoking at least once {@link #tryAcquireShared},
     * returning on success.  Otherwise the thread is queued, possibly
     * repeatedly blocking and unblocking, invoking {@link
     * #tryAcquireShared} until success.
     *
     * @param arg the acquire argument.  This value is conveyed to
     *        {@link #tryAcquireShared} but is otherwise uninterpreted
     *        and can represent anything you like.
     */

#Code:
    public final void acquireShared(int arg) {
        if (tryAcquireShared(arg) < 0)
            doAcquireShared(arg);
    }

#No. 4267
#File: E:\bishe\1\AbstractQueuedSynchronizer.java
#Comment:
    /**
     * Acquires in shared mode, aborting if interrupted.  Implemented
     * by first checking interrupt status, then invoking at least once
     * {@link #tryAcquireShared}, returning on success.  Otherwise the
     * thread is queued, possibly repeatedly blocking and unblocking,
     * invoking {@link #tryAcquireShared} until success or the thread
     * is interrupted.
     * @param arg the acquire argument
     * This value is conveyed to {@link #tryAcquireShared} but is
     * otherwise uninterpreted and can represent anything
     * you like.
     * @throws InterruptedException if the current thread is interrupted
     */

#Code:
    public final void acquireSharedInterruptibly(int arg)
            throws InterruptedException {
        if (Thread.interrupted())
            throw new InterruptedException();
        if (tryAcquireShared(arg) < 0)
            doAcquireSharedInterruptibly(arg);
    }

#No. 4268
#File: E:\bishe\1\AbstractQueuedSynchronizer.java
#Comment:
    /**
     * Attempts to acquire in shared mode, aborting if interrupted, and
     * failing if the given timeout elapses.  Implemented by first
     * checking interrupt status, then invoking at least once {@link
     * #tryAcquireShared}, returning on success.  Otherwise, the
     * thread is queued, possibly repeatedly blocking and unblocking,
     * invoking {@link #tryAcquireShared} until success or the thread
     * is interrupted or the timeout elapses.
     *
     * @param arg the acquire argument.  This value is conveyed to
     *        {@link #tryAcquireShared} but is otherwise uninterpreted
     *        and can represent anything you like.
     * @param nanosTimeout the maximum number of nanoseconds to wait
     * @return {@code true} if acquired; {@code false} if timed out
     * @throws InterruptedException if the current thread is interrupted
     */

#Code:
    public final boolean tryAcquireSharedNanos(int arg, long nanosTimeout)
            throws InterruptedException {
        if (Thread.interrupted())
            throw new InterruptedException();
        return tryAcquireShared(arg) >= 0 ||
            doAcquireSharedNanos(arg, nanosTimeout);
    }

#No. 4269
#File: E:\bishe\1\AbstractQueuedSynchronizer.java
#Comment:
    /**
     * Releases in shared mode.  Implemented by unblocking one or more
     * threads if {@link #tryReleaseShared} returns true.
     *
     * @param arg the release argument.  This value is conveyed to
     *        {@link #tryReleaseShared} but is otherwise uninterpreted
     *        and can represent anything you like.
     * @return the value returned from {@link #tryReleaseShared}
     */

#Code:
    public final boolean releaseShared(int arg) {
        if (tryReleaseShared(arg)) {
            doReleaseShared();
            return true;
        }
        return false;
    }

#No. 4270
#File: E:\bishe\1\AbstractQueuedSynchronizer.java
#Comment:
    /**
     * Queries whether any threads are waiting to acquire. Note that
     * because cancellations due to interrupts and timeouts may occur
     * at any time, a {@code true} return does not guarantee that any
     * other thread will ever acquire.
     *
     * <p>In this implementation, this operation returns in
     * constant time.
     *
     * @return {@code true} if there may be other threads waiting to acquire
     */

#Code:
    public final boolean hasQueuedThreads() {
        return head != tail;
    }

#No. 4271
#File: E:\bishe\1\AbstractQueuedSynchronizer.java
#Comment:
    /**
     * Queries whether any threads have ever contended to acquire this
     * synchronizer; that is if an acquire method has ever blocked.
     *
     * <p>In this implementation, this operation returns in
     * constant time.
     *
     * @return {@code true} if there has ever been contention
     */

#Code:
    public final boolean hasContended() {
        return head != null;
    }

#No. 4272
#File: E:\bishe\1\AbstractQueuedSynchronizer.java
#Comment:
    /**
     * Returns the first (longest-waiting) thread in the queue, or
     * {@code null} if no threads are currently queued.
     *
     * <p>In this implementation, this operation normally returns in
     * constant time, but may iterate upon contention if other threads are
     * concurrently modifying the queue.
     *
     * @return the first (longest-waiting) thread in the queue, or
     *         {@code null} if no threads are currently queued
     */

#Code:
    public final Thread getFirstQueuedThread() {
        // handle only fast path, else relay
        return (head == tail) ? null : fullGetFirstQueuedThread();
    }

#No. 4273
#File: E:\bishe\1\AbstractQueuedSynchronizer.java
#Comment:
    /**
     * Version of getFirstQueuedThread called when fastpath fails
     */

#Code:
    private Thread fullGetFirstQueuedThread() {
        /*
         * The first node is normally head.next. Try to get its
         * thread field, ensuring consistent reads: If thread
         * field is nulled out or s.prev is no longer head, then
         * some other thread(s) concurrently performed setHead in
         * between some of our reads. We try this twice before
         * resorting to traversal.
         */
        Node h, s;
        Thread st;
        if (((h = head) != null && (s = h.next) != null &&
             s.prev == head && (st = s.thread) != null) ||
            ((h = head) != null && (s = h.next) != null &&
             s.prev == head && (st = s.thread) != null))
            return st;

        /*
         * Head's next field might not have been set yet, or may have
         * been unset after setHead. So we must check to see if tail
         * is actually first node. If not, we continue on, safely
         * traversing from tail back to head to find first,
         * guaranteeing termination.
         */

        Node t = tail;
        Thread firstThread = null;
        while (t != null && t != head) {
            Thread tt = t.thread;
            if (tt != null)
                firstThread = tt;
            t = t.prev;
        }
        return firstThread;
    }

#No. 4274
#File: E:\bishe\1\AbstractQueuedSynchronizer.java
#Comment:
    /**
     * Returns true if the given thread is currently queued.
     *
     * <p>This implementation traverses the queue to determine
     * presence of the given thread.
     *
     * @param thread the thread
     * @return {@code true} if the given thread is on the queue
     * @throws NullPointerException if the thread is null
     */

#Code:
    public final boolean isQueued(Thread thread) {
        if (thread == null)
            throw new NullPointerException();
        for (Node p = tail; p != null; p = p.prev)
            if (p.thread == thread)
                return true;
        return false;
    }

#No. 4275
#File: E:\bishe\1\AbstractQueuedSynchronizer.java
#Comment:
    /**
     * Returns {@code true} if the apparent first queued thread, if one
     * exists, is waiting in exclusive mode.  If this method returns
     * {@code true}, and the current thread is attempting to acquire in
     * shared mode (that is, this method is invoked from {@link
     * #tryAcquireShared}) then it is guaranteed that the current thread
     * is not the first queued thread.  Used only as a heuristic in
     * ReentrantReadWriteLock.
     */

#Code:
    final boolean apparentlyFirstQueuedIsExclusive() {
        Node h, s;
        return (h = head) != null &&
            (s = h.next)  != null &&
            !s.isShared()         &&
            s.thread != null;
    }

#No. 4276
#File: E:\bishe\1\AbstractQueuedSynchronizer.java
#Comment:
    /**
     * Queries whether any threads have been waiting to acquire longer
     * than the current thread.
     *
     * <p>An invocation of this method is equivalent to (but may be
     * more efficient than):
     *  <pre> {@code
     * getFirstQueuedThread() != Thread.currentThread() &&
     * hasQueuedThreads()}</pre>
     *
     * <p>Note that because cancellations due to interrupts and
     * timeouts may occur at any time, a {@code true} return does not
     * guarantee that some other thread will acquire before the current
     * thread.  Likewise, it is possible for another thread to win a
     * race to enqueue after this method has returned {@code false},
     * due to the queue being empty.
     *
     * <p>This method is designed to be used by a fair synchronizer to
     * avoid <a href="AbstractQueuedSynchronizer#barging">barging</a>.
     * Such a synchronizer's {@link #tryAcquire} method should return
     * {@code false}, and its {@link #tryAcquireShared} method should
     * return a negative value, if this method returns {@code true}
     * (unless this is a reentrant acquire).  For example, the {@code
     * tryAcquire} method for a fair, reentrant, exclusive mode
     * synchronizer might look like this:
     *
     *  <pre> {@code
     * protected boolean tryAcquire(int arg) {
     *   if (isHeldExclusively()) {
     *     // A reentrant acquire; increment hold count
     *     return true;
     *   } else if (hasQueuedPredecessors()) {
     *     return false;
     *   } else {
     *     // try to acquire normally
     *   }
     * }}</pre>
     *
     * @return {@code true} if there is a queued thread preceding the
     *         current thread, and {@code false} if the current thread
     *         is at the head of the queue or the queue is empty
     * @since 1.7
     */

#Code:
    public final boolean hasQueuedPredecessors() {
        // The correctness of this depends on head being initialized
        // before tail and on head.next being accurate if the current
        // thread is first in queue.
        Node t = tail; // Read fields in reverse initialization order
        Node h = head;
        Node s;
        return h != t &&
            ((s = h.next) == null || s.thread != Thread.currentThread());
    }

#No. 4277
#File: E:\bishe\1\AbstractQueuedSynchronizer.java
#Comment:
    /**
     * Returns an estimate of the number of threads waiting to
     * acquire.  The value is only an estimate because the number of
     * threads may change dynamically while this method traverses
     * internal data structures.  This method is designed for use in
     * monitoring system state, not for synchronization
     * control.
     *
     * @return the estimated number of threads waiting to acquire
     */

#Code:
    public final int getQueueLength() {
        int n = 0;
        for (Node p = tail; p != null; p = p.prev) {
            if (p.thread != null)
                ++n;
        }
        return n;
    }

#No. 4278
#File: E:\bishe\1\AbstractQueuedSynchronizer.java
#Comment:
    /**
     * Returns a collection containing threads that may be waiting to
     * acquire.  Because the actual set of threads may change
     * dynamically while constructing this result, the returned
     * collection is only a best-effort estimate.  The elements of the
     * returned collection are in no particular order.  This method is
     * designed to facilitate construction of subclasses that provide
     * more extensive monitoring facilities.
     *
     * @return the collection of threads
     */

#Code:
    public final Collection<Thread> getQueuedThreads() {
        ArrayList<Thread> list = new ArrayList<Thread>();
        for (Node p = tail; p != null; p = p.prev) {
            Thread t = p.thread;
            if (t != null)
                list.add(t);
        }
        return list;
    }

#No. 4279
#File: E:\bishe\1\AbstractQueuedSynchronizer.java
#Comment:
    /**
     * Returns a collection containing threads that may be waiting to
     * acquire in exclusive mode. This has the same properties
     * as {@link #getQueuedThreads} except that it only returns
     * those threads waiting due to an exclusive acquire.
     *
     * @return the collection of threads
     */

#Code:
    public final Collection<Thread> getExclusiveQueuedThreads() {
        ArrayList<Thread> list = new ArrayList<Thread>();
        for (Node p = tail; p != null; p = p.prev) {
            if (!p.isShared()) {
                Thread t = p.thread;
                if (t != null)
                    list.add(t);
            }
        }
        return list;
    }

#No. 4280
#File: E:\bishe\1\AbstractQueuedSynchronizer.java
#Comment:
    /**
     * Returns a collection containing threads that may be waiting to
     * acquire in shared mode. This has the same properties
     * as {@link #getQueuedThreads} except that it only returns
     * those threads waiting due to a shared acquire.
     *
     * @return the collection of threads
     */

#Code:
    public final Collection<Thread> getSharedQueuedThreads() {
        ArrayList<Thread> list = new ArrayList<Thread>();
        for (Node p = tail; p != null; p = p.prev) {
            if (p.isShared()) {
                Thread t = p.thread;
                if (t != null)
                    list.add(t);
            }
        }
        return list;
    }

#No. 4281
#File: E:\bishe\1\AbstractQueuedSynchronizer.java
#Comment:
    /**
     * Returns a string identifying this synchronizer, as well as its state.
     * The state, in brackets, includes the String {@code "State ="}
     * followed by the current value of {@link #getState}, and either
     * {@code "nonempty"} or {@code "empty"} depending on whether the
     * queue is empty.
     *
     * @return a string identifying this synchronizer, as well as its state
     */

#Code:
    public String toString() {
        int s = getState();
        String q  = hasQueuedThreads() ? "non" : "";
        return super.toString() +
            "[State = " + s + ", " + q + "empty queue]";
    }

#No. 4282
#File: E:\bishe\1\AbstractQueuedSynchronizer.java
#Comment:
    /**
     * Returns true if a node, always one that was initially placed on
     * a condition queue, is now waiting to reacquire on sync queue.
     * @param node the node
     * @return true if is reacquiring
     */

#Code:
    final boolean isOnSyncQueue(Node node) {
        if (node.waitStatus == Node.CONDITION || node.prev == null)
            return false;
        if (node.next != null) // If has successor, it must be on queue
            return true;
        /*
         * node.prev can be non-null, but not yet on queue because
         * the CAS to place it on queue can fail. So we have to
         * traverse from tail to make sure it actually made it.  It
         * will always be near the tail in calls to this method, and
         * unless the CAS failed (which is unlikely), it will be
         * there, so we hardly ever traverse much.
         */
        return findNodeFromTail(node);
    }

#No. 4283
#File: E:\bishe\1\AbstractQueuedSynchronizer.java
#Comment:
    /**
     * Returns true if node is on sync queue by searching backwards from tail.
     * Called only when needed by isOnSyncQueue.
     * @return true if present
     */

#Code:
    private boolean findNodeFromTail(Node node) {
        Node t = tail;
        for (;;) {
            if (t == node)
                return true;
            if (t == null)
                return false;
            t = t.prev;
        }
    }

#No. 4284
#File: E:\bishe\1\AbstractQueuedSynchronizer.java
#Comment:
    /**
     * Transfers a node from a condition queue onto sync queue.
     * Returns true if successful.
     * @param node the node
     * @return true if successfully transferred (else the node was
     * cancelled before signal).
     */

#Code:
    final boolean transferForSignal(Node node) {
        /*
         * If cannot change waitStatus, the node has been cancelled.
         */
        if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))
            return false;

        /*
         * Splice onto queue and try to set waitStatus of predecessor to
         * indicate that thread is (probably) waiting. If cancelled or
         * attempt to set waitStatus fails, wake up to resync (in which
         * case the waitStatus can be transiently and harmlessly wrong).
         */
        Node p = enq(node);
        int ws = p.waitStatus;
        if (ws > 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))
            LockSupport.unpark(node.thread);
        return true;
    }

#No. 4285
#File: E:\bishe\1\AbstractQueuedSynchronizer.java
#Comment:
    /**
     * Transfers node, if necessary, to sync queue after a cancelled
     * wait. Returns true if thread was cancelled before being
     * signalled.
     * @param current the waiting thread
     * @param node its node
     * @return true if cancelled before the node was signalled
     */

#Code:
    final boolean transferAfterCancelledWait(Node node) {
        if (compareAndSetWaitStatus(node, Node.CONDITION, 0)) {
            enq(node);
            return true;
        }
        /*
         * If we lost out to a signal(), then we can't proceed
         * until it finishes its enq().  Cancelling during an
         * incomplete transfer is both rare and transient, so just
         * spin.
         */
        while (!isOnSyncQueue(node))
            Thread.yield();
        return false;
    }

#No. 4286
#File: E:\bishe\1\AbstractQueuedSynchronizer.java
#Comment:
    /**
     * Invokes release with current state value; returns saved state.
     * Cancels node and throws exception on failure.
     * @param node the condition node for this wait
     * @return previous sync state
     */

#Code:
    final int fullyRelease(Node node) {
        boolean failed = true;
        try {
            int savedState = getState();
            if (release(savedState)) {
                failed = false;
                return savedState;
            } else {
                throw new IllegalMonitorStateException();
            }
        } finally {
            if (failed)
                node.waitStatus = Node.CANCELLED;
        }
    }

#No. 4287
#File: E:\bishe\1\AbstractQueuedSynchronizer.java
#Comment:
    /**
     * Queries whether the given ConditionObject
     * uses this synchronizer as its lock.
     *
     * @param condition the condition
     * @return <tt>true</tt> if owned
     * @throws NullPointerException if the condition is null
     */

#Code:
    public final boolean owns(ConditionObject condition) {
        if (condition == null)
            throw new NullPointerException();
        return condition.isOwnedBy(this);
    }

#No. 4288
#File: E:\bishe\1\AbstractQueuedSynchronizer.java
#Comment:
    /**
     * Queries whether any threads are waiting on the given condition
     * associated with this synchronizer. Note that because timeouts
     * and interrupts may occur at any time, a <tt>true</tt> return
     * does not guarantee that a future <tt>signal</tt> will awaken
     * any threads.  This method is designed primarily for use in
     * monitoring of the system state.
     *
     * @param condition the condition
     * @return <tt>true</tt> if there are any waiting threads
     * @throws IllegalMonitorStateException if exclusive synchronization
     *         is not held
     * @throws IllegalArgumentException if the given condition is
     *         not associated with this synchronizer
     * @throws NullPointerException if the condition is null
     */

#Code:
    public final boolean hasWaiters(ConditionObject condition) {
        if (!owns(condition))
            throw new IllegalArgumentException("Not owner");
        return condition.hasWaiters();
    }

#No. 4289
#File: E:\bishe\1\AbstractQueuedSynchronizer.java
#Comment:
    /**
     * Returns an estimate of the number of threads waiting on the
     * given condition associated with this synchronizer. Note that
     * because timeouts and interrupts may occur at any time, the
     * estimate serves only as an upper bound on the actual number of
     * waiters.  This method is designed for use in monitoring of the
     * system state, not for synchronization control.
     *
     * @param condition the condition
     * @return the estimated number of waiting threads
     * @throws IllegalMonitorStateException if exclusive synchronization
     *         is not held
     * @throws IllegalArgumentException if the given condition is
     *         not associated with this synchronizer
     * @throws NullPointerException if the condition is null
     */

#Code:
    public final int getWaitQueueLength(ConditionObject condition) {
        if (!owns(condition))
            throw new IllegalArgumentException("Not owner");
        return condition.getWaitQueueLength();
    }

#No. 4290
#File: E:\bishe\1\AbstractQueuedSynchronizer.java
#Comment:
    /**
     * Returns a collection containing those threads that may be
     * waiting on the given condition associated with this
     * synchronizer.  Because the actual set of threads may change
     * dynamically while constructing this result, the returned
     * collection is only a best-effort estimate. The elements of the
     * returned collection are in no particular order.
     *
     * @param condition the condition
     * @return the collection of threads
     * @throws IllegalMonitorStateException if exclusive synchronization
     *         is not held
     * @throws IllegalArgumentException if the given condition is
     *         not associated with this synchronizer
     * @throws NullPointerException if the condition is null
     */

#Code:
    public final Collection<Thread> getWaitingThreads(ConditionObject condition) {
        if (!owns(condition))
            throw new IllegalArgumentException("Not owner");
        return condition.getWaitingThreads();
    }

#No. 4291
#File: E:\bishe\1\AbstractQueuedSynchronizer.java
#Comment:
    /**
     * Setup to support compareAndSet. We need to natively implement
     * this here: For the sake of permitting future enhancements, we
     * cannot explicitly subclass AtomicInteger, which would be
     * efficient and useful otherwise. So, as the lesser of evils, we
     * natively implement using hotspot intrinsics API. And while we
     * are at it, we do the same for other CASable fields (which could
     * otherwise be done with atomic field updaters).
     */

#Code:
    private static final Unsafe unsafe = Unsafe.getUnsafe();
    private static final long stateOffset;
    private static final long headOffset;
    private static final long tailOffset;
    private static final long waitStatusOffset;
    private static final long nextOffset;

    static {
        try {
            stateOffset = unsafe.objectFieldOffset
                (AbstractQueuedSynchronizer.class.getDeclaredField("state"));
            headOffset = unsafe.objectFieldOffset
                (AbstractQueuedSynchronizer.class.getDeclaredField("head"));
            tailOffset = unsafe.objectFieldOffset
                (AbstractQueuedSynchronizer.class.getDeclaredField("tail"));
            waitStatusOffset = unsafe.objectFieldOffset
                (Node.class.getDeclaredField("waitStatus"));
            nextOffset = unsafe.objectFieldOffset
                (Node.class.getDeclaredField("next"));

        } catch (Exception ex) { throw new Error(ex); }
    }

#No. 4292
#File: E:\bishe\1\AbstractQueuedSynchronizer.java
#Comment:
    /**
     * CAS head field. Used only by enq.
     */

#Code:
    private final boolean compareAndSetHead(Node update) {
        return unsafe.compareAndSwapObject(this, headOffset, null, update);
    }

#No. 4293
#File: E:\bishe\1\AbstractQueuedSynchronizer.java
#Comment:
    /**
     * CAS tail field. Used only by enq.
     */

#Code:
    private final boolean compareAndSetTail(Node expect, Node update) {
        return unsafe.compareAndSwapObject(this, tailOffset, expect, update);
    }

#No. 4294
#File: E:\bishe\1\AbstractQueuedSynchronizer.java
#Comment:
    /**
     * CAS waitStatus field of a node.
     */

#Code:
    private static final boolean compareAndSetWaitStatus(Node node,
                                                         int expect,
                                                         int update) {
        return unsafe.compareAndSwapInt(node, waitStatusOffset,
                                        expect, update);
    }

#No. 4295
#File: E:\bishe\1\AbstractQueuedSynchronizer.java
#Comment:
    /**
     * CAS next field of a node.
     */

#Code:
    private static final boolean compareAndSetNext(Node node,
                                                   Node expect,
                                                   Node update) {
        return unsafe.compareAndSwapObject(node, nextOffset, expect, update);
    }

#No. 4296
#File: E:\bishe\1\AbstractQueuedSynchronizerTest.java
#Comment:
    /**
     * Spin-waits until sync.isQueued(t) becomes true.
     */

#Code:
    void waitForQueuedThread(AbstractQueuedSynchronizer sync, Thread t) {
        long startTime = System.nanoTime();
        while (!sync.isQueued(t)) {
            if (millisElapsedSince(startTime) > LONG_DELAY_MS)
                throw new AssertionFailedError("timed out");
            Thread.yield();
        }
        assertTrue(t.isAlive());
    }

#No. 4297
#File: E:\bishe\1\AbstractQueuedSynchronizerTest.java
#Comment:
    /**
     * Checks that sync has exactly the given queued threads.
     */

#Code:
    void assertHasQueuedThreads(AbstractQueuedSynchronizer sync,
                                Thread... expected) {
        Collection<Thread> actual = sync.getQueuedThreads();
        assertEquals(expected.length > 0, sync.hasQueuedThreads());
        assertEquals(expected.length, sync.getQueueLength());
        assertEquals(expected.length, actual.size());
        assertEquals(expected.length == 0, actual.isEmpty());
        assertEquals(new HashSet<Thread>(actual),
                     new HashSet<Thread>(Arrays.asList(expected)));
    }

#No. 4298
#File: E:\bishe\1\AbstractQueuedSynchronizerTest.java
#Comment:
    /**
     * Checks that sync has exactly the given (exclusive) queued threads.
     */

#Code:
    void assertHasExclusiveQueuedThreads(AbstractQueuedSynchronizer sync,
                                         Thread... expected) {
        assertHasQueuedThreads(sync, expected);
        assertEquals(new HashSet<Thread>(sync.getExclusiveQueuedThreads()),
                     new HashSet<Thread>(sync.getQueuedThreads()));
        assertEquals(0, sync.getSharedQueuedThreads().size());
        assertTrue(sync.getSharedQueuedThreads().isEmpty());
    }

#No. 4299
#File: E:\bishe\1\AbstractQueuedSynchronizerTest.java
#Comment:
    /**
     * Checks that sync has exactly the given (shared) queued threads.
     */

#Code:
    void assertHasSharedQueuedThreads(AbstractQueuedSynchronizer sync,
                                      Thread... expected) {
        assertHasQueuedThreads(sync, expected);
        assertEquals(new HashSet<Thread>(sync.getSharedQueuedThreads()),
                     new HashSet<Thread>(sync.getQueuedThreads()));
        assertEquals(0, sync.getExclusiveQueuedThreads().size());
        assertTrue(sync.getExclusiveQueuedThreads().isEmpty());
    }

#No. 4300
#File: E:\bishe\1\AbstractQueuedSynchronizerTest.java
#Comment:
    /**
     * Checks that condition c has exactly the given waiter threads,
     * after acquiring mutex.
     */

#Code:
    void assertHasWaitersUnlocked(Mutex sync, ConditionObject c,
                                 Thread... threads) {
        sync.acquire();
        assertHasWaitersLocked(sync, c, threads);
        sync.release();
    }

#No. 4301
#File: E:\bishe\1\AbstractQueuedSynchronizerTest.java
#Comment:
    /**
     * Checks that condition c has exactly the given waiter threads.
     */

#Code:
    void assertHasWaitersLocked(Mutex sync, ConditionObject c,
                                Thread... threads) {
        assertEquals(threads.length > 0, sync.hasWaiters(c));
        assertEquals(threads.length, sync.getWaitQueueLength(c));
        assertEquals(threads.length == 0, sync.getWaitingThreads(c).isEmpty());
        assertEquals(threads.length, sync.getWaitingThreads(c).size());
        assertEquals(new HashSet<Thread>(sync.getWaitingThreads(c)),
                     new HashSet<Thread>(Arrays.asList(threads)));
    }

#No. 4302
#File: E:\bishe\1\AbstractQueuedSynchronizerTest.java
#Comment:
    /**
     * Awaits condition using the specified AwaitMethod.
     */

#Code:
    void await(ConditionObject c, AwaitMethod awaitMethod)
            throws InterruptedException {
        long timeoutMillis = 2 * LONG_DELAY_MS;
        switch (awaitMethod) {
        case await:
            c.await();
            break;
        case awaitTimed:
            assertTrue(c.await(timeoutMillis, MILLISECONDS));
            break;
        case awaitNanos:
            long nanosTimeout = MILLISECONDS.toNanos(timeoutMillis);
            long nanosRemaining = c.awaitNanos(nanosTimeout);
            assertTrue(nanosRemaining > 0);
            break;
        case awaitUntil:
            assertTrue(c.awaitUntil(delayedDate(timeoutMillis)));
            break;
        default:
            throw new AssertionError();
        }
    }

#No. 4303
#File: E:\bishe\1\AbstractQueuedSynchronizerTest.java
#Comment:
    /**
     * Checks that awaiting the given condition times out (using the
     * default timeout duration).
     */

#Code:
    void assertAwaitTimesOut(ConditionObject c, AwaitMethod awaitMethod) {
        long timeoutMillis = timeoutMillis();
        long startTime;
        try {
            switch (awaitMethod) {
            case awaitTimed:
                startTime = System.nanoTime();
                assertFalse(c.await(timeoutMillis, MILLISECONDS));
                assertTrue(millisElapsedSince(startTime) >= timeoutMillis);
                break;
            case awaitNanos:
                startTime = System.nanoTime();
                long nanosTimeout = MILLISECONDS.toNanos(timeoutMillis);
                long nanosRemaining = c.awaitNanos(nanosTimeout);
                assertTrue(nanosRemaining <= 0);
                assertTrue(nanosRemaining > -MILLISECONDS.toNanos(LONG_DELAY_MS));
                assertTrue(millisElapsedSince(startTime) >= timeoutMillis);
                break;
            case awaitUntil:
                // We shouldn't assume that nanoTime and currentTimeMillis
                // use the same time source, so don't use nanoTime here.
                java.util.Date delayedDate = delayedDate(timeoutMillis());
                assertFalse(c.awaitUntil(delayedDate(timeoutMillis)));
                assertTrue(new java.util.Date().getTime() >= delayedDate.getTime());
                break;
            default:
                throw new UnsupportedOperationException();
            }
        } catch (InterruptedException ie) { threadUnexpectedException(ie); }
    }

#No. 4304
#File: E:\bishe\1\AbstractQueuedSynchronizerTest.java
#Comment:
    /**
     * isHeldExclusively is false upon construction
     */

#Code:
    public void testIsHeldExclusively() {
        Mutex sync = new Mutex();
        assertFalse(sync.isHeldExclusively());
    }

#No. 4305
#File: E:\bishe\1\AbstractQueuedSynchronizerTest.java
#Comment:
    /**
     * acquiring released sync succeeds
     */

#Code:
    public void testAcquire() {
        Mutex sync = new Mutex();
        sync.acquire();
        assertTrue(sync.isHeldExclusively());
        sync.release();
        assertFalse(sync.isHeldExclusively());
    }

#No. 4306
#File: E:\bishe\1\AbstractQueuedSynchronizerTest.java
#Comment:
    /**
     * tryAcquire on a released sync succeeds
     */

#Code:
    public void testTryAcquire() {
        Mutex sync = new Mutex();
        assertTrue(sync.tryAcquire());
        assertTrue(sync.isHeldExclusively());
        sync.release();
        assertFalse(sync.isHeldExclusively());
    }

#No. 4307
#File: E:\bishe\1\AbstractQueuedSynchronizerTest.java
#Comment:
    /**
     * hasQueuedThreads reports whether there are waiting threads
     */

#Code:
    public void testHasQueuedThreads() {
        final Mutex sync = new Mutex();
        assertFalse(sync.hasQueuedThreads());
        sync.acquire();
        Thread t1 = newStartedThread(new InterruptedSyncRunnable(sync));
        waitForQueuedThread(sync, t1);
        assertTrue(sync.hasQueuedThreads());
        Thread t2 = newStartedThread(new InterruptibleSyncRunnable(sync));
        waitForQueuedThread(sync, t2);
        assertTrue(sync.hasQueuedThreads());
        t1.interrupt();
        awaitTermination(t1);
        assertTrue(sync.hasQueuedThreads());
        sync.release();
        awaitTermination(t2);
        assertFalse(sync.hasQueuedThreads());
    }

#No. 4308
#File: E:\bishe\1\AbstractQueuedSynchronizerTest.java
#Comment:
    /**
     * isQueued(null) throws NullPointerException
     */

#Code:
    public void testIsQueuedNPE() {
        final Mutex sync = new Mutex();
        try {
            sync.isQueued(null);
            shouldThrow();
        } catch (NullPointerException success) {}
    }

#No. 4309
#File: E:\bishe\1\AbstractQueuedSynchronizerTest.java
#Comment:
    /**
     * isQueued reports whether a thread is queued
     */

#Code:
    public void testIsQueued() {
        final Mutex sync = new Mutex();
        Thread t1 = new Thread(new InterruptedSyncRunnable(sync));
        Thread t2 = new Thread(new InterruptibleSyncRunnable(sync));
        assertFalse(sync.isQueued(t1));
        assertFalse(sync.isQueued(t2));
        sync.acquire();
        t1.start();
        waitForQueuedThread(sync, t1);
        assertTrue(sync.isQueued(t1));
        assertFalse(sync.isQueued(t2));
        t2.start();
        waitForQueuedThread(sync, t2);
        assertTrue(sync.isQueued(t1));
        assertTrue(sync.isQueued(t2));
        t1.interrupt();
        awaitTermination(t1);
        assertFalse(sync.isQueued(t1));
        assertTrue(sync.isQueued(t2));
        sync.release();
        awaitTermination(t2);
        assertFalse(sync.isQueued(t1));
        assertFalse(sync.isQueued(t2));
    }

#No. 4310
#File: E:\bishe\1\AbstractQueuedSynchronizerTest.java
#Comment:
    /**
     * getFirstQueuedThread returns first waiting thread or null if none
     */

#Code:
    public void testGetFirstQueuedThread() {
        final Mutex sync = new Mutex();
        assertNull(sync.getFirstQueuedThread());
        sync.acquire();
        Thread t1 = newStartedThread(new InterruptedSyncRunnable(sync));
        waitForQueuedThread(sync, t1);
        assertEquals(t1, sync.getFirstQueuedThread());
        Thread t2 = newStartedThread(new InterruptibleSyncRunnable(sync));
        waitForQueuedThread(sync, t2);
        assertEquals(t1, sync.getFirstQueuedThread());
        t1.interrupt();
        awaitTermination(t1);
        assertEquals(t2, sync.getFirstQueuedThread());
        sync.release();
        awaitTermination(t2);
        assertNull(sync.getFirstQueuedThread());
    }

#No. 4311
#File: E:\bishe\1\AbstractQueuedSynchronizerTest.java
#Comment:
    /**
     * hasContended reports false if no thread has ever blocked, else true
     */

#Code:
    public void testHasContended() {
        final Mutex sync = new Mutex();
        assertFalse(sync.hasContended());
        sync.acquire();
        assertFalse(sync.hasContended());
        Thread t1 = newStartedThread(new InterruptedSyncRunnable(sync));
        waitForQueuedThread(sync, t1);
        assertTrue(sync.hasContended());
        Thread t2 = newStartedThread(new InterruptibleSyncRunnable(sync));
        waitForQueuedThread(sync, t2);
        assertTrue(sync.hasContended());
        t1.interrupt();
        awaitTermination(t1);
        assertTrue(sync.hasContended());
        sync.release();
        awaitTermination(t2);
        assertTrue(sync.hasContended());
    }

#No. 4312
#File: E:\bishe\1\AbstractQueuedSynchronizerTest.java
#Comment:
    /**
     * getQueuedThreads returns all waiting threads
     */

#Code:
    public void testGetQueuedThreads() {
        final Mutex sync = new Mutex();
        Thread t1 = new Thread(new InterruptedSyncRunnable(sync));
        Thread t2 = new Thread(new InterruptibleSyncRunnable(sync));
        assertHasExclusiveQueuedThreads(sync, NO_THREADS);
        sync.acquire();
        assertHasExclusiveQueuedThreads(sync, NO_THREADS);
        t1.start();
        waitForQueuedThread(sync, t1);
        assertHasExclusiveQueuedThreads(sync, t1);
        assertTrue(sync.getQueuedThreads().contains(t1));
        assertFalse(sync.getQueuedThreads().contains(t2));
        t2.start();
        waitForQueuedThread(sync, t2);
        assertHasExclusiveQueuedThreads(sync, t1, t2);
        assertTrue(sync.getQueuedThreads().contains(t1));
        assertTrue(sync.getQueuedThreads().contains(t2));
        t1.interrupt();
        awaitTermination(t1);
        assertHasExclusiveQueuedThreads(sync, t2);
        sync.release();
        awaitTermination(t2);
        assertHasExclusiveQueuedThreads(sync, NO_THREADS);
    }

#No. 4313
#File: E:\bishe\1\AbstractQueuedSynchronizerTest.java
#Comment:
    /**
     * getExclusiveQueuedThreads returns all exclusive waiting threads
     */

#Code:
    public void testGetExclusiveQueuedThreads() {
        final Mutex sync = new Mutex();
        Thread t1 = new Thread(new InterruptedSyncRunnable(sync));
        Thread t2 = new Thread(new InterruptibleSyncRunnable(sync));
        assertHasExclusiveQueuedThreads(sync, NO_THREADS);
        sync.acquire();
        assertHasExclusiveQueuedThreads(sync, NO_THREADS);
        t1.start();
        waitForQueuedThread(sync, t1);
        assertHasExclusiveQueuedThreads(sync, t1);
        assertTrue(sync.getExclusiveQueuedThreads().contains(t1));
        assertFalse(sync.getExclusiveQueuedThreads().contains(t2));
        t2.start();
        waitForQueuedThread(sync, t2);
        assertHasExclusiveQueuedThreads(sync, t1, t2);
        assertTrue(sync.getExclusiveQueuedThreads().contains(t1));
        assertTrue(sync.getExclusiveQueuedThreads().contains(t2));
        t1.interrupt();
        awaitTermination(t1);
        assertHasExclusiveQueuedThreads(sync, t2);
        sync.release();
        awaitTermination(t2);
        assertHasExclusiveQueuedThreads(sync, NO_THREADS);
    }

#No. 4314
#File: E:\bishe\1\AbstractQueuedSynchronizerTest.java
#Comment:
    /**
     * getSharedQueuedThreads does not include exclusively waiting threads
     */

#Code:
    public void testGetSharedQueuedThreads_Exclusive() {
        final Mutex sync = new Mutex();
        assertTrue(sync.getSharedQueuedThreads().isEmpty());
        sync.acquire();
        assertTrue(sync.getSharedQueuedThreads().isEmpty());
        Thread t1 = newStartedThread(new InterruptedSyncRunnable(sync));
        waitForQueuedThread(sync, t1);
        assertTrue(sync.getSharedQueuedThreads().isEmpty());
        Thread t2 = newStartedThread(new InterruptibleSyncRunnable(sync));
        waitForQueuedThread(sync, t2);
        assertTrue(sync.getSharedQueuedThreads().isEmpty());
        t1.interrupt();
        awaitTermination(t1);
        assertTrue(sync.getSharedQueuedThreads().isEmpty());
        sync.release();
        awaitTermination(t2);
        assertTrue(sync.getSharedQueuedThreads().isEmpty());
    }

#No. 4315
#File: E:\bishe\1\AbstractQueuedSynchronizerTest.java
#Comment:
    /**
     * getSharedQueuedThreads returns all shared waiting threads
     */

#Code:
    public void testGetSharedQueuedThreads_Shared() {
        final BooleanLatch l = new BooleanLatch();
        assertHasSharedQueuedThreads(l, NO_THREADS);
        Thread t1 = newStartedThread(new CheckedInterruptedRunnable() {
            public void realRun() throws InterruptedException {
                l.acquireSharedInterruptibly(0);
            }});
        waitForQueuedThread(l, t1);
        assertHasSharedQueuedThreads(l, t1);
        Thread t2 = newStartedThread(new CheckedRunnable() {
            public void realRun() throws InterruptedException {
                l.acquireSharedInterruptibly(0);
            }});
        waitForQueuedThread(l, t2);
        assertHasSharedQueuedThreads(l, t1, t2);
        t1.interrupt();
        awaitTermination(t1);
        assertHasSharedQueuedThreads(l, t2);
        assertTrue(l.releaseShared(0));
        awaitTermination(t2);
        assertHasSharedQueuedThreads(l, NO_THREADS);
    }

#No. 4316
#File: E:\bishe\1\AbstractQueuedSynchronizerTest.java
#Comment:
    /**
     * tryAcquireNanos is interruptible
     */

#Code:
    public void testTryAcquireNanos_Interruptible() {
        final Mutex sync = new Mutex();
        sync.acquire();
        Thread t = newStartedThread(new CheckedInterruptedRunnable() {
            public void realRun() throws InterruptedException {
                sync.tryAcquireNanos(MILLISECONDS.toNanos(2 * LONG_DELAY_MS));
            }});

        waitForQueuedThread(sync, t);
        t.interrupt();
        awaitTermination(t);
    }

#No. 4317
#File: E:\bishe\1\AbstractQueuedSynchronizerTest.java
#Comment:
    /**
     * tryAcquire on exclusively held sync fails
     */

#Code:
    public void testTryAcquireWhenSynced() {
        final Mutex sync = new Mutex();
        sync.acquire();
        Thread t = newStartedThread(new CheckedRunnable() {
            public void realRun() {
                assertFalse(sync.tryAcquire());
            }});

        awaitTermination(t);
        sync.release();
    }

#No. 4318
#File: E:\bishe\1\AbstractQueuedSynchronizerTest.java
#Comment:
    /**
     * tryAcquireNanos on an exclusively held sync times out
     */

#Code:
    public void testAcquireNanos_Timeout() {
        final Mutex sync = new Mutex();
        sync.acquire();
        Thread t = newStartedThread(new CheckedRunnable() {
            public void realRun() throws InterruptedException {
                long startTime = System.nanoTime();
                long nanos = MILLISECONDS.toNanos(timeoutMillis());
                assertFalse(sync.tryAcquireNanos(nanos));
                assertTrue(millisElapsedSince(startTime) >= timeoutMillis());
            }});

        awaitTermination(t);
        sync.release();
    }

#No. 4319
#File: E:\bishe\1\AbstractQueuedSynchronizerTest.java
#Comment:
    /**
     * getState is true when acquired and false when not
     */

#Code:
    public void testGetState() {
        final Mutex sync = new Mutex();
        sync.acquire();
        assertTrue(sync.isHeldExclusively());
        sync.release();
        assertFalse(sync.isHeldExclusively());

        final BooleanLatch acquired = new BooleanLatch();
        final BooleanLatch done = new BooleanLatch();
        Thread t = newStartedThread(new CheckedRunnable() {
            public void realRun() throws InterruptedException {
                sync.acquire();
                assertTrue(acquired.releaseShared(0));
                done.acquireShared(0);
                sync.release();
            }});

        acquired.acquireShared(0);
        assertTrue(sync.isHeldExclusively());
        assertTrue(done.releaseShared(0));
        awaitTermination(t);
        assertFalse(sync.isHeldExclusively());
    }

#No. 4320
#File: E:\bishe\1\AbstractQueuedSynchronizerTest.java
#Comment:
    /**
     * acquireInterruptibly succeeds when released, else is interruptible
     */

#Code:
    public void testAcquireInterruptibly() throws InterruptedException {
        final Mutex sync = new Mutex();
        final BooleanLatch threadStarted = new BooleanLatch();
        sync.acquireInterruptibly();
        Thread t = newStartedThread(new CheckedInterruptedRunnable() {
            public void realRun() throws InterruptedException {
                assertTrue(threadStarted.releaseShared(0));
                sync.acquireInterruptibly();
            }});

        threadStarted.acquireShared(0);
        waitForQueuedThread(sync, t);
        t.interrupt();
        awaitTermination(t);
        assertTrue(sync.isHeldExclusively());
    }

#No. 4321
#File: E:\bishe\1\AbstractQueuedSynchronizerTest.java
#Comment:
    /**
     * owns is true for a condition created by sync else false
     */

#Code:
    public void testOwns() {
        final Mutex sync = new Mutex();
        final ConditionObject c = sync.newCondition();
        final Mutex sync2 = new Mutex();
        assertTrue(sync.owns(c));
        assertFalse(sync2.owns(c));
    }

#No. 4322
#File: E:\bishe\1\AbstractQueuedSynchronizerTest.java
#Comment:
    /**
     * Calling await without holding sync throws IllegalMonitorStateException
     */

#Code:
    public void testAwait_IMSE() {
        final Mutex sync = new Mutex();
        final ConditionObject c = sync.newCondition();
        for (AwaitMethod awaitMethod : AwaitMethod.values()) {
            long startTime = System.nanoTime();
            try {
                await(c, awaitMethod);
                shouldThrow();
            } catch (IllegalMonitorStateException success) {
            } catch (InterruptedException e) { threadUnexpectedException(e); }
            assertTrue(millisElapsedSince(startTime) < LONG_DELAY_MS);
        }
    }

#No. 4323
#File: E:\bishe\1\AbstractQueuedSynchronizerTest.java
#Comment:
    /**
     * Calling signal without holding sync throws IllegalMonitorStateException
     */

#Code:
    public void testSignal_IMSE() {
        final Mutex sync = new Mutex();
        final ConditionObject c = sync.newCondition();
        try {
            c.signal();
            shouldThrow();
        } catch (IllegalMonitorStateException success) {}
        assertHasWaitersUnlocked(sync, c, NO_THREADS);
    }

#No. 4324
#File: E:\bishe\1\AbstractQueuedSynchronizerTest.java
#Comment:
    /**
     * Calling signalAll without holding sync throws IllegalMonitorStateException
     */

#Code:
    public void testSignalAll_IMSE() {
        final Mutex sync = new Mutex();
        final ConditionObject c = sync.newCondition();
        try {
            c.signalAll();
            shouldThrow();
        } catch (IllegalMonitorStateException success) {}
    }

#No. 4325
#File: E:\bishe\1\AbstractQueueLoader.java
#Comment:
    /**
     * Call "on pause" for all listeners
     */

#Code:
    protected final synchronized void callOnPause() {

        //set the state
        state = ActionTaskLoaderState.PAUSED;

        //notify the main thread that we are paused
        this.notifyAll();
    }

#No. 4326
#File: E:\bishe\1\AbstractQueueLoader.java
#Comment:
    /**
     * Call "on finish" for all listeners
     */

#Code:
    protected final synchronized void callOnFinish() {

        //set the state
        state = ActionTaskLoaderState.FINISHED;

        //notify all listeners
        for( QueueLoaderListener listener : listeners ) {
            listener.onFinish( queueName );
        }

        //notify the main thread that we are done
        this.notifyAll();
    }

#No. 4327
#File: E:\bishe\1\AbstractQueueLoader.java
#Comment:
    /**
     *
     * @return queue name
     */

#Code:
    public String getName() {

        return queueName;
    }

#No. 4328
#File: E:\bishe\1\AbstractQueueTest.java
#Comment:
    /**
     * add returns true if offer succeeds
     */

#Code:
    public void testAddS() {
        Succeed q = new Succeed();
        assertTrue(q.add(two));
    }

#No. 4329
#File: E:\bishe\1\AbstractQueueTest.java
#Comment:
    /**
     * add throws ISE true if offer fails
     */

#Code:
    public void testAddF() {
        Fail q = new Fail();
        try {
            q.add(one);
            shouldThrow();
        } catch (IllegalStateException success) {}
    }

#No. 4330
#File: E:\bishe\1\AbstractQueueTest.java
#Comment:
    /**
     * add throws NPE if offer does
     */

#Code:
    public void testAddNPE() {
        Succeed q = new Succeed();
        try {
            q.add(null);
            shouldThrow();
        } catch (NullPointerException success) {}
    }

#No. 4331
#File: E:\bishe\1\AbstractQueueTest.java
#Comment:
    /**
     * remove returns normally if poll succeeds
     */

#Code:
    public void testRemoveS() {
        Succeed q = new Succeed();
        q.remove();
    }

#No. 4332
#File: E:\bishe\1\AbstractQueueTest.java
#Comment:
    /**
     * remove throws NSEE if poll returns null
     */

#Code:
    public void testRemoveF() {
        Fail q = new Fail();
        try {
            q.remove();
            shouldThrow();
        } catch (NoSuchElementException success) {}
    }

#No. 4333
#File: E:\bishe\1\AbstractQueueTest.java
#Comment:
    /**
     * element returns normally if peek succeeds
     */

#Code:
    public void testElementS() {
        Succeed q = new Succeed();
        q.element();
    }

#No. 4334
#File: E:\bishe\1\AbstractQueueTest.java
#Comment:
    /**
     * element throws NSEE if peek returns null
     */

#Code:
    public void testElementF() {
        Fail q = new Fail();
        try {
            q.element();
            shouldThrow();
        } catch (NoSuchElementException success) {}
    }

#No. 4335
#File: E:\bishe\1\AbstractQueueTest.java
#Comment:
    /**
     * addAll(null) throws NPE
     */

#Code:
    public void testAddAll1() {
        Succeed q = new Succeed();
        try {
            q.addAll(null);
            shouldThrow();
        } catch (NullPointerException success) {}
    }

#No. 4336
#File: E:\bishe\1\AbstractQueueTest.java
#Comment:
    /**
     * addAll(this) throws IAE
     */

#Code:
    public void testAddAllSelf() {
        Succeed q = new Succeed();
        try {
            q.addAll(q);
            shouldThrow();
        } catch (IllegalArgumentException success) {}
    }

#No. 4337
#File: E:\bishe\1\AbstractQueueTest.java
#Comment:
    /**
     * addAll of a collection with null elements throws NPE
     */

#Code:
    public void testAddAll2() {
        Succeed q = new Succeed();
        Integer[] ints = new Integer[SIZE];
        try {
            q.addAll(Arrays.asList(ints));
            shouldThrow();
        } catch (NullPointerException success) {}
    }

#No. 4338
#File: E:\bishe\1\AbstractQueueTest.java
#Comment:
    /**
     * addAll of a collection with any null elements throws NPE after
     * possibly adding some elements
     */

#Code:
    public void testAddAll3() {
        Succeed q = new Succeed();
        Integer[] ints = new Integer[SIZE];
        for (int i = 0; i < SIZE - 1; ++i)
            ints[i] = new Integer(i);
        try {
            q.addAll(Arrays.asList(ints));
            shouldThrow();
        } catch (NullPointerException success) {}
    }

#No. 4339
#File: E:\bishe\1\AbstractQueueTest.java
#Comment:
    /**
     * addAll throws ISE if an add fails
     */

#Code:
    public void testAddAll4() {
        Fail q = new Fail();
        Integer[] ints = new Integer[SIZE];
        for (int i = 0; i < SIZE; ++i)
            ints[i] = new Integer(i);
        try {
            q.addAll(Arrays.asList(ints));
            shouldThrow();
        } catch (IllegalStateException success) {}
    }

#No. 4340
#File: E:\bishe\1\AbstractQuickstartTest.java
#Comment:
        /*
         * Do nothing. Deployment is tested when the test container is started.
         * This method simply prevents errors for "No runnable methods" for
         * those test cases that don't actually exercise the deployment.
         */

#Code:
    }

    protected static void startTestContainer(String featureName, String bundleName) throws Exception {
        startTestContainer(featureName, bundleName, null);
    }

#No. 4341
#File: E:\bishe\1\AbstractRandomTest.java
#Comment:
    /**
     * Test will timeout if secure random implementation always returns a
     * constant value.
     */

#Code:
    private void checkRandomBytes(CryptoRandom random, int len) {
        byte[] bytes = new byte[len];
        byte[] bytes1 = new byte[len];
        random.nextBytes(bytes);
        random.nextBytes(bytes1);

        while (Arrays.equals(bytes1, new byte[len]) || Arrays.equals(bytes, bytes1)) {
            random.nextBytes(bytes1);
        }
    }

#No. 4342
#File: E:\bishe\1\AbstractRandomVariableMapUsertaskExecutor.java
#Comment:
	/**
	 * randomly choose one variable map for given task
	 * @param execTask
	 * @return
	 */

#Code:
	protected Map<String, Object> getVariables(TaskEntity execTask) {
		if (taskVariablesMap.containsKey( execTask.getTaskDefinitionKey())) {
			List<Map<String, Object>> variablesList = taskVariablesMap.get( execTask.getTaskDefinitionKey());
			if (!variablesList.isEmpty()) {
				return variablesList.get( SimUtils.getRandomInt(variablesList.size()));
			}
		}
		return null;
	}

#No. 4343
#File: E:\bishe\1\AbstractRandomVariableMapUsertaskExecutor.java
#Comment:
	/**
	 * return constant time for task execution
	 * choose randomly one possibility for setting variables 
	 */

#Code:
	public long simulateTaskExecution(TaskEntity execTask, Map<String, Object> variables) {
		if (taskVariablesMap != null) {
			Map<String, Object> var = getVariables(execTask);
			if ( var != null)
				variables.putAll( var );
		}
		return getExecutionTime(execTask, variables);		
	}

#No. 4344
#File: E:\bishe\1\AbstractRange.java
#Comment:
  /**
   * Create the range
   *
   * @param offset The line offset
   * @param move   True if cursor moved
   */

#Code:
  public AbstractRange(int offset, boolean move) {
    this.offset = offset;
    this.move = move;
  }

#No. 4345
#File: E:\bishe\1\AbstractRange.java
#Comment:
  /**
   * Gets the line offset
   *
   * @return The line offset
   */

#Code:
  protected int getOffset() {
    return offset;
  }

#No. 4346
#File: E:\bishe\1\AbstractRange.java
#Comment:
  /**
   * Should the cursor move
   *
   * @return True if cursor should move, false if not
   */

#Code:
  public boolean isMove() {
    return move;
  }

#No. 4347
#File: E:\bishe\1\AbstractRange.java
#Comment:
  /**
   * Gets the line number (0 based) specificied by this range. Includes the offset.
   *
   * @param editor   The editor to get the line for
   * @param context  The data context
   * @param lastZero True if last line was set to start of file
   * @return The zero based line number, -1 if unable to get the line number
   */

#Code:
  public int getLine(Editor editor, DataContext context, boolean lastZero) {
    int line = getRangeLine(editor, context, lastZero);

    return line + offset;
  }

#No. 4348
#File: E:\bishe\1\AbstractRangeMetricTest.java
#Comment:
    /**
     * A call to {@link AbstractRangeMetric#calculate()} after {@link AbstractRangeMetric#setUserRange(double)} has been
     * called with a positive, non-negative argument should return the value of
     * {@link AbstractRangeMetric#calculate(double)} called with the same argument as
     * {@link AbstractRangeMetric#setUserRange(double)} was called.
     */

#Code:
    @Test
    public final void testCalculate_changeRange() {
        final double range = 20.0;

        Mockito.when(cut.calculate(anyDouble())).thenReturn(0.0);
        Mockito.when(cut.calculate(range)).thenReturn(1.0);

        cut.setUserRange(range);
        assertEquals(1.0, cut.calculate(), 0.0);
    }

#No. 4349
#File: E:\bishe\1\AbstractRangeMetricTest.java
#Comment:
    /**
     * If {@link AbstractRangeMetric#setUserRange(double)} was last called with a negative or zero argument; a call to
     * {@link AbstractRangeMetric#calculate()} should return the maximum value of
     * {@link AbstractRangeMetric#calculate(double)} for all the ranges returned by
     * {@link WeaponRanges#getRanges(Loadout)}.
     */

#Code:
    @Test
    public final void testCalculate_negativeChangeRange() throws Exception {
        cut.setUserRange(10.0);
        cut.setUserRange(-1.0);

        testCalculate_noChangeRange();
    }

#No. 4350
#File: E:\bishe\1\AbstractRangeMetricTest.java
#Comment:
    /**
     * If {@link AbstractRangeMetric#setUserRange(double)} has not been called; a call to
     * {@link AbstractRangeMetric#calculate()} should return the maximum value of
     * {@link AbstractRangeMetric#calculate(double)} for all the ranges returned by
     * {@link WeaponRanges#getRanges(Loadout)}.
     *
     */

#Code:
    @Test
    public final void testCalculate_noChangeRange() throws Exception {
        // Should give ranges: 0, 270, 450, 540, 900
        items.add((Weapon) ItemDB.lookup("MEDIUM LASER"));
        items.add((Weapon) ItemDB.lookup("LARGE LASER"));

        Mockito.when(cut.calculate(anyDouble())).thenReturn(0.0);
        Mockito.when(cut.calculate(270.0)).thenReturn(1.0);
        Mockito.when(cut.calculate(450.0)).thenReturn(3.0);
        Mockito.when(cut.calculate(540.0)).thenReturn(2.0);
        Mockito.when(cut.calculate(900.0)).thenReturn(1.0);

        assertEquals(3.0, cut.calculate(), 0.0);
    }

#No. 4351
#File: E:\bishe\1\AbstractRangeMetricTest.java
#Comment:
    /**
     * After a call to {@link AbstractRangeMetric#calculate()}, {@link AbstractRangeMetric#getDisplayRange()} should
     * return the range for which {@link AbstractRangeMetric#calculate(double)} returned the highest value of the ranges
     * determined by the weapons on the loadout.
     */

#Code:
    @Test
    public final void testGetDisplayRange() throws Exception {
        // Should give ranges: 0, 270, 450, 540, 900
        items.add((Weapon) ItemDB.lookup("MEDIUM LASER"));
        items.add((Weapon) ItemDB.lookup("LARGE LASER"));

        Mockito.when(cut.calculate(anyDouble())).thenReturn(0.0);
        Mockito.when(cut.calculate(270.0)).thenReturn(1.0);
        Mockito.when(cut.calculate(450.0)).thenReturn(3.0);
        Mockito.when(cut.calculate(540.0)).thenReturn(2.0);
        Mockito.when(cut.calculate(900.0)).thenReturn(1.0);

        cut.calculate();

        assertEquals(450.0, cut.getDisplayRange(), 0.0);
    }

#No. 4352
#File: E:\bishe\1\AbstractRDFEntityEncoder.java
#Comment:
/**
 * TODO JavaDoc
 *
 * @author Christian Autermann <autermann@uni-muenster.de>
 */

#Code:
public abstract class AbstractRDFEntityEncoder<T>
        extends AbstractRDFMessageBodyWriter<T>
        implements RDFEntityEncoder<T> {
    private Provider<AccessRights> rights;
    private Provider<UriInfo> uriInfo;

    public AbstractRDFEntityEncoder(Class<T> classType) {
        super(classType);
    }

    @Inject
    public void setRights(Provider<AccessRights> rights) {
        this.rights = rights;
    }

    @Inject
    public void setUriInfo(Provider<UriInfo> uriInfo) {
        this.uriInfo = uriInfo;
    }

    @Override
    public Model encodeRDF(T t) {
        return encodeRDF(t, rights.get());
    }

    @Override
    public Model encodeRDF(T t, AccessRights rights) {
        return encodeRDF(t, rights, new RequestUriBuilderProvider());
    }

    private class RequestUriBuilderProvider implements Provider<UriBuilder> {
        @Override
        public UriBuilder get() {
            return uriInfo.get().getBaseUriBuilder();
        }
    }
}

#No. 4353
#File: E:\bishe\1\AbstractReadKerberosTime.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public final void action( E container ) throws DecoderException
    {
        TLV tlv = container.getCurrentTLV();

        // The Length should not be null and should be 15
        if ( tlv.getLength() != 15 )
        {
            LOG.error( I18n.err( I18n.ERR_04066 ) );

            // This will generate a PROTOCOL_ERROR
            throw new DecoderException( I18n.err( I18n.ERR_04067 ) );
        }

        // The value is the KerberosTime
        BerValue value = tlv.getValue();
        String date = Strings.utf8ToString( value.getData() );

        try
        {
            KerberosTime krbTime = new KerberosTime( date );

            if ( IS_DEBUG )
            {
                LOG.debug( "decoded kerberos time is : {}", krbTime );
            }

            setKerberosTime( krbTime, container );
        }
        catch ( IllegalArgumentException iae )
        {
            LOG.error( I18n.err( I18n.ERR_04066 ) );

            // This will generate a PROTOCOL_ERROR
            throw new DecoderException( I18n.err( I18n.ERR_04067 ) );
        }
    }

#No. 4354
#File: E:\bishe\1\AbstractReadRealm.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public final void action( E container ) throws DecoderException
    {
        TLV tlv = container.getCurrentTLV();

        // The Length should not be null
        if ( tlv.getLength() == 0 )
        {
            LOG.error( I18n.err( I18n.ERR_04066 ) );

            // This will generate a PROTOCOL_ERROR
            throw new DecoderException( I18n.err( I18n.ERR_04067 ) );
        }

        // The value is the realm
        BerValue value = tlv.getValue();
        String realm = Strings.utf8ToString( value.getData() );

        if ( IS_DEBUG )
        {
            LOG.debug( "read realm value : " + realm );
        }

        setRealm( realm, container );
    }

#No. 4355
#File: E:\bishe\1\AbstractReadWriteAccessStrategy.java
#Comment:
	/**
	 * Soft-lock a cache item.
	 */

#Code:
	public final SoftLock lockItem(Object key, Object version) throws CacheException {

		try {
			log.debug("locking key[{}] in region[{}]", key, getInternalRegion().getName());
			writeLock.lock();
			Lockable item = (Lockable) getInternalRegion().get(key);
			long timeout = getInternalRegion().nextTimestamp() + getInternalRegion().getTimeout();
			final Lock lock = (item == null) ? new Lock(timeout, uuid, nextLockId(), version) : item.lock(
					timeout,
					uuid,
					nextLockId()
			);
			getInternalRegion().put(key, lock);
			return lock;
		} finally {
			writeLock.unlock();
		}
	}

#No. 4356
#File: E:\bishe\1\AbstractReadWriteAccessStrategy.java
#Comment:
	/**
	 * Soft-unlock a cache item.
	 */

#Code:
	public final void unlockItem(Object key, SoftLock lock) throws CacheException {

		try {
			log.debug("unlocking key[{}] in region[{}]", key, getInternalRegion().getName());
			writeLock.lock();
			Lockable item = (Lockable) getInternalRegion().get(key);

			if ((item != null) && item.isUnlockable(lock)) {
				decrementLock(key, (Lock) item);
			} else {
				handleLockExpiry(key, item);
			}
		} finally {
			writeLock.unlock();
		}
	}

#No. 4357
#File: E:\bishe\1\AbstractReadWriteAccessStrategy.java
#Comment:
	/**
	 * Unlock and re-put the given key, lock combination.
	 */

#Code:
	protected void decrementLock(Object key, Lock lock) {
		lock.unlock(getInternalRegion().nextTimestamp());
		getInternalRegion().put(key, lock);
	}

#No. 4358
#File: E:\bishe\1\AbstractReadWriteAccessStrategy.java
#Comment:
	/**
	 * Handle the timeout of a previous lock mapped to this key
	 */

#Code:
	protected void handleLockExpiry(Object key, Lockable lock) {
		long ts = getInternalRegion().nextTimestamp() + getInternalRegion().getTimeout();
		// create new lock that times out immediately
		Lock newLock = new Lock(ts, uuid, nextLockId.getAndIncrement(), null);
		newLock.unlock(ts);
		getInternalRegion().put(key, newLock);
	}

#No. 4359
#File: E:\bishe\1\AbstractReadWriteMemcachedAccessStrategy.java
#Comment:
    /**
     * Creates a read/write cache access strategy around the given cache region.
     */

#Code:
    public AbstractReadWriteMemcachedAccessStrategy(T region, SessionFactoryOptions settings, CacheDataDescription cacheDataDescription) {
        super(region, settings);
        this.versionComparator = cacheDataDescription.getVersionComparator();
    }

#No. 4360
#File: E:\bishe\1\AbstractReadWriteMemcachedAccessStrategy.java
#Comment:
    /**
     * Returns <code>null</code> if the item is not readable.  Locked items are not readable, nor are items created
     * afterQuery the start of this transaction.
     */

#Code:
    public final Object get(SharedSessionContractImplementor session, Object key, long txTimestamp) throws CacheException {
        readLockIfNeeded(key);
        try {
            final Lockable item = (Lockable) region().get(key);

            final boolean readable = item != null && item.isReadable(txTimestamp);
            if (readable) {
                return item.getValue();
            } else {
                return null;
            }
        } finally {
            readUnlockIfNeeded(key);
        }
    }

#No. 4361
#File: E:\bishe\1\AbstractReadWriteMemcachedAccessStrategy.java
#Comment:
    /**
     * Returns <code>false</code> and fails to put the value if there is an existing un-writeable item mapped to this
     * key.
     */

#Code:
    @Override
    public final boolean putFromLoad(
            SharedSessionContractImplementor session,
            Object key,
            Object value,
            long txTimestamp,
            Object version,
            boolean minimalPutOverride)
            throws CacheException {

        region.getCache().lock(key);
        try {
            final Lockable item = (Lockable) region().get(key);
            final boolean writeable = item == null || item.isWriteable(txTimestamp, version, versionComparator);
            if (writeable) {
                region().put(key, new Item(value, version, region.nextTimestamp()));
                return true;
            } else {
                return false;
            }
        } finally {
            region.getCache().unlock(key);
        }
    }

#No. 4362
#File: E:\bishe\1\AbstractReadWriteMemcachedAccessStrategy.java
#Comment:
    /**
     * Soft-lock a cache item.
     */

#Code:
    public final SoftLock lockItem(SharedSessionContractImplementor session, Object key, Object version) throws CacheException {
        region.getCache().lock(key);
        try {
            final Lockable item = (Lockable) region().get(key);
            final long timeout = region.nextTimestamp() + region.getTimeout();
            final Lock lock = (item == null) ? new Lock(timeout, uuid, nextLockId(), version) : item.lock(
                    timeout,
                    uuid,
                    nextLockId()
            );
            region().put(key, lock);
            return lock;
        } finally {
            region.getCache().unlock(key);
        }
    }

#No. 4363
#File: E:\bishe\1\AbstractReadWriteMemcachedAccessStrategy.java
#Comment:
    /**
     * Soft-unlock a cache item.
     */

#Code:
    public final void unlockItem(SharedSessionContractImplementor session, Object key, SoftLock lock) throws CacheException {
        region.getCache().lock(key);
        try {
            final Lockable item = (Lockable) region().get(key);

            if ((item != null) && item.isUnlockable(lock)) {
                decrementLock(key, (Lock) item);
            } else {
                handleLockExpiry(key, item);
            }
        } finally {
            region.getCache().unlock(key);
        }
    }

#No. 4364
#File: E:\bishe\1\AbstractReadWriteMemcachedAccessStrategy.java
#Comment:
    /**
     * Unlock and re-put the given key, lock combination.
     */

#Code:
    protected void decrementLock(Object key, Lock lock) {
        lock.unlock(region.nextTimestamp());
        region.getCache().put(key, lock);
    }

#No. 4365
#File: E:\bishe\1\AbstractReadWriteMemcachedAccessStrategy.java
#Comment:
    /**
     * Handle the timeout of a previous lock mapped to this key
     */

#Code:
    protected void handleLockExpiry(Object key, Lockable lock) {
        log.warn("Cache " + region.getName() + " Key " + key + " Lockable : " + lock + "\n"
                + "A soft-locked cache entry was expired by the underlying Memcache. "
                + "If this happens regularly you should consider increasing the cache timeouts and/or capacity limits");
        long ts = region.nextTimestamp() + region.getTimeout();
        // create new lock that times out immediately
        Lock newLock = new Lock(ts, uuid, nextLockId.getAndIncrement(), null);
        newLock.unlock(ts);
        region.getCache().put(key, newLock);
    }

#No. 4366
#File: E:\bishe\1\AbstractReadWriteMemcachedAccessStrategy.java
#Comment:
    /**
     * Read lock the entry for the given key if internal cache locks will not provide correct exclusion.
     */

#Code:
    private void readLockIfNeeded(Object key) {
        region.getCache().lock(key);
    }

#No. 4367
#File: E:\bishe\1\AbstractReadWriteMemcachedAccessStrategy.java
#Comment:
    /**
     * Read unlock the entry for the given key if internal cache locks will not provide correct exclusion.
     */

#Code:
    private void readUnlockIfNeeded(Object key) {
        region.getCache().unlock(key);
    }

#No. 4368
#File: E:\bishe\1\AbstractRealtimeBarEngine.java
#Comment:
    /**
     * Called after listeners have been added to the listener lists.
     * @param request The request for real time bars.
     * @param listener The listener which will listen for bar events.
     */

#Code:
    public abstract void subscribeRealtimeBarInternal(RealtimeBarRequest request, RealtimeBarListener listener);

    
    /**
     * Called after listeners have been removed from listener lists.
     * @param request The request to unsubscribe.
     * @param noMoreListeners true if there are no further listeners for this market data.
     */
    public abstract void unsubscribeRealtimeBarInternal(RealtimeBarRequest request, RealtimeBarListener listener, boolean noMoreListeners);
    
    
}
}

#No. 4369
#File: E:\bishe\1\AbstractRecipeRegistrar.java
#Comment:
    /**
     * Returns true if the name provided is know by the ore dictionary.
     */

#Code:
    protected static boolean knowsOre(String pName) {
        return !OreDictionary.getOres(pName).isEmpty();
    }

#No. 4370
#File: E:\bishe\1\AbstractRecognizerActivity.java
#Comment:
    /**
     * Launches an activity which the user probably does not want to see
     * if he presses HOME while in this activity and then starts Arvutaja again
     * from the launcher.
     * <p/>
     * TODO: Note that activities cannot be launched when the app was launched via voice interaction.
     * We get the exception:
     * java.lang.SecurityException: Starting under voice control not allowed for:
     * Intent { act=android.intent.action.VIEW dat=http://maps.google.com/... flg=0x80000 }
     */

#Code:
    protected void startForeignActivity(Intent intent) {
        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
            // If in split-screen mode, launch the foreign activity into the 2nd screen.
            // TODO: not sure this has any effect,
            // the launched activity ends up in the 2nd screen anyway.
            intent.addFlags(Intent.FLAG_ACTIVITY_LAUNCH_ADJACENT | Intent.FLAG_ACTIVITY_MULTIPLE_TASK);
        }
        try {
            startActivity(intent);
        } catch (SecurityException e) {
            // TODO: localize the error message
            toast(e.getMessage());
        }
    }

#No. 4371
#File: E:\bishe\1\AbstractRecognizerActivity.java
#Comment:
    /**
     * If the caller defines the EXTRA_LANGUAGE, then use that language.
     * Otherwise take the language from the Language-setting.
     */

#Code:
    protected String getLang(SharedPreferences prefs, Resources res) {
        Intent intent = getIntent();
        if (intent != null) {
            String lang = intent.getStringExtra(RecognizerIntent.EXTRA_LANGUAGE);
            if (lang != null) {
                return lang;
            }
        }
        return PreferenceUtils.getPrefString(prefs, res, R.string.keyLanguage, R.string.defaultLanguage);
    }

#No. 4372
#File: E:\bishe\1\AbstractRecognizerActivity.java
#Comment:
    /**
     * If the caller defines the EXTRA_AUDIO_CUES, then if it is boolean and true then play the audio
     * cues.
     * Otherwise play the audio cues if the AudioCues-setting is true.
     * TODO: future work: just pass this EXTRA on to the recognizer engine (i.e. do not play cues in Arvutaja)
     */

#Code:
    protected AudioCue createAudioCue(SharedPreferences prefs, Resources res) {
        Intent intent = getIntent();
        if (intent != null && intent.hasExtra(Extras.EXTRA_AUDIO_CUES)) {
            if (intent.getBooleanExtra(Extras.EXTRA_AUDIO_CUES, false)) {
                return new AudioCue(this);
            }
            return null;
        }

        if (PreferenceUtils.getPrefBoolean(prefs, res, R.string.keyAudioCues, R.bool.defaultAudioCues)) {
            return new AudioCue(this);
        }
        return null;
    }

#No. 4373
#File: E:\bishe\1\AbstractReconnectionHandlerTest.java
#Comment:
    /**
     * Note: a handler that succeeds immediately resets the future to null, so there is a very small window of opportunity
     * for this scenario. Therefore we consider that if we find a completed future, the connection was successfully
     * re-established a few milliseconds ago, so we don't start another attempt.
     */

#Code:
    @Test(groups = "unit")
    public void should_yield_to_another_handler_that_just_succeeded() {
        future.set(Futures.immediateCheckedFuture(null));

        handler.start();

        schedule.tick();

        waitForCompletion();

        assertThat(work.success).isFalse();
    }

#No. 4374
#File: E:\bishe\1\AbstractRecyclableDerivedByteBuf.java
#Comment:
    /**
     * Called when the ref count for the derived buffer gets to 0
     */

#Code:
    protected void deallocate() {
        this.origBuffer.release();
        this.recycle();
    }

#No. 4375
#File: E:\bishe\1\AbstractRedisCache.java
#Comment:
    /**
     * redis本身就是原子操作, 所以这儿不用管多线程修改的问题
     * 另外缓存本身多删除或者少删除没有什么影响
     */

#Code:
    @Override
    public int reload() {
        Set<String> keys = client.hKeys(mapKey);
        if (CommonsUtils.isEmpty(keys)) return 0;
        Map<String, V> values = loadValue(keys);
        List<String> needRemoveKeys = new ArrayList<>();
        for (String k : keys) {
            V v = values.get(k);
            if (v == null) {
                needRemoveKeys.add(k);
            } else {
                client.hSet(mapKey, k, v);
            }
        }
        //没有用的field删除
        if (needRemoveKeys.isEmpty()) {
            return keys.size();
        } else {
            int length = needRemoveKeys.size();
            client.hDel(mapKey, needRemoveKeys.toArray(new String[length]));
            return keys.size() - length;
        }
    }

#No. 4376
#File: E:\bishe\1\AbstractRefInput.java
#Comment:
	/**
	 * Set the entity where this xref should get its values from
	 * 
	 * @param xrefEntity
	 * @throws HtmlInputException
	 */

#Code:
	protected void setXrefEntity(Class<? extends Entity> xrefEntity)
	{
		try
		{
			Entity instance = xrefEntity.newInstance();
			this.xrefField = instance.getIdField();
			this.xrefLabels = instance.getLabelFields();
			this.placeholder = "Choose " + instance.getClass().getSimpleName();
			// this.xrefEntity = xrefEntity;
		}
		catch (Exception e)
		{
			this.error = e.getMessage();
			e.printStackTrace();
		}
	}

#No. 4377
#File: E:\bishe\1\AbstractReflectionDynamicEventTemplateProviderAdapter.java
#Comment:
    /**
     * @param failSilently - when set to true {@link #afterPropertiesSet()} will not raise an
     *                     exception if an annotated method is not found.
     */

#Code:
    public void setFailSilentlyIfMethodNotFound(boolean failSilently) {
        this.failSilentlyIfAnnotationNotFound = failSilently;
    }

#No. 4378
#File: E:\bishe\1\AbstractRegionCacheEntryProcessor.java
#Comment:
/**
 * An abstract implementation of {@link EntryProcessor} which acts on a hibernate region cache
 * {@link com.hazelcast.core.IMap}
 */

#Code:

public abstract class AbstractRegionCacheEntryProcessor implements EntryProcessor<Object, Expirable>,
        EntryBackupProcessor<Object, Expirable>, IdentifiedDataSerializable {

    @Override
    public int getFactoryId() {
        return HibernateDataSerializerHook.F_ID;
    }

    @Override
    public void processBackup(Map.Entry<Object, Expirable> entry) {
        process(entry);
    }

    @Override
    public EntryBackupProcessor<Object, Expirable> getBackupProcessor() {
        return this;
    }

}

#No. 4379
#File: E:\bishe\1\AbstractRelationalDatabaseSupport.java
#Comment:
    /*
     * Obtain a valid DatabaseBackup object for the given database instance where the backup was taken prior to the given time.
     *
     * Throws CloudException on failure
     */

#Code:
    public DatabaseBackup getUsableBackup(String providerDbId, String beforeTimestamp) throws CloudException, InternalException {
        throw new OperationNotSupportedException("Snapshot functionality is not currently implemented for "+getProvider().getCloudName());
    }

#No. 4380
#File: E:\bishe\1\AbstractRelationalDatabaseSupport.java
#Comment:
    /*
     * Obtain a list of DatabaseBackup objects for a given database, or for all databases if null.
     * 
     * Throws CloudException on failure
     */

#Code:
    public Iterable<DatabaseBackup> listBackups(String forOptionalProviderDatabaseId) throws CloudException, InternalException{
        throw new OperationNotSupportedException("Snapshot functionality is not currently implemented for "+getProvider().getCloudName());
    }

#No. 4381
#File: E:\bishe\1\AbstractRelationalDatabaseSupport.java
#Comment:
    /*
     * Create a new database from the passed in backup object
     * 
     * Throws CloudException on failure
     */

#Code:
    public void createFromBackup(DatabaseBackup backup, String databaseCloneToName) throws CloudException, InternalException{
        throw new OperationNotSupportedException("Snapshot functionality is not currently implemented for "+getProvider().getCloudName());
    }

#No. 4382
#File: E:\bishe\1\AbstractRelationalDatabaseSupport.java
#Comment:
    /*
     * Remove specified database backup
     * 
     * Throws CloudException on failure
     */

#Code:
    public void removeBackup(DatabaseBackup backup) throws CloudException, InternalException{
        throw new OperationNotSupportedException("Snapshot functionality is not currently implemented for "+getProvider().getCloudName());
    }

#No. 4383
#File: E:\bishe\1\AbstractRelationalDatabaseSupport.java
#Comment:
    /*
     * Restore the passed in DatabaseBackup to its current database instance.
     * 
     * Throws CloudException on failure
     */

#Code:
    public void restoreBackup(DatabaseBackup backup) throws CloudException, InternalException{
        throw new OperationNotSupportedException("Snapshot functionality is not currently implemented for "+getProvider().getCloudName());
    }

#No. 4384
#File: E:\bishe\1\AbstractReminderNotificationListenerService.java
#Comment:
    /**
     * Update the available notification information from the node information of the accessibility event
     * <br>
     * The algorithm is not exact. All the strings are recursively retrieved in the view hierarchy and then
     * titles are compared with the available notifications
     *
     * @param accessibilityEvent
     */

#Code:
    private void updateNotifications(AccessibilityEvent accessibilityEvent) {
        AccessibilityNodeInfo node = accessibilityEvent.getSource();
        node = mStatusBarWindowUtils.getRootNode(node);
        boolean removed = false;
        Set<String> titles = node == null ? Collections.emptySet() : recursiveGetStrings(node);
        for (Iterator<NotificationData> iter = mAvailableNotifications.iterator(); iter.hasNext(); ) {
            NotificationData data = iter.next();
            if (!titles.contains(data.title.toString())) {
                // if the title is absent in the view hierarchy remove notification from available notifications
                iter.remove();
                removed = true;
            }
        }
        if (removed) {
            Timber.d("updateNotifications: removed");
            // fire event if at least one notification was removed
            onNotificationRemoved();
        }
    }

#No. 4385
#File: E:\bishe\1\AbstractReminderNotificationListenerService.java
#Comment:
    /**
     * Remove all notifications from the available notifications with the specified package name
     *
     * @param packageName
     */

#Code:
    private void removeNotificationsFor(String packageName) {
        boolean removed = false;
        Timber.d("removeNotificationsFor: %1$s", packageName);
        for (Iterator<NotificationData> iter = mAvailableNotifications.iterator(); iter.hasNext(); ) {
            NotificationData data = iter.next();
            if (TextUtils.equals(packageName, data.packageName)) {
                iter.remove();
                removed = true;
            }
        }
        if (removed) {
            Timber.d("removeNotificationsFor: removed for %1$s", packageName);
            onNotificationRemoved();
        }
    }

#No. 4386
#File: E:\bishe\1\AbstractReminderNotificationListenerService.java
#Comment:
    /**
     * Get all the text information from the node view hierarchy
     *
     * @param node
     * @return
     */

#Code:
    private Set<String> recursiveGetStrings(AccessibilityNodeInfo node) {
        Set<String> strings = new HashSet<>();
        if (node != null) {
            if (node.getText() != null) {
                strings.add(node.getText().toString());
                Timber.d("recursiveGetStrings: %1$s", node.getText().toString());
            }
            for (int i = 0; i < node.getChildCount(); i++) {
                strings.addAll(recursiveGetStrings(node.getChild(i)));
            }
        }
        return strings;
    }

#No. 4387
#File: E:\bishe\1\AbstractRemoteFileProperties.java
#Comment:
	/**
	 * The remote FTP directory.
	 */

#Code:
	private String remoteDir = "/";

	/**
	 * The suffix to use while the transfer is in progress.
	 */
	private String tmpFileSuffix = ".tmp";

	/**
	 * The remote file separator.
	 */
	private String remoteFileSeparator = "/";

	@NotBlank
	public String getRemoteDir() {
		return remoteDir;
	}

#No. 4388
#File: E:\bishe\1\AbstractRemoteFileSinkProperties.java
#Comment:
	/**
	 * A temporary directory where the file will be written if {@link #isUseTemporaryFilename()}
	 * is true.
	 */

#Code:
	private String temporaryRemoteDir = "/";

	/**
	 * Whether or not to create the remote directory.
	 */
	private boolean autoCreateDir = true;

	/**
	 * Action to take if the remote file already exists.
	 */
	private FileExistsMode mode = FileExistsMode.REPLACE;

	/**
	 * Whether or not to write to a temporary file and rename.
	 */
	private boolean useTemporaryFilename = true;

	/**
	 * A SpEL expression to generate the remote file name.
	 */
	private Expression filenameExpression;

	@NotBlank
	public String getTemporaryRemoteDir() {
		return this.temporaryRemoteDir;
	}

#No. 4389
#File: E:\bishe\1\AbstractRenderPlugIn.java
#Comment:
	/**
	 *	Default behaviour : POLICY_MODIFY
	 */

#Code:
	public int getAudioPolicy()
	{
		return POLICY_MODIFY;
	}

#No. 4390
#File: E:\bishe\1\AbstractRenderPlugIn.java
#Comment:
	/**
	 *	Default behaviour : POLICY_BYPASS
	 */

#Code:
	public int getUnselectedAudioPolicy()
	{
		return POLICY_MODIFY;
	}

#No. 4391
#File: E:\bishe\1\AbstractRenderPlugIn.java
#Comment:
	/**
	 *	Default behaviour : POLICY_BYPASS
	 */

#Code:
	public int getMarkerPolicy()
	{
		return POLICY_BYPASS;
	}

#No. 4392
#File: E:\bishe\1\AbstractRenderPlugIn.java
#Comment:
	/**
	 *	Default behaviour : POLICY_BYPASS
	 */

#Code:
	public int getLengthPolicy()
	{
		return POLICY_BYPASS;
	}

#No. 4393
#File: E:\bishe\1\AbstractRenderPlugIn.java
#Comment:
	/**
	 *	Default behaviour : no user parameters (false)
	 */

#Code:
	public boolean hasUserParameters()
	{
		return false;
	}

#No. 4394
#File: E:\bishe\1\AbstractRenderPlugIn.java
#Comment:
	/**
	 *	Default behaviour : shouldn't display parameters (false)
	 */

#Code:
	public boolean shouldDisplayParameters()
	{
		return false;
	}

#No. 4395
#File: E:\bishe\1\AbstractRenderPlugIn.java
#Comment:
	/**
	 *	Sub-classes should call super.init() !
	 */

#Code:
	public void init( Preferences p )
	{
		this.prefs	= p;
	}

#No. 4396
#File: E:\bishe\1\AbstractRenderPlugIn.java
#Comment:
	/**
	 *	Sub-classes should call super.init() !
	 */

#Code:
	public void dispose()
	{
		/* empty */ 
	}

#No. 4397
#File: E:\bishe\1\AbstractRenderPlugIn.java
#Comment:
	/**
	 *	Default behaviour : returns null (no GUI)
	 */

#Code:
	public JComponent getSettingsView( RenderContext context )
	{
		return null;
	}

#No. 4398
#File: E:\bishe\1\AbstractRenderPlugIn.java
#Comment:
	/**
	 *	Default behaviour : simply calls consumer.consumerBegin()
	 */

#Code:
	public boolean producerBegin( RenderSource source )
	throws IOException
	{
		return source.context.getConsumer().consumerBegin( source );
	}

#No. 4399
#File: E:\bishe\1\AbstractRenderPlugIn.java
#Comment:
	/**
	 *	Default behaviour : simply calls consumer.consumerRender(), i.e. bypass
	 */

#Code:
	public boolean producerRender( RenderSource source )
	throws IOException
	{
		return source.context.getConsumer().consumerRender( source );
	}

#No. 4400
#File: E:\bishe\1\AbstractRenderPlugIn.java
#Comment:
	/**
	 *	Default behaviour : simply calls consumer.consumerFinish() and
	 *	delete all temp files
	 */

#Code:
	public boolean producerFinish( RenderSource source )
	throws IOException
	{
		try {
			return source.context.getConsumer().consumerFinish( source );
		}
		finally {
			deleteAllTempFiles();
		}
	}

#No. 4401
#File: E:\bishe\1\AbstractRenderPlugIn.java
#Comment:
	/**
	 * Default behaviour : simply calls consumer.consumerCancel() and
	 * delete all temp files
	 */

#Code:
	public void producerCancel(RenderSource source)
			throws IOException {
		try {
			source.context.getConsumer().consumerCancel(source);
		} finally {
			deleteAllTempFiles();
		}
	}

#No. 4402
#File: E:\bishe\1\AbstractRepeater2.java
#Comment:
	/**
	 * Renders all child items in no specified order
	 */

#Code:
	@Override
	protected final void onRender()
	{
		Iterator<? extends Component> it = renderIterator();
		while (it.hasNext())
		{
			Component child = it.next();
			if (child == null)
			{
				throw new IllegalStateException(
					"The render iterator returned null for a child. Container: " + this.toString() +
						"; Iterator=" + it.toString());
			}
			renderChild(child);
		}
	}

#No. 4403
#File: E:\bishe\1\AbstractRepeater2.java
#Comment:
	/**
	 * Render a single child. This method can be overridden to modify how a single child component
	 * is rendered.
	 * 
	 * @param child
	 *            Child component to be rendered
	 */

#Code:
	protected void renderChild(final Component child)
	{
		child.render();
	}

#No. 4404
#File: E:\bishe\1\AbstractRepeater2.java
#Comment:
	/**
	 * @see org.apache.wicket.Component#onBeforeRender()
	 */

#Code:
	@Override
	protected void onBeforeRender()
	{
		onPopulate();

		if (getApplication().usesDevelopmentConfig())
		{
			Iterator<? extends Component> i = iterator();
			while (i.hasNext())
			{
				Component c = i.next();
				Matcher matcher = SAFE_CHILD_ID_PATTERN.matcher(c.getId());
				if (!matcher.matches())
				{
					log.warn("Child component of repeater " + getClass().getName() + ":" + getId() +
						" has a non-safe child id of " + c.getId() +
						". Safe child ids must be composed of digits only.");
					// do not flood the log
					break;
				}

			}
		}
		super.onBeforeRender();
	}

#No. 4405
#File: E:\bishe\1\AbstractRepeater2.java
#Comment:
	/**
	 * @see org.apache.wicket.MarkupContainer#getMarkup(org.apache.wicket.Component)
	 */

#Code:
	@Override
	public IMarkupFragment getMarkup(final Component child)
	{
		// each direct child gets the markup of this repeater
		return getMarkup();
	}

#No. 4406
#File: E:\bishe\1\AbstractReplacement.java
#Comment:
    /**
     * @return the type
     */

#Code:
    public String getType() {
        return type;
    }

#No. 4407
#File: E:\bishe\1\AbstractReplacement.java
#Comment:
    /**
     * @param type
     *            the type to set
     */

#Code:
    public void setType(String type) {
        this.type = type;
    }

#No. 4408
#File: E:\bishe\1\AbstractReplacement.java
#Comment:
    /**
     * @return the section
     */

#Code:
    public Section getSection() {
        return section;
    }

#No. 4409
#File: E:\bishe\1\AbstractReplacement.java
#Comment:
    /**
     * @param section
     *            the section to set
     */

#Code:
    public void setSection(Section section) {
        this.section = section;
    }

#No. 4410
#File: E:\bishe\1\AbstractReplacement.java
#Comment:
    /**
     * @param searchQuery
     *            The search query pattern
     * @param replaceString
     *            The replacement string
     * @param value
     * @param type
     * @return
     */

#Code:
    protected List<ReplaceEntity> getReplacementInValue(String searchQuery, String replaceString, String value,
            String type) {
        return getReplacementInValue(searchQuery, replaceString, value, type, null);
    }

#No. 4411
#File: E:\bishe\1\AbstractReplacement.java
#Comment:
    /**
     * @param searchQuery
     *            The search query pattern
     * @param replaceString
     *            The replacement string
     * @param value
     *            The value to be searched in.
     * 
     * @param type
     *            The type of the
     * @param key
     *            The key to be set in the replace entity if a match was found.
     * @return
     */

#Code:
    protected List<ReplaceEntity> getReplacementInValue(String searchQuery, String replaceString, String value,
            String type, String key) {
        if (StringUtils.isEmpty(searchQuery) || StringUtils.isEmpty(value)) {
            return Collections.emptyList();
        }
        if (!this.type.equals(type)) {
            return Collections.emptyList();
        }

        List<ReplaceEntity> reList = new ArrayList<ReplaceEntity>();
        if (isMatch(searchQuery, replaceString, value)) {
            ReplaceEntity re = new ReplaceEntity();
            re.setValue(value);
            re.setAfter(replaceString);
            re.setSection(getSection());
            re.setKey(key);
            reList.add(re);
        }
        return reList;
    }

#No. 4412
#File: E:\bishe\1\AbstractReplacement.java
#Comment:
    /**
     * Finds the pattern in the value and returns how the replacement string would like to the user
     * 
     * @param searchQuery
     *            the search query
     * @param replaceString
     *            The replacement string
     * @param value
     *            The value to be searched in.
     * @return
     */

#Code:
    private boolean isMatch(String searchQuery, String replaceString, String value) {
        searchQuery = RegexUtil.wildcardToRegexp(searchQuery);
        Pattern p = Pattern.compile(searchQuery, Pattern.CASE_INSENSITIVE);
        return p.matcher(value).matches();
    }

#No. 4413
#File: E:\bishe\1\AbstractReplacement.java
#Comment:
    /**
     * @param step
     *            The step in which the search should be performed.
     * @param searchQuery
     *            The search Query.
     * @param replaceString
     *            The replacement string.
     * @param requestDatas
     *            The set of RequestData where the replacements should be searched for.
     * @param searchMode
     *            The search mode for the replacements
     * @return
     */

#Code:
    protected List<ReplaceEntity> getReplacementsInRequestData(ScriptStep step, String searchQuery,
            String replaceString,
            Set<RequestData> requestDatas, SearchMode searchMode) {
        List<ReplaceEntity> reList = new ArrayList<ReplaceEntity>();
        for (RequestData requestData : requestDatas) {
            if (searchMode == SearchMode.all) {
                reList.addAll(getReplacementInValue(searchQuery, replaceString, requestData.getValue(), step.getType(),
                        requestData.getKey()));
                reList.addAll(getReplacementInKey(searchQuery, replaceString, requestData.getValue(), step.getType(),
                        requestData.getKey()));
            } else if (searchMode == SearchMode.keyOnly) {
                reList.addAll(getReplacementInKey(searchQuery, replaceString, requestData.getValue(), step.getType(),
                        requestData.getKey()));
            } else if (searchMode == SearchMode.valueOnly) {
                reList.addAll(getReplacementInValue(searchQuery, replaceString, requestData.getValue(), step.getType(),
                        requestData.getKey()));
            }
        }
        return reList;
    }

#No. 4414
#File: E:\bishe\1\AbstractReplacement.java
#Comment:
    /**
     * Replace the value in the replacement entity.
     * 
     * @param requestDatas
     *            The post datas
     * @param replaceString
     *            The replacement string
     * @param key
     *            TODO
     * @return
     */

#Code:
    protected void replaceInRequestDatas(Set<RequestData> requestDatas, String replaceString, String key) {
        for (RequestData requestData : requestDatas) {
            if (requestData.getKey().equals(key)) {
                requestData.setValue(replaceString);
            }
        }
    }

#No. 4415
#File: E:\bishe\1\AbstractReplacement.java
#Comment:
    /**
     * Replace the key in the replacement entity.
     * 
     * @param requestDatas
     *            The post datas
     * @param keyReplaceString
     *            The replacement string
     * @param key
     *            TODO
     * @return
     */

#Code:
    protected void replaceInRequestDatas(Set<RequestData> requestDatas, String replaceString, String key,
            ReplaceMode replaceMode) {
        for (RequestData requestData : requestDatas) {
            if (requestData.getKey().equals(key)) {
                if (replaceMode == ReplaceMode.KEY) {
                    requestData.setKey(replaceString);
                } else {
                    requestData.setValue(replaceString);
                }
            }
        }
    }

#No. 4416
#File: E:\bishe\1\AbstractReplacement.java
#Comment:
    /**
     * Gets the replacement.
     * 
     * @param step
     *            the step where the replacement is to be searched
     * @param searchQuery
     *            The search Query.
     * @param replaceString
     *            The replacement string which should be set within the replacements if replacements are identified
     * @param searchMode
     *            The mode of the search.
     * @return
     */

#Code:
    public abstract List<ReplaceEntity> getReplacements(ScriptStep step, String searchQuery, String replaceString,
            SearchMode searchMode);

    /**
     * Replace the value in the step with replaceString
     * 
     * @param step
     *            the step in which the replacements is to be performed.
     * @param replaceString
     *            the replacement string
     * @param key
     *            TODO
     * @param replaceMode
     *            the field to be replaced
     */
    public abstract void replace(ScriptStep step, String replaceString, String key, ReplaceMode replaceMode);

}
}

#No. 4417
#File: E:\bishe\1\AbstractReplicationChannelDataFilter.java
#Comment:
/**
 * @author Dan Kilman
 * @since 9.0
 */

#Code:
public abstract class AbstractReplicationChannelDataFilter
        implements IReplicationChannelDataFilter {

    @Override
    public void filterAfterReplicatedEntryData(
            IReplicationPacketEntryData data,
            PlatformLogicalVersion targetLogicalVersion,
            IReplicationPacketEntryDataContentExtractor contentExtractor,
            Logger contextLogger) {

    }

    @Override
    public boolean filterBeforeReplicatingEntryDataHasSideEffects() {
        return false;
    }

}

#No. 4418
#File: E:\bishe\1\AbstractReplicationPacket.java
#Comment:
    /**
     * Process the replication packet at the target side.
     *
     * @param sourceMemberLookupName source of the packet
     * @param replicationNode        target replication node
     * @return process result
     */

#Code:
    public abstract T accept(IIncomingReplicationFacade incomingReplicationFacade);

    @Override
    public String toString() {
        return Textualizer.toString(this);
    }

#No. 4419
#File: E:\bishe\1\AbstractReplicationSourceChannel.java
#Comment:
    /**
     * If this packets were sent in a delay, i.e not at sync state, this will validate this packets
     * are still relevant and need to be updated or they should be discarded
     *
     * @return a list of processed packets, containing discarded packets instead of packets that are
     * not relevant any more
     */

#Code:
    private List<IReplicationOrderedPacket> beforeDelayedReplication(
            List<IReplicationOrderedPacket> packets) {
        List<IReplicationOrderedPacket> result = new LinkedList<IReplicationOrderedPacket>();
        for (IReplicationOrderedPacket packet : packets) {
            // Check if the packet is still relevant, if not replace it with
            // discarded packet
            final boolean stillRelevant = packet.getData()
                    .beforeDelayedReplication();

            if (stillRelevant) {
                result.add(packet);
            } else {
                if (_specificLogger.isLoggable(Level.FINER))
                    _specificLogger.finer("Packet [" + packet.toString() + "] discarded by the channel filter");
                result.add(getGroupBacklog().replaceWithDiscarded(packet, false));
            }
        }

        return result;
    }

#No. 4420
#File: E:\bishe\1\AbstractReplicationSourceChannel.java
#Comment:
    /**
     * Replicate given packets
     *
     * @return number of completed replications
     */

#Code:
    protected int replicateBatch(List<IReplicationOrderedPacket> packets)
            throws RemoteException, ReplicationException {
        if (packets == null || packets.isEmpty())
            return 0;

        packets = invokeBeforeReplicatingChannelDataFilter(packets);

        return replicateBatchAfterChannelFilter(packets);
    }

#No. 4421
#File: E:\bishe\1\AbstractReplicationSourceChannel.java
#Comment:
    /**
     * This method should be called when replicating packets that were generated at a considerable
     * time before the actual replication (i.e async replication), this will replicate only packets
     * that are not obsolete (i.e {@link IReplicationPacketData#beforeDelayedReplication() equals
     * true})
     */

#Code:
    protected void replicateBatchDelayed(List<IReplicationOrderedPacket> packets)
            throws RemoteException, ReplicationException {
        // Execute before delayed first to filter obsolete packets
        packets = beforeDelayedReplication(packets);
        // Replicate packets
        replicateBatchAfterChannelFilter(packets);
    }

#No. 4422
#File: E:\bishe\1\AbstractReplicationSourceChannel.java
#Comment:
    /**
     * Get a list of packets that are waiting to be replicated
     */

#Code:
    protected List<IReplicationOrderedPacket> getPendingPackets(int batchSize) {
        return _groupBacklog.getPackets(getMemberName(),
                batchSize,
                getDataFilter(),
                getTargetLogicalVersion(),
                _specificLogger);
    }

#No. 4423
#File: E:\bishe\1\AbstractReplicationTargetChannel.java
#Comment:
    /*
     * @see
     * com.gigaspaces.internal.cluster.node.impl.groups.IReplicationInFilterCallback
     * #invokeInFilter(com.gigaspaces.internal.cluster.node.impl.packets.data.
     * IReplicationPacketData)
     */

#Code:
    public void invokeInFilter(IReplicationInContext context,
                               IReplicationPacketData<?> data) {
        if (!data.supportsReplicationFilter())
            return;

        // Each packet can become more than one filter entry
        // (transaction)
        Iterable<IReplicationFilterEntry> filterEntries = _processLog.getDataConsumer()
                .toFilterEntries(context, data);
        // Invoke filter on entries
        for (IReplicationFilterEntry filterEntry : filterEntries) {
            _inFilter.filterIn(filterEntry, getSourceLookupName(), _groupName);
        }

        if (data.isEmpty()) {
            if (_specificLogger.isLoggable(Level.FINER))
                _specificLogger.finer("Input filter discarded packet " + data);
        }
    }

#No. 4424
#File: E:\bishe\1\AbstractResetableProperty.java
#Comment:
    /**
     * The constructor of {@code AbstractResetableProperty}
     *
     * @param bean the bean of this {@code AbstractResetableProperty}
     * @param name the name of this {@code AbstractResetableProperty}
     */

#Code:
    public AbstractResetableProperty(@Nullable Object bean, @Nonnull String name) {
        this(bean, name, null);
    }

    /**
     * The constructor of {@code AbstractResetableProperty}
     *
     * @param bean      the bean of this {@code AbstractResetableProperty}
     * @param name      the name of this {@code AbstractResetableProperty}
     * @param baseValue the base value  of this {@code AbstractResetableProperty}
     */
    public AbstractResetableProperty(@Nullable Object bean, @Nonnull String name, @Nullable T baseValue) {
        this.bean = bean;
        this.name = isBlank(name) ? DEFAULT_NAME : name;

        writableBaseValueProperty().setValue(baseValue);
        setValue(baseValue);

        dirty = createDirtyBinding();
    }

    @Nonnull
    protected BooleanBinding createDirtyBinding() {
        return Bindings.createBooleanBinding(new Callable<Boolean>() {
            @Override
            public Boolean call() throws Exception {
                return AbstractResetableProperty.this.checkValuesAreNotEqual();
            }
        }, baseValueProperty(), valueProperty());
    }

#No. 4425
#File: E:\bishe\1\AbstractResolver.java
#Comment:
    /**
     * 解析表达式的值部分, 返回null表示表达式值部分存在问题, 调用者应该抛出异常
     *
     * @param value 表达式的值部分, 需要提前做过term操作
     * @return 返回null表示表达式值部分存在问题, 调用者应该抛出异常
     */

#Code:
    abstract Map.Entry<StrValueConvert, T> resolveValue(String value) throws ResolveExpressionException;

    abstract FieldCondition createFieldCondition(String field, Map.Entry<StrValueConvert, T> value);

    @Override
    public final FieldCondition resolve(String filed, String strValue) throws ResolveExpressionException {
        Map.Entry<StrValueConvert, T> value = resolveValue(strValue);
        return createFieldCondition(filed, value);
    }

#No. 4426
#File: E:\bishe\1\AbstractResolver.java
#Comment:
    /**
     * 识别该字符串表示的class
     *
     * @param value 字符串值, 左右都是经过trim的
     * @return 对应类型的class, 如果为null则value就是null了
     */

#Code:
    static Class parseValueClass(String value) {
        if (value.equals("null")) return null;
        if (BOOLEAN_VALUES.contains(value.toLowerCase())) return Boolean.class;
        if (StrValueConverts.getBasicConvert(Date.class).convert(value) != null) return Date.class;
        boolean hadPoint = false;
        for (int i = value.length() - 1; i >= 0; i--) {
            char c = value.charAt(i);
            //非字符, 很定时字符串了
            if (c == '.') {
                if (hadPoint) return String.class;
                hadPoint = true;
            } else if (c < '0' || c > '9') {
                return String.class;
            }
        }
        //超过10位的数字, 则为long
        return hadPoint ? BigDecimal.class : (value.length() >= 10 ? Long.class : Integer.class);
    }

#No. 4427
#File: E:\bishe\1\AbstractResourceBuilder.java
#Comment:
    /**
     * Collects every simulink element whiches OSLC resource this builder can build.
     * @param commandFactory The matlab command factory to use.
     * @param systemId The id of the simulink system.
     * @param page The page number.
     * @param limit The number of elements on an individual page.
     * @return The list of OSLC resources.
     */

#Code:
    public abstract List<AbstractResource> collect(final MatlabCommandFactory commandFactory, final String systemId, int page, int limit);

    /**
     * Creates a new empty OSLC resource specific to the builder implementation.
     * @return The empty OSLC resource.
     * @throws URISyntaxException
     */
    public abstract AbstractResource newInstance() throws URISyntaxException;

    /**
     * Gets the URI of the OSLC resource.
     * @param id The id of the simulink element.
     * @param systemId The id of the simulink system.
     * @return
     */
    public abstract URI getAbout(String id, String systemId);

    /**
     * Returns the class the builder can build.
     * @return The class the builder can build.
     */
    public Class<? extends AbstractResource> getForClazz() {
        return forClazz;
    }

#No. 4428
#File: E:\bishe\1\AbstractResourceBuilder.java
#Comment:
    /**
     * Sets the class the builder can build.
     * @forClass The class the builder can build.
     */

#Code:
    public void setForClazz(final Class<? extends AbstractResource> forClass) {
        forClazz = forClass;
    }

#No. 4429
#File: E:\bishe\1\AbstractResourceDescriptor.java
#Comment:
    /**
     * Constructs new instance of AbstractResourceDescriptor.
     *
     * @param resourceClass
     *         resource class
     */

#Code:
    public AbstractResourceDescriptor(Class<?> resourceClass) {
        this(PathValue.getPath(resourceClass.getAnnotation(Path.class)), resourceClass);
    }

#No. 4430
#File: E:\bishe\1\AbstractResourceDescriptor.java
#Comment:
    /**
     * Constructs new instance of AbstractResourceDescriptor.
     *
     * @param resource
     *         resource
     */

#Code:
    public AbstractResourceDescriptor(Object resource) {
        this(resource.getClass());
    }

#No. 4431
#File: E:\bishe\1\AbstractResourceDescriptor.java
#Comment:
    /**
     * According to JSR-311:
     * <p>
     * On receipt of a HEAD request an implementation MUST either: 1. Call method annotated with request method
     * designation for HEAD or, if none present, 2. Call method annotated with a request method designation GET and
     * discard any returned entity.
     * </p>
     */

#Code:
    private void resolveHeadRequest() {
        List<ResourceMethodDescriptor> getResources = resourceMethods.get(HttpMethod.GET);
        if (getResources != null && getResources.size() > 0) {
            List<ResourceMethodDescriptor> headResources = getResourceMethods(HttpMethod.HEAD);
            for (ResourceMethodDescriptor resourceMethod : getResources) {
                if (findMethodResourceMediaType(headResources, resourceMethod.consumes(), resourceMethod.produces()) == null) {
                    headResources.add(
                            new ResourceMethodDescriptorImpl(resourceMethod.getMethod(), HttpMethod.HEAD,
                                                             resourceMethod.getMethodParameters(), this, resourceMethod.consumes(),
                                                             resourceMethod.produces(),
                                                             resourceMethod.getAnnotations()));
                }
            }
        }

        for (Map<String, List<SubResourceMethodDescriptor>> allSubResourceMethods : subResourceMethods.values()) {
            List<SubResourceMethodDescriptor> getSubResources = allSubResourceMethods.get(HttpMethod.GET);
            if (getSubResources != null && getSubResources.size() > 0) {
                List<SubResourceMethodDescriptor> headSubResources = allSubResourceMethods.get(HttpMethod.HEAD);
                if (headSubResources == null) {
                    headSubResources = new ArrayList<>();
                    allSubResourceMethods.put(HttpMethod.HEAD, headSubResources);
                }
                for (SubResourceMethodDescriptor subResourceMethod : getSubResources) {
                    if (findMethodResourceMediaType(headSubResources, subResourceMethod.consumes(), subResourceMethod.produces()) == null) {
                        headSubResources.add(
                                new SubResourceMethodDescriptorImpl(subResourceMethod.getPathValue(), subResourceMethod.getMethod(),
                                                                    HttpMethod.HEAD, subResourceMethod.getMethodParameters(), this,
                                                                    subResourceMethod.consumes(),
                                                                    subResourceMethod.produces(), subResourceMethod.getAnnotations()));
                    }
                }
            }
        }
    }

#No. 4432
#File: E:\bishe\1\AbstractResourceDescriptor.java
#Comment:
    /**
     * According to JSR-311:
     * <p>
     * On receipt of a OPTIONS request an implementation MUST either: 1. Call method annotated with request method
     * designation for OPTIONS or, if none present, 2. Generate an automatic response using the metadata provided by the
     * JAX-RS annotations on the matching class and its methods.
     * </p>
     */

#Code:
    private void resolveOptionsRequest() {
        List<ResourceMethodDescriptor> optionResources = getResourceMethods(HttpMethod.OPTIONS);
        if (optionResources.isEmpty()) {
            List<Parameter> methodParameters = Collections.emptyList();
            List<MediaType> consumes = Collections.singletonList(WILDCARD_TYPE);
            List<MediaType> produces = Collections.singletonList(WADL_TYPE);
            optionResources.add(new OptionsRequestResourceMethodDescriptorImpl("OPTIONS", methodParameters, this, consumes, produces, new Annotation[0]));
        }
    }

#No. 4433
#File: E:\bishe\1\AbstractResourceDescriptor.java
#Comment:
    /**
     * Get all method with at least one annotation which has annotation <i>annotation</i>. It is useful for annotation
     * {@link javax.ws.rs.GET}, etc. All HTTP method annotations has annotation {@link javax.ws.rs.HttpMethod}.
     *
     * @param <T>
     *         annotation type
     * @param method
     *         method
     * @param annotationClass
     *         annotation class
     * @return list of annotation
     */

#Code:
    private <T extends Annotation> T getMetaAnnotation(Method method, Class<T> annotationClass) {
        for (Annotation annotation : method.getAnnotations()) {
            T result;
            if ((result = annotation.annotationType().getAnnotation(annotationClass)) != null) {
                return result;
            }
        }
        return null;
    }

#No. 4434
#File: E:\bishe\1\AbstractResourceDescriptor.java
#Comment:
    /**
     * Tries to get JAX-RS annotation on method from the resource class's superclasses or implemented interfaces.
     *
     * @param <T>
     *         annotation type
     * @param method
     *         method for discovering
     * @param resourceClass
     *         class that contains discovered method
     * @param annotationClass
     *         annotation type what we are looking for
     * @param metaAnnotation
     *         false if annotation should be on method and true in method should contain annotations that
     *         has supplied annotation
     * @return annotation from class or its ancestor or null if nothing found
     */

#Code:
    private <T extends Annotation> T getMethodAnnotation(Method method,
                                                         Class<?> resourceClass,
                                                         Class<T> annotationClass,
                                                         boolean metaAnnotation) {
        T annotation = metaAnnotation ? getMetaAnnotation(method, annotationClass) : method.getAnnotation(annotationClass);

        if (annotation == null) {
            Method myMethod;
            Class<?> myClass = resourceClass;
            while (annotation == null && myClass != null && myClass != Object.class) {
                for (Class<?> anInterface : myClass.getInterfaces()) {
                    try {
                        myMethod = anInterface.getDeclaredMethod(method.getName(), method.getParameterTypes());
                        T newAnnotation = metaAnnotation ? getMetaAnnotation(myMethod, annotationClass) : myMethod.getAnnotation(annotationClass);
                        if (annotation == null) {
                            annotation = newAnnotation;
                        } else {
                            throw new RuntimeException(String.format("Conflicts of JAX-RS annotations on method %s of resource %s. " +
                                                                     "Method is declared in more than one interface and different interfaces contains JAX-RS annotations.",
                                                                     myMethod.getName(), resourceClass.getName()));
                        }
                    } catch (NoSuchMethodException ignored) {
                    }
                }
                if (annotation == null) {
                    myClass = myClass.getSuperclass();
                    if (myClass != null && myClass != Object.class) {
                        try {
                            myMethod = myClass.getDeclaredMethod(method.getName(), method.getParameterTypes());
                            annotation = metaAnnotation ? getMetaAnnotation(myMethod, annotationClass) : myMethod.getAnnotation(annotationClass);
                        } catch (NoSuchMethodException ignored) {
                        }
                    }
                }
            }
        }

        return annotation;
    }

#No. 4435
#File: E:\bishe\1\AbstractResourceDescriptor.java
#Comment:
    /**
     * Check is collection of {@link org.everrest.core.resource.ResourceMethodDescriptor} already contains ResourceMethodDescriptor with
     * the same media types.
     *
     * @param resourceMethods
     *         {@link java.util.Set} of {@link org.everrest.core.resource.ResourceMethodDescriptor}
     * @param consumes
     *         resource method consumed media type
     * @param produces
     *         resource method produced media type
     * @return ResourceMethodDescriptor or null if nothing found
     */

#Code:
    private <T extends ResourceMethodDescriptor> ResourceMethodDescriptor findMethodResourceMediaType(List<T> resourceMethods,
                                                                                                      List<MediaType> consumes,
                                                                                                      List<MediaType> produces) {
        if (resourceMethods == null || resourceMethods.isEmpty()) {
            return null;
        }
        ResourceMethodDescriptor matched = null;
        for (Iterator<T> iterator = resourceMethods.iterator(); matched == null && iterator.hasNext(); ) {
            T method = iterator.next();

            if (method.consumes().size() != consumes.size() || method.produces().size() != produces.size()) {
                continue;
            }

            if (method.consumes().containsAll(consumes) && method.produces().containsAll(produces)) {
                matched = method;
            }
        }
        return matched;
    }

#No. 4436
#File: E:\bishe\1\AbstractResourceDescriptor.java
#Comment:
    /**
     * Get security annotation (DenyAll, RolesAllowed, PermitAll) from <code>method</code> or class
     * <code>clazz</class> which contains method.
     * Supper class or implemented interfaces will be also checked. Annotation
     * on method has the advantage on annotation on class or interface.
     *
     * @param method
     *         method to be checked for security annotation
     * @param clazz
     *         class which contains <code>method</code>
     * @return one of security annotation or <code>null</code> is no such annotation found
     * @see javax.annotation.security.DenyAll
     * @see javax.annotation.security.RolesAllowed
     * @see javax.annotation.security.PermitAll
     */

#Code:
    @SuppressWarnings("unchecked")
    private <T extends Annotation> T getSecurityAnnotation(Method method, Class<?> clazz) {
        Class<T>[] securityAnnotationClassesClasses = new Class[]{DenyAll.class, RolesAllowed.class, PermitAll.class};
        T annotation = getAnnotation(method, securityAnnotationClassesClasses);
        if (annotation == null) {
            annotation = getAnnotation(clazz, securityAnnotationClassesClasses);
            if (annotation == null) {
                Method myMethod;
                Class<?> myClass = clazz;
                while (annotation == null && myClass != null && myClass != Object.class) {
                    Class<?>[] interfaces = myClass.getInterfaces();
                    for (int i = 0; annotation == null && i < interfaces.length; i++) {
                        try {
                            myMethod = interfaces[i].getDeclaredMethod(method.getName(), method.getParameterTypes());
                            annotation = getAnnotation(myMethod, securityAnnotationClassesClasses);
                        } catch (NoSuchMethodException ignored) {
                        }
                        if (annotation == null) {
                            annotation = getAnnotation(interfaces[i], securityAnnotationClassesClasses);
                        }
                    }
                    if (annotation == null) {
                        myClass = myClass.getSuperclass();
                        if (myClass != null && myClass != Object.class) {
                            try {
                                myMethod = myClass.getDeclaredMethod(method.getName(), method.getParameterTypes());
                                annotation = getAnnotation(myMethod, securityAnnotationClassesClasses);
                            } catch (NoSuchMethodException ignored) {
                            }
                            if (annotation == null) {
                                annotation = getAnnotation(myClass, securityAnnotationClassesClasses);
                            }
                        }
                    }
                }
            }
        }
        return annotation;
    }

#No. 4437
#File: E:\bishe\1\AbstractResourceManager.java
#Comment:
	/**
	 * The constructor
	 *
	 * @param storage the storage
	 * @param clazz   type class
	 */

#Code:
	protected AbstractResourceManager(Storage storage, Class<T> clazz) {
		this.storage = storage;
		this.clazz = clazz;
		register(clazz);
	}

#No. 4438
#File: E:\bishe\1\AbstractResourceManager.java
#Comment:
	/**
	 * Gets the storage
	 *
	 * @return the storage
	 */

#Code:
	protected Storage getStorage() {
		return storage;
	}

#No. 4439
#File: E:\bishe\1\AbstractResourceManager.java
#Comment:
	/**
	 * Registers the manager
	 *
	 * @param clazz type class
	 */

#Code:
	private void register(Class clazz) {
		getStorage().registerResourceManager(clazz, this);
	}

#No. 4440
#File: E:\bishe\1\AbstractResourcePool.java
#Comment:
    /**
     * We defer actual acquisition of the resources to a 
     * method outside the constructor because subclasses
     * may need to do prep work in their own constructor
     * before resource acquisition can occur. This method
     * will usually be called at the end of a subclasses
     * constructor.
     */

#Code:
    protected synchronized void init() throws Exception
    {
	for (int i = 0; i < start; ++i) assimilateResource();

	this.initted = true;
    }

#No. 4441
#File: E:\bishe\1\AbstractResourceServices.java
#Comment:
    /*
     * Trivial implementation that does *not* leverage bootstrap validation nor caching
     */

#Code:
    @Override
    public ResourceReferenceFactory<Object> registerResourceInjectionPoint(final InjectionPoint injectionPoint) {
        return new ResourceReferenceFactory<Object>() {
            @Override
            public ResourceReference<Object> createResource() {
                return new SimpleResourceReference<Object>(resolveResource(injectionPoint));
            }
        };
    }

#No. 4442
#File: E:\bishe\1\AbstractResourceServices.java
#Comment:
    /*
     * Trivial implementation that does *not* leverage bootstrap validation nor caching
     */

#Code:
    @Override
    public ResourceReferenceFactory<Object> registerResourceInjectionPoint(final String jndiName,
            final String mappedName) {
        return new ResourceReferenceFactory<Object>() {
            @Override
            public ResourceReference<Object> createResource() {
                return new SimpleResourceReference<Object>(resolveResource(jndiName, mappedName));
            }
        };
    }

#No. 4443
#File: E:\bishe\1\AbstractResponseWriter.java
#Comment:
/**
 * Helper methods for ResponseWriters
 */

#Code:
public abstract class AbstractResponseWriter
   implements ResponseWriter
{
   protected static List<Language> ENGLISH = Arrays.asList( Language.ENGLISH );

   protected Variant getVariant( Request request, List<Language> possibleLanguages, List<MediaType> possibleMediaTypes )
   {
      Language language = request.getClientInfo().getPreferredLanguage( possibleLanguages );

      if (language == null)
         language = possibleLanguages.get( 0 );

      MediaType responseType = request.getClientInfo().getPreferredMediaType( possibleMediaTypes );

      if (responseType == null && request.getClientInfo().getPreferredMediaType( Collections.singletonList( MediaType.ALL)) == MediaType.ALL)
      {
         responseType = possibleMediaTypes.get( 0 );
      }

      Variant variant = new Variant( responseType, language );
      variant.setCharacterSet( CharacterSet.UTF_8 );

      return variant;
   }

}

#No. 4444
#File: E:\bishe\1\AbstractRestaurantControllerTests.java
#Comment:
    /**
     * RESTAURANT ID constant having value 1
     */

#Code:
    protected static final String RESTAURANT = "1";

    /**
     * RESTAURANT name constant having value Big-O Restaurant
     */
    protected static final String RESTAURANT_NAME = "Le Meurice";

    /**
     * RESTAURANT address constant
     */
    protected static final String RESTAURANT_ADDRESS = "228 rue de Rivoli, 75001, Paris";

    @Autowired
    RestaurantController restaurantController;

    /**
     * Test method for findById method
     */
    @Test
    public void validResturantById() {
        Logger.getGlobal().info("Start validResturantById test");
        ResponseEntity<Entity> restaurant = restaurantController.findById(RESTAURANT);

        Assert.assertEquals(HttpStatus.OK, restaurant.getStatusCode());
        Assert.assertTrue(restaurant.hasBody());
        Assert.assertNotNull(restaurant.getBody());
        Assert.assertEquals(RESTAURANT, restaurant.getBody().getId());
        Assert.assertEquals(RESTAURANT_NAME, restaurant.getBody().getName());
        Logger.getGlobal().info("End validResturantById test");
    }

#No. 4445
#File: E:\bishe\1\AbstractRestaurantControllerTests.java
#Comment:
    /**
     * Test method for findByName method
     */

#Code:
    @Test
    public void validResturantByName() {
        Logger.getGlobal().info("Start validResturantByName test");
        ResponseEntity<Collection<Restaurant>> restaurants = restaurantController.findByName(RESTAURANT_NAME);
        Logger.getGlobal().info("In validAccount test");

        Assert.assertEquals(HttpStatus.OK, restaurants.getStatusCode());
        Assert.assertTrue(restaurants.hasBody());
        Assert.assertNotNull(restaurants.getBody());
        Assert.assertFalse(restaurants.getBody().isEmpty());
        Restaurant restaurant = (Restaurant) restaurants.getBody().toArray()[0];
        Assert.assertEquals(RESTAURANT, restaurant.getId());
        Assert.assertEquals(RESTAURANT_NAME, restaurant.getName());
        Logger.getGlobal().info("End validResturantByName test");
    }

#No. 4446
#File: E:\bishe\1\AbstractRestaurantControllerTests.java
#Comment:
    /**
     * Test method for add method
     */

#Code:
    @Test
    public void validAdd() {
        Logger.getGlobal().info("Start validAdd test");
        RestaurantVO restaurant = new RestaurantVO();
        restaurant.setId("999");
        restaurant.setName("Test Restaurant");

        ResponseEntity<Restaurant> restaurants = restaurantController.add(restaurant);
        Assert.assertEquals(HttpStatus.CREATED, restaurants.getStatusCode());
        Logger.getGlobal().info("End validAdd test");
    }

#No. 4447
#File: E:\bishe\1\AbstractRestCommandJob.java
#Comment:
    /**
     * Construct the post.
     *
     * @param reviewInput    input
     * @param reviewEndpoint end point
     * @return the entity
     */

#Code:
    private HttpPost createHttpPostEntity(ReviewInput reviewInput, String reviewEndpoint) {
        HttpPost httpPost = new HttpPost(reviewEndpoint);

        String asJson = GSON.toJson(reviewInput);

        StringEntity entity = null;
        try {
            entity = new StringEntity(asJson);
        } catch (UnsupportedEncodingException e) {
            logger.error("Failed to create JSON for posting to Gerrit", e);
            if (altLogger != null) {
                altLogger.print("ERROR Failed to create JSON for posting to Gerrit: " + e.toString());
            }
            return null;
        }
        entity.setContentType("application/json");
        httpPost.setEntity(entity);
        return httpPost;
    }

#No. 4448
#File: E:\bishe\1\AbstractRestCommandJob.java
#Comment:
    /**
     * What it says resolve Endpoint URL.
     *
     * @return the url.
     */

#Code:
    private String resolveEndpointURL() {
        String gerritFrontEndUrl = config.getGerritFrontEndUrl();
        if (!gerritFrontEndUrl.endsWith("/")) {
            gerritFrontEndUrl = gerritFrontEndUrl + "/";
        }

        ChangeId changeId = new ChangeId(event.getChange().getProject(), event.getChange().getBranch(),
                event.getChange().getId());

        return gerritFrontEndUrl + "a/changes/" + changeId.asUrlPart()
                + "/revisions/" + event.getPatchSet().getRevision() + "/review";
    }

#No. 4449
#File: E:\bishe\1\AbstractRestCommandJob.java
#Comment:
    /**
     * REST related configuration.
     * @return the config
     */

#Code:
    public RestConnectionConfig getConfig() {
        return config;
    }

#No. 4450
#File: E:\bishe\1\AbstractRestCommandJob2.java
#Comment:
    /**
     * Construct the post.
     *
     * @param reviewInput    input
     * @param reviewEndpoint end point
     * @return the entity
     */

#Code:
    private HttpPost createHttpPostEntity(ReviewInput reviewInput, String reviewEndpoint) {
        HttpPost httpPost = new HttpPost(reviewEndpoint);

        String asJson = GSON.toJson(reviewInput);

        StringEntity entity = null;
        try {
            entity = new StringEntity(asJson);
        } catch (UnsupportedEncodingException e) {
            logger.error("Failed to create JSON for posting to Gerrit", e);
            if (altLogger != null) {
                altLogger.print("ERROR Failed to create JSON for posting to Gerrit: " + e.toString());
            }
            return null;
        }
        entity.setContentType("application/json");
        httpPost.setEntity(entity);
        return httpPost;
    }

#No. 4451
#File: E:\bishe\1\AbstractRestCommandJob2.java
#Comment:
    /**
     * What it says resolve Endpoint URL.
     *
     * @return the url.
     */

#Code:
    private String resolveEndpointURL() {
        String gerritFrontEndUrl = frontEndUrl;
        if (!gerritFrontEndUrl.endsWith("/")) {
            gerritFrontEndUrl = gerritFrontEndUrl + "/";
        }

        ChangeId changeId = new ChangeId(event.getChange().getProject(), event.getChange().getBranch(),
                event.getChange().getId());

        return gerritFrontEndUrl + "a/changes/" + changeId.asUrlPart()
                + "/revisions/" + event.getPatchSet().getRevision() + "/review";
    }

#No. 4452
#File: E:\bishe\1\AbstractRestIntegrationTest.java
#Comment:
    /**
     * Get response code from the response string.
     *
     * @param response
     * @return
     * @throws Exception
     */

#Code:
    public int getResponseCode(String response) throws Exception {
        ObjectMapper mapper = new ObjectMapper();
        JsonNode node = mapper.readTree(response);
        return mapper.treeToValue(node.get("responseCode"), Integer.class);
    }

#No. 4453
#File: E:\bishe\1\AbstractRestIntegrationTest.java
#Comment:
    /**
     * Get the entities from response string
     *
     * @param response
     * @param clazz
     * @param <T>
     * @return
     */

#Code:
    protected <T> List<T> getEntities(String response, Class<T> clazz,
                                      List<String> fieldsToIgnore) {
        List<T> entities = new ArrayList<>();
        try {
            ObjectMapper mapper = new ObjectMapper();
            JsonNode node = mapper.readTree(response);
            Iterator<JsonNode> it = node.get("entities").elements();
            while (it.hasNext()) {
                entities.add(filterFields(mapper.treeToValue(it.next(), clazz), fieldsToIgnore));
            }
        } catch (Exception ex) {
            throw new RuntimeException(ex);
        }
        return entities;
    }

#No. 4454
#File: E:\bishe\1\AbstractRestIntegrationTest.java
#Comment:
    /**
     * Get entity from the response string.
     *
     * @param response
     * @param clazz
     * @param <T>
     * @return
     */

#Code:
    protected <T> T getEntity(String response, Class<T> clazz,
                              List<String> fieldsToIgnore) {
        try {
            ObjectMapper mapper = new ObjectMapper();
            JsonNode node = mapper.readTree(response);
            return filterFields(mapper.treeToValue(node.get("entity"), clazz), fieldsToIgnore);
        } catch (Exception ex) {
            throw new RuntimeException(ex);
        }
    }

#No. 4455
#File: E:\bishe\1\AbstractRestModel.java
#Comment:
	/**
	 * Get the data for the model
	 * @return T
	 */

#Code:
	public T getData(){
		return data;
	}

#No. 4456
#File: E:\bishe\1\AbstractRestModel.java
#Comment:
	/**
	 * Used to validate the model.
	 * Override as required in subclassess
	 * @param response
	 */

#Code:
	@JsonIgnore
	public boolean validate(){
		return true;
	}

#No. 4457
#File: E:\bishe\1\AbstractResultAction.java
#Comment:
    /**
     * Returns the associated build of this action.
     *
     * @return the associated build of this action
     */

#Code:
    @WithBridgeMethods(value=AbstractBuild.class, adapterMethod="getAbstractBuild")
    public final Run<?, ?> getOwner() {
        return owner;
    }

#No. 4458
#File: E:\bishe\1\AbstractResultAction.java
#Comment:
    /**
     * Returns the project actions for this result action.
     *
     * @return default implementation returns empty collection, plug-in must override if they want to contribute to the UI.
     * FIXME: Make it abstract in 2.0
     */

#Code:
    @Override
    public Collection<? extends Action> getProjectActions() {
        return Collections.emptyList();
    }

#No. 4459
#File: E:\bishe\1\AbstractResultAction.java
#Comment:
    /**
     * Added for backward compatibility. It generates <pre>AbstractBuild getOwner()</pre> bytecode during the build
     * process, so old implementations can use that signature.
     * 
     * @see {@link WithBridgeMethods}
     */

#Code:
    @Deprecated
    private Object getAbstractBuild(final Run owner, final Class targetClass) {
      return owner instanceof AbstractBuild ? (AbstractBuild) owner : null;
    }

#No. 4460
#File: E:\bishe\1\AbstractResultAction.java
#Comment:
    /**
     * Returns whether a large image is defined.
     *
     * @return <code>true</code> if a large image is defined, <code>false</code>
     *         otherwise. If no large image is defined, then the attribute
     *         {@code icon} must to be provided in jelly tag {@code summary}.
     * @since 1.41
     */

#Code:
    public boolean hasLargeImage() {
        return StringUtils.isNotBlank(getLargeImageName());
    }

#No. 4461
#File: E:\bishe\1\AbstractResultAction.java
#Comment:
    /**
     * Returns the URL of the 48x48 image used in the build summary.
     *
     * @return the URL of the image
     * @since 1.41
     */

#Code:
    public String getLargeImageName() {
        return getDescriptor().getSummaryIconUrl();
    }

#No. 4462
#File: E:\bishe\1\AbstractResultAction.java
#Comment:
    /**
     * Returns the URL of the 24x24 image used in the build link.
     *
     * @return the URL of the image
     * @since 1.41
     */

#Code:
    public String getSmallImageName() {
        return getSmallImage();
    }

#No. 4463
#File: E:\bishe\1\AbstractResultAction.java
#Comment:
    /**
     * Returns the URL of the 24x24 image used in the build link.
     *
     * @return the URL of the image
     */

#Code:
    protected String getSmallImage() {
        return createStaticIconUrl(getDescriptor().getIconUrl());
    }

#No. 4464
#File: E:\bishe\1\AbstractResultAction.java
#Comment:
    /**
     * Factory method to create the result of this action.
     *
     * @return the result of this action
     */

#Code:
    protected ParserResult createResult() {
        return new ParserResult();
    }

#No. 4465
#File: E:\bishe\1\AbstractResultAction.java
#Comment:
    /**
     * Returns the tooltip for several items.
     *
     * @param numberOfItems
     *            the number of items to display the tooltip for
     * @return the tooltip for several items
     */

#Code:
    protected String getMultipleItemsTooltip(final int numberOfItems) {
        return Messages.ResultAction_MultipleWarnings(numberOfItems);
    }

#No. 4466
#File: E:\bishe\1\AbstractResultAction.java
#Comment:
    /**
     * Returns the tooltip for exactly one item.
     *
     * @return the tooltip for exactly one item
     */

#Code:
    protected String getSingleItemTooltip() {
        return Messages.ResultAction_OneWarning();
    }

#No. 4467
#File: E:\bishe\1\AbstractResultAction.java
#Comment:
    /**
     * Aggregates the results of the specified maven module builds.
     *
     * @param moduleBuilds
     *            the module builds to aggregate
     * @return the aggregated result
     * @deprecated replaced by {@link MavenResultAction}
     */

#Code:
    @Deprecated
    protected ParserResult createAggregatedResult(final Map<MavenModule, List<MavenBuild>> moduleBuilds) {
        return new ParserResult();
    }

#No. 4468
#File: E:\bishe\1\AbstractResultAction.java
#Comment:
    /**
     * Updates the build status if the number of annotations exceeds one of the
     * thresholds.
     *
     * @param build
     *            the build to change the status from
     * @param buildResult
     *            the build result
     * @deprecated replaced by {@link MavenResultAction}
     */

#Code:
    @Deprecated
    protected void updateBuildHealth(final MavenBuild build, final BuildResult buildResult) {
        // does nothing
    }

#No. 4469
#File: E:\bishe\1\AbstractResultAction.java
#Comment:
    /**
     * Adds a new module to the specified project. The new module is obtained
     * from the specified list of builds.
     *
     * @param aggregatedResult
     *            the result to add the module to
     * @param builds
     *            the builds for a module
     * @deprecated replaced by {@link MavenResultAction}
     */

#Code:
    @Deprecated
    protected void addModule(final ParserResult aggregatedResult, final List<MavenBuild> builds) {
        // does nothing
    }

#No. 4470
#File: E:\bishe\1\AbstractResultAction.java
#Comment:
    /**
     * Creates a new instance of <code>AbstractResultAction</code>.
     *
     * @param owner
     *            the associated build of this action
     * @param healthDescriptor
     *            health descriptor
     * @deprecated use
     *             {@link #AbstractResultAction(AbstractBuild, AbstractHealthDescriptor, BuildResult)}
     *             so that every action will have a result that is not null
     */

#Code:
    @Deprecated
    public AbstractResultAction(final AbstractBuild<?, ?> owner, final AbstractHealthDescriptor healthDescriptor) {
        this.owner = owner;
        this.healthDescriptor = healthDescriptor;
    }

#No. 4471
#File: E:\bishe\1\AbstractResultAction.java
#Comment:
    /**
     * Creates a new instance of <code>AbstractResultAction</code>.
     *
     * @param owner
     *            the associated build of this action
     * @param healthDescriptor
     *            health descriptor
     * @param result
     *            the result of the action
     * @deprecated use {@link #AbstractResultAction(Run, AbstractHealthDescriptor, BuildResult)} instead
     */

#Code:
    @Deprecated
    public AbstractResultAction(final AbstractBuild<?, ?> owner, final AbstractHealthDescriptor healthDescriptor, final T result) {
        this.owner = owner;
        this.result = result;
        this.healthDescriptor = healthDescriptor;
    }

#No. 4472
#File: E:\bishe\1\AbstractResultEventListenerAdapter.java
#Comment:
    /**
     * Sets if the write operation will perform an update in case the entry result already exists in
     * the space. Default to <code>true</code>.
     */

#Code:
    public void setUpdateOrWrite(boolean updateOrWrite) {
        this.updateOrWrite = updateOrWrite;
    }

#No. 4473
#File: E:\bishe\1\AbstractResultEventListenerAdapter.java
#Comment:
    /**
     * Sets the update timeout (im milliseconds) in case the flag {@link #setUpdateOrWrite(boolean)}
     * is set to <code>true</code>.
     */

#Code:
    public void setUpdateTimeout(long updateTimeout) {
        this.updateTimeout = updateTimeout;
    }

#No. 4474
#File: E:\bishe\1\AbstractResultEventListenerAdapter.java
#Comment:
    /**
     * Implements the {@link org.openspaces.events.SpaceDataEventListener} by delegating to {@link
     * #onEventWithResult(Object, org.openspaces.core.GigaSpace, org.springframework.transaction.TransactionStatus,
     * Object)} and writing the result back to the space (if it is not <code>null</code>) using
     * {@link #handleResult(Object, org.openspaces.core.GigaSpace)}.
     */

#Code:
    public void onEvent(Object data, GigaSpace gigaSpace, TransactionStatus txStatus, Object source) {
        Object result = onEventWithResult(data, gigaSpace, txStatus, source);
        handleResult(result, gigaSpace);
    }

#No. 4475
#File: E:\bishe\1\AbstractResultEventListenerAdapter.java
#Comment:
    /**
     * Writes the result back to the space (if not <code>null</code>) under the configured write
     * lease. Allows to be overridden in order to implement more advance result handling.
     *
     * <p> By default handles both single object and array of objects. Takes into account the {@link
     * #setUpdateOrWrite(boolean) 'updateOrWrite'} flag when writing/updating the result back to the
     * space.
     *
     * @param result    The result to write back to the space
     * @param gigaSpace The GigaSpace instance to operate against the space
     */

#Code:
    protected void handleResult(Object result, GigaSpace gigaSpace) throws DataAccessException {
        if (result != null) {
            if (result instanceof Object[]) {
                Object[] resultArr = (Object[]) result;
                if (updateOrWrite)
                    gigaSpace.writeMultiple(resultArr, writeLease, WriteModifiers.UPDATE_OR_WRITE);
                else
                    gigaSpace.writeMultiple(resultArr, writeLease, WriteModifiers.WRITE_ONLY);
            } else {
                if (updateOrWrite) {
                    gigaSpace.write(result, writeLease, updateTimeout, WriteModifiers.UPDATE_OR_WRITE);
                } else {
                    gigaSpace.write(result, writeLease, updateTimeout, WriteModifiers.WRITE_ONLY);
                }
            }
        }
    }

#No. 4476
#File: E:\bishe\1\AbstractResultParser.java
#Comment:
	/**
	 * Create new ResultParser
	 */

#Code:
	public AbstractResultParser() {
		this.dateFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'");
		this.dateFormat.setTimeZone(TimeZone.getTimeZone("UTC"));
	}

#No. 4477
#File: E:\bishe\1\AbstractResultParser.java
#Comment:
	/**
	 * Parse a received line into a {@link IGPSObject}
	 *
	 * @param line the line read from GPSd
	 * @return the parsed object
	 * @throws ParseException if parsing fails
	 */

#Code:
	public IGPSObject parse(final String line) throws ParseException {
		try {
			final JSONObject json = new JSONObject(line);
			return this.parse(json);
		} catch (final JSONException e) {
			throw new ParseException("Parsing failed", e);
		}
	}

#No. 4478
#File: E:\bishe\1\AbstractResultParser.java
#Comment:
	/**
	 * @param json
	 * @return the parsed {@link IGPSObject}
	 * @throws ParseException
	 */

#Code:
	public abstract IGPSObject parse(final JSONObject json) throws ParseException;
	
	/**
	 * parse a whole JSONArray into a list of IGPSObjects
	 */
	@SuppressWarnings({"unchecked", "unused"})
	protected <T extends IGPSObject> List<T> parseObjectArray(final JSONArray array, final Class<T> type) throws ParseException {
		try {
			if (array == null) {
				return new ArrayList<T>(10);
			}
			final List<T> objects = new ArrayList<T>(10);
			for (int i = 0; i < array.length(); i++) {
				objects.add((T) this.parse(array.getJSONObject(i)));
			}
			return objects;
		} catch (final JSONException e) {
			throw new ParseException("Parsing failed", e);
		}
	}

#No. 4479
#File: E:\bishe\1\AbstractResultSet.java
#Comment:
	/**
	 * Return the column at the ordinal location idx (e.g. 1 based).
	 *
	 * @param idx
	 * @return The column
	 * @throws SQLException
	 */

#Code:
	protected Column getColumn(final int idx) throws SQLException {
		checkColumn(idx);
		return table.getColumn(idx - 1);
	}

#No. 4480
#File: E:\bishe\1\AbstractResultSet.java
#Comment:
	/**
	 * Return the data object for the column from the dataset.
	 */

#Code:
	@Override
	public Object getObject(final int columnOrdinal) throws SQLException {
		final Object retval = readObject(columnOrdinal);
		lastReadWasNull = retval == null;
		return retval;
	}

#No. 4481
#File: E:\bishe\1\AbstractRetrieveIntentHandler.java
#Comment:
	/**
	 * Return the properties to use for controlling the retrieval.
	 * <p/>
	 * Classes may override this method to change default retrieval behaviour as
	 * required.
	 * 
	 * @return The properties to use to control retrieval behaviour.
	 */

#Code:
	protected IRetrievalProperties getRetrievalProperties()
	{
		return new RetrievalProperties();
	}

#No. 4482
#File: E:\bishe\1\AbstractRetryPolicy.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public void tryCall(Callable<Void> callable, Class<? extends Throwable> exception)
            throws Exception {
        int attempts = 0;
        while (attempts < maxAttempts) {
            try {
                callable.call();
                break;
            } catch (Exception e) {
                attempts++;
                if ((exception != null) && (exception.isAssignableFrom(e.getClass()))
                        && !(attempts >= maxAttempts)) {
                    Thread.sleep(getDelay(attempts));
                } else {
                    throw e;
                }
            }
        }
    }

#No. 4483
#File: E:\bishe\1\AbstractReusableInformationControlCreator.java
#Comment:
	/*
	 * @see org.eclipse.jface.text.IInformationControlCreator#createInformationControl(org.eclipse.swt.widgets.Shell)
	 */

#Code:
	public IInformationControl createInformationControl(Shell parent) {
		IInformationControl control= (IInformationControl)fInformationControls.get(parent);
		if (control == null) {
			control= doCreateInformationControl(parent);
			control.addDisposeListener(this);
			fInformationControls.put(parent, control);
		}
		return control;
	}

#No. 4484
#File: E:\bishe\1\AbstractReusableInformationControlCreator.java
#Comment:
	/*
	 * @see org.eclipse.swt.events.DisposeListener#widgetDisposed(org.eclipse.swt.events.DisposeEvent)
	 */

#Code:
	public void widgetDisposed(DisposeEvent e) {
		Composite parent= null;
		if (e.widget instanceof Shell)
			parent= ((Shell)e.widget).getParent();
		if (parent instanceof Shell)
			fInformationControls.remove(parent);
	}

#No. 4485
#File: E:\bishe\1\AbstractReusableInformationControlCreator.java
#Comment:
	/*
	 * @see org.eclipse.jface.text.IInformationControlCreatorExtension#canReuse(org.eclipse.jface.text.IInformationControl)
	 */

#Code:
	public boolean canReuse(IInformationControl control) {
		return fInformationControls.containsValue(control);
	}

#No. 4486
#File: E:\bishe\1\AbstractReusableInformationControlCreator.java
#Comment:
	/*
	 * @see org.eclipse.jface.text.IInformationControlCreatorExtension#canReplace(org.eclipse.jface.text.IInformationControlCreator)
	 */

#Code:
	public boolean canReplace(IInformationControlCreator creator) {
		return creator.getClass() == getClass();
	}

#No. 4487
#File: E:\bishe\1\AbstractRewritePomsPhase.java
#Comment:
    /**
     * 
     * @return {@code true} if the SCM-section should be updated, otherwise {@code false}
     * @since 2.4
     */

#Code:
    protected boolean isUpdateScm()
    {
        return true;
    }

#No. 4488
#File: E:\bishe\1\AbstractRewritePomsPhase.java
#Comment:
    /**
     * Determines the relative path from trunk to tag, and adds this relative path
     * to the url.
     *
     * @param trunkPath - The trunk url
     * @param tagPath   - The tag base
     * @param urlPath   - scm.url or scm.connection
     * @return The url path for the tag.
     */

#Code:
    protected static String translateUrlPath( String trunkPath, String tagPath, String urlPath )
    {
        trunkPath = trunkPath.trim();
        tagPath = tagPath.trim();
        //Strip the slash at the end if one is present
        if ( trunkPath.endsWith( "/" ) )
        {
            trunkPath = trunkPath.substring( 0, trunkPath.length() - 1 );
        }
        if ( tagPath.endsWith( "/" ) )
        {
            tagPath = tagPath.substring( 0, tagPath.length() - 1 );
        }
        char[] tagPathChars = trunkPath.toCharArray();
        char[] trunkPathChars = tagPath.toCharArray();
        // Find the common path between trunk and tags
        int i = 0;
        while ( ( i < tagPathChars.length ) && ( i < trunkPathChars.length ) && tagPathChars[i] == trunkPathChars[i] )
        {
            ++i;
        }
        // If there is nothing common between trunk and tags, or the relative
        // path does not exist in the url, then just return the tag.
        if ( i == 0 || urlPath.indexOf( trunkPath.substring( i ) ) < 0 )
        {
            return tagPath;
        }
        else
        {
            return StringUtils.replace( urlPath, trunkPath.substring( i ), tagPath.substring( i ) );
        }
    }

#No. 4489
#File: E:\bishe\1\AbstractRichInputAction.java
#Comment:
	/**
	 * 转换数据为JsonArray格式
	 * 
	 * @param array
	 * @param data
	 */

#Code:
	protected void convert2JsonArray(JSONArray array, List<T> data) {
		for (T d : data) {
			array.put(this.convert2JsonObject(d));
		}
	}

#No. 4490
#File: E:\bishe\1\AbstractRichInputAction.java
#Comment:
	/**
	 * 转换对象为JsonObject格式
	 * 
	 * @param obj
	 * @return
	 */

#Code:
	protected Object convert2JsonObject(T obj) {
		return obj;
	}

#No. 4491
#File: E:\bishe\1\AbstractRoutesParser.java
#Comment:
    /**
     * Parses routes data
     *
     * @param data Data with routes info
     * @return True on success parse, false otherwise.
     */

#Code:
    abstract public RouteList parse(InputStream data);


    public RouteList parseFile(String fileName) throws FileNotFoundException {
        return parseFile(new File(fileName));
    }

#No. 4492
#File: E:\bishe\1\AbstractRouteStrategy.java
#Comment:
		/**
     * 处理一些路由之前的逻辑
     * 全局序列号，父子表插入
     */

#Code:
		if ( beforeRouteProcess(schema, sqlType, origSQL, sc) ) {
			return null;
		}

#No. 4493
#File: E:\bishe\1\AbstractRouteStrategy.java
#Comment:
		/**
		 * SQL 语句拦截
		 */

#Code:
		String stmt = MycatServer.getInstance().getSqlInterceptor().interceptSQL(origSQL, sqlType);
		if (!origSQL.equals(stmt) && LOGGER.isDebugEnabled()) {
			LOGGER.debug("sql intercepted to " + stmt + " from " + origSQL);
		}

#No. 4494
#File: E:\bishe\1\AbstractRouteStrategy.java
#Comment:
		/**
		 * 优化debug loaddata输出cache的日志会极大降低性能
		 */

#Code:
		if (LOGGER.isDebugEnabled() && origSQL.startsWith(LoadData.loadDataHint)) {
			rrs.setCacheAble(false);
		}

#No. 4495
#File: E:\bishe\1\AbstractRouteStrategy.java
#Comment:
        /**
         * rrs携带ServerConnection的autocommit状态用于在sql解析的时候遇到
         * select ... for update的时候动态设定RouteResultsetNode的canRunInReadDB属性
         */

#Code:
		if (sc != null ) {
			rrs.setAutocommit(sc.isAutocommit());
		}

#No. 4496
#File: E:\bishe\1\AbstractRouteStrategy.java
#Comment:
		/**
		 * DDL 语句的路由
		 */

#Code:
		if (ServerParse.DDL == sqlType) {
			return RouterUtil.routeToDDLNode(rrs, sqlType, stmt, schema);
		}

#No. 4497
#File: E:\bishe\1\AbstractRouteStrategy.java
#Comment:
		/**
		 * 检查是否有分片
		 */

#Code:
		if (schema.isNoSharding() && ServerParse.SHOW != sqlType) {
			rrs = RouterUtil.routeToSingleNode(rrs, schema.getDataNode(), stmt);
		} else {
			RouteResultset returnedSet = routeSystemInfo(schema, sqlType, stmt, rrs);
			if (returnedSet == null) {
				rrs = routeNormalSqlWithAST(schema, stmt, rrs, charset, cachePool);
			}
		}

#No. 4498
#File: E:\bishe\1\AbstractRouteStrategy.java
#Comment:
	/**
	 * 路由之前必要的处理
	 * 主要是全局序列号插入，还有子表插入
	 */

#Code:
	private boolean beforeRouteProcess(SchemaConfig schema, int sqlType, String origSQL, ServerConnection sc)
			throws SQLNonTransientException {
		
		return RouterUtil.processWithMycatSeq(schema, sqlType, origSQL, sc)
				|| (sqlType == ServerParse.INSERT && RouterUtil.processERChildTable(schema, origSQL, sc))
				|| (sqlType == ServerParse.INSERT && RouterUtil.processInsert(schema, sqlType, origSQL, sc));
	}

#No. 4499
#File: E:\bishe\1\AbstractRouteStrategy.java
#Comment:
	/**
	 * 通过解析AST语法树类来寻找路由
	 */

#Code:
	public abstract RouteResultset routeNormalSqlWithAST(SchemaConfig schema, String stmt, RouteResultset rrs,
			String charset, LayerCachePool cachePool) throws SQLNonTransientException;

	/**
	 * 路由信息指令, 如 SHOW、SELECT@@、DESCRIBE
	 */
	public abstract RouteResultset routeSystemInfo(SchemaConfig schema, int sqlType, String stmt, RouteResultset rrs)
			throws SQLSyntaxErrorException;

	/**
	 * 解析 Show 之类的语句
	 */
	public abstract RouteResultset analyseShowSQL(SchemaConfig schema, RouteResultset rrs, String stmt)
			throws SQLNonTransientException;

}
}

#No. 4500
#File: E:\bishe\1\AbstractRPCManager.java
#Comment:
	/**
	 * any result will be sent.
	 * 
	 * @param callId
	 * @param result
	 * @throws IOException
	 * @throws SerializationException
	 */

#Code:
	private void sendResult(String callId, Object... result) throws IOException, SerializationException{

		OutputWampCallResultMessage resultMsg = new OutputWampCallResultMessage();

		if(result != null && result.length > 0){
			if(result.length == 1)
				resultMsg.setResult(result[0]);
			else
				resultMsg.setResult(result);
		}
		
		resultMsg.setCallId(callId);


		conn.sendMessage(resultMsg);
	}

#No. 4501
#File: E:\bishe\1\AbstractRssFile.java
#Comment:
    /**
     * Returns publication date. One second diff in case of several items;
     * keeps sort order in RSS client.  
     */

#Code:
    private Date nextPublicationDate() {
        Date result = startTime.getTime();
        startTime.add(Calendar.SECOND, -1);
        return result;
    }

#No. 4502
#File: E:\bishe\1\AbstractRT.java
#Comment:
    /**
     * Initialize the RT
     */

#Code:
    public abstract void initialize();
    
    /**
     * Terminate the RT
     */
    public abstract void terminate();
}
}

#No. 4503
#File: E:\bishe\1\AbstractRtCacheNotify.java
#Comment:
    /**
     * 根据slaveHost获取对应的HostInfo
     * @return 如果没有,不存在返回null
     */

#Code:
    protected T getSlaveHost(HostInfo slaveHost) {
        for (T host : slaveHostMap.keySet()) {
            if (HttpUtils.isEquals(host, slaveHost)) {
                return host;
            }
        }
        return null;
    }

#No. 4504
#File: E:\bishe\1\AbstractRtCacheReceive.java
#Comment:
    /**
     * 填充masterHost信息, {@link #status()}接口使用, 默认啥都不干
     * @return hostInfo的map, 建议返回入参
     */

#Code:
    protected Map<String, Object> appendHostStatusInfo(T masterHost, Map<String, Object> hostInfo) {
        return hostInfo;
    }

#No. 4505
#File: E:\bishe\1\AbstractRtCacheReceive.java
#Comment:
    /**
     * @return 返回的Map中key = "status"表示处理的状态, true为成功
     */

#Code:
    @Override
    public final synchronized MapResult registerHandler(RtCacheSlaveHandle handler) {
        Objects.requireNonNull(handler);
        HostInfo masterHost = handler.getMasterHost();
        try {
            HttpUtils.hostInfoCheck(masterHost, false);
        } catch (IllegalArgumentException e) {
            log.warn("registerHandler, masterHost: " + HttpUtils.hostInfoToString(masterHost) + "参数有误: "
                    + e.getMessage() + ", 无法完成注册");
            return ResultUtils.mapResult(MemoryCacheErrorCode.HOST_INFO_INVALID, e.getMessage());
        }
        T masterHostInfo = null;
        for (T e : masterHostMap.keySet()) {
            if (HttpUtils.isEquals(e, masterHost)) {
                masterHostInfo = e;
                break;
            }
        }
        if (masterHostInfo == null) {
            masterHostInfo = initMasterHostInfo(masterHost);
            if (masterHostInfo != null) {
                masterHostMap.put(masterHostInfo, new ArrayList<String>());
            }
        }
        if (masterHostInfo == null) {
            String msg = "注册RtCacheSlaveHandle时, masterHost: " + HttpUtils.hostInfoToString(masterHost)
                    + ", 没有生成对用的MasterHostInfo对象, 取消注册";
            log.warn(msg);
            return ResultUtils.mapResult(MemoryCacheErrorCode.RECEIVER_RUNTIME_ERROR, msg);
        } else {
            String cacheKey = RtCacheManager.getCacheHandleKey(handler);
            handleMap.put(cacheKey, handler);
            masterHostMap.get(masterHostInfo).add(cacheKey);
            return ResultUtils.mapResult("status", true);
        }
    }

#No. 4506
#File: E:\bishe\1\AbstractRtCacheReceive.java
#Comment:
    /**
     * @return 返回的Map中key = "status"表示处理的状态, true为成功
     */

#Code:
    @Override
    public synchronized MapResult unRegister(HostInfo localHost) {
        HostInfo usedLocalHost;
        try {
           usedLocalHost = HttpUtils.hostInfoCheck(localHost, true);
        } catch (IllegalArgumentException e) {
            log.warn("unRegister, localHost: " + HttpUtils.hostInfoToString(localHost) + "参数有误: "
                    + e.getMessage() + ", 无法完成注销");
            return ResultUtils.mapResult(MemoryCacheErrorCode.HOST_INFO_INVALID, e.getMessage());
        }
        boolean status = true;
        for (T info : masterHostMap.keySet()) {
            if (info.getRegisterStatus() == RegisterStatus.SUCCEED) {
                boolean succeed;
                try {
                    succeed = doMasterUnRegister(usedLocalHost, info);
                } catch (RuntimeException e) {
                    succeed = false;
                    log.error("doMasterUnRegister 存在异常", e);
                }
                if (!succeed) {
                    status = false;
                }
            }
            info.setRegisterStatus(RegisterStatus.UNREGISTER);
        }
        return ResultUtils.mapResult("status", status);
    }

#No. 4507
#File: E:\bishe\1\AbstractRtCacheReceive.java
#Comment:
    /**
     * 添加filter
     */

#Code:
    public void setFilter(Predicate<RtCacheSlaveHandle> filter) {
        this.filter = filter;
    }

#No. 4508
#File: E:\bishe\1\AbstractRTDwr.java
#Comment:
    /**
     * Save the Process
     * @return
     */

#Code:
    @DwrPermission(admin = true)
    @Override
    public ProcessResult save(VO vo) {
        ProcessResult response = new ProcessResult();
        vo.validate(response);
        if(!response.getHasMessages()){
            //Save it
            try{
                runtimeManager.save(vo);
            }catch(Exception e){
                //Handle the exceptions.
                LOG.error(e); //TODO Clean up and generify these messages to some central place
                if(e instanceof DuplicateKeyException)
                    response.addMessage(this.keyName + "Errors", new TranslatableMessage("dsEdit.alreadyExists"));
                else
                    response.addMessage(this.keyName + "Errors", new TranslatableMessage("dsEdit.unableToSave"));
            }
        }
        response.addData("vo", vo);
        response.addData("id", vo.getId()); //In case there are errors
        return response;
    }

#No. 4509
#File: E:\bishe\1\AbstractRTM.java
#Comment:
    /**
     * Construct Me
     * @param initializationPriority
     */

#Code:
    public AbstractRTM(int initializationPriority) {
        this.initializationPriority = initializationPriority;
    }

#No. 4510
#File: E:\bishe\1\AbstractRTM.java
#Comment:
    /**
     * Saves a MonitorVO by stopping it first then starting it
     * if it is enabled
     * @param vo
     */

#Code:
    public void save(VO vo) {
        // If the monitor is running, stop it
        stop(vo.getId());

        getDao().save(vo);

        // If the monitor is enabled, start it
        if (vo.isEnabled()) {
            start(getRt(vo));
        }
    }

#No. 4511
#File: E:\bishe\1\AbstractRTM.java
#Comment:
    /**
     * Stops a downtime monitor
     * @param id
     */

#Code:
    private void stop(int id) {
        synchronized (running) {
            if (running.containsKey(id)) {
                RT rt = running.remove(id);
                rt.terminate();
                LOG.info(rt.getVo().getName() + " stopped");
            }
        }
    }

#No. 4512
#File: E:\bishe\1\AbstractRTM.java
#Comment:
    /**
     * Create an RT Type from the VO
     * @param vo
     * @return
     */

#Code:
    public abstract RT getRt(VO vo);
    
    /**
     * Kludge to allow using the Dao and not having 
     * to have it set a construction time as the DB Layer
     * isn't ready when this object is created
     * @return
     */
    public abstract DAO getDao();
}
}

#No. 4513
#File: E:\bishe\1\AbstractRuleNode.java
#Comment:
	/**
	 * <p>Constructor for AbstractRuleNode.</p>
	 *
	 * @param parent a {@link lupos.rif.IRuleNode} object.
	 */

#Code:
	public AbstractRuleNode(IRuleNode parent) {
		this();
		setParent(parent);
	}

#No. 4514
#File: E:\bishe\1\AbstractRuleNode.java
#Comment:
	/**
	 * <p>Getter for the field <code>parent</code>.</p>
	 *
	 * @return a {@link lupos.rif.IRuleNode} object.
	 */

#Code:
	public IRuleNode getParent() {
		return parent;
	}

#No. 4515
#File: E:\bishe\1\AbstractRuleNode.java
#Comment:
	/**
	 * <p>getChildren.</p>
	 *
	 * @return a {@link java.util.List} object.
	 */

#Code:
	public List<IRuleNode> getChildren() {
		return Arrays.asList();
	}

#No. 4516
#File: E:\bishe\1\AbstractRuleOperator.java
#Comment:
	/**
	 * <p>Constructor for AbstractRuleOperator.</p>
	 */

#Code:
	public AbstractRuleOperator() {
		super();
	}

#No. 4517
#File: E:\bishe\1\AbstractRuleOperator.java
#Comment:
	/**
	 * <p>Constructor for AbstractRuleOperator.</p>
	 *
	 * @param classType a {@link lupos.gui.operatorgraph.visualeditor.ruleeditor.util.RuleEnum} object.
	 * @param name a {@link java.lang.String} object.
	 */

#Code:
	public AbstractRuleOperator(RuleEnum classType, String name) {
		this.classType = classType;
		this.name = name;
	}

#No. 4518
#File: E:\bishe\1\AbstractRuleOperator.java
#Comment:
	/**
	 * <p>Constructor for AbstractRuleOperator.</p>
	 *
	 * @param name a {@link java.lang.String} object.
	 * @param loadObject a {@link org.json.JSONObject} object.
	 * @throws org.json.JSONException if any.
	 */

#Code:
	public AbstractRuleOperator(String name, JSONObject loadObject) throws JSONException {
		this.classType = RuleEnum.valueOf(loadObject.getString("class type"));

		this.name = name;

		if(this.name.matches(AbstractRuleOperator.internal_name + "\\d+")) {
			this.internal_id = AbstractRuleOperator.internal_global_id;
			AbstractRuleOperator.internal_global_id++;
		}

		this.alsoSubClasses = loadObject.getBoolean("also subclasses");

		this.fromJSON(loadObject);
	}

#No. 4519
#File: E:\bishe\1\AbstractRuleOperator.java
#Comment:
	/**
	 * <p>toJSON.</p>
	 *
	 * @param connectionsObject a {@link org.json.JSONObject} object.
	 * @return a {@link org.json.JSONObject} object.
	 * @throws org.json.JSONException if any.
	 */

#Code:
	public abstract JSONObject toJSON(JSONObject connectionsObject) throws JSONException;

	/**
	 * <p>toString.</p>
	 *
	 * @return a {@link java.lang.String} object.
	 */
	public String toString() {
		return this.getClass().getSimpleName() + "(" + this.classType + ")";
	}

#No. 4520
#File: E:\bishe\1\AbstractRulePackage.java
#Comment:
	/**
	 * <p>applyRules.</p>
	 *
	 * @param rootOp a {@link lupos.engine.operators.BasicOperator} object.
	 */

#Code:
	public abstract void applyRules(BasicOperator rootOp);
	/**
	 * <p>applyRulesDebugByteArray.</p>
	 *
	 * @param rootOp a {@link lupos.engine.operators.BasicOperator} object.
	 * @param prefixInstance a {@link lupos.rdf.Prefix} object.
	 * @return a {@link java.util.List} object.
	 */
	public abstract List<DebugContainer<BasicOperatorByteArray>> applyRulesDebugByteArray(BasicOperator rootOp, Prefix prefixInstance);
}
}

#No. 4521
#File: E:\bishe\1\AbstractRunGoalsPhase.java
#Comment:
    /**
     * Determines the path of the working directory. By default, this is the
     * checkout directory. For some SCMs, the project root directory is not the
     * checkout directory itself, but a SCM-specific subdirectory.
     *
     * @param checkoutDirectory            The checkout directory as java.io.File
     * @param relativePathProjectDirectory The relative path of the project directory within the checkout
     *                                     directory or ""
     * @return The working directory
     */

#Code:
    protected File determineWorkingDirectory( File checkoutDirectory, String relativePathProjectDirectory )
    {
        File workingDirectory = checkoutDirectory;

        if ( StringUtils.isNotEmpty( relativePathProjectDirectory ) )
        {
            workingDirectory = new File( checkoutDirectory, relativePathProjectDirectory );
        }

        return workingDirectory;
    }

#No. 4522
#File: E:\bishe\1\AbstractRunningState.java
#Comment:
	/**
	 * Request for getting files in the worker
	 * @param gridProcessg
	 */

#Code:
	private void getFiles(GridProcess gridProcessg, List<IResponseTO> responses) {
		String workerID = gridProcessg.getWorkerEntry().getWorkerID();
		long requestID = gridProcessg.getWorkerEntry().getRequestID();
		
		FileTransferInfo[] files = new FileTransferInfo[gridProcessg.getOperations().getFinalPhaseOperationsList().size()];
		int i = 0;
		
		for (GetOperation operation : gridProcessg.getOperations().getFinalPhaseOperationsList()) {
			files[i] = new FileTransferInfo(operation.getHandle().getId(), operation.getRemoteFilePath());
			i++;
		}	
		
		GetFilesMessageHandleResponseTO to = new GetFilesMessageHandleResponseTO(requestID, 
				StringUtil.deploymentIDToAddress(workerID), files);
		
		responses.add(to);
		
	}

#No. 4523
#File: E:\bishe\1\AbstractRunningState.java
#Comment:
	/**
	 * @return the heuristic
	 */

#Code:
	protected WorkQueueExecutionController getHeuristic() {
		return heuristic;
	}

#No. 4524
#File: E:\bishe\1\AbstractRuntimeExecContentTransformerWorker.java
#Comment:
    /**
     * Checks for the JMagick and ImageMagick dependencies, using the common
     * {@link #transformInternal(File, File) transformation method} to check
     * that the sample image can be converted. 
     */

#Code:
    @Override
    public void initialize()
    {
        try
        {
            loadProperties();
    
            initializeExecuter();
            initializeVersionDetailsExecuter();
            initializeFileDetailsExecuter();
            
            initializeVersionString();
            initializeVersionDetailsString();
            
            initializationTest();
            setIsAvailable(true);
        }
        catch (Exception e)
        {
            logger.warn(e.getMessage(), e);
            setIsAvailable(false);
        }
    }

#No. 4525
#File: E:\bishe\1\AbstractRuntimeExecContentTransformerWorker.java
#Comment:
    /**
     * Optional method for implementations able to return details of a file which will
     * vary greatly depending on the file type and implementation.
     * 
     * @param file
     * @return a simple string of file detail output
     * @throws Exception
     */

#Code:
    public String getDetails(File file) throws Exception
    {
        if (fileDetailsExecuter == null)
        {
            return null;
        }
        Map<String, String> properties = new HashMap<String, String>(1);
        properties.put(VAR_SOURCE, file.getAbsolutePath());
        
        try
        {
            // On some platforms / versions / executables, the command seems to 
            // return an error code whilst still
            // returning output or error, so let's not worry about the exit code!
            ExecutionResult result = this.fileDetailsExecuter.execute(properties);
            String out = result.getStdOut().trim();
            if (!out.equals(""))
            {
                return out;
            }
            return result.getStdErr().trim();
        }
        catch (Throwable e)
        {
            logger.info(getClass().getSimpleName() + " could not get details: "
                    + (e.getMessage() != null ? e.getMessage() : ""));
        }
        return null;
    }

#No. 4526
#File: E:\bishe\1\AbstractRuntimeMapTest.java
#Comment:
    /** 
     * Polymorphic.
     */

#Code:
    public static abstract class Person
    {
        protected int id;
        protected String name;
        
        @Override
        public int hashCode()
        {
            final int prime = 31;
            int result = 1;
            result = prime * result + id;
            result = prime * result + ((name == null)?0:name.hashCode());
            return result;
        }
        @Override
        public boolean equals(Object obj)
        {
            if (this == obj)
                return true;
            if (obj == null)
                return false;
            if (getClass() != obj.getClass())
                return false;
            Person other = (Person)obj;
            if (id != other.id)
                return false;
            if (name == null)
            {
                if (other.name != null)
                    return false;
            }
            else if (!name.equals(other.name))
                return false;
            return true;
        }
        
    }

#No. 4527
#File: E:\bishe\1\AbstractS3FileInputPlugin.java
#Comment:
    /**
     * Lists S3 filenames filtered by prefix.
     *
     * The resulting list does not include the file that's size == 0.
     */

#Code:
    public static void listS3FilesByPrefix(FileList.Builder builder,
            AmazonS3Client client, String bucketName,
            String prefix, Optional<String> lastPath)
    {
        String lastKey = lastPath.orNull();
        do {
            ListObjectsRequest req = new ListObjectsRequest(bucketName, prefix, lastKey, null, 1024);
            ObjectListing ol = client.listObjects(req);
            for (S3ObjectSummary s : ol.getObjectSummaries()) {
                if (s.getSize() > 0) {
                    builder.add(s.getKey(), s.getSize());
                    if (!builder.needsMore()) {
                        return;
                    }
                }
            }
            lastKey = ol.getNextMarker();
        } while(lastKey != null);
    }

#No. 4528
#File: E:\bishe\1\AbstractS3Storage.java
#Comment:
    /**
     * S3 metadata names must be compatible with header naming.  Filter the names so
     * they're acceptable.
     * Per HTTP RFC:<br>
     * <pre>
     * token          = 1*<any CHAR except CTLs or separators>
     * separators     = "(" | ")" | "<" | ">" | "@"
     *                 | "," | ";" | ":" | "\" | <">
     *                 | "/" | "[" | "]" | "?" | "="
     *                 | "{" | "}" | SP | HT
     * <pre>
     *
     * @param name the header name to filter.
     * @return the metadata name filtered to be compatible with HTTP headers.
     */

#Code:
    private String filterName(String name) {
        try {
            // First, filter out any non-ASCII characters.
            byte[] raw = name.getBytes("US-ASCII");
            String ascii = new String(raw, "US-ASCII");

            // Strip separator chars
            for (char sep : HTTP_SEPARATOR_CHARS) {
                ascii = ascii.replace(sep, '-');
            }

            return ascii;
        } catch (UnsupportedEncodingException e) {
            // should never happen
            throw new RuntimeException("Missing ASCII encoding", e);
        }
    }

#No. 4529
#File: E:\bishe\1\AbstractS3Storage.java
#Comment:
    /**
     * S3 sends metadata as HTTP headers, unencoded.  Filter values to be compatible
     * with headers.
     */

#Code:
    private String filterValue(String value) {
        try {
            // First, filter out any non-ASCII characters.
            byte[] raw = value.getBytes("US-ASCII");
            String ascii = new String(raw, "US-ASCII");

            // Make sure there's no newlines
            ascii = ascii.replace('\n', ' ');

            return ascii;
        } catch (UnsupportedEncodingException e) {
            // should never happen
            throw new RuntimeException("Missing ASCII encoding", e);
        }
    }

#No. 4530
#File: E:\bishe\1\AbstractSaslCallbackHandler.java
#Comment:
    /**
     * Convenience method for getting an environment suitable for acquiring
     * an {@link LdapContext} for the client.
     * 
     * @param session The current session.
     * @return An environment suitable for acquiring an {@link LdapContext} for the client.
     */

#Code:
    protected Hashtable<String, Object> getEnvironment( IoSession session )
    {
        Hashtable<String, Object> env = new Hashtable<String, Object>();
        env.put( Context.PROVIDER_URL, session.getAttribute( "baseDn" ) );
        env.put( Context.INITIAL_CONTEXT_FACTORY, "org.apache.directory.server.core.jndi.CoreContextFactory" );
        env.put( Context.SECURITY_PRINCIPAL, ServerDNConstants.ADMIN_SYSTEM_DN );
        env.put( Context.SECURITY_CREDENTIALS, "secret" );
        env.put( Context.SECURITY_AUTHENTICATION, AuthenticationLevel.SIMPLE.toString() );

        return env;
    }

#No. 4531
#File: E:\bishe\1\AbstractSaslSCRAM.java
#Comment:
		/**
		 * Client doesn't support channel binding.
		 */

#Code:
		n,
		/**
		 * Client does support channel binding but thinks the server does not.
		 */
		y,
		/**
		 * Client requires channel binding: <code>tls-unique</code>.
		 */
		tls_unique,
		/**
		 * Client requires channel binding: <code>tls-server-end-point</code>.
		 */
		tls_server_end_point
	}

	private enum Step {
		clientFinalMessage,
		clientFirstMessage,
		finished;
	}

#No. 4532
#File: E:\bishe\1\AbstractScalableOptions.java
#Comment:
    /**
     * Step into the scale configuration
     */

#Code:
    public Scales<T> scales() {
        if (scales == null) {
            scales = new Scales<>(getThis());
        }
        return scales;
    }

#No. 4533
#File: E:\bishe\1\AbstractScanWriter.java
#Comment:
    /**
     * Writes the contents to the "scan complete" file located at "fileUri" only if the file doesn't already exist.
     * @return true if the file was written, false if the file already existed
     */

#Code:
    abstract protected boolean writeScanCompleteFile(URI fileUri, byte[] contents)
            throws IOException;

    /**
     * Writes the contents to the "latest" file located at "fileUri".
     */
    abstract protected void writeLatestFile(URI fileUri, byte[] contents)
            throws IOException;

    public void close() {
        _closed = true;
    }

#No. 4534
#File: E:\bishe\1\AbstractSceneController.java
#Comment:
    /**
     * Releases resources associated with this scene controller.
     */

#Code:
    public void dispose()
    {
        if (this.lastPickedObjects != null)
            this.lastPickedObjects.clear();
        this.lastPickedObjects = null;
        
        if (this.dc != null)
            this.dc.dispose();

        if (this.textRendererCache != null)
            this.textRendererCache.dispose();
    }

#No. 4535
#File: E:\bishe\1\AbstractSceneController.java
#Comment:
    /**
     * Called to check for openGL errors. This method includes a "round-trip" between the application and renderer,
     * which is slow. Therefore, this method is excluded from the "normal" render pass. It is here as a matter of
     * convenience to developers, and is not part of the API.
     *
     * @param dc the relevant <code>DrawContext</code>
     */

#Code:
    protected void checkGLErrors(DrawContext dc)
    {
        GL gl = dc.getGL().getGL2();
        int err = gl.glGetError();
        if (err != GL.GL_NO_ERROR)
        {
            String msg = dc.getGLU().gluErrorString(err);
            msg += err;
            Logging.logger().severe(msg);
        }
    }

#No. 4536
#File: E:\bishe\1\AbstractScheduledPoolConnectionMonitor.java
#Comment:
    /* determines if the thread executing a future 'connection monitoring' task should be interrupted;
       otherwise, in-progress tasks are allowed to complete. Default is false. */

#Code:
    public final boolean mayInterruptIfRunning = Boolean.getBoolean("com.gs.replication.connection-monitor.mayInterruptIfRunning");


    public AbstractScheduledPoolConnectionMonitor(String myLookupName,
                                                  int corePoolSize, long monitorConnectedDelay,
                                                  long monitorDisconnectedDelay, TimeUnit timeUnit) {
        _myLookupName = myLookupName;
        _monitorConnectedDelay = monitorConnectedDelay;
        _monitorDisconnectedDelay = monitorDisconnectedDelay;
        _timeUnit = timeUnit;
        _specificLogger = Logger.getLogger(Constants.LOGGER_REPLICATION_ROUTER
                + "." + ReplicationLogUtils.toShortLookupName(_myLookupName));
        _pool = new ScheduledThreadPoolExecutor(corePoolSize,
                new GSThreadFactory("connection-monitor-thread", true));
    }

#No. 4537
#File: E:\bishe\1\AbstractScheduledService.java
#Comment:
  /**
   * Returns the {@link ScheduledExecutorService} that will be used to execute the {@link #startUp},
   * {@link #runOneIteration} and {@link #shutDown} methods.  If this method is overridden the 
   * executor will not be {@linkplain ScheduledExecutorService#shutdown shutdown} when this 
   * service {@linkplain Service.State#TERMINATED terminates} or 
   * {@linkplain Service.State#TERMINATED fails}. Subclasses may override this method to supply a 
   * custom {@link ScheduledExecutorService} instance. This method is guaranteed to only be called 
   * once.
   * 
   * <p>By default this returns a new {@link ScheduledExecutorService} with a single thread thread
   * pool that sets the name of the thread to the {@linkplain #serviceName() service name}.  
   * Also, the pool will be {@linkplain ScheduledExecutorService#shutdown() shut down} when the 
   * service {@linkplain Service.State#TERMINATED terminates} or 
   * {@linkplain Service.State#TERMINATED fails}.
   */

#Code:
  protected ScheduledExecutorService executor() {
    final ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor(
        new ThreadFactory() {
          @Override public Thread newThread(Runnable runnable) {
            return MoreExecutors.newThread(serviceName(), runnable);
          }
        });

#No. 4538
#File: E:\bishe\1\AbstractScheduledService.java
#Comment:
  /**
   * Returns the name of this service. {@link AbstractScheduledService} may include the name in 
   * debugging output.
   *
   * @since 14.0
   */

#Code:
  protected String serviceName() {
    return getClass().getSimpleName();
  }

#No. 4539
#File: E:\bishe\1\AbstractSchemaMigrationStep.java
#Comment:
    /**
     * Converts String to URL.
     *
     * @param string string to convert.
     *
     * @return URL or <code>NULL</code> if string is <code>NULL</code> or unconvertable.
     */

#Code:
    protected static URL urlFromString(String string)
    {
        URL url = null;

        if (string != null)
        {
            try
            {
                url = new URL(string);
            } catch (MalformedURLException e)
            {
                // Bad URL
            }
        }

        return url;
    }

#No. 4540
#File: E:\bishe\1\AbstractSchemaMigrationStep.java
#Comment:
    /**
     * Deserializes URL from bytes stream.
     *
     * @param stream stream of bytes.
     *
     * @return URL or NULL if the stream was empty or damaged.
     */

#Code:
    protected static URL urlFromStream(byte[] stream)
    {
        URL url = null;

        if (stream != null)
        {
            ByteArrayInputStream is = new ByteArrayInputStream(stream);
            try
            {
                ObjectInputStream os = new ObjectInputStream(is);
                url = (URL)os.readObject();
            } catch (Exception e)
            {
                url = null;
            }
        }

        return url;
    }

#No. 4541
#File: E:\bishe\1\AbstractSchemaMigrationStep.java
#Comment:
    /**
     * Looks for a table in database with a given name.
     *
     * @param con       connection to use.
     * @param table     name of the target table.
     *
     * @return <code>TRUE</code> if table is there.
     *
     * @throws SQLException if database error happened.
     */

#Code:
    protected boolean isTablePresent(Connection con, String table)
        throws SQLException
    {
        boolean present = true;
        try
        {
            con.createStatement().executeQuery("SELECT * FROM " + table + " WHERE 1=0");
        } catch (SQLException e)
        {
            if (e.getErrorCode() == ERR_UNKNOWN_TABLE)
            {
                present = false;
            } else
            {
                throw e;
            }
        }

        return present;
    }

#No. 4542
#File: E:\bishe\1\AbstractSchemaMigrationStep.java
#Comment:
    /**
     * Drops the list of tables if they are in database. It's not a problem if tables aren't there.
     *
     * @param con       connection to use.
     * @param tables    list of tables.
     *
     * @throws SQLException if there's database error.
     */

#Code:
    protected static void dropTables(Connection con, String[] tables)
        throws SQLException
    {
        for (int i = 0; i < tables.length; i++)
        {
            String table = tables[i];
            dropTable(con, table);
        }
    }

#No. 4543
#File: E:\bishe\1\AbstractSchemaMigrationStep.java
#Comment:
    /**
     * Drops database table with a given name. It's not a problem if table isn't there.
     *
     * @param con       conneciton to use.
     * @param table     name of the table.
     *
     * @throws SQLException if there's database error.
     */

#Code:
    private static void dropTable(Connection con, String table)
        throws SQLException
    {
        Statement stmt = con.createStatement();
        stmt.execute("DROP TABLE " + table + " IF EXISTS;");
    }

#No. 4544
#File: E:\bishe\1\AbstractSchemaMigrationStep.java
#Comment:
    /**
     * Drops the constraint on the table.
     *
     * @param con           connection to use.
     * @param table         name of the table.
     * @param constraint    constraint name.
     *
     * @throws SQLException if there's database error.
     */

#Code:
    protected void dropConstraint(Connection con, String table, String constraint)
        throws SQLException
    {
        Statement stmt = con.createStatement();
        try
        {
            stmt.execute("ALTER TABLE " + table + " DROP CONSTRAINT " + constraint + ";");
        } catch (SQLException e)
        {
            int errorCode = e.getErrorCode();
            if (errorCode != ERR_UNKNOWN_CONSTRAINT && errorCode != ERR_UNKNOWN_TABLE) throw e;
        }
    }

#No. 4545
#File: E:\bishe\1\AbstractSchemaMigrationStep.java
#Comment:
    /**
     * Returns <code>TRUE</code> if the statement should be skipped for some reason.
     * For example, it's empty, or it's a forbidden statement ("CREATE USER...", "CREATE ALIAS..."
     * and so on).
     *
     * @param stmt statement questioned.
     *
     * @return <code>TRUE</code> if statement shouldn't be executed.
     */

#Code:
    static boolean skipStatement(String stmt)
    {
        boolean skip = true;

        if (stmt != null && (stmt = stmt.trim()).length() > 0)
        {
            skip = stmt.startsWith("CREATE USER") || stmt.startsWith("CREATE ALIAS");
        }

        return skip;
    }

#No. 4546
#File: E:\bishe\1\AbstractSchemaMigrationStep.java
#Comment:
    /**
     * Performs update operation and returns number of row changed.
     *
     * @param stmt statement to execute.
     *
     * @return number of rows changed.
     *
     * @throws SQLException if database operation fails.
     */

#Code:
    int update(String stmt)
        throws SQLException
    {
        return connection.createStatement().executeUpdate(stmt);
    }

#No. 4547
#File: E:\bishe\1\AbstractSchemaTestUtils.java
#Comment:
    /**
     * Return the SchemaParser.Request for the given parameters.
     *
     * @param content the dataset con.ent.
     * @param dataSetId the dataset id.
     * @return the SchemaParser.Request for the given parameters.
     */

#Code:
    protected SchemaParser.Request getRequest(InputStream content, String dataSetId) {
        DataSetMetadata dataSetMetadata = metadataBuilder.metadata().id(dataSetId).build();
        return new SchemaParser.Request(content, dataSetMetadata);
    }

#No. 4548
#File: E:\bishe\1\AbstractSciJavaTest.java
#Comment:
	/**
	 * Disposes of the {@link Context} that was initialized in {@link #setUp()}.
	 */

#Code:
	@After
	public synchronized void cleanUp() {
		if (context != null) {
			context.dispose();
			context = null;
		}
	}

#No. 4549
#File: E:\bishe\1\AbstractScmMojo.java
#Comment:
    /**
     * Get info from scm.
     *
     * @param repository
     * @param fileSet
     * @return
     * @throws ScmException
     * @todo this should be rolled into org.apache.maven.scm.provider.ScmProvider and
     *       org.apache.maven.scm.provider.svn.SvnScmProvider
     */

#Code:
    protected InfoScmResult info( ScmRepository repository, ScmFileSet fileSet )
        throws ScmException
    {
        CommandParameters commandParameters = new CommandParameters();

        // only for Git, we will make a test for shortRevisionLength parameter
        if ( GitScmProviderRepository.PROTOCOL_GIT.equals( scmManager.getProviderByRepository( repository ).getScmType() )
            && this.shortRevisionLength > 0 )
        {
            getLog().info( "ShortRevision tag detected. The value is '" + this.shortRevisionLength + "'." );
            if ( shortRevisionLength >= 0 && shortRevisionLength < 4 )
            {
                getLog().warn( "shortRevision parameter less then 4. ShortRevisionLength is relaying on 'git rev-parese --short=LENGTH' command, accordingly to Git rev-parse specification the LENGTH value is miminum 4. " );
            }
            commandParameters.setInt( CommandParameter.SCM_SHORT_REVISION_LENGTH, this.shortRevisionLength );
        }

        if ( !StringUtils.isBlank( scmTag ) && !"HEAD".equals( scmTag ) )
        {
            commandParameters.setScmVersion( CommandParameter.SCM_VERSION, new ScmTag( scmTag ) );
        }

        return scmManager.getProviderByRepository( repository ).info( repository.getProviderRepository(), fileSet,
                                                                      commandParameters );
    }

#No. 4550
#File: E:\bishe\1\AbstractScope.java
#Comment:
  /**
   * @return the trace
   */

#Code:
  public boolean isTrace() {
    return AbstractScope.trace;
  }

#No. 4551
#File: E:\bishe\1\AbstractScope.java
#Comment:
  /**
   * @param trace the trace to set
   */

#Code:
  public void setTrace(boolean trace) {
    AbstractScope.trace = trace;
  }

#No. 4552
#File: E:\bishe\1\AbstractScramSHAMechanismTestBase.java
#Comment:
    /**
     * 5.1.  SCRAM Attributes
     * "m: This attribute is reserved for future extensibility.  In this
     * version of SCRAM, its presence in a client or a server message
     * MUST cause authentication failure when the attribute is parsed by
     * the other end."
     *
     * @throws Exception if an unexpected exception is thrown.
     */

#Code:
    @Test
    public void testServerFirstMessageMandatoryExtensionRejected() throws Exception {
        Mechanism mechanism = getConfiguredMechanism();

        mechanism.getInitialResponse();
        try {
            mechanism.getChallengeResponse("m=notsupported,s=,i=".getBytes());
            fail("Exception not thrown");
        } catch (SaslException s) {
            // PASS
        }
    }

#No. 4553
#File: E:\bishe\1\AbstractScramSHAMechanismTestBase.java
#Comment:
    /**
     * 5.  SCRAM Authentication Exchange
     * "In [the server first] response, the server sends a "server-first-message" containing the
     * user's iteration count i and the user's salt, and appends its own
     * nonce to the client-specified one."
     *
     * @throws Exception if an unexpected exception is thrown.
     */

#Code:
    @Test
    public void testServerFirstMessageInvalidNonceRejected() throws Exception {
        Mechanism mechanism = getConfiguredMechanism();

        mechanism.getInitialResponse();
        try {
            mechanism.getChallengeResponse("r=invalidnonce,s=W22ZaJ0SNY7soEsUEjb6gQ==,i=4096".getBytes());
            fail("Exception not thrown");
        } catch (SaslException s) {
            // PASS
        }
    }

#No. 4554
#File: E:\bishe\1\AbstractScramSHAMechanismTestBase.java
#Comment:
    /**
     * 5.  SCRAM Authentication Exchange
     * "The client then authenticates the server by computing the
     * ServerSignature and comparing it to the value sent by the server.  If
     * the two are different, the client MUST consider the authentication
     * exchange to be unsuccessful, and it might have to drop the
     * connection."
     *
     * @throws Exception if an unexpected exception is thrown.
     */

#Code:
    @Test
    public void testServerSignatureDiffer() throws Exception {
        Mechanism mechanism = getConfiguredMechanism();

        mechanism.getInitialResponse();
        mechanism.getChallengeResponse(serverFirstMessage);
        try {
            mechanism.getChallengeResponse("v=badserverfinal".getBytes());
            fail("Exception not thrown");
        } catch (SaslException e) {
            // PASS
        }
    }

#No. 4555
#File: E:\bishe\1\AbstractScriptedMojoDescriptorExtractor.java
#Comment:
    /**
     * Should be implemented in the sub classes.
     *
     * @param metadataFilesByBasedir could be null
     * @param request The plugin request, never <code>null</code>.
     * @return always null
     * @throws ExtractionException if any
     * @throws InvalidPluginDescriptorException if any
     */

#Code:
    protected List<MojoDescriptor> extractMojoDescriptorsFromMetadata( Map<String, Set<File>> metadataFilesByBasedir,
                                                                       PluginToolsRequest request )
        throws ExtractionException, InvalidPluginDescriptorException
    {
        return null;
    }

#No. 4556
#File: E:\bishe\1\AbstractScriptedMojoDescriptorExtractor.java
#Comment:
    /**
     * Should be implemented in the sub classes.
     *
     * @return always null
     */

#Code:
    protected String getMetadataFileExtension( PluginToolsRequest request )
    {
        return null;
    }

#No. 4557
#File: E:\bishe\1\AbstractScriptedMojoDescriptorExtractor.java
#Comment:
    /**
     * Should be implemented in the sub classes.
     *
     * @param scriptFilesKeyedByBasedir could be null
     * @param request The plugin request, never <code>null</code>.
     * @return always null
     * @throws ExtractionException if any
     * @throws InvalidPluginDescriptorException if any
     */

#Code:
    protected List<MojoDescriptor> extractMojoDescriptors( Map<String, Set<File>> scriptFilesKeyedByBasedir,
                                                           PluginToolsRequest request )
        throws ExtractionException, InvalidPluginDescriptorException
    {
        return null;
    }

#No. 4558
#File: E:\bishe\1\AbstractScriptFactory.java
#Comment:
    /*
     * MESH
     */

#Code:
    @Override
    public File getMeshScript(Model model) {
        File parallelScript = getMeshParallelScript(model);
        File serialScript = getMeshSerialScript(model);

        if (model.getProject().isParallel()) {
            return parallelScript;
        } else {
            return serialScript;
        }
    }

#No. 4559
#File: E:\bishe\1\AbstractScriptFactory.java
#Comment:
    /*
     * SOLVER
     */

#Code:

    @Override
    public File getSolverScript(Model model) {
        File parallelScript = getSolverParallelScript(model);
        File serialScript = getSolverSerialScript(model);

        if (model.getProject().isParallel()) {
            return parallelScript;
        } else {
            return serialScript;
        }
    }

#No. 4560
#File: E:\bishe\1\AbstractScriptingNodeModel.java
#Comment:
    /**
     * @return default script
     */

#Code:
	public String getDefaultScript(String defaultScript) {
		if (getHardwiredTemplate() != null) {
			return TemplateConfigurator.generateScript(getHardwiredTemplate());
		}
		return defaultScript;
    }

#No. 4561
#File: E:\bishe\1\AbstractScriptingNodeModel.java
#Comment:
    /**
     * does the node has output ports?
     * @return
     */

#Code:
    protected boolean hasOutput() {  	
        return getNrOutPorts() > 0;
    }

#No. 4562
#File: E:\bishe\1\AbstractScriptingNodeModel.java
#Comment:
    /**
     * if the node has an hardwired template, it's script needs to be adapted (RGG placeholders)
     * @param inData
     */

#Code:
    protected void adaptHardwiredTemplateToContext(PortObjectSpec[] inData) {
        if (hardwiredTemplate != null && hardwiredTemplate.isLinkedToScript()) {
            Map<Integer, List<DataColumnSpec>> nodeInputModel = ScriptProvider.getPushableInputSpec(inData, m_colSupport);
            contextAwareHWTemplateText = TemplateUtils.replaceRGGPlaceholders(hardwiredTemplate.getTemplate(), nodeInputModel);
        }
    }

#No. 4563
#File: E:\bishe\1\AbstractScriptingNodeModel.java
#Comment:
    /**
     * <p>
     * deserializes the template from the node setting 'node.template'<br>
     * loads the script (either with RGG configuration settings or as it is)<br>
     * replace flowvariable placeholders
     * </p>
     * 
     * This method is usually just called from within the different execute implementations. Occassionally it is also
     * called in the view implemntations.
     */

#Code:
    public String prepareScript() {

    	if(!m_nodeCfg.m_useScriptSettings) return "";

        String script;
        String serializedTemplate = ((SettingsModelString) getModelSetting(SCRIPT_TEMPLATE)).getStringValue();

        ScriptTemplate restoredTemplate = ScriptingNodeDialog.deserializeTemplate(serializedTemplate);


        // if the node is a hard-wired one, use the default template, otherwise use the script as saved in the template definition
        if (contextAwareHWTemplateText == null || hardwiredTemplate == null || (restoredTemplate != null && !restoredTemplate.isLinkedToScript())) {
            script = ((SettingsModelString) getModelSetting(SCRIPT_PROPERTY)).getStringValue();

        } else {
            ScriptTemplate contextAwareHWTemplate = new ScriptTemplate();
            contextAwareHWTemplate.setName("context-aware hardwired tempalte");
            contextAwareHWTemplate.setTemplate(contextAwareHWTemplateText);

            if (restoredTemplate != null) {
                Map<String, Object> uiConfig = restoredTemplate.getPersistedConfig();

                if (uiConfig != null) {
                    contextAwareHWTemplate.setPersistedConfig(uiConfig);
                }
            }

            script = TemplateConfigurator.generateScript(contextAwareHWTemplate);
        }
        
        script = fixEncoding(script);

        // replace flow-variables
        return FlowVarUtils.replaceFlowVars(script, this);
    }

#No. 4564
#File: E:\bishe\1\AbstractScriptingNodeModel.java
#Comment:
    /**
     * cast an array of PortObjects into an array of BufferedDataTables
     * @param inData
     * @return array of BufferedDataTables
     */

#Code:
	public static BufferedDataTable[] castToBDT(PortObject[] inData) {		
		
		List<BufferedDataTable> inTables = new ArrayList<BufferedDataTable>();
		
		for(PortObject in : inData) {
			if(in instanceof BufferedDataTable)
				inTables.add((BufferedDataTable) in);
		}	
		
		return inTables.toArray(new BufferedDataTable[inTables.size()]);
	}

#No. 4565
#File: E:\bishe\1\AbstractScriptingNodeModel.java
#Comment:
    /**
     * cast a PortObjects into a BufferedDataTables
     * @param inData
     * @return BufferedDataTable or null
     */

#Code:
	public static BufferedDataTable castToBDT(PortObject inData) {
		if(inData instanceof BufferedDataTable) return (BufferedDataTable) inData;
		return null;
	}

#No. 4566
#File: E:\bishe\1\AbstractScriptingNodeModel.java
#Comment:
	/**
	 * ensure UTF-8 encoding
	 * @param stringValue
	 * @return
	 */

#Code:
    public static String fixEncoding(String stringValue) {
        String encodedString = new String(stringValue.getBytes(StandardCharsets.UTF_8));
        return encodedString.replace("\r","");
    }

#No. 4567
#File: E:\bishe\1\AbstractScriptLanguage.java
#Comment:
/**
 * Abstract superclass for {@link ScriptLanguage} implementations.
 * <p>
 * This class implements dummy versions of {@link ScriptEngineFactory}'s methods
 * that are not needed by the SciJava scripting framework.
 * </p>
 * 
 * @author Johannes Schindelin
 */

#Code:
public abstract class AbstractScriptLanguage extends AbstractRichPlugin
	implements ScriptLanguage
{

	// -- Object methods --

	@Override
	public String toString() {
		return getLanguageName();
	}

	// -- Default implementations --

	@Override
	public String getEngineName() {
		return inferNameFromClassName();
	}

	@Override
	public String getLanguageName() {
		String name = null;
		final PluginInfo<?> info = getInfo();
		if (info != null) name = info.getName();
		return name != null && !name.isEmpty() ? name : inferNameFromClassName();
	}

	// -- Helper methods --

	private String inferNameFromClassName() {
		String className = getClass().getSimpleName();
		if (className.endsWith("ScriptLanguage")) {
			// strip off "ScriptLanguage" suffix
			className = className.substring(0, className.length() - 14);
		}
		// replace underscores with spaces
		className = className.replace('_', ' ');
		return className;
	}

}

#No. 4568
#File: E:\bishe\1\AbstractScrolledComposite.java
#Comment:
/**
 * Abstract class for all ScrolledComposite implementations
 * 
 * @author rawagner
 *
 */

#Code:
public abstract class AbstractScrolledComposite extends AbstractControl<ScrolledComposite>
		implements org.eclipse.reddeer.swt.api.ScrolledComposite {

	public AbstractScrolledComposite(ScrolledComposite widget) {
		super(widget);
	}

	public AbstractScrolledComposite(ReferencedComposite referencedComposite, int index, Matcher<?>... matchers) {
		super(ScrolledComposite.class, referencedComposite, index, matchers);
	}

	@Override
	public Control getControl() {
		return ScrolledCompositeHandler.getInstance().getContent(swtWidget);
	}

}

#No. 4569
#File: E:\bishe\1\AbstractSDGLogisticRegression.java
#Comment:
	/**
	 * you should make sure the LABEL of data is the same as that of training set. 
	 * Otherwise use {@link #predict(String, String, Evaluator...)} instead.
	 */

#Code:
	@Override
	public void predict(DataReader<Vector> data, String resultPath, Evaluator... evaluators) throws Exception {
		if (this.featureWeights == null)
			throw new IOException("!Model haven't been initialized yet! :(");
		BufferedWriter bw = new BufferedWriter(new FileWriter(resultPath));
		double[] resultProbs = new double[2];
		int idx = -1;
		Vector sample = new Vector();
		for(data.next(sample); sample.featureSize >= 0; data.next(sample)){
			if (sample.featureSize == 0)
				continue;
			this.predict(sample, resultProbs);
			for(Evaluator e : evaluators){
				int tmp = dataInfo[LABELRANGEBASE + sample.label][0];
				e.collect(tmp, resultProbs);
			}
			idx = resultProbs[0] > resultProbs[1] ? 0 : 1;
			bw.write(String.format("%d\t%.4f" + Constants.ENDL, sample.label, resultProbs[idx]));
		}
		bw.close();
		for(Evaluator e : evaluators){
			System.out.println(e.resultString());
		}
	}

#No. 4570
#File: E:\bishe\1\AbstractSdkFidoMojo.java
#Comment:
    /**
     * The maven project.
     * 
     * @parameter expression="${project}"
     * @required
     * @readonly
     */

#Code:
    public MavenProject project;

    protected void ensureDirExists(File dir) throws MojoExecutionException {
        if (dir.exists()) {
            if (dir.isDirectory()) {
                return; // dir exists.
            }
        }
        if (dir.mkdirs() == false) {
            throw new MojoExecutionException("Unable to create directory: " + dir);
        }
    }

#No. 4571
#File: E:\bishe\1\AbstractSdpContentSession.java
#Comment:
	/**
	 * Star media element implementation.
	 * 
	 * @param sourceContentPath
	 *            Path of outgoing media element
	 * @param sinkContentPath
	 *            Path of ingoing media element
	 * @throws KurentoMediaFrameworkException
	 *             Exception while sending an SDP answer to client
	 */

#Code:
	@Override
	public void start(String sourceContentPath, String sinkContentPath) {
		try {
			Assert.isTrue(
					sourceContentPath != null || sinkContentPath != null,
					"Cannot invoke start specifying null source and sink content paths",
					1); // TODO

			goToState(
					STATE.STARTING,
					"Cannot start SdpEndPoint in state "
							+ getState()
							+ ". This is probably due to an explicit session termination comming from another thread",
					1); // TODO

			internalStart(sourceContentPath, sinkContentPath);

		} catch (KurentoMediaFrameworkException ke) {
			internalTerminateWithError(null, ke.getCode(), ke.getMessage(),
					null);
			throw ke;
		} catch (Throwable t) {
			KurentoMediaFrameworkException kmfe = new KurentoMediaFrameworkException(
					t.getMessage(), t, 20029);
			internalTerminateWithError(null, kmfe.getCode(), kmfe.getMessage(),
					null);
			throw kmfe;
		}
	}

#No. 4572
#File: E:\bishe\1\AbstractSearchRequest.java
#Comment:
    /**
     * Constant for denoting undefined value for result count.
     */

#Code:
    public static final int UNDEFINED = -1;

    private Query query;

    private List<IndexingContext> contexts;

    /**
     * The maximum count of results expected to have delivered, actually count of items (AIs). More precisely, with this
     * setting we LIMIT the number of Lucene Documents for total set of hits to be processed. If set to anything other
     * than {@link #UNDEFINED}, search will stop upon processing this count of AIs (that correspond to Lucene Document).
     */
    private int count;

    /**
     * The filter to be used while executing the search request.
     */
    private ArtifactInfoFilter artifactInfoFilter;

    /**
     * The postprocessor to apply to hits while returning the,
     */
    private ArtifactInfoPostprocessor artifactInfoPostprocessor;

    /**
     * The highlighting requests, if any.
     */
    private List<MatchHighlightRequest> matchHighlightRequests;

    /**
     * Should Lucene Explanations be added to resulting ArtifactInfo's attributes (keyed as
     * org.apache.lucene.search.Explanation.class.getName())? Warning: calculating these are costly operation, and
     * should not be used in production systems (maybe on some "debug" like UI or so).
     */
    private boolean luceneExplain = false;

    public AbstractSearchRequest( Query query )
    {
        this( query, null );
    }

#No. 4573
#File: E:\bishe\1\AbstractSearchRequest.java
#Comment:
    /**
     * Returns the "count" of wanted results. See {@link #UNDEFINED} and {@link #count}.
     * 
     * @return
     */

#Code:
    public int getCount()
    {
        return count;
    }

#No. 4574
#File: E:\bishe\1\AbstractSearchRequest.java
#Comment:
    /**
     * Sets the "count" of wanted results. See {@link #UNDEFINED} and {@link #count}.
     * 
     * @param count
     */

#Code:
    public void setCount( int count )
    {
        if ( UNDEFINED != count && count < 1 )
        {
            throw new IllegalArgumentException( "Count cannot be less than 1!" );
        }

        this.count = count;
    }

#No. 4575
#File: E:\bishe\1\AbstractSearchRequest.java
#Comment:
    /**
     * Returns true if hits are limited.
     * 
     * @return
     * @deprecated always returns false, since 4.1.0 there is no notion of hit limit
     * @see http://jira.codehaus.org/browse/MINDEXER-14
     */

#Code:
    public boolean isHitLimited()
    {
        return false;
    }

#No. 4576
#File: E:\bishe\1\AbstractSearchRequest.java
#Comment:
    /**
     * Gets the hit limit. Since 4.1.0 does nothing, always returns -1 (was "no hit limit").
     * 
     * @return
     * @deprecated always returns -1 (no hit limit), since 4.1.0 there is no notion of hit limit
     * @see http://jira.codehaus.org/browse/MINDEXER-14
     */

#Code:
    public int getResultHitLimit()
    {
        return -1;
    }

#No. 4577
#File: E:\bishe\1\AbstractSearchRequest.java
#Comment:
    /**
     * Sets the hit limit. Since 4.1.0 does nothing.
     * 
     * @param resultHitLimit
     * @deprecated does nothing, since 4.1.0 there is no notion of hit limit
     * @see http://jira.codehaus.org/browse/MINDEXER-14
     */

#Code:
    public void setResultHitLimit( int resultHitLimit )
    {
        // noop
    }

#No. 4578
#File: E:\bishe\1\AbstractSearchResponse.java
#Comment:
    /**
     * Returns the number of total hits found. This may be different that actual hits returned (is usually more).
     * 
     * @return
     * @deprecated use {@link #getTotalHitsCount()} instead.
     */

#Code:
    public int getTotalHits()
    {
        return getTotalHitsCount();
    }

#No. 4579
#File: E:\bishe\1\AbstractSearchResponse.java
#Comment:
    /**
     * Returns the number of total hits found by this query (total number of potential hits as reported by Lucene
     * index). This is the number of existing AIs matching your query, and does not represent the count of hits
     * delivered, which is returned by {@link #getReturnedHitsCount()}.
     * 
     * @return
     */

#Code:
    public int getTotalHitsCount()
    {
        return totalHitsCount;
    }

#No. 4580
#File: E:\bishe\1\AbstractSearchResponse.java
#Comment:
    /**
     * Returns the number of hits returned by this search response. This number is affected by various input parameters
     * (like count set on request) and filtering, paging, etc. Warning: this number's meaning depends on actual search
     * response (for flat response number of actual AIs, for grouped response number of actual groups), and also, might
     * be not precise at all (see {@link IteratorSearchResponse}).
     * 
     * @return
     */

#Code:
    public int getReturnedHitsCount()
    {
        return returnedHitsCount;
    }

#No. 4581
#File: E:\bishe\1\AbstractSearchResponse.java
#Comment:
    /**
     * Returns true if hit limit exceeded.
     * 
     * @return
     * @deprecated always returns false, since 4.1.0 there is no notion of hit limit
     * @see http://jira.codehaus.org/browse/MINDEXER-14
     */

#Code:
    public boolean isHitLimitExceeded()
    {
        return false;
    }

#No. 4582
#File: E:\bishe\1\AbstractSearchResponse.java
#Comment:
    /**
     * Frees any resource associated with this response. Should be called as last method on this response, when it's not
     * used anymore.
     * 
     * @throws IOException
     */

#Code:
    public void close()
        throws IOException
    {
        // noop
    }

#No. 4583
#File: E:\bishe\1\AbstractSearchService.java
#Comment:
    /**
     * rebuild contacts and calllogs in a new thread
     *
     * @param urgent
     */

#Code:
    public void asyncRebuild(final boolean urgent) {
        rebuildThreadPool.execute(new Runnable() {
            public void run() {
                rebuildContacts(urgent);
            }
        });
        rebuildThreadPool.execute(new Runnable() {
            public void run() {
                rebuildCalllog(urgent);
            }
        });
    }

#No. 4584
#File: E:\bishe\1\AbstractSearchService.java
#Comment:
    /**
     * 不能使用lucene的highlight,因为号码使用的是NGram分词，所以token项很多，这就导致高亮枚举token特别耗时
     *
     * @param number
     * @param query
     * @return
     * @throws java.io.IOException
     */

#Code:
    protected String highlightNumber(String number, String query) throws IOException {
        if (StringUtils.isEmpty(query)) {
            return null;
        }
        int start = number.indexOf(query);
        if (start != -1) {
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append(number.substring(0, start));
            stringBuilder.append(preTag).append(query).append(postTag).append(number.substring(start + query.length()));
            return stringBuilder.toString();
        }
        return null;
    }

#No. 4585
#File: E:\bishe\1\AbstractSectionableItem.java
#Comment:
/**
 * Generic implementation of {@link ISectionable} interface for items that hold a header item.
  * <p>This abstract class extends {@link AbstractFlexibleItem}.</p>
 *
 * @param <VH> {@link android.support.v7.widget.RecyclerView.ViewHolder}
 * @param <H>  The header item of type {@link IHeader}
 * @author Davide Steduto
 * @since 20/01/2016 Created
 */

#Code:
public abstract class AbstractSectionableItem<VH extends RecyclerView.ViewHolder, H extends IHeader>
		extends AbstractFlexibleItem<VH>
		implements ISectionable<VH, H> {

	/**
	 * The header of this item
	 */
	protected H header;

	public AbstractSectionableItem(H header) {
		this.header = header;
	}

	@Override
	public H getHeader() {
		return header;
	}

	@Override
	public void setHeader(H header) {
		this.header = header;
	}

}
#No. 4586
#File: E:\bishe\1\AbstractSecurityAttributesTest.java
#Comment:
/**
 * The base class for testing Spring Security attributes.
 */

#Code:
@RunWith(SpringRunner.class)
@SpringBootTest(
        value = {
                "security.basic.enabled=true",
                "security.user.name=TEST-USER",
                "security.user.password=TEST-PASSWORD",
                "logback.access.config=classpath:logback-access.queue.xml",
        },

#No. 4587
#File: E:\bishe\1\AbstractSecurityAttributesTest.java
#Comment:
    /**
     * The REST template.
     */

#Code:
    @Autowired
    protected TestRestTemplate rest;

    /**
     * Creates a test rule.
     *
     * @return a test rule.
     */
    @Rule
    public TestRule rule() {
        return RuleChain
                .outerRule(new LogbackAccessEventQueuingAppenderRule())
                .around(new LogbackAccessEventQueuingListenerRule());
    }

#No. 4588
#File: E:\bishe\1\AbstractSecurityAttributesTest.java
#Comment:
    /**
     * Tests a Logback-access event.
     */

#Code:
    @Test
    public void logbackAccessEvent() {

        ResponseEntity<String> response = rest
                .withBasicAuth("TEST-USER", "TEST-PASSWORD")
                .getForEntity("/test/text", String.class);
        IAccessEvent event = LogbackAccessEventQueuingAppender.appendedEventQueue.pop();
        LogbackAccessEventQueuingListener.appendedEventQueue.pop();

        assertThat(response).hasStatusCode(HttpStatus.OK);
        assertThat(event).hasRemoteUser("TEST-USER");

    }

#No. 4589
#File: E:\bishe\1\AbstractSecurityPanel.java
#Comment:
	/**
	 * @param resourceName
	 * @param securityController
	 */

#Code:
	public void load() {
		securityController.getResourcePermissions(getRsourceTypeOrdinal(),resourceName, new GetPermAsync());
	}

#No. 4590
#File: E:\bishe\1\AbstractSecurityPanel.java
#Comment:
	//********************************************************************
	//               private method
	//********************************************************************
	private void addRow(final PermissionModel model) {
		//need check if this group/user already in panel, if so, skip it: don't add duplicated value
		int rowCount = table.getRowCount();
		for(int idx=startRow;idx<rowCount;idx++){
			WritableCheckbox box = (WritableCheckbox) table.getWidget(idx, startCol);
			PermissionModel myModel = (PermissionModel) box.getObject();
			if(myModel.equals(model)){
				//duplicated! don't add to new row
				return;
			}
		}
		
		int[] validOperations = getValidOperations();

		int row = startRow;
		if(model.mask){
			//always put mask in last row
			row = table.getRowCount();
			table.setText(row,startCol,Msg.consts.masks());
			table.getFlexCellFormatter().setColSpan(row, startCol,validOperations.length);
			
			row++;
			table.setText(row,startCol,Msg.consts.masks());
			for(int idx=startCol;idx< validOperations.length;idx++){
				model.operation = validOperations[idx];
				addColumn(model,false,row,idx+1);
			}
			return;
		}
		
		row = calculateRow(startRow, model);
		
		//first column: role/user name
		if(model.ownerType == OWNER_TYPE_ROLE){
			table.setWidget(row, 0, new Image(IconBundle.I.get().group()));
			if(this instanceof SpaceSecurityPanel && model.roleType == SharedConstants.ROLE_TYPE_SPACE){
				//display this space's user group if they are friend space
				ClickLink groupLink = new ClickLink(model.ownerDisplayName);
				groupLink.addClickHandler(new ClickHandler() {
					public void onClick(ClickEvent event) {
						((SpaceSecurityPanel)AbstractSecurityPanel.this).showGroupUsers(resourceName,model.ownerName.substring(SharedConstants.ROLE_SPACE_PREFIX.length()));
					}
				});
				table.setWidget(row,1,groupLink);
			}else{
				table.setText(row,1,model.ownerDisplayName);
			}
		}else if(model.ownerType == OWNER_TYPE_USER){
			table.setWidget(row, 0, ButtonIconBundle.userImage());
			//TODO: page or space resource need to set spaceUname?
			UserProfileLink userLink = new UserProfileLink(model.ownerDisplayName, null , model.ownerName, null);
			table.setWidget(row, 1, userLink);
		}
		
		for(int idx=0;idx< validOperations.length;idx++){
//			when new added user/role which chosen from user/role list, the ownerName is null
			//but for admin and anonymous, it always on list when this panel first show, so, owner name always has value.
			boolean readonly = false;
			if(model.ownerName != null){
				//XXX:HARDCODE:role name
				if(model.ownerName.equalsIgnoreCase(SharedConstants.ROLE_ADMIN)){
					readonly = getRoleAdminReadonly(validOperations[idx]);
				}else if(model.ownerName.equalsIgnoreCase(SharedConstants.ROLE_ANONYMOUS)){
					readonly = getRoleAnonymousReadonly(validOperations[idx]);
				}
			}

			//column is from 1, because first is ownerDisplayName
			model.operation = validOperations[idx];
			addColumn(model,readonly,row,idx+startCol);
		}
		
		if(model.ownerType == OWNER_TYPE_ROLE){
			roleRowCount++;
		}else if(model.ownerType == OWNER_TYPE_USER){
			userRowCount++;
		}

	}


	private void addColumn(PermissionModel model,boolean readOnly, int row, int column ){
		//special for page:only allow tick off, does allow turn on, except this permission is tick off in page level
		boolean checked = model.operations[model.operation];
//		SecurityValues.RESOURCE_TYPES.PAGE
		if(getRsourceTypeOrdinal() == 2){
			//if current is off
			if(!model.operations[model.operation]){
				//this node mark off by page permission (model.dead == true)
				readOnly = !model.dead[model.operation];
			}
			//if this operation is marked off on upper level (space/instance), page must mark it as off.
			if(model.dead[model.operation])
				checked = false;
		}else{
			//mark different for space/instance, these setting is useless currently, until corresponding attribute turn on
			//such as Role1 space read, must wait Role1 instance read open
			if(model.dead[model.operation]){
				//TODO
			}
		}
		//the index of operations decided by SecurityValues.OPERATIONS enum positions
		WritableCheckbox box = new WritableCheckbox(checked,model.editing,readOnly);
		PermissionModel myModel = (PermissionModel) model.clone();
		box.setObject(myModel);
		table.setWidget(row, column,  box);
	}
	/*
	 * Set permission table to enable edit or disable edit.
	 */

#Code:
	private void setTableEditable(boolean editable) {
		int rowSize = table.getRowCount();
		for(int rowIdx=startRow;rowIdx<rowSize;rowIdx++){
			int colSize = table.getCellCount(rowIdx);
			for(int colIdx=startCol;colIdx<colSize;colIdx++){
				Widget w = table.getWidget(rowIdx, colIdx);
				if(!(w instanceof WritableCheckbox))
					continue;
				WritableCheckbox box = (WritableCheckbox) w;
				box.setEditing(editable);
			}
		}
		
	}

#No. 4591
#File: E:\bishe\1\AbstractSecurityPanel.java
#Comment:
	/*
	 * When user click "save" button while editing
	 */

#Code:
	private void updateEdit(final SecurityControllerAsync adminController,
			final UpdatePermissionAsync updatePermissionAsync) {
		ArrayList<PermissionModel> changedModelList = new ArrayList<PermissionModel>();
		int rowSize = table.getRowCount();
		for(int rowIdx=startRow;rowIdx<rowSize;rowIdx++){
			int colSize = table.getCellCount(rowIdx);
			for(int colIdx=startCol;colIdx<colSize;colIdx++){
				Widget w = table.getWidget(rowIdx, colIdx);
				if(!(w instanceof WritableCheckbox))
					continue;
				WritableCheckbox box = (WritableCheckbox) w;
				PermissionModel model = (PermissionModel) box.getObject();
				//call server and update 
				if(box.isChanged()){
//						Window.alert("Change " + model.ownerName + " oper:" + model.operation);
					model.checked = box.isChecked();
					changedModelList.add(model);
				}
			}
		}
		if(changedModelList.size() == 0){
			//nothing change, so just do same with cancel
			cancelEdit();
		}else{
			loadingImg.setVisible(true);
			adminController.updatePermission(getRsourceTypeOrdinal(),changedModelList,updatePermissionAsync);
		}
	}

#No. 4592
#File: E:\bishe\1\AbstractSecurityPanel.java
#Comment:
	/*
	 * When user click "cancel" button while editing
	 */

#Code:
	private void cancelEdit() {
		//does allow add role/user in view status
		buttonDeckPanel.showWidget(0);
		addRole.setVisible(false);
		addUser.setVisible(false);

		setTableEditable(false);
		//need remove all new added users/roles when cancelling
		List newAddedRow = new ArrayList();
		int rowSize = table.getRowCount();
		
		for(int rowIdx=startRow;rowIdx<rowSize;rowIdx++){
			int colSize = table.getCellCount(rowIdx);
			for(int colIdx=startCol;colIdx<colSize;colIdx++){
				Widget w = table.getWidget(rowIdx, colIdx);
				if(!(w instanceof WritableCheckbox))
					continue;
				WritableCheckbox box = (WritableCheckbox) w;
				box.reset();
				if(colIdx == startCol){
					//for each row, only need check first one is enough, break to next row.
					PermissionModel model = (PermissionModel) box.getObject();
					if(model.newadded){
						if(!newAddedRow.contains(Integer.valueOf(rowIdx))){
							newAddedRow.add(Integer.valueOf(rowIdx));
						}
						continue;
					}
				}
			}
		}
		//remove row from maximum to minimum so that the table row are always correct when removing.
		for(int idx=newAddedRow.size() -1;idx>=0;idx--){
			table.removeRow(((Integer)newAddedRow.get(idx)).intValue());
		}
	}

#No. 4593
#File: E:\bishe\1\AbstractSeekableByteChannel.java
#Comment:
    /**
     * Advances this channel's position by the given number of bytes, if it is
     * positive. If the number of bytes is zero or negative, the position is not
     * changed.
     *
     * @param numBytes the number of bytes transferred
     *
     * @return the input number of bytes
     */

#Code:
    protected final int advancePosition(int numBytes) {
        if (numBytes > 0) {
            position += numBytes;
        }
        return numBytes;
    }

#No. 4594
#File: E:\bishe\1\AbstractSeekableByteChannel.java
#Comment:
    /**
     * Sets this channel's position to {@code size} if it is less than the
     * current position.
     *
     * @param size the new size of the underlying resource
     *
     * @return {@code true} if this channel's position changed, {@code false}
     *         otherwise
     */

#Code:
    protected final boolean truncatePosition(long size) {
        checkArgument(size >= 0, "size cannot be negative");
        if (size < position) {
            position = size;
            return true;
        } else {
            return false;
        }
    }

#No. 4595
#File: E:\bishe\1\AbstractSeekableByteChannel.java
#Comment:
    /**
     * Checks that this channel is open. Implementations should call this at the
     * start of every I/O method.
     *
     * @throws ClosedChannelException if this channel is closed
     */

#Code:
    protected final void checkIsOpen() throws ClosedChannelException {
        if (!isOpen()) {
            throw new ClosedChannelException();
        }
    }

#No. 4596
#File: E:\bishe\1\AbstractSelect.java
#Comment:
	/**
	 * @param list a list of unsorted keys.
	 * @param k the k'th maximum key to search.
	 * @return the k'th maximum key in the list.
	 * @throws IllegalArgumentException if the size of the list is smaller than {@code k}. 
	 */

#Code:
	abstract public T max(List<T> list, int k);
	
	protected void throwIllegalArgumentException(List<T> list, int k)
	{
		if (list.size() < k)
			throw new IllegalArgumentException("The array size is smaller than k.");
	}

#No. 4597
#File: E:\bishe\1\AbstractSelectableChannel.java
#Comment:
    /**
     * Adjusts this channel's blocking mode.
     *
     * <p> If the given blocking mode is different from the current blocking
     * mode then this method invokes the {@link #implConfigureBlocking
     * implConfigureBlocking} method, while holding the appropriate locks, in
     * order to change the mode.  </p>
     */

#Code:
    public final SelectableChannel configureBlocking(boolean block)
        throws IOException
    {
        synchronized (regLock) {
            if (!isOpen())
                throw new ClosedChannelException();
            if (blocking == block)
                return this;
            if (block && haveValidKeys())
                throw new IllegalBlockingModeException();
            implConfigureBlocking(block);
            blocking = block;
        }
        return this;
    }

#No. 4598
#File: E:\bishe\1\AbstractSelection.java
#Comment:
    /**
     * Returns the selection produced by this object.
     *
     * @return the selection produced by this object.
     */

#Code:
    public String sel() {
        return mSelection.toString();
    }

#No. 4599
#File: E:\bishe\1\AbstractSelection.java
#Comment:
    /**
     * Returns the selection arguments produced by this object.
     *
     * @return the selection arguments produced by this object.
     */

#Code:
    public String[] args() {
        int size = mSelectionArgs.size();
        if (size == 0) return null;
        return mSelectionArgs.toArray(new String[size]);
    }

#No. 4600
#File: E:\bishe\1\AbstractSelection.java
#Comment:
    /**
     * Returns the order string produced by this object.
     *
     * @return the order string.
     */

#Code:
    public String order() {
        return mOrderBy.length() > 0 ? mOrderBy.toString() : null;
    }

#No. 4601
#File: E:\bishe\1\AbstractSelection.java
#Comment:
    /**
     * Returns the {@code uri} argument to pass to the {@code ContentResolver} methods.
     *
     * @return the Uri to pass to ContentResolver.
     */

#Code:
    public Uri uri() {
        Uri uri = baseUri();
        if (mNotify != null) uri = BaseContentProvider.notify(uri, mNotify);
        if (mGroupBy != null) uri = BaseContentProvider.groupBy(uri, mGroupBy);
        if (mHaving != null) uri = BaseContentProvider.having(uri, mHaving);
        if (mLimit != null) uri = BaseContentProvider.limit(uri, String.valueOf(mLimit));
        return uri;
    }

#No. 4602
#File: E:\bishe\1\AbstractSelection.java
#Comment:
    /**
     * Deletes row(s) specified by this selection.
     *
     * @param contentResolver The content resolver to use.
     * @return The number of rows deleted.
     */

#Code:
    public int delete(ContentResolver contentResolver) {
        return contentResolver.delete(uri(), sel(), args());
    }

#No. 4603
#File: E:\bishe\1\AbstractSelection.java
#Comment:
    /**
     * Deletes row(s) specified by this selection.
     *
     * @param context The context to use.
     * @return The number of rows deleted.
     */

#Code:
    public int delete(Context context) {
        return context.getContentResolver().delete(uri(), sel(), args());
    }

#No. 4604
#File: E:\bishe\1\AbstractSelectionKey.java
#Comment:
/**
 * Base implementation class for selection keys.
 *
 * <p> This class tracks the validity of the key and implements cancellation.
 *
 * @author Mark Reinhold
 * @author JSR-51 Expert Group
 * @since 1.4
 */

#Code:

public abstract class AbstractSelectionKey
    extends SelectionKey
{

    /**
     * Initializes a new instance of this class.  </p>
     */
    protected AbstractSelectionKey() { }

    private volatile boolean valid = true;

    public final boolean isValid() {
        return valid;
    }

    void invalidate() {                                 // package-private
        valid = false;
    }

    /**
     * Cancels this key.
     *
     * <p> If this key has not yet been cancelled then it is added to its
     * selector's cancelled-key set while synchronized on that set.  </p>
     */
    public final void cancel() {
        // Synchronizing "this" to prevent this key from getting canceled
        // multiple times by different threads, which might cause race
        // condition between selector's select() and channel's close().
        synchronized (this) {
            if (valid) {
                valid = false;
                ((AbstractSelector)selector()).cancel(this);
            }
        }
    }
}

#No. 4605
#File: E:\bishe\1\AbstractSelectionProvider.java
#Comment:
    /**
     * Inform listeners about a change of selection.
     */

#Code:
    private void fireSelectionChanged() {
        SelectionChangedEvent event = new SelectionChangedEvent(this, getSelection());
        if (_selectionChangeListeners != null) {
            for (ISelectionChangedListener listener : _selectionChangeListeners) {
                listener.selectionChanged(event);
            }
        }
    }

#No. 4606
#File: E:\bishe\1\AbstractSelectionProvider.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public void rowSelectionAdded(IRow row) {
        fireSelectionChanged();
    }

#No. 4607
#File: E:\bishe\1\AbstractSelectionProvider.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public void rowSelectionRemoved(IRow row) {
        fireSelectionChanged();
    }

#No. 4608
#File: E:\bishe\1\AbstractSelectionProvider.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public void cellSelectionAdded(IJaretTableCell cell) {
        fireSelectionChanged();
    }

#No. 4609
#File: E:\bishe\1\AbstractSelectionProvider.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public void cellSelectionRemoved(IJaretTableCell cell) {
        fireSelectionChanged();
    }

#No. 4610
#File: E:\bishe\1\AbstractSelectionProvider.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public void columnSelectionAdded(IColumn column) {
        fireSelectionChanged();
    }

#No. 4611
#File: E:\bishe\1\AbstractSelectionProvider.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public void columnSelectionRemoved(IColumn column) {
        fireSelectionChanged();
    }

#No. 4612
#File: E:\bishe\1\AbstractSelector.java
#Comment:
/**
 * ???
 *
 * @since 1.0
 */

#Code:
public abstract class AbstractSelector
    extends ComponentSupport
    implements Selector
{
  private final SelectionFactory selectionFactory;

  @Inject
  public AbstractSelector(final SelectionFactory selectionFactory) {
      this.selectionFactory = Preconditions.checkNotNull(selectionFactory);
  }

  protected SelectionFactory getSelectionFactory() {
    return selectionFactory;
  }
}

#No. 4613
#File: E:\bishe\1\AbstractSelectorComponent.java
#Comment:
    /**
     * Returns separator icon in the given state.
     *
     * @param state state.
     *
     * @return icon.
     */

#Code:
    protected static Icon getSeparatorIcon(State state)
    {
        return SEPARATOR[state.ordinal()];
    }

#No. 4614
#File: E:\bishe\1\AbstractSelectorComponent.java
#Comment:
    /**
     * Returns the state of the mode button.
     *
     * @param md    mode.
     *
     * @return state.
     */

#Code:
    protected State getCurrentState(int md)
    {
        return pressed == md && mouseOver ? State.PRESSED : getMode() == md ? State.ON : State.OFF;
    }

#No. 4615
#File: E:\bishe\1\AbstractSelectorComponent.java
#Comment:
    /**
     * Returns the state of a separator component between two buttons with
     * the given states.
     *
     * @param firstState    first state.
     * @param secondState   second state.
     *
     * @return separator state.
     */

#Code:
    protected static State getSeparatorState(State firstState, State secondState)
    {
        return (firstState == State.ON || secondState == State.ON)
            ? State.ON : (firstState == State.PRESSED || secondState == State.PRESSED)
            ? State.PRESSED : State.OFF;
    }

#No. 4616
#File: E:\bishe\1\AbstractSelectorComponent.java
#Comment:
    /**
     * Processes mouse motion events, such as MouseEvent.MOUSE_DRAGGED.
     *
     * @param e the <code>MouseEvent</code>
     *
     * @see java.awt.event.MouseEvent
     */

#Code:
    protected void processMouseMotionEvent(MouseEvent e)
    {
        int id = e.getID();
        if (!contains(e.getPoint())) return;

        if (id == MouseEvent.MOUSE_DRAGGED)
        {
            int md = locationToMode(e.getPoint());
            if (pressed != md)
            {
                if (mouseOver)
                {
                    mouseOver = false;
                    repaint();
                }
            } else if (!mouseOver)
            {
                mouseOver = true;
                repaint();
            }
        }
    }

#No. 4617
#File: E:\bishe\1\AbstractSelectorComponent.java
#Comment:
    /**
     * Returns current mode.
     *
     * @return mode.
     */

#Code:
    private int getMode()
    {
        return (Integer)model.getValue();
    }

#No. 4618
#File: E:\bishe\1\AbstractSelectorComponent.java
#Comment:
    /**
     * Sets different mode.
     *
     * @param mode mode.
     */

#Code:
    protected void setMode(int mode)
    {
        model.setValue(mode);
    }

#No. 4619
#File: E:\bishe\1\AbstractSelectorComponent.java
#Comment:
    /**
     * Returns icon by its resource key. It automatically appends ".mac" to the
     * key on Mac platform.
     *
     * @param key key of the icon resource.
     *
     * @return icon.
     */

#Code:
    protected static Icon getIcon(String key)
    {
        if (SystemUtils.IS_OS_MAC) key += ".mac";
        return IconSource.getIcon(key);
    }

#No. 4620
#File: E:\bishe\1\AbstractSelectorComponent.java
#Comment:
    /**
     * Listens for mode changes.
     */

#Code:
    protected class ModelChangeListener implements PropertyChangeListener
    {
        /**
         * Invoked when mode changes.
         *
         * @param evt event object.
         */
        public void propertyChange(PropertyChangeEvent evt)
        {
            if (!selfEvent) repaint();
        }
    }

#No. 4621
#File: E:\bishe\1\AbstractSelectorManager.java
#Comment:
						/**
						 * slot match, but got nothing from this slot, should
						 * not happen, log and bump awaiting offset to avoid
						 * infinite triggering
						 */

#Code:
						log.warn("Slot match, but nothing got from this slot");
						nextAwaitingOffset = nextAwaitingNormalOffset(key, slotMatchResults[i].biggerOffset(), triggerResult.getArg());
						// biggerOffset is triggeringOffset
					} else {
						nextAwaitingOffset = slotMatchResults[i].getAwaitingOffset();
					}

#No. 4622
#File: E:\bishe\1\AbstractSelectorManager.java
#Comment:
			/**
			 * Triggered but got nothing, usually triggered by safe trigger.
			 * Bump all matched awaiting offset to avoid immediately triggered
			 * again.
			 */

#Code:
			nextAwaitingSlots = new Slot[slotCount];

			for (int i = 0; i < slotCount - 1; i++) {
				if (slotMatchResults[i].isMatch()) {
					nextAwaitingOffset = nextAwaitingNormalOffset(key, slotMatchResults[i].biggerOffset(), triggerResult.getArg());
					// biggerOffset is triggeringOffset
				} else {
					nextAwaitingOffset = slotMatchResults[i].getAwaitingOffset();
				}
				nextAwaitingSlots[i] = new Slot(i, nextAwaitingOffset);
			}

#No. 4623
#File: E:\bishe\1\AbstractSelectorManager.java
#Comment:
			/**
			 * Some elements is got, but some error occurred when processing,
			 * and the elements are returned. So wait until triggered by safe
			 * trigger.
			 */

#Code:
			nextAwaitingSlots = new Slot[1];

			nextAwaitingSlots[0] = new Slot(slotCount - 1, nextAwaitingSafeTriggerOffset(key, triggerResult.getArg()));
			break;
		}

		getSelector().register(key, expireTimeHolder, callback, callbackCtx.getTriggerTime(), nextAwaitingSlots);
	}

	@Override
	public void register(T key, ExpireTimeHolder expireTimeHolder, SelectorCallback callback, Object arg, long... initDoneOffsets) {
		int slotCount = getSelector().getSlotCount();
		Preconditions.checkArgument(initDoneOffsets.length == slotCount - 1, //
				"initDoneOffsets length %s is not slot count %s minus 1", initDoneOffsets.length, slotCount);

		Slot[] slots = new Slot[slotCount];

		for (int i = 0; i < slotCount - 1; i++) {
			slots[i] = new Slot(i, nextAwaitingNormalOffset(key, initDoneOffsets[i], arg));
		}

		slots[slotCount - 1] = new Slot(slotCount - 1, nextAwaitingSafeTriggerOffset(key, arg));

		getSelector().register(key, expireTimeHolder, callback, System.currentTimeMillis(), slots);
	}

#No. 4624
#File: E:\bishe\1\AbstractSelectPageAction.java
#Comment:
	/**
	 * 创建对话框的确认按钮
	 * 
	 * @return
	 */

#Code:
	protected ButtonOption buildOkButton() {
		return new ButtonOption(getOkButtonLabel(), null, getClickOkMethod());
	}

#No. 4625
#File: E:\bishe\1\AbstractSelectPageAction.java
#Comment:
	/**
	 * 对话框确认按钮显示的文字
	 * 
	 * @return
	 */

#Code:
	protected String getOkButtonLabel() {
		return getText("label.ok");
	}

#No. 4626
#File: E:\bishe\1\AbstractSemiAutoTracker.java
#Comment:
	/**
	 * Returns a new instance of a {@link SpotDetector} that will inspect the
	 * neighborhood.
	 *
	 * @param img
	 *            the source image.
	 * @param interval
	 *            defines the neighborhood to inspect.
	 * @param calibration
	 *            the pixel sizes to convert pixel coordinates into image
	 *            coordinates.
	 * @param radius
	 *            the expected spot radius.
	 * @param quality
	 *            the quality threshold below which found spots will be
	 *            discarded.
	 * @return a new {@link SpotDetector}.
	 */

#Code:
	protected SpotDetector< T > createDetector( final RandomAccessible< T > img, final Interval interval, final double[] calibration, final double radius, final double quality )
	{
		final LogDetector< T > detector = new LogDetector< T >( img, interval, calibration, radius, quality, true, false );
		detector.setNumThreads( 1 );
		return detector;
	}

#No. 4627
#File: E:\bishe\1\AbstractSemiAutoTracker.java
#Comment:
	/**
	 * A utility class made to return the information on a neighborhood
	 * generated from a source around a {@link Spot}.
	 */

#Code:
	public static class SearchRegion< R >
	{
		/** The source image. */
		public RandomAccessible< R > source;

		/**
		 * The source image calibration. That is: the pixel sizes in all
		 * dimensions, to account for anisotropy in the source image (
		 * <i>e.g.</i>dz might larger that dx, and the detector needs to exploit
		 * that).
		 * <p>
		 * The segmented spots will be returned with coordinates scaled with
		 * this calibration (image coordinates).
		 */
		public double[] calibration;

		/**
		 * The neighborhood in the source image to inspect, in pixel
		 * coordinates.
		 */
		public Interval interval;

		/**
		 * An affine transform that will convert the spot coordinates in the
		 * calibrated image coordinates to the global coordinate system whatever
		 * it is. If you do not have fancy rotations and multi-sources handling,
		 * this is most likely the identity transform.
		 */
		public AffineTransform3D transform;
	}

#No. 4628
#File: E:\bishe\1\AbstractSenderModule.java
#Comment:
  /**
   * @param sResendAction
   *        Handler action name to use. May not be <code>null</code>.
   * @param aMsg
   *        The message to be resend. May be an AS2 message or an MDN.
   * @param aCause
   *        The error cause.
   * @param nTriesLeft
   *        The number of retries left.
   * @return <code>true</code> if the message was scheduled for re-sending.
   * @throws OpenAS2Exception
   *         In case of an error
   */

#Code:
  protected final boolean doResend (@Nonnull final String sResendAction,
                                    @Nonnull final IMessage aMsg,
                                    @Nullable final OpenAS2Exception aCause,
                                    final int nTriesLeft) throws OpenAS2Exception
  {
    if (nTriesLeft <= 0)
    {
      s_aLogger.info ("Retry count exceeded - no more retries for" + aMsg.getLoggingText ());
      return false;
    }

    final ICommonsMap <String, Object> aOptions = new CommonsHashMap<> ();
    aOptions.put (IProcessorResenderModule.OPTION_CAUSE, aCause);
    aOptions.put (IProcessorResenderModule.OPTION_INITIAL_SENDER, this);
    aOptions.put (IProcessorResenderModule.OPTION_RESEND_ACTION, sResendAction);
    aOptions.put (IProcessorResenderModule.OPTION_RETRIES, Integer.toString (nTriesLeft));
    getSession ().getMessageProcessor ().handle (IProcessorResenderModule.DO_RESEND, aMsg, aOptions);

    s_aLogger.info ("Scheduled message for resending" + aMsg.getLoggingText ());
    return true;
  }

#No. 4629
#File: E:\bishe\1\AbstractSensor.java
#Comment:
	/**
	 * Convenience method to access the application context. However, you should
	 * not call this in your sensor constructor, the value might not be
	 * initialized yet
	 * 
	 * @return
	 */

#Code:
	protected Context getContext() {
		return SensorRegistry.getInstance().getContext();
	}

#No. 4630
#File: E:\bishe\1\AbstractSequenceMaxValueIncrementer.java
#Comment:
	/**
	 * 设置缓存个数。
	 */

#Code:
	public void setCacheSize(int cacheSize) {
		this.cacheSize = cacheSize;
	}

#No. 4631
#File: E:\bishe\1\AbstractSequenceMaxValueIncrementer.java
#Comment:
	/**
	 * 返回缓存个数。
	 */

#Code:
	public int getCacheSize() {
		return this.cacheSize;
	}

#No. 4632
#File: E:\bishe\1\AbstractSequenceMaxValueIncrementer.java
#Comment:
	/**
	 * 获取步进。
	 */

#Code:
	public long getStep() {
		return step;
	}

#No. 4633
#File: E:\bishe\1\AbstractSequenceMaxValueIncrementer.java
#Comment:
	/**
	 * 设置步进。
	 */

#Code:
	public void setStep(long step) {
		this.step = step;
	}

#No. 4634
#File: E:\bishe\1\AbstractSequentialIterator.java
#Comment:
/**
 * This class provides a skeletal implementation of the {@code Iterator}
 * interface for sequences whose next element can always be derived from the
 * previous element. Null elements are not supported, nor is the
 * {@link #remove()} method.
 *
 * <p>Example: <pre>   {@code
 *
 *   Iterator<Integer> powersOfTwo = 
 *       new AbstractSequentialIterator<Integer>(1) {
 *         protected Integer computeNext(Integer previous) {
 *           return (previous == 1 << 30) ? null : previous * 2;
 *         }
 *       };}</pre>
 *
 * @author Chris Povirk
 * @since 12.0 (in Guava as {@code AbstractLinkedIterator} since 8.0)
 */

#Code:
@GwtCompatible
public abstract class AbstractSequentialIterator<T>
    extends UnmodifiableIterator<T> {
  private T nextOrNull;

  /**
   * Creates a new iterator with the given first element, or, if {@code
   * firstOrNull} is null, creates a new empty iterator.

#No. 4635
#File: E:\bishe\1\AbstractSerializingParameterProvider.java
#Comment:
	/**
	 * IMPORTANT: ITAI - This is done for supporting Linux and Mac environments. DO NOT REMOVE!
	 * 
	 * If EOL is in Linux style, change it to Windows style.
	 * 
	 * @param str String that contains eol 
	 * @return
	 */

#Code:
	protected String convertToWindowsEol(String str){
		if (!str.contains("\r\n")){
			return str.replace("\n", "\r\n");
		}
		return str;
	
	}

#No. 4636
#File: E:\bishe\1\AbstractServant.java
#Comment:
	/**
	 * 以XML协议进行服务处理
	 * @param ctx 上下文
	 * @return 结果
	 * @throws Exception
	 * 
	 * @since 1.4.0
	 */

#Code:
	protected int onXml(Context ctx) throws Exception{ // NOSONAR
		throw new ServantException("core.not_supported",
				"Protocol XML is not suppurted.");		
	}

#No. 4637
#File: E:\bishe\1\AbstractServer.java
#Comment:
    /**
     * Gets the current server config
     * 
     * @return the current config
     */

#Code:
    protected final K getServerConfig() {
        return serverConfig;
    }

#No. 4638
#File: E:\bishe\1\AbstractServer.java
#Comment:
    /**
     * Gets the server bind address.
     * 
     * @return the bind address.
     */

#Code:
    public final InetAddress getInetAddress() {
        return serverConfig.getAddress();
    }

#No. 4639
#File: E:\bishe\1\AbstractServer.java
#Comment:
    /**
     * Sets the server bind address. Will be taken into account during the next server start.
     * 
     * @param address
     *            new server bind address.
     * @throws NullPointerException
     *             if address is <code>null</code>
     * @throws ServerConfigurationException
     *             if address is invalid (not a local address)
     */

#Code:
    public final void setAddress(@Nonnull final InetAddress address) throws NullPointerException,
            ServerConfigurationException {
        setAddress(address, true);
    }

#No. 4640
#File: E:\bishe\1\AbstractServer.java
#Comment:
    /**
     * Add a target device to the server.
     * 
     * @param target
     *            the target to add.
     * @return the previous target that had the same TargetName or <code>null</code>
     */

#Code:
    public final T addTarget(@Nonnull final T target) {
        serverLock.writeLock().lock();
        try {
            final T prev = targets.put(target.getTargetName(), target);
            targetAdded(target, prev);
            return prev;
        }

#No. 4641
#File: E:\bishe\1\AbstractServer.java
#Comment:
    /**
     * Remove a target device from the server.
     * 
     * @param targetName
     *            name of the target to remove
     * @return the removed target or <code>null</code> if no target have this name
     */

#Code:
    public final T removeTarget(@Nonnull final String targetName) {
        serverLock.writeLock().lock();
        try {
            final T removed = targets.remove(Objects.requireNonNull(targetName));
            targetRemoved(targetName, removed);
            return removed;
        }

#No. 4642
#File: E:\bishe\1\AbstractServer.java
#Comment:
    /**
     * Lock to take to read the target map.
     * 
     * @return the lock to read the target map.
     */

#Code:
    protected final Lock getTargetSharedLock() {
        return serverLock.readLock();
    }

#No. 4643
#File: E:\bishe\1\AbstractServer.java
#Comment:
    /**
     * Read-only view of the targets. Must take the target shared lock to avoid a concurrent access from another thread.
     * 
     * @return the targets by name.
     */

#Code:
    protected final Map<String, T> getTargetMap() {
        return Collections.unmodifiableMap(targets);
    }

#No. 4644
#File: E:\bishe\1\AbstractServer.java
#Comment:
    /**
     * Gets notification broadcaster support.
     * 
     * @return the notification emitter
     */

#Code:
    protected final NotificationBroadcasterSupport getNotificationBroadcasterSupport() {
        return notificationEmitter;
    }

#No. 4645
#File: E:\bishe\1\AbstractServer.java
#Comment:
    /**
     * Gets a new sequence number.
     * 
     * @return the new sequence number
     */

#Code:
    protected final int getNotificationSequenceNumber() {
        return notificationSequenceNumber.getAndIncrement();
    }

#No. 4646
#File: E:\bishe\1\AbstractServerAdapter.java
#Comment:
    /**
     * Creates a description of context paths gathered from the {@link #getContextPaths()} method.
     * 
     * @return a description of context paths
     */

#Code:
    protected String getContextPathDescription()
    {
        StringBuilder builder = new StringBuilder();
        Collection<String> contextPaths = getContextPaths();

        for (String contextPath : contextPaths)
        {
            if (builder.length() > 0)
            {
                builder.append(", ");
            }

            builder.append(contextPath);
        }

        return builder.toString();
    }

#No. 4647
#File: E:\bishe\1\AbstractServerAdapter.java
#Comment:
    /**
     * Creates a description of ports gathered from the {@link #getPorts()} method.
     * 
     * @return a description of ports
     */

#Code:
    protected String getPortDescription()
    {
        StringBuilder builder = new StringBuilder();
        Collection<Integer> ports = new LinkedHashSet<Integer>();

        ports.addAll(getPorts());
        ports.addAll(getSecurePorts());

        for (Integer port : ports)
        {
            if (builder.length() > 0)
            {
                builder.append(", ");
            }

            builder.append(port);
        }

        return builder.toString();
    }

#No. 4648
#File: E:\bishe\1\AbstractServerCommand.java
#Comment:
    /**
     * Initializes this class's fields based on the given {@link ServerProperties}
     * @param serverProperties the configuration to source from
     */

#Code:
    public void initializeFromProperties(final ServerProperties serverProperties) {
        setHost(serverProperties.getServerHost());
        setPort(serverProperties.getServerPort());
        setPassword(serverProperties.getServerAdminPw());
    }

#No. 4649
#File: E:\bishe\1\AbstractServerConfig.java
#Comment:
    /**
     * Gets IP address.
     * 
     * @return the address
     */

#Code:
    public final InetAddress getAddress() {
        return address;
    }

#No. 4650
#File: E:\bishe\1\AbstractServerConfig.java
#Comment:
    /**
     * Check and set a new ip address.
     * 
     * @param address
     *            the new address to be set
     */

#Code:
    public final void setAddress(final InetAddress address) {

        try {
            // This call checks if address is null
            if (!address.isAnyLocalAddress() && NetworkInterface.getByInetAddress(address) == null) {
                throw new ServerConfigurationException("Invalid address: " + address);
            }
        }
        catch (final SocketException e) {
            throw new ServerConfigurationException("Invalid address: " + address, e);
        }
        this.address = address;
    }

#No. 4651
#File: E:\bishe\1\AbstractServerConfig.java
#Comment:
    /**
     * Get the port.
     * 
     * @return the current port
     */

#Code:
    public final int getPort() {
        return port;
    }

#No. 4652
#File: E:\bishe\1\AbstractServerConfig.java
#Comment:
    /**
     * Check and set the port.
     * 
     * @param port
     *            the new port to be set
     */

#Code:
    public final void setPort(final int port) {
        if (port < 1 || port > 0xFFFF) {
            throw new ServerConfigurationException("port=" + port);
        }
        this.port = port;
    }

#No. 4653
#File: E:\bishe\1\AbstractServerConfiguration.java
#Comment:
    /**
     * Builds the handler part.
     *
     * @param builder the builder
     */

#Code:
    protected void buildHandler(JettyConfigBuilder builder)
    {
        buildDefaultHandler(builder);
    }

#No. 4654
#File: E:\bishe\1\AbstractServerConfiguration.java
#Comment:
    /**
     * Builds the default handler.
     *
     * @param builder the builder
     */

#Code:
    protected void buildDefaultHandler(JettyConfigBuilder builder)
    {
        builder.comment("Handler");

        builder.beginSet("handler");
        {
            builder.beginNew(getDefaultHandlerClass());
            {
                File defaultWar = getDefaultWar();
                
                builder.arg((defaultWar != null) ? defaultWar.getAbsolutePath() : "/");
                builder.arg(getDefaultContextPath());

                if (getCustomWebDefaultsFile() != null)
                {
                    builder.set("defaultsDescriptor", getCustomWebDefaultsFile().getAbsolutePath());
                }

                Collection<String> configurations = new LinkedHashSet<String>();

                collectDefaultHandlerConfigurations(configurations);

                if (configurations.size() > 0)
                {
                    builder.setArray("configurationClasses", configurations.toArray());
                }

                buildDefaultHandlerSetters(builder);
            }
            builder.end();
        }
        builder.end();
    }

#No. 4655
#File: E:\bishe\1\AbstractServerConfiguration.java
#Comment:
    /**
     * Builds additional handler setters.
     *
     * @param builder the builder
     */

#Code:
    protected void buildDefaultHandlerSetters(JettyConfigBuilder builder)
    {
        builder.set("extraClasspath", link(defaultClasspath));
    }

#No. 4656
#File: E:\bishe\1\AbstractServerConnectionTest.java
#Comment:
    /**
     * @throws Exception
     */

#Code:
    @Before
    public void setUp() throws Exception {
        log = mock(Log.class);
    }

#No. 4657
#File: E:\bishe\1\AbstractServerConnectionTest.java
#Comment:
    /**
     * Tests that if there is an <id> provided in the pom.xml file but no
     * username and password, and there is no settings.xml file in the
     * plugin's context, then the plugin falls back to prompting for
     * credentials on the CLI.
     */

#Code:
    @Test
    public void testIdProvidedInPomButDefaultSettingsFile() throws Exception {
        final DeployMojo mojo = lookupMojoVerifyAndApplySettings("deploy", "id-provided-pom.xml", "default-settings.xml");
        mojo.setLog(log);
        mojo.getClientConfiguration();
        verify(log).debug(DeployMojo.DEBUG_MESSAGE_NO_SERVER_SECTION);
    }

#No. 4658
#File: E:\bishe\1\AbstractServerConnectionTest.java
#Comment:
    /**
     * Tests that if there is an <id> provided in the pom.xml file but no
     * username and password, and there is a settings.xml file that doesn't
     * match the id of the server, then the plugin falls back to prompting
     * for credentials on the CLI.
     */

#Code:
    @Test
    public void testIdProvidedInPomButNoServerSection() throws Exception {
        final DeployMojo mojo = lookupMojoVerifyAndApplySettings("deploy", "id-provided-pom.xml", "missing-id-settings.xml");
        mojo.setLog(log);
        mojo.getClientConfiguration();
        verify(log).debug(DeployMojo.DEBUG_MESSAGE_NO_SERVER_SECTION);
    }

#No. 4659
#File: E:\bishe\1\AbstractServerConnectionTest.java
#Comment:
    /**
     * Tests that if there is an <id> provided in the pom.xml file but no
     * username and password, and there is a settings.xml file that has a
     * <server> section that matches the id, but there is no username and
     * password specified, then the plugin falls back to prompting for
     * credentials on the CLI.
     */

#Code:
    @Test
    public void testIdProvidedInPomButNoCredentials() throws Exception {
        final DeployMojo mojo = lookupMojoVerifyAndApplySettings("deploy", "id-provided-pom.xml", "id-provided-settings.xml");
        mojo.setLog(log);
        mojo.getClientConfiguration();
        final InOrder inOrder = inOrder(log);
        inOrder.verify(log).debug(DeployMojo.DEBUG_MESSAGE_SETTINGS_HAS_ID);
        inOrder.verify(log).debug(DeployMojo.DEBUG_MESSAGE_NO_CREDS);
    }

#No. 4660
#File: E:\bishe\1\AbstractServerConnectionTest.java
#Comment:
    /**
     * Test that if credentials are provided in the pom.xml file, they are used
     * regardless of whether an <id> element is also present.
     */

#Code:
    @Test
    public void testCredentialsProvidedInPom() throws Exception {
        final DeployMojo mojo = lookupMojoAndVerify("deploy", "credentials-provided-pom.xml");
        mojo.setLog(log);
        mojo.getClientConfiguration();
    }

#No. 4661
#File: E:\bishe\1\AbstractServerConnectionTest.java
#Comment:
    /**
     * Tests that if there is an <id> provided in the pom.xml file but no
     * username and password, and there is a settings.xml file that has a
     * <server> section that matches the id, and the section includes
     * credentials, then they are used by the plugin.
     */

#Code:
    @Test
    public void testCredentialsProvidedInSettings() throws Exception {
        final DeployMojo mojo = lookupMojoVerifyAndApplySettings("deploy", "id-provided-pom.xml", "credentials-provided-settings.xml");
        mojo.setLog(log);
        mojo.getClientConfiguration();
        final InOrder inOrder = inOrder(log);
        inOrder.verify(log).debug(DeployMojo.DEBUG_MESSAGE_SETTINGS_HAS_ID);
        inOrder.verify(log).debug(DeployMojo.DEBUG_MESSAGE_SETTINGS_HAS_CREDS);
    }

#No. 4662
#File: E:\bishe\1\AbstractServerConnectionTest.java
#Comment:
    /**
     * Test that if there is no <id> element and no credentials in the pom.xml
     * file, then it falls back to prompting for them on the CLI.
     */

#Code:
    @Test
    public void testNoCredentialsOrIdInPom() throws Exception {
        final DeployMojo mojo = lookupMojoAndVerify("deploy", "missing-id-pom.xml");
        mojo.setLog(log);
        mojo.getClientConfiguration();
        verify(log).debug(DeployMojo.DEBUG_MESSAGE_NO_ID);
    }

#No. 4663
#File: E:\bishe\1\AbstractServerConnectionTest.java
#Comment:
    /**
     * Looks up the specified mojo by name, passing it the POM file that
     * references it and a settings file that configures it, then verifying
     * that the lookup was successful.
     *
     * @param mojoName         the name of the mojo being tested
     * @param pomFileName      the name of the pom.xml file to be used during testing
     * @param settingsFileName the settings.xml file to be used during testing
     *
     * @return the Mojo object under test
     *
     * @throws Exception if the mojo can not be found
     */

#Code:
    @SuppressWarnings("unchecked")
    private <T extends Mojo> T lookupMojoVerifyAndApplySettings(final String mojoName, final String pomFileName, final String settingsFileName) throws Exception {
        T mojo = lookupMojoAndVerify(mojoName, pomFileName);
        rule.setVariableValueToObject(mojo, "settings", getSettingsFile(settingsFileName));
        return mojo;
    }

#No. 4664
#File: E:\bishe\1\AbstractServerConnectionTest.java
#Comment:
    /**
     * Gets a settings.xml file from the input File and prepares it to be
     * attached to a pom.xml
     *
     * @param fileName file object pointing to the candidate settings file
     *
     * @return the settings object
     *
     * @throws java.io.IOException - if the settings file can't be read
     */

#Code:
    private Settings getSettingsFile(final String fileName) throws IOException {
        Map<String, ?> options = Collections.singletonMap(SettingsReader.IS_STRICT, Boolean.TRUE);
        SettingsReader reader = new DefaultSettingsReader();
        final File settingsFile = new File(BASE_CONFIG_DIR, fileName);
        assertTrue("Could not find settings file: " + settingsFile.getAbsolutePath(), settingsFile.exists());

        Settings settings = null;
        try {
            settings = reader.read(settingsFile, options);
        } catch (SettingsParseException e) {

        }

        return settings;
    }

#No. 4665
#File: E:\bishe\1\AbstractServerPortUnusingTest.java
#Comment:
/**
 * The base class for testing to unuse the server port.
 */

#Code:
@RunWith(SpringRunner.class)
@SpringBootTest(
        value = {
                "server.useForwardHeaders=true",
                "logback.access.config=classpath:logback-access.queue.xml",
                "logback.access.useServerPortInsteadOfLocalPort=false",
        },

#No. 4666
#File: E:\bishe\1\AbstractServerPortUnusingTest.java
#Comment:
    /**
     * The REST template.
     */

#Code:
    @Autowired
    protected TestRestTemplate rest;

    /**
     * The server port.
     */
    @LocalServerPort
    protected int port;

    /**
     * Creates a test rule.
     *
     * @return a test rule.
     */
    @Rule
    public TestRule rule() {
        return RuleChain
                .outerRule(new LogbackAccessEventQueuingAppenderRule())
                .around(new LogbackAccessEventQueuingListenerRule());
    }

#No. 4667
#File: E:\bishe\1\AbstractServiceProviderProcessor.java
#Comment:
    /**
     * Register a service.
     * If the class does not have an appropriate signature, an error will be printed and the registration skipped.
     * @param clazz the service implementation type (an error will be reported if not a {@link TypeElement})
     * @param annotation the (top-level) annotation registering the service, for diagnostic purposes
     * @param type the type to which the implementation must be assignable
     * @param path a path under which to register, or "" if inapplicable
     * @param position a position at which to register, or {@link Integer#MAX_VALUE} to skip
     * @param supersedes possibly empty list of implementation to supersede
     * @since 8.8
     */

#Code:
    protected final void register(
        Element el, Class<? extends Annotation> annotation,
        TypeMirror type, String path, int position, String... supersedes
    ) {
        if (el.getKind() != ElementKind.CLASS) {
            processingEnv.getMessager().printMessage(Kind.ERROR, annotation.getName() + " is not applicable to a " + el.getKind(), el);
            return;
        }
        if (el.getEnclosingElement().getKind() == ElementKind.CLASS && !el.getModifiers().contains(Modifier.STATIC)) {
            processingEnv.getMessager().printMessage(Kind.ERROR, "Inner class needs to be static to be annotated with @ServiceProvider", el);
            return;
        }
        
        TypeElement clazz = (TypeElement) el;
        String impl = processingEnv.getElementUtils().getBinaryName(clazz).toString();
        String xface = processingEnv.getElementUtils().getBinaryName((TypeElement) processingEnv.getTypeUtils().asElement(type)).toString();
        if (!processingEnv.getTypeUtils().isAssignable(clazz.asType(), type)) {
            AnnotationMirror ann = findAnnotationMirror(clazz, annotation);
            processingEnv.getMessager().printMessage(Kind.ERROR, impl + " is not assignable to " + xface,
                    clazz, ann, findAnnotationValue(ann, "service"));
            return;
        }
        String rsrc = (path.length() > 0 ? "META-INF/namedservices/" + path + "/" : "META-INF/services/") + xface;
        Boolean verify = verifiedClasses.get(clazz);
        if (verify == null) {
            verify = verifyServiceProviderSignature(clazz, annotation);
            verifiedClasses.put(clazz, verify);
        }
        if (!verify) {
            return;
        }
        registerImpl(clazz, impl, rsrc, position, supersedes);
    }

#No. 4668
#File: E:\bishe\1\AbstractServiceProviderProcessor.java
#Comment:
        /*
        processingEnv.getMessager().printMessage(Kind.NOTE,
                impl + " to be registered as a " + xface + (path.length() > 0 ? " under " + path : ""));
        */

#Code:
        Filer filer = processingEnv.getFiler();
        {
            Map<String,List<Element>> originatingElements = originatingElementsByProcessor.get(filer);
            if (originatingElements == null) {
                originatingElements = new HashMap<String,List<Element>>();
                originatingElementsByProcessor.put(filer, originatingElements);
            }
            List<Element> origEls = originatingElements.get(rsrc);
            if (origEls == null) {
                origEls = new ArrayList<Element>();
                originatingElements.put(rsrc, origEls);
            }
            origEls.add(clazz);
        }

#No. 4669
#File: E:\bishe\1\AbstractServiceProviderProcessor.java
#Comment:
    /**
     * @param element a source element
     * @param annotation a type of annotation
     * @return the instance of that annotation on the element, or null if not found
     */

#Code:
    private AnnotationMirror findAnnotationMirror(Element element, Class<? extends Annotation> annotation) {
        for (AnnotationMirror ann : element.getAnnotationMirrors()) {
            if (processingEnv.getElementUtils().getBinaryName((TypeElement) ann.getAnnotationType().asElement()).
                    contentEquals(annotation.getName())) {
                return ann;
            }
        }
        return null;
    }

#No. 4670
#File: E:\bishe\1\AbstractServiceProviderProcessor.java
#Comment:
    /**
     * @param annotation an annotation instance (null permitted)
     * @param name the name of an attribute of that annotation
     * @return the corresponding value if found
     */

#Code:
    private AnnotationValue findAnnotationValue(AnnotationMirror annotation, String name) {
        if (annotation != null) {
            for (Map.Entry<? extends ExecutableElement,? extends AnnotationValue> entry : annotation.getElementValues().entrySet()) {
                if (entry.getKey().getSimpleName().contentEquals(name)) {
                    return entry.getValue();
                }
            }
        }
        return null;
    }

#No. 4671
#File: E:\bishe\1\AbstractServiceRequest.java
#Comment:
    /**
     * Reads the whole response without interpreting it to ensure, that the response's connection can be used again.
     * Can be called by implementations which are not interested in the response's content.
     * @param response the response to be consumed.
     */

#Code:
    protected void consumeResponse(HttpResponse response) {
        try {
            response.getEntity().consumeContent();
        } catch (IOException ex) {
            Log.w(AbstractServiceRequest.class.getSimpleName(), "Failed to consume the response");
        }
    }

#No. 4672
#File: E:\bishe\1\AbstractServiceWithStatus.java
#Comment:
	/**
	 * {@inheritDoc}
	 */

#Code:
	@Override
	public void onDestroy() {
		Log.d(name, "onDestroy");
		super.onDestroy();
		localBroadcastManager.sendBroadcast(SERVICE_STOPPED.intent());
	}

#No. 4673
#File: E:\bishe\1\AbstractServletModuleBinding.java
#Comment:
/**
 * Abstract implementation for all servlet module bindings
 *
 * @author sameb@google.com (Sam Berlin)
 */

#Code:
class AbstractServletModuleBinding<T> implements ServletModuleBinding {

    private final Map<String, String> initParams;
    private final String pattern;
    private final T target;
    private final UriPatternMatcher patternMatcher;

    AbstractServletModuleBinding(Map<String, String> initParams, String pattern, T target,
                                 UriPatternMatcher patternMatcher) {
        this.initParams = initParams;
        this.pattern = pattern;
        this.target = target;
        this.patternMatcher = patternMatcher;
    }

    public Map<String, String> getInitParams() {
        return initParams;
    }

    public String getPattern() {
        return pattern;
    }

    protected T getTarget() {
        return target;
    }

    public UriPatternType getUriPatternType() {
        return patternMatcher.getPatternType();
    }

    public boolean matchesUri(String uri) {
        return patternMatcher.matches(uri);
    }

}

#No. 4674
#File: E:\bishe\1\AbstractSesameBackend.java
#Comment:
    /**
     * Find the correct "LIMIT" and "OFFSET" for an iteration of a query
     * 
     * @return The query to send to the back-end
     */

#Code:
    protected String constructSearchSequence() {
      if (pagination == 0) { // No Pagination
        return query;
      } else { // With Pagination
        final long newOffset = pagination * (paginatedOffset++) + offset;
        if (limit == 0) { // get all the results
          return query + "\nLIMIT " + pagination + "\nOFFSET " + newOffset;
        } else { // get the first limit-results
          if (limit > newOffset + pagination) {
            return query + "\nLIMIT " + pagination + "\nOFFSET " + newOffset;
          } else { // last page
            return query + "\nLIMIT " + (limit - newOffset) + "\nOFFSET "
                + newOffset;
          }
        }
      }
    }

#No. 4675
#File: E:\bishe\1\AbstractSesameBackend.java
#Comment:
    /**
     * @return true if initialisation is OK
     */

#Code:
    private boolean init() {
      try {
        resultCounter = 0;

        if (pagination != 0) {
          // if the user specified a range, we will paginate the
          // results within that range
          if (!ast.containsQuery()) {
            return false;
          }
          if (ast.getQuery() instanceof ASTAskQuery) {
            pagination = 0; // disable pagination
          } else {
            if (ast.getQuery().getOffset() != null) {
              offset = ast.getQuery().getOffset().getValue();
              rmOffset.reset(this.query);
              this.query = rmOffset.region(this.query.lastIndexOf('}'),
                  this.query.length()).replaceFirst("");
            }
            if (ast.getQuery().getLimit() != null) {
              /*
               * Add the offset, so that the pagination is correct within that
               * range
               */
              limit = ast.getQuery().getLimit().getValue() + offset;
              rmLimit.reset(this.query);
              this.query = rmLimit.region(this.query.lastIndexOf('}'),
                  this.query.length()).replaceFirst("");
            }
          }
        }

#No. 4676
#File: E:\bishe\1\AbstractSessionManagerHandler.java
#Comment:
/**
 * Abstract base for handlers that need a {@link ISessionManager} instance.
 */

#Code:
public abstract class AbstractSessionManagerHandler extends AbstractHandler
    implements ISessionListener {

  protected final ISessionManager sessionManager;

  protected AbstractSessionManagerHandler(ISessionManager sessionManager) {
    this.sessionManager = sessionManager;
    sessionManager.addSessionListener(this);
  }

  @Override
  public void dispose() {
    sessionManager.removeSessionListener(this);
  }

  public void sessionAdded(ICoverageSession addedSession) {
    fireEnabledChanged();
  }

  public void sessionRemoved(ICoverageSession removedSession) {
    fireEnabledChanged();
  }

  public void sessionActivated(ICoverageSession session) {
    fireEnabledChanged();
  }

  private void fireEnabledChanged() {
    fireHandlerChanged(new HandlerEvent(this, true, false));
  }

}

#No. 4677
#File: E:\bishe\1\AbstractSessionObject.java
#Comment:
	/**
	 *  Retrieves the property map manager of the session
	 *	object. This manager may be used to read and
	 *	write properties and register listeners.
	 *
	 *	@return	the property map manager that stores
	 *			all the properties of this session object
	 */

#Code:
	public MapManager getMap()
	{
		return map;
	}

#No. 4678
#File: E:\bishe\1\AbstractSessionTool.java
#Comment:
    /**
     * Add a TCP transport configuration for a session
     * 
     * @param ipAddress IP address
     * @param port port number
     * @return this session object
     */

#Code:
    public SessionObject withTcpTransport(String ipAddress, int port) {
      Objects.requireNonNull(ipAddress, "Address cannot be null");

      OWLClass tcpTransportClass = dataFactory.getOWLClass(":TcpTransport", getDefaultPrefixManager());
      OWLObjectProperty hasProperty = dataFactory.getOWLObjectProperty(":has", getDefaultPrefixManager());

      OWLDataProperty hasAddressProperty =
          dataFactory.getOWLDataProperty(":hasAddress", getDefaultPrefixManager());
      OWLDataProperty hasPortProperty = dataFactory.getOWLDataProperty(":hasPort", getDefaultPrefixManager());

      String sessionName = getName();

      OWLNamedIndividual transport = dataFactory
          .getOWLNamedIndividual("transports/" + sessionName, getPrefixManager());

      OWLClassAssertionAxiom classAssertion =
          dataFactory.getOWLClassAssertionAxiom(tcpTransportClass, transport);
      ontologyManager.addAxiom(derivedModel, classAssertion);
      OWLObjectPropertyAssertionAxiom propertyAssertion =
          dataFactory.getOWLObjectPropertyAssertionAxiom(hasProperty, getObject(), transport);
      ontologyManager.addAxiom(derivedModel, propertyAssertion);

      OWLDataPropertyAssertionAxiom dataPropertyAssertion =
          dataFactory.getOWLDataPropertyAssertionAxiom(hasAddressProperty, transport, ipAddress);
      ontologyManager.addAxiom(derivedModel, dataPropertyAssertion);

      dataPropertyAssertion =
          dataFactory.getOWLDataPropertyAssertionAxiom(hasPortProperty, transport, port);
      ontologyManager.addAxiom(derivedModel, dataPropertyAssertion);

      return this;
    }

#No. 4679
#File: E:\bishe\1\AbstractSessionTool.java
#Comment:
  /**
   * Create a new ontology model
   * 
   * @param prefix prefix for the identifier
   * @param uri identifier of the model
   * @throws Exception if an ontology cannot be created
   */

#Code:
  public void createNewModel(String prefix, URI uri) throws Exception {
    removeOntology();
    this.derivedIRI = IRI.create(uri);
    this.derivedModel = ontologyManager.createOntology(derivedIRI);
    this.prefixManager = new DefaultPrefixManager(null, null, derivedIRI.toString());
    StructuralReasonerFactory reasonerFactory = new StructuralReasonerFactory();
    this.reasoner = reasonerFactory.createReasoner(getDerivedModel());
  }

#No. 4680
#File: E:\bishe\1\AbstractSessionTool.java
#Comment:
  /**
   * Returns a named session
   * 
   * @param sessionName name of a session
   * @return a session
   */

#Code:
  public abstract Session getSession(String sessionName);


  /**
   * Returns a Set of session objects
   * 
   * @return set of sessions
   */
  public abstract Set<Session> getSessions();

  /**
   * Initialize resources and base ontology
   * 
   * @throws Exception if any resource cannot be initialized
   */
  public void init() throws Exception {
    this.ontologyManager = OWLManager.createOWLOntologyManager();
    this.dataFactory = OWLManager.getOWLDataFactory();

    InputStream in = ClassLoader.class.getResourceAsStream("/fix-orch-session.rdf");
    OWLOntology baseModel = loadOntologyModel(in);
    Optional<IRI> optional = baseModel.getOntologyID().getOntologyIRI();
    if (optional.isPresent()) {
      IRI baseIRI = optional.get();
      this.defaultPrefixManager = new DefaultPrefixManager(null, null, baseIRI.toString());
    } else {
      throw new RuntimeException("No ontoloty IRI found");
    }
  }

#No. 4681
#File: E:\bishe\1\AbstractSessionTool.java
#Comment:
  /**
   * Load an ontology model from an input stream
   * 
   * @param in stream
   * @throws Exception if an ontology cannot be read or parsed
   */

#Code:
  public void loadModel(InputStream in) throws Exception {
    this.derivedModel = loadOntologyModel(in);
    Optional<IRI> optional = this.derivedModel.getOntologyID().getOntologyIRI();
    if (optional.isPresent()) {
      this.derivedIRI = optional.get();
      StructuralReasonerFactory reasonerFactory = new StructuralReasonerFactory();
      this.reasoner = reasonerFactory.createReasoner(getDerivedModel());
      this.reasoner.precomputeInferences();
    } else {
      throw new RuntimeException("No ontoloty IRI found");
    }
  }

#No. 4682
#File: E:\bishe\1\AbstractSessionTool.java
#Comment:
  /**
   * Store the current ontology model to an output stream
   * 
   * @param out stream
   * @throws Exception if the model cannot be written
   */

#Code:
  public void storeModel(OutputStream out) throws Exception {
    write(derivedModel, out);
  }

#No. 4683
#File: E:\bishe\1\AbstractSessionTool.java
#Comment:
  /**
   * @return the dataFactory
   */

#Code:
  protected OWLDataFactory getDataFactory() {
    return dataFactory;
  }

#No. 4684
#File: E:\bishe\1\AbstractSessionTool.java
#Comment:
  /**
   * @return the derivedIRI
   */

#Code:
  protected IRI getDerivedIRI() {
    return derivedIRI;
  }

#No. 4685
#File: E:\bishe\1\AbstractSessionTool.java
#Comment:
  /**
   * @return the derivedModel
   */

#Code:
  protected OWLOntology getDerivedModel() {
    return derivedModel;
  }

#No. 4686
#File: E:\bishe\1\AbstractSessionTool.java
#Comment:
  /**
   * @return the ontologyManager
   */

#Code:
  protected OWLOntologyManager getOntologyManager() {
    return ontologyManager;
  }

#No. 4687
#File: E:\bishe\1\AbstractSessionTool.java
#Comment:
  /**
   * @return the prefixManager
   */

#Code:
  protected PrefixManager getDefaultPrefixManager() {
    return defaultPrefixManager;
  }

#No. 4688
#File: E:\bishe\1\AbstractSessionTool.java
#Comment:
   /**
   * @return the reasoner
   */

#Code:
  OWLReasoner getReasoner() {
    return reasoner;
  }

#No. 4689
#File: E:\bishe\1\AbstractSessionTool.java
#Comment:
  /**
   * Create the base ontology model
   * 
   * @param in input stream
   * @return base model
   * @throws OWLOntologyCreationException If there was a problem in creating and loading the
   *         ontology.
   */

#Code:
  private OWLOntology loadOntologyModel(InputStream in) throws OWLOntologyCreationException {
    removeOntology();
    return ontologyManager.loadOntologyFromOntologyDocument(in);
  }

#No. 4690
#File: E:\bishe\1\AbstractSessionTool.java
#Comment:
  /**
   * Save an ontology to an output stream as OWL XML format
   * 
   * @param ontology a populated ontology
   * @param out output stream
   * @throws OWLOntologyStorageException If there was a problem saving this ontology to the
   *         specified output stream
   */

#Code:
  private void write(OWLOntology ontology, OutputStream out) throws OWLOntologyStorageException {
    ontologyManager.saveOntology(ontology, new RDFXMLDocumentFormat(), out);
  }

#No. 4691
#File: E:\bishe\1\AbstractSetMultimap.java
#Comment:
/**
 * Basic implementation of the {@link SetMultimap} interface. It's a wrapper
 * around {@link AbstractMultimap} that converts the returned collections into
 * {@code Sets}. The {@link #createCollection} method must return a {@code Set}.
 *
 * @author Jared Levy
 */

#Code:
abstract class AbstractSetMultimap<K, V>
    extends AbstractMultimap<K, V> implements SetMultimap<K, V> {
  /**
   * Creates a new multimap that uses the provided map.
   *
   * @param map place to store the mapping from each key to its corresponding
   *     values
   */
  protected AbstractSetMultimap(Map<K, Collection<V>> map) {
    super(map);
  }

  @Override abstract Set<V> createCollection();

  @Override public Set<V> get(K key) {
    return (Set<V>) super.get(key);
  }

#No. 4692
#File: E:\bishe\1\AbstractSetMultimap.java
#Comment:
  /**
   * {@inheritDoc}
   *
   * <p>Any duplicates in {@code values} will be stored in the multimap once.
   */

#Code:
  @Override public Set<V> replaceValues(
      K key, Iterable<? extends V> values) {
    return (Set<V>) super.replaceValues(key, values);
  }

#No. 4693
#File: E:\bishe\1\AbstractSetMultimap.java
#Comment:
  /**
   * Stores a key-value pair in the multimap.
   *
   * @param key key to store in the multimap
   * @param value value to store in the multimap
   * @return {@code true} if the method increased the size of the multimap, or
   *     {@code false} if the multimap already contained the key-value pair
   */

#Code:
  @Override public boolean put(K key, V value) {
    return super.put(key, value);
  }

  /**
   * Compares the specified object to this multimap for equality.
   *
   * <p>Two {@code SetMultimap} instances are equal if, for each key, they
   * contain the same values. Equality does not depend on the ordering of keys
   * or values.
   */
  @Override public boolean equals(Object object) {
    return super.equals(object);
  }
  
  private static final long serialVersionUID = 7431625294878419160L;  
}
}

#No. 4694
#File: E:\bishe\1\AbstractSettersTest.java
#Comment:
    /*
    /**********************************************************
    /* Test methods
    /**********************************************************
     */

#Code:

    private final ObjectMapper MAPPER = newObjectMapper();
    
    public void testSimpleConstructor() throws Exception
    {
        FooImpl1 item = new FooImpl1();
        String string = MAPPER.writer()
                .without(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)
                .writeValueAsString(item);
        FooBase read = MAPPER.readValue(string, FooBase.class);
        assertNotNull(read);
    }

#No. 4695
#File: E:\bishe\1\AbstractSettingsActivity.java
#Comment:
    /*
     * lifecycle management
     */

#Code:

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        /*
         * handle activity configuration changes
         */
        final Object nonConfigurationInstance = getLastNonConfigurationInstance();
        if (nonConfigurationInstance != null) {
            final AbstractSettingsActivity prevInstance = (AbstractSettingsActivity) nonConfigurationInstance;
            accessor = prevInstance.accessor;
            accessor.setActivity(this);
        } else {
            accessor = new ActionContextActivityAccessor<Application, AbstractSettingsActivity>(this);
        }
    }

#No. 4696
#File: E:\bishe\1\AbstractSettingsActivity.java
#Comment:
    /*
     * interface implementations
     */

#Code:

    @Override
    public android.app.Activity getActivity() {
        return accessor.getActivity();
    }

#No. 4697
#File: E:\bishe\1\AbstractSettingsActivity.java
#Comment:
    /*
     * dialog handling
     */

#Code:

    @Override
    protected Dialog onCreateDialog(int id) {
        final Dialog dlg = accessor.onCreateDialog(id);
        return dlg != null ? dlg : super.onCreateDialog(id);
    }

#No. 4698
#File: E:\bishe\1\AbstractShapedItemIconRenderer.java
#Comment:
        /*drawLine(graphic, c, c.add(10,0));
        drawLine(graphic, c, c.add(0,10));*/

#Code:
        renderBorderAndBody(graphic, item, settings, c, radius);
        renderIcon(graphic, item, settings, c);
        renderLabel(graphic, item, settings, c);
        renderSlots(graphic, item, settings);
        renderBounds(graphic, item, settings);
    }
    
    protected void renderIcon(Graphics2D graphic, IBoundedItem item, IItemRendererSettings settings, Coord2d c) {
        if(settings.isNodeDisplayed(item)){
            if(item instanceof IBoundedItemIcon){
                IBoundedItemIcon iNode = (IBoundedItemIcon)item;
                Icon icon = iNode.getIcon();
                
                if(display!=null && icon!=null){
                    Color color = settings.getIconFilterColor(item);
                    
                    int x = (int) c.x - icon.getIconWidth()/2;
                    int y = (int) c.y - icon.getIconHeight()/2 - TextUtils.textHeight();
                    
                    if(color==null)
                        icon.paintIcon((Component)display, graphic, x, y);
                    else{
                        Icon icon2 = settings.getFilteredIcon((ImageIcon)icon, color, display);
                        icon2.paintIcon((Component)display, graphic, x, y);
                    }
                }
            }
        }
    }

#No. 4699
#File: E:\bishe\1\AbstractShapedItemRenderer.java
#Comment:
            /*RectangleBounds b = item.getRectangleBounds().clone();
            b.enlargeSelfInPlace(item.getMargin(), item.getMargin());
            b.shiftSelfCenterTo(item.getAbsolutePosition());
            render(graphic, b, Color.RED, "margin", false);
            
            render(graphic, ModelGeometryProcessor.shiftToAbsolute(item.getExternalRectangleBounds(), item.getAbsolutePosition()), Color.BLUE, "external(+margin)", false);
            render(graphic, ModelGeometryProcessor.shiftToAbsolute(item.getCorridorRectangleBounds(), item.getAbsolutePosition()), Color.BLUE, "corridor(+corridor)", false);*/

#Code:
        }
    }  
    
    public void render(Graphics2D graphic, RectangleBounds bounds, Color borderColor, String info, boolean showGeometryText) {
        graphic.setColor(borderColor);
        
        // Draw border
        drawRect(graphic, bounds.x, bounds.y, bounds.width, bounds.height);
        if(showGeometryText)
            drawText(graphic, bounds.width+"x"+bounds.height+" @ "+bounds.getTopLeftCorner(), bounds.getTopLeftCorner());
        if(info!=null)
            drawText(graphic, info, bounds.getTopLeftCorner().add(0, TextUtils.textHeight()));
    }

#No. 4700
#File: E:\bishe\1\AbstractShapedItemRenderer.java
#Comment:
        /*if(item instanceof HierarchicalGraphModel){
            final HierarchicalGraphModel hm = (HierarchicalGraphModel)item;
            int nattract = hm.getAttractorForces().size();
            int nrepuls  = hm.getNumberOfRepulsors();
            return " (r:" + nrepuls + ",a:" + nattract + ",children:"+hm.getChildren().size()+",enlarge:"+hm.mustEnlarge()+")";
        }
        else*/

#Code:
            return "";
    }

    protected void renderSlots(Graphics2D graphic, IBoundedItem item, IItemRendererSettings settings) {
        if(ALLOW_SLOT_RENDERING)
            slotableItemRenderer.render(graphic, item, settings.getNodeBorderColor(item));
    }

#No. 4701
#File: E:\bishe\1\AbstractShapefileTrackEncoder.java
#Comment:
/**
 * TODO JavaDoc
 *
 * @author Benjamin Pross
 */

#Code:
public abstract class AbstractShapefileTrackEncoder<T>
        extends AbstractShapefileMessageBodyWriter<T>
        implements ShapefileTrackEncoder<T> {
    private DateTimeFormatter dateTimeFormat;
    private Provider<AccessRights> rights;

    public AbstractShapefileTrackEncoder(Class<T> classType) {
        super(classType);
    }

    public DateTimeFormatter getDateTimeFormat() {
        return dateTimeFormat;
    }

    @Inject
    public void setDateTimeFormat(DateTimeFormatter dateTimeFormat) {
        this.dateTimeFormat = dateTimeFormat;
    }

    @Inject
    public void setRights(Provider<AccessRights> rights) {
        this.rights = rights;
    }

    @Override
    public File encodeShapefile(T t, MediaType mt) throws TrackTooLongException{
        return encodeShapefile(t, rights.get(), mt);
    }
}

#No. 4702
#File: E:\bishe\1\AbstractSharesButton.java
#Comment:
    /**
     * This method execute an asynchronous HTTP call to Facebook Graph Apis,
     * to fetch the shares count of the <b>sharesUrl</b>.
     * Before calling this method, please set this value using {@link #setSharesUrl(String)}.
     */

#Code:
    public void fetchShares() {

        // Enabling bubble if needed
        checkAndManageAnnotation();

        String sharesUrl = getSharesUrl();
        if(sharesUrl != null && !mIsFetched) {

            TextView sharesText = (TextView) findViewById(R.id.fb_like_cloud_text);
            ProgressBar sharesProgress = (ProgressBar) findViewById(R.id.fb_like_cloud_progress);

            sharesProgress.setVisibility(View.VISIBLE);
            sharesText.setVisibility(View.GONE);

            downloadShares(sharesUrl);

        }

    }

#No. 4703
#File: E:\bishe\1\AbstractSharesButton.java
#Comment:
    /**
     * Setter for the attribute <b>sharesUrl</b>
     * @param sharesUrl the URL to be passed to Facebook Graph Apis to count shares
     */

#Code:
    public void setSharesUrl(String sharesUrl) {
        mSharesUrl = sharesUrl;
    }

#No. 4704
#File: E:\bishe\1\AbstractSharesButton.java
#Comment:
    /**
     * Getter for the attribute <b>sharesUrl</b>
     */

#Code:
    public String getSharesUrl() {
        return mSharesUrl;
    }

#No. 4705
#File: E:\bishe\1\AbstractSharesButton.java
#Comment:
    /**
     * Getter for the attribute <b>annotation</b>
     */

#Code:
    public int getAnnotation() {
        return mAnnotation;
    }

#No. 4706
#File: E:\bishe\1\AbstractSharesButton.java
#Comment:
    /**
     * Setter for the attribute <b>annotation</b>
     * @param annotation the kind of annotation display, can be {@link #ANNOTATION_NONE}, {@link #ANNOTATION_BUBBLE} and {@link #ANNOTATION_BUBBLE_ONLOAD}
     */

#Code:
    public void setAnnotation(int annotation) {
        mAnnotation = annotation;
    }

#No. 4707
#File: E:\bishe\1\AbstractSharesButton.java
#Comment:
    /**
     * Getter for the attribute <b>type</b>
     */

#Code:
    public int getType() {
        return mType;
    }

#No. 4708
#File: E:\bishe\1\AbstractSharesButton.java
#Comment:
    /**
     * Setter for the attribute <b>type</b>
     * @param type the kind of share button
     */

#Code:
    public void setType(int type) {
        mType = type;
    }

#No. 4709
#File: E:\bishe\1\AbstractSheetEmporter.java
#Comment:
	/**
	 * @param dateStyle
	 */

#Code:
	public void setDateStyle(CellStyle dateStyle) {
		this.dateStyle = dateStyle;
		
	}

#No. 4710
#File: E:\bishe\1\AbstractSheetEmporter.java
#Comment:
	/**
	 * @param percentStyle
	 */

#Code:
	public void setPercentStyle(CellStyle percentStyle) {
		this.percentStyle = percentStyle;
		
	}

#No. 4711
#File: E:\bishe\1\AbstractSheetEmporter.java
#Comment:
	/**
	 * @param currentSheet
	 */

#Code:
	public void setSheet(Sheet sheet) {
		this.sheet = sheet;
	}

#No. 4712
#File: E:\bishe\1\AbstractSheetEmporter.java
#Comment:
	/**
	 * Increment and return row number
	 * @return
	 */

#Code:
	public int incrementRowNum(){
		return this.rowNum++;
	}

#No. 4713
#File: E:\bishe\1\AbstractSheetEmporter.java
#Comment:
	/**
	 * @return
	 */

#Code:
	public int getRowsAdded() {
		return this.rowsAdded;
	}

#No. 4714
#File: E:\bishe\1\AbstractShortList.java
#Comment:
    /**
     * Returns the index of the first occurrence of the specified element.
     * Returns <code>-1</code> if the receiver does not contain this element.
     * 
     * @param element
     *            the element to be searched for.
     * @return the index of the first occurrence of the element in the receiver;
     *         returns <code>-1</code> if the element is not found.
     */

#Code:
    public int indexOf(short element) { // delta
        return indexOfFromTo(element, 0, size - 1);
    }

#No. 4715
#File: E:\bishe\1\AbstractShortList.java
#Comment:
    /**
     * Returns the index of the first occurrence of the specified element.
     * Returns <code>-1</code> if the receiver does not contain this element.
     * Searches between <code>from</code>, inclusive and <code>to</code>,
     * inclusive. Tests for identity.
     * 
     * @param element
     *            element to search for.
     * @param from
     *            the leftmost search position, inclusive.
     * @param to
     *            the rightmost search position, inclusive.
     * @return the index of the first occurrence of the element in the receiver;
     *         returns <code>-1</code> if the element is not found.
     * @exception IndexOutOfBoundsException
     *                index is out of range (
     *                <tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>
     *                ).
     */

#Code:
    public int indexOfFromTo(short element, int from, int to) {
        checkRangeFromTo(from, to, size);

        for (int i = from; i <= to; i++) {
            if (element == getQuick(i))
                return i; // found
        }
        return -1; // not found
    }

#No. 4716
#File: E:\bishe\1\AbstractShortList.java
#Comment:
    /**
     * Returns the index of the last occurrence of the specified element.
     * Returns <code>-1</code> if the receiver does not contain this element.
     * 
     * @param element
     *            the element to be searched for.
     * @return the index of the last occurrence of the element in the receiver;
     *         returns <code>-1</code> if the element is not found.
     */

#Code:
    public int lastIndexOf(short element) {
        return lastIndexOfFromTo(element, 0, size - 1);
    }

#No. 4717
#File: E:\bishe\1\AbstractShortList.java
#Comment:
    /**
     * Returns the index of the last occurrence of the specified element.
     * Returns <code>-1</code> if the receiver does not contain this element.
     * Searches beginning at <code>to</code>, inclusive until <code>from</code>,
     * inclusive. Tests for identity.
     * 
     * @param element
     *            element to search for.
     * @param from
     *            the leftmost search position, inclusive.
     * @param to
     *            the rightmost search position, inclusive.
     * @return the index of the last occurrence of the element in the receiver;
     *         returns <code>-1</code> if the element is not found.
     * @exception IndexOutOfBoundsException
     *                index is out of range (
     *                <tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>
     *                ).
     */

#Code:
    public int lastIndexOfFromTo(short element, int from, int to) {
        checkRangeFromTo(from, to, size());

        for (int i = to; i >= from; i--) {
            if (element == getQuick(i))
                return i; // found
        }
        return -1; // not found
    }

#No. 4718
#File: E:\bishe\1\AbstractShortList.java
#Comment:
    /**
     * Sorts the specified range of the receiver into ascending order.
     * 
     * The sorting algorithm is a modified mergesort (in which the merge is
     * omitted if the highest element in the low sublist is less than the lowest
     * element in the high sublist). This algorithm offers guaranteed n*log(n)
     * performance, and can approach linear performance on nearly sorted lists.
     * 
     * <p>
     * <b>You should never call this method unless you are sure that this
     * particular sorting algorithm is the right one for your data set.</b> It
     * is generally better to call <tt>sort()</tt> or <tt>sortFromTo(...)</tt>
     * instead, because those methods automatically choose the best sorting
     * algorithm.
     * 
     * @param from
     *            the index of the first element (inclusive) to be sorted.
     * @param to
     *            the index of the last element (inclusive) to be sorted.
     * @exception IndexOutOfBoundsException
     *                index is out of range (
     *                <tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>
     *                ).
     */

#Code:

    public void mergeSortFromTo(int from, int to) {
        int mySize = size();
        checkRangeFromTo(from, to, mySize);

        short[] myElements = elements();
        cern.colt.Sorting.mergeSort(myElements, from, to + 1);
        elements(myElements);
        setSizeRaw(mySize);
    }

#No. 4719
#File: E:\bishe\1\AbstractShortList.java
#Comment:
    /**
     * Sorts the receiver according to the order induced by the specified
     * comparator. All elements in the range must be <i>mutually comparable</i>
     * by the specified comparator (that is, <tt>c.compare(e1, e2)</tt> must not
     * throw a <tt>ClassCastException</tt> for any elements <tt>e1</tt> and
     * <tt>e2</tt> in the range).
     * <p>
     * 
     * This sort is guaranteed to be <i>stable</i>: equal elements will not be
     * reordered as a result of the sort.
     * <p>
     * 
     * The sorting algorithm is a modified mergesort (in which the merge is
     * omitted if the highest element in the low sublist is less than the lowest
     * element in the high sublist). This algorithm offers guaranteed n*log(n)
     * performance, and can approach linear performance on nearly sorted lists.
     * 
     * @param from
     *            the index of the first element (inclusive) to be sorted.
     * @param to
     *            the index of the last element (inclusive) to be sorted.
     * @param c
     *            the comparator to determine the order of the receiver.
     * @throws ClassCastException
     *             if the array contains elements that are not <i>mutually
     *             comparable</i> using the specified comparator.
     * @throws IllegalArgumentException
     *             if <tt>fromIndex &gt; toIndex</tt>
     * @throws ArrayIndexOutOfBoundsException
     *             if <tt>fromIndex &lt; 0</tt> or
     *             <tt>toIndex &gt; a.length</tt>
     * @exception IndexOutOfBoundsException
     *                index is out of range (
     *                <tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>
     *                ).
     */

#Code:
    public void mergeSortFromTo(int from, int to, ShortComparator c) {
        int mySize = size();
        checkRangeFromTo(from, to, mySize);

        short[] myElements = elements();
        cern.colt.Sorting.mergeSort(myElements, from, to + 1, c);
        elements(myElements);
        setSizeRaw(mySize);
    }

#No. 4720
#File: E:\bishe\1\AbstractShortList.java
#Comment:
    /**
     * Returns a new list of the part of the receiver between <code>from</code>,
     * inclusive, and <code>to</code>, inclusive.
     * 
     * @param from
     *            the index of the first element (inclusive).
     * @param to
     *            the index of the last element (inclusive).
     * @return a new list
     * @exception IndexOutOfBoundsException
     *                index is out of range (
     *                <tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>
     *                ).
     */

#Code:
    public AbstractShortList partFromTo(int from, int to) {
        checkRangeFromTo(from, to, size);

        int length = to - from + 1;
        ShortArrayList part = new ShortArrayList(length);
        part.addAllOfFromTo(this, from, to);
        return part;
    }

#No. 4721
#File: E:\bishe\1\AbstractShortList.java
#Comment:
    /**
     * Sorts the specified range of the receiver into ascending numerical order.
     * The sorting algorithm is a tuned quicksort, adapted from Jon L. Bentley
     * and M. Douglas McIlroy's "Engineering a Sort Function", Software-Practice
     * and Experience, Vol. 23(11) P. 1249-1265 (November 1993). This algorithm
     * offers n*log(n) performance on many data sets that cause other quicksorts
     * to degrade to quadratic performance.
     * 
     * <p>
     * <b>You should never call this method unless you are sure that this
     * particular sorting algorithm is the right one for your data set.</b> It
     * is generally better to call <tt>sort()</tt> or <tt>sortFromTo(...)</tt>
     * instead, because those methods automatically choose the best sorting
     * algorithm.
     * 
     * @param from
     *            the index of the first element (inclusive) to be sorted.
     * @param to
     *            the index of the last element (inclusive) to be sorted.
     * @exception IndexOutOfBoundsException
     *                index is out of range (
     *                <tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>
     *                ).
     */

#Code:

    public void quickSortFromTo(int from, int to) {
        int mySize = size();
        checkRangeFromTo(from, to, mySize);

        short[] myElements = elements();
        java.util.Arrays.sort(myElements, from, to + 1);
        elements(myElements);
        setSizeRaw(mySize);
    }

#No. 4722
#File: E:\bishe\1\AbstractShortList.java
#Comment:
    /**
     * Sorts the receiver according to the order induced by the specified
     * comparator. All elements in the range must be <i>mutually comparable</i>
     * by the specified comparator (that is, <tt>c.compare(e1, e2)</tt> must not
     * throw a <tt>ClassCastException</tt> for any elements <tt>e1</tt> and
     * <tt>e2</tt> in the range).
     * <p>
     * 
     * The sorting algorithm is a tuned quicksort, adapted from Jon L. Bentley
     * and M. Douglas McIlroy's "Engineering a Sort Function", Software-Practice
     * and Experience, Vol. 23(11) P. 1249-1265 (November 1993). This algorithm
     * offers n*log(n) performance on many data sets that cause other quicksorts
     * to degrade to quadratic performance.
     * 
     * @param from
     *            the index of the first element (inclusive) to be sorted.
     * @param to
     *            the index of the last element (inclusive) to be sorted.
     * @param c
     *            the comparator to determine the order of the receiver.
     * @throws ClassCastException
     *             if the array contains elements that are not <i>mutually
     *             comparable</i> using the specified comparator.
     * @throws IllegalArgumentException
     *             if <tt>fromIndex &gt; toIndex</tt>
     * @throws ArrayIndexOutOfBoundsException
     *             if <tt>fromIndex &lt; 0</tt> or
     *             <tt>toIndex &gt; a.length</tt>
     * @exception IndexOutOfBoundsException
     *                index is out of range (
     *                <tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>
     *                ).
     */

#Code:
    public void quickSortFromTo(int from, int to, ShortComparator c) {
        int mySize = size();
        checkRangeFromTo(from, to, mySize);

        short[] myElements = elements();
        cern.colt.Sorting.quickSort(myElements, from, to + 1, c);
        elements(myElements);
        setSizeRaw(mySize);
    }

#No. 4723
#File: E:\bishe\1\AbstractShortList.java
#Comment:
    /**
     * Removes from the receiver all elements that are contained in the
     * specified list. Tests for identity.
     * 
     * @param other
     *            the other list.
     * @return <code>true</code> if the receiver changed as a result of the
     *         call.
     */

#Code:
    public boolean removeAll(AbstractShortList other) {
        if (other.size() == 0)
            return false; // nothing to do
        int limit = other.size() - 1;
        int j = 0;

        for (int i = 0; i < size; i++) {
            if (other.indexOfFromTo(getQuick(i), 0, limit) < 0)
                setQuick(j++, getQuick(i));
        }

        boolean modified = (j != size);
        setSize(j);
        return modified;
    }

#No. 4724
#File: E:\bishe\1\AbstractShortList.java
#Comment:
    /**
     * Removes from the receiver all elements whose index is between
     * <code>from</code>, inclusive and <code>to</code>, inclusive. Shifts any
     * succeeding elements to the left (reduces their index). This call shortens
     * the list by <tt>(to - from + 1)</tt> elements.
     * 
     * @param from
     *            index of first element to be removed.
     * @param to
     *            index of last element to be removed.
     * @exception IndexOutOfBoundsException
     *                index is out of range (
     *                <tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>
     *                ).
     */

#Code:

    public void removeFromTo(int from, int to) {
        checkRangeFromTo(from, to, size);
        int numMoved = size - to - 1;
        if (numMoved > 0) {
            replaceFromToWithFrom(from, from - 1 + numMoved, this, to + 1);
            // fillFromToWith(from+numMoved, size-1, 0.0f); //delta
        }
        int width = to - from + 1;
        if (width > 0)
            setSizeRaw(size - width);
    }

#No. 4725
#File: E:\bishe\1\AbstractShortList.java
#Comment:
    /**
     * Replaces a number of elements in the receiver with the same number of
     * elements of another list. Replaces elements in the receiver, between
     * <code>from</code> (inclusive) and <code>to</code> (inclusive), with
     * elements of <code>other</code>, starting from <code>otherFrom</code>
     * (inclusive).
     * 
     * @param from
     *            the position of the first element to be replaced in the
     *            receiver
     * @param to
     *            the position of the last element to be replaced in the
     *            receiver
     * @param other
     *            list holding elements to be copied into the receiver.
     * @param otherFrom
     *            position of first element within other list to be copied.
     */

#Code:
    public void replaceFromToWithFrom(int from, int to, AbstractShortList other, int otherFrom) {
        int length = to - from + 1;
        if (length > 0) {
            checkRangeFromTo(from, to, size());
            checkRangeFromTo(otherFrom, otherFrom + length - 1, other.size());

            // unambiguous copy (it may hold other==this)
            if (from <= otherFrom) {
                for (; --length >= 0;)
                    setQuick(from++, other.getQuick(otherFrom++));
            } else {
                int otherTo = otherFrom + length - 1;
                for (; --length >= 0;)
                    setQuick(to--, other.getQuick(otherTo--));
            }

        }
    }

#No. 4726
#File: E:\bishe\1\AbstractShortList.java
#Comment:
    /**
     * Replaces the part between <code>from</code> (inclusive) and
     * <code>to</code> (inclusive) with the other list's part between
     * <code>otherFrom</code> and <code>otherTo</code>. Powerful (and tricky)
     * method! Both parts need not be of the same size (part A can both be
     * smaller or larger than part B). Parts may overlap. Receiver and other
     * list may (but most not) be identical. If <code>from &gt; to</code>, then
     * inserts other part before <code>from</code>.
     * 
     * @param from
     *            the first element of the receiver (inclusive)
     * @param to
     *            the last element of the receiver (inclusive)
     * @param other
     *            the other list (may be identical with receiver)
     * @param otherFrom
     *            the first element of the other list (inclusive)
     * @param otherTo
     *            the last element of the other list (inclusive)
     * 
     *            <p>
     *            <b>Examples:</b>
     * 
     *            <pre>
     * a=[0, 1, 2, 3, 4, 5, 6, 7]
     * b=[50, 60, 70, 80, 90]
     * a.R(...)=a.replaceFromToWithFromTo(...)
     * 
     * a.R(3,5,b,0,4)--&gt;[0, 1, 2, 50, 60, 70, 80, 90, 6, 7]
     * a.R(1,6,b,0,4)--&gt;[0, 50, 60, 70, 80, 90, 7]
     * a.R(0,6,b,0,4)--&gt;[50, 60, 70, 80, 90, 7]
     * a.R(3,5,b,1,2)--&gt;[0, 1, 2, 60, 70, 6, 7]
     * a.R(1,6,b,1,2)--&gt;[0, 60, 70, 7]
     * a.R(0,6,b,1,2)--&gt;[60, 70, 7]
     * a.R(5,3,b,0,4)--&gt;[0, 1, 2, 3, 4, 50, 60, 70, 80, 90, 5, 6, 7]
     * a.R(5,0,b,0,4)--&gt;[0, 1, 2, 3, 4, 50, 60, 70, 80, 90, 5, 6, 7]
     * a.R(5,3,b,1,2)--&gt;[0, 1, 2, 3, 4, 60, 70, 5, 6, 7]
     * a.R(5,0,b,1,2)--&gt;[0, 1, 2, 3, 4, 60, 70, 5, 6, 7]
     * 
     * Extreme cases:
     * a.R(5,3,b,0,0)--&gt;[0, 1, 2, 3, 4, 50, 5, 6, 7]
     * a.R(5,3,b,4,4)--&gt;[0, 1, 2, 3, 4, 90, 5, 6, 7]
     * a.R(3,5,a,0,1)--&gt;[0, 1, 2, 0, 1, 6, 7]
     * a.R(3,5,a,3,5)--&gt;[0, 1, 2, 3, 4, 5, 6, 7]
     * a.R(3,5,a,4,4)--&gt;[0, 1, 2, 4, 6, 7]
     * a.R(5,3,a,0,4)--&gt;[0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 5, 6, 7]
     * a.R(0,-1,b,0,4)--&gt;[50, 60, 70, 80, 90, 0, 1, 2, 3, 4, 5, 6, 7]
     * a.R(0,-1,a,0,4)--&gt;[0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 5, 6, 7]
     * a.R(8,0,a,0,4)--&gt;[0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4]
     * </pre>
     */

#Code:
    public void replaceFromToWithFromTo(int from, int to, AbstractShortList other, int otherFrom, int otherTo) {
        if (otherFrom > otherTo) {
            throw new IndexOutOfBoundsException("otherFrom: " + otherFrom + ", otherTo: " + otherTo);
        }

        if (this == other && to - from != otherTo - otherFrom) { // avoid
            // stumbling
            // over my
            // own feet
            replaceFromToWithFromTo(from, to, partFromTo(otherFrom, otherTo), 0, otherTo - otherFrom);
            return;
        }

        int length = otherTo - otherFrom + 1;
        int diff = length;
        int theLast = from - 1;

        if (to >= from) {
            diff -= (to - from + 1);
            theLast = to;
        }

        if (diff > 0) {
            beforeInsertDummies(theLast + 1, diff);
        } else {
            if (diff < 0) {
                removeFromTo(theLast + diff, theLast - 1);
            }
        }

        if (length > 0) {
            replaceFromToWithFrom(from, from + length - 1, other, otherFrom);
        }
    }

#No. 4727
#File: E:\bishe\1\AbstractShortList.java
#Comment:
    /**
     * Replaces the part of the receiver starting at <code>from</code>
     * (inclusive) with all the elements of the specified collection. Does not
     * alter the size of the receiver. Replaces exactly
     * <tt>Math.max(0,Math.min(size()-from, other.size()))</tt> elements.
     * 
     * @param from
     *            the index at which to copy the first element from the
     *            specified collection.
     * @param other
     *            Collection to replace part of the receiver
     * @exception IndexOutOfBoundsException
     *                index is out of range (index &lt; 0 || index &gt;=
     *                size()).
     */

#Code:

    public void replaceFromWith(int from, java.util.Collection other) {
        checkRange(from, size());
        java.util.Iterator e = other.iterator();
        int index = from;
        int limit = Math.min(size() - from, other.size());
        for (int i = 0; i < limit; i++)
            set(index++, ((Number) e.next()).shortValue()); // delta
    }

#No. 4728
#File: E:\bishe\1\AbstractShortList.java
#Comment:
    /**
     * Retains (keeps) only the elements in the receiver that are contained in
     * the specified other list. In other words, removes from the receiver all
     * of its elements that are not contained in the specified other list.
     * 
     * @param other
     *            the other list to test against.
     * @return <code>true</code> if the receiver changed as a result of the
     *         call.
     */

#Code:
    public boolean retainAll(AbstractShortList other) {
        if (other.size() == 0) {
            if (size == 0)
                return false;
            setSize(0);
            return true;
        }

        int limit = other.size() - 1;
        int j = 0;
        for (int i = 0; i < size; i++) {
            if (other.indexOfFromTo(getQuick(i), 0, limit) >= 0)
                setQuick(j++, getQuick(i));
        }

        boolean modified = (j != size);
        setSize(j);
        return modified;
    }

#No. 4729
#File: E:\bishe\1\AbstractShortList.java
#Comment:
    /**
     * Reverses the elements of the receiver. Last becomes first, second last
     * becomes second first, and so on.
     */

#Code:

    public void reverse() {
        short tmp;
        int limit = size() / 2;
        int j = size() - 1;

        for (int i = 0; i < limit;) { // swap
            tmp = getQuick(i);
            setQuick(i++, getQuick(j));
            setQuick(j--, tmp);
        }
    }

#No. 4730
#File: E:\bishe\1\AbstractShortList.java
#Comment:
    /**
     * Replaces the element at the specified position in the receiver with the
     * specified element.
     * 
     * @param index
     *            index of element to replace.
     * @param element
     *            element to be stored at the specified position.
     * @throws IndexOutOfBoundsException
     *             if <tt>index &lt; 0 || index &gt;= size()</tt>.
     */

#Code:
    public void set(int index, short element) {
        if (index >= size || index < 0)
            throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size);
        setQuick(index, element);
    }

#No. 4731
#File: E:\bishe\1\AbstractShortList.java
#Comment:
    /**
     * Sets the size of the receiver without modifying it otherwise. This method
     * should not release or allocate new memory but simply set some instance
     * variable like <tt>size</tt>.
     * 
     * If your subclass overrides and delegates size changing methods to some
     * other object, you must make sure that those overriding methods not only
     * update the size of the delegate but also of this class. For example:
     * public DatabaseList extends AbstractShortList { ... public void
     * removeFromTo(int from,int to) { myDatabase.removeFromTo(from,to);
     * this.setSizeRaw(size-(to-from+1)); } }
     */

#Code:
    protected void setSizeRaw(int newSize) {
        size = newSize;
    }

#No. 4732
#File: E:\bishe\1\AbstractShortList.java
#Comment:
    /**
     * Randomly permutes the part of the receiver between <code>from</code>
     * (inclusive) and <code>to</code> (inclusive).
     * 
     * @param from
     *            the index of the first element (inclusive) to be permuted.
     * @param to
     *            the index of the last element (inclusive) to be permuted.
     * @exception IndexOutOfBoundsException
     *                index is out of range (
     *                <tt>size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())</tt>
     *                ).
     */

#Code:

    public void shuffleFromTo(int from, int to) {
        checkRangeFromTo(from, to, size());

        cern.jet.random.tdouble.DoubleUniform gen = new cern.jet.random.tdouble.DoubleUniform(
                new cern.jet.random.tdouble.engine.DRand(new java.util.Date()));
        for (int i = from; i < to; i++) {
            int random = gen.nextIntFromTo(i, to);

            // swap(i, random)
            short tmpElement = getQuick(random);
            setQuick(random, getQuick(i));
            setQuick(i, tmpElement);
        }
    }

#No. 4733
#File: E:\bishe\1\AbstractShortList.java
#Comment:
    /**
     * Returns the number of elements contained in the receiver.
     * 
     * @return the number of elements contained in the receiver.
     */

#Code:

    public int size() {
        return size;
    }

#No. 4734
#File: E:\bishe\1\AbstractShortList.java
#Comment:
    /**
     * Returns a list which is a concatenation of <code>times</code> times the
     * receiver.
     * 
     * @param times
     *            the number of times the receiver shall be copied.
     */

#Code:
    public AbstractShortList times(int times) {
        AbstractShortList newList = new ShortArrayList(times * size());
        for (int i = times; --i >= 0;) {
            newList.addAllOfFromTo(this, 0, size() - 1);
        }
        return newList;
    }

#No. 4735
#File: E:\bishe\1\AbstractShortList.java
#Comment:
    /**
     * Returns a <code>java.util.ArrayList</code> containing all the elements in
     * the receiver.
     */

#Code:

    public java.util.ArrayList toList() {
        int mySize = size();
        java.util.ArrayList list = new java.util.ArrayList(mySize);
        for (int i = 0; i < mySize; i++)
            list.add(new Short(get(i)));
        return list;
    }

#No. 4736
#File: E:\bishe\1\AbstractShortList.java
#Comment:
    /**
     * Returns a string representation of the receiver, containing the String
     * representation of each element.
     */

#Code:

    public String toString() {
        return cern.colt.Arrays.toString(partFromTo(0, size() - 1).elements());
    }

#No. 4737
#File: E:\bishe\1\AbstractSignal.java
#Comment:
    /**
     * Emits the supplied event to all connected slots.
     */

#Code:
    protected void notifyEmit (T event) {
        notify(EMIT, event, null, null);
    }

#No. 4738
#File: E:\bishe\1\AbstractSignalListenerFactory.java
#Comment:
/**
 * Helper implementation of {@link SignalListenerFactory}
 *
 * @author Eugene Schava <eschava@gmail.com>
 */

#Code:
public abstract class AbstractSignalListenerFactory<Factory extends SignalListenerFactory, Props extends Properties>
        implements SignalListenerFactory<Factory>, Cloneable {

    private String protocol;
    private Props properties;
    private PropertiesConfigurer propertiesConfigurer;

    public AbstractSignalListenerFactory(String protocol, Props properties) {
        this.protocol = protocol;
        this.properties = properties;
        propertiesConfigurer = new PropertiesConfigurer(properties);
    }

    @Override
    public String getProtocol() {
        return protocol;
    }

    public Props getProperties() {
        return properties;
    }

    @Override
    public void setProperty(String property, String value) {
        propertiesConfigurer.setProperty(property, value);
    }

    @Override
    public Factory clone(String newProtocolName) {
        try {
            AbstractSignalListenerFactory clone = (AbstractSignalListenerFactory) super.clone();
            clone.protocol = newProtocolName;
            clone.properties = properties.clone();
            clone.propertiesConfigurer = new PropertiesConfigurer(clone.properties);
            return (Factory) clone;
        } catch (CloneNotSupportedException e) {
            throw new RuntimeException(e);
        }
    }
}

#No. 4739
#File: E:\bishe\1\AbstractSignatureActionExecuter.java
#Comment:
    /**
     * Predefined position options
     */

#Code:
    public static final String            POSITION_CENTER          = "center";
    public static final String            POSITION_TOPLEFT         = "topleft";
    public static final String            POSITION_TOPRIGHT        = "topright";
    public static final String            POSITION_BOTTOMLEFT      = "bottomleft";
    public static final String            POSITION_BOTTOMRIGHT     = "bottomright";
    
	protected ServiceRegistry 			  serviceRegistry;
	
    public static final String            PARAM_LOCATION           = "location";
    public static final String 			  PARAM_GEOLOCATION	   	   = "geolocation";
    public static final String            PARAM_REASON             = "reason";
    public static final String            PARAM_KEY_PASSWORD       = "key-password";
    
    protected String	 				  alias					   = "countersign";

    protected SignatureProviderFactory	  signatureProviderFactory = null;

    /**
     * Load the parameter definitions common across all signature types
     *
     */
	protected void addParameterDefinitions(List<ParameterDefinition> paramList) 
	{
        paramList.add(new ParameterDefinitionImpl(PARAM_LOCATION, DataTypeDefinition.TEXT, false, getParamDisplayLabel(PARAM_LOCATION)));
        paramList.add(new ParameterDefinitionImpl(PARAM_GEOLOCATION, DataTypeDefinition.TEXT, false, getParamDisplayLabel(PARAM_GEOLOCATION)));
        paramList.add(new ParameterDefinitionImpl(PARAM_REASON, DataTypeDefinition.TEXT, false, getParamDisplayLabel(PARAM_REASON)));
        paramList.add(new ParameterDefinitionImpl(PARAM_KEY_PASSWORD, DataTypeDefinition.TEXT, true, getParamDisplayLabel(PARAM_KEY_PASSWORD)));
	}

#No. 4740
#File: E:\bishe\1\AbstractSignatureActionExecuter.java
#Comment:
    /**
     * Get the signature block position, using the provided JSON for the box coordinates
     * and the selected page
     * 
     * @param pageRect
     * @param box
     * @return
     */

#Code:
    protected Rectangle positionBlock(Rectangle pageRect, JSONObject box)
    {
    	float startX = Float.parseFloat(String.valueOf(box.get("startX")));
    	float startY = Float.parseFloat(String.valueOf(box.get("startY")));
    	float endX = Float.parseFloat(String.valueOf(box.get("endX")));
    	float endY = Float.parseFloat(String.valueOf(box.get("endY")));
    	
    	// make sure that the ll and ur coordinates match iText's expectations
    	startY = pageRect.getHeight() - startY;
    	endY = pageRect.getHeight() - endY;
    	
    	// create the rectangle to contain the signature from the corrected coordinates
    	Rectangle r = new Rectangle(startX, startY, endX, endY);
    	
    	return r;
    }

#No. 4741
#File: E:\bishe\1\AbstractSignatureActionExecuter.java
#Comment:
    /**
     * @param actionedUponNodeRef
     * @return
     */

#Code:
    protected ContentReader getReader(NodeRef nodeRef)
    {
        // First check that the node is a sub-type of content
        QName typeQName = serviceRegistry.getNodeService().getType(nodeRef);
        if (serviceRegistry.getDictionaryService().isSubClass(typeQName, ContentModel.TYPE_CONTENT) == false)
        {
            // it is not content, so can't transform
            return null;
        }

        // Get the content reader
        ContentReader contentReader = serviceRegistry.getContentService().getReader(nodeRef, ContentModel.PROP_CONTENT);

        return contentReader;
    }

#No. 4742
#File: E:\bishe\1\AbstractSignatureActionExecuter.java
#Comment:
    /**
     * Gets the X value for centering the signature stamp
     * 
     * @param r
     * @param img
     * @return
     */

#Code:
    protected float getCenterX(Rectangle r, Image img)
    {
        float x = 0;
        float pdfwidth = r.getWidth();
        float imgwidth = img.getWidth();

        x = (pdfwidth - imgwidth) / 2;

        return x;
    }

#No. 4743
#File: E:\bishe\1\AbstractSignatureActionExecuter.java
#Comment:
    /**
     * Gets the Y value for centering the signature stamp
     * 
     * @param r
     * @param img
     * @return
     */

#Code:
    protected float getCenterY(Rectangle r, Image img)
    {
        float y = 0;
        float pdfheight = r.getHeight();
        float imgheight = img.getHeight();

        y = (pdfheight - imgheight) / 2;

        return y;
    }

#No. 4744
#File: E:\bishe\1\AbstractSignatureActionExecuter.java
#Comment:
    /**
     * Create a rectangle for the visible stamp using the selected position and block size
     * 
     * @param position
     * @param width
     * @param height
     * @return
     */

#Code:
    protected Rectangle positionBlock(String position, Rectangle pageRect, int width, int height)
    {

    	float pageHeight = pageRect.getHeight();
    	float pageWidth = pageRect.getWidth();
    	
    	Rectangle r = null;
    	//Rectangle constructor(float llx, float lly, float urx, float ury)
    	if (position.equals(POSITION_BOTTOMLEFT))
    	{
    		r = new Rectangle(0, height, width, 0);
    	}
    	else if (position.equals(POSITION_BOTTOMRIGHT))
    	{
    		r = new Rectangle(pageWidth - width, height, pageWidth, 0);
    	}
    	else if (position.equals(POSITION_TOPLEFT))
    	{
    		r = new Rectangle(0, pageHeight, width, pageHeight - height);
    	}
    	else if (position.equals(POSITION_TOPRIGHT))
    	{
    		r = new Rectangle(pageWidth - width, pageHeight, pageWidth, pageHeight - height);
    	}
    	else if (position.equals(POSITION_CENTER))
    	{
    		r = new Rectangle((pageWidth / 2) - (width / 2), (pageHeight / 2) - (height / 2),
    				(pageWidth / 2) + (width / 2), (pageHeight / 2) + (height / 2));
    	}

    	return r;
    }

#No. 4745
#File: E:\bishe\1\AbstractSignatureActionExecuter.java
#Comment:
    /**
     * Sets the signature provider used to sign documents without the need to select
     * a keystore, etc.
     * 
     * @param signatureProvider
     */

#Code:
    public void setSignatureProviderFactory(SignatureProviderFactory signatureProviderFactory)
    {
    	this.signatureProviderFactory = signatureProviderFactory;
    }

#No. 4746
#File: E:\bishe\1\AbstractSignUpController.java
#Comment:
	/**
	 * Set a request cache here to change the default 
	 * <code>HttpSessionRequestCache</code> used by this class
	 * to determine if a saved request was set previously
	 * by an access denied handler.
	 * 
	 * @param requestCache
	 */

#Code:
	public void setRequestCache(RequestCache requestCache) {
		this.requestCache = requestCache;
	}

#No. 4747
#File: E:\bishe\1\AbstractSimulationActivityBehavior.java
#Comment:
	  /**
	   * The namespace of the CrystalBall custom BPMN extensions.
	   */

#Code:
	  public static final String CRYSTALBALL_BPMN_EXTENSIONS_NS = "http://crystalball.org/simulation";
	  
	public AbstractSimulationActivityBehavior(Element scriptTaskElement, ScopeImpl scope, ActivityImpl activity) {
		
	}

#No. 4748
#File: E:\bishe\1\AbstractSingleInputPreprocessor.java
#Comment:
/**
 * Abstract superclass for {@link PreprocessorPlugin} implementations that
 * populate singleton inputs. Contains helper methods to facilitate this
 * functionality.
 *
 * @author Mark Hiner
 */

#Code:
public abstract class AbstractSingleInputPreprocessor extends
	AbstractPreprocessorPlugin
{

	@Parameter
	private ModuleService moduleService;

	/**
	 * Helper method to look up the name of singleton module inputs of a given
	 * type.
	 *
	 * @param module Module to check for single input
	 * @param type Type of single input to look for
	 * @return If the given module has exactly one input of the specified type,
	 *         return that input's name. Otherwise null;
	 */
	protected String getSingleInput(final Module module, final Class<?> type) {
		if (moduleService == null) return null;
		final ModuleItem<?> item = moduleService.getSingleInput(module, type);
		if (item == null || !item.isAutoFill()) return null;

		return item.getName();
	}

}

#No. 4749
#File: E:\bishe\1\AbstractSingleLabelledQuery.java
#Comment:
  /**
   * Initialize the queries launcher.
   * 
   * @param d
   *          The Dump object, allows the use to modify the output easily.
   */

#Code:
  public AbstractSingleLabelledQuery(Dump d) {
    super(d);
  }

#No. 4750
#File: E:\bishe\1\AbstractSingleLabelledQuery.java
#Comment:
  /**
   * Initialize the queries launcher.
   */

#Code:
  public AbstractSingleLabelledQuery() {
    super();
  }

#No. 4751
#File: E:\bishe\1\AbstractSingleLabelledQuery.java
#Comment:
  /**
   * Get the name and the cardinality of the nodes.
   * 
   * @throws Exception
   */

#Code:
  @Override
  public void computeName() throws Exception {
    String query = "SELECT ?label ?pType ?pDescription (COUNT (?s) AS ?cardinality)\n"
        + _graphFrom
        + "WHERE {\n{\n"
        + "SELECT ?s (IF(isURI(?type),\n"
        + "           concat('{<', str(?type), '>,',?p,'}'),\n"
        + "           concat('{\"', ENCODE_FOR_URI(?type), '\",',?p,'}')) AS ?label)\n"
        + "        WHERE {\n";

    if (AnalyticsClassAttributes.getClassAttributes().size() > 0) {
      query += "{ ?s <" + AnalyticsClassAttributes.getClassAttributes().get(0)
          + "> ?type .\n  BIND ('0' AS ?p) }\n";
      for (int i = 1; i < AnalyticsClassAttributes.getClassAttributes().size(); ++i) {
        query += "UNION{ ?s <"
            + AnalyticsClassAttributes.getClassAttributes().get(i)
            + "> ?type .\n BIND ('" + i + "' AS ?p) }\n";
      }
    }

    query += "        }\n" + "    }\n" + "FILTER(?label != \"\")\n" + "}\n"
        + "GROUP BY ?label ?pType ?pDescription\n";

    _logger.debug(query);
    launchQueryNode(query);

  }

#No. 4752
#File: E:\bishe\1\AbstractSinglePageApplication.java
#Comment:
  /*****************************************************************************
   * Private Members
   ****************************************************************************/

#Code:

  private IPageSource _pageSource;

  private Widget _pageWidget = null;

  private IPageSource _exceptionPage = new ExceptionPage();

  private boolean _hadError = false;

  private RootPanel _panel;

  /*****************************************************************************
   * Public Methods
   ****************************************************************************/

  public void handleException(Throwable ex) {

  }

#No. 4753
#File: E:\bishe\1\AbstractSinglePageApplication.java
#Comment:
  /*****************************************************************************
   * {@link EntryPoint}
   ****************************************************************************/

#Code:

  public void onModuleLoad() {

    ExceptionSupport.addExceptionListener(this);

    _panel = RootPanel.get("content");

    _contextManager.addContextListener(this);

    Context context = _contextManager.getContext();

    if (context == null)
      context = new ContextImpl();

    final Context finalContext = context;
    
    // We defer execution of the command so that other modules can finish loading before we fire the context change event
    DeferredCommand.addCommand(new Command() {
      public void execute() {
        onContextChanged(finalContext);
      }
    });
  }

#No. 4754
#File: E:\bishe\1\AbstractSinglePageApplication.java
#Comment:
  /*****************************************************************************
   * {@link HistoryListener} Interface
   ****************************************************************************/

#Code:

  public void onContextChanged(Context context) {
    try {

      if (_pageWidget == null || _hadError) {
        _panel.clear();
        _pageWidget = _pageSource.create(context);
        _panel.add(_pageWidget);
      } else {
        Widget widget = _pageSource.update(context);
        if (widget != null) {
          _panel.clear();
          _pageWidget = widget;
          _panel.add(_pageWidget);
        }
      }

    } catch (PageException ex) {
      onException(ex);
    }
  }

#No. 4755
#File: E:\bishe\1\AbstractSinglePageApplication.java
#Comment:
  /*****************************************************************************
   * {@link ExceptionListener} Interface
   ****************************************************************************/

#Code:

  public void onException(Throwable ex) {
    ex.printStackTrace();

    String msg = ex.getMessage();

    Map<String, String> p = new HashMap<String, String>();
    p.put("message", msg);
    ContextImpl c = new ContextImpl(p);

    try {
      _panel.clear();
      Widget widget = _exceptionPage.create(c);
      _panel.add(widget);
      _hadError = true;
    } catch (PageException e) {
      e.printStackTrace();
    }
  }

#No. 4756
#File: E:\bishe\1\AbstractSinglePageApplication.java
#Comment:
  /*****************************************************************************
   * Private Methods
   ****************************************************************************/

#Code:

  protected void setPage(IPageSource page) {
    _pageSource = page;
  }

#No. 4757
#File: E:\bishe\1\AbstractSingleParamSameColTypeProjectionFunction.java
#Comment:
/**
 * Abstract implementation for projection functions with a single param and which produce the same output
 * {@link ColumnType} as the input.
 *
 * @author Bastian Gloeckle
 */

#Code:
public abstract class AbstractSingleParamSameColTypeProjectionFunction<T>
    extends AbstractSingleParamProjectionFunction<T, T> {

  protected AbstractSingleParamSameColTypeProjectionFunction(String nameLowercase, ColumnType inputAndOutputType,
      Function<T, T> fn) {
    super(nameLowercase, inputAndOutputType, inputAndOutputType, fn);
  }
}

#No. 4758
#File: E:\bishe\1\AbstractSingleReadHandler.java
#Comment:
    /**
     * 使用处理器处理异常，处理之后关闭当前的通道
     * 
     * @param exc
     */

#Code:
    public void catchThrowable(Throwable exc)
    {
        if (serverChannel.closeChannel())
        {
            InternalResult task = new InternalResultImpl();
            task.setChannelInfo(serverChannel);
            task.setData(exc);
            task.setIndex(0);
            Object intermediateResult = exc;
            try
            {
                for (DataHandler each : handlers)
                {
                    intermediateResult = each.catchException(intermediateResult, task);
                }
            }
            catch (Exception e)
            {
                e.printStackTrace();
            }
        }
        //在single模式中，写线程成功后才会再次注册读取。只有失败的时候才会调用这个异常方法。所以可以这个方法中直接释放iobuf。因为后续不会再有对iobuf的操作。
        iobufReleseState.close();
    }

#No. 4759
#File: E:\bishe\1\AbstractSingleReadHandler.java
#Comment:
    /**
     * 开始空闲读取等待，并且将倒数计时状态重置为false
     */

#Code:
    public void readAndWait()
    {
        startCountdown = false;
        serverChannel.getSocketChannel().read(getWriteBuffer(), waitTimeout, TimeUnit.MILLISECONDS, serverChannel, this);
    }

#No. 4760
#File: E:\bishe\1\AbstractSingleReadHandler.java
#Comment:
    /**
     * 将iobuf的内容进行压缩，返回一个处于可写状态的ByteBuffer
     * 
     * @return
     */

#Code:
    protected ByteBuffer getWriteBuffer()
    {
        ByteBuffer ioBuffer = ioBuf.nioBuffer();
        ioBuffer.position(ioBuffer.limit()).limit(ioBuffer.capacity());
        return ioBuffer;
    }

#No. 4761
#File: E:\bishe\1\AbstractSingleReadHandler.java
#Comment:
    /**
     * 在通道上继续读取未读取完整的数据
     */

#Code:
    public void continueRead()
    {
        if (startCountdown == false)
        {
            lastReadTime = System.currentTimeMillis();
            endReadTime = lastReadTime + readTimeout;
            startCountdown = true;
        }
        serverChannel.getSocketChannel().read(getWriteBuffer(), getRemainTime(), TimeUnit.MILLISECONDS, serverChannel, this);
        lastReadTime = System.currentTimeMillis();
    }

#No. 4762
#File: E:\bishe\1\AbstractSingleReadHandler.java
#Comment:
    /**
     * 剩余的读取消息时间
     * 
     * @return
     */

#Code:
    protected long getRemainTime()
    {
        long time = endReadTime - lastReadTime;
        return time;
    }

#No. 4763
#File: E:\bishe\1\AbstractSingleYamlDeployMojo.java
#Comment:
  /**
   * The Google Cloud Platform project name to use for this invocation. If omitted then the current
   * project is assumed.
   */

#Code:
  @Parameter(alias = "deploy.project", property = "app.deploy.project")
  protected String project;

  public AbstractSingleYamlDeployMojo() {
    super();
  }

#No. 4764
#File: E:\bishe\1\AbstractSingleYamlDeployMojo.java
#Comment:
  /**
   * Sets {@code appEngineDirectory} based on whether the project is GAE Standard or Flexible if
   * the user has not set a value explicitly.
   *
   * <p>For Standard it uses {@code <stagingDirectory>/WEB-INF/appengine-generated}, for Flexible
   * it uses <code>${basedir}/src/main/appengine</code>.
   */

#Code:
  @Override
  protected void configureAppEngineDirectory() {
    if (isStandardStaging()) {
      appEngineDirectory =
          stagingDirectory.toPath().resolve("WEB-INF/appengine-generated").toFile();
    } else {
      appEngineDirectory =
          mavenProject.getBasedir().toPath().resolve("src/main/appengine").toFile();
    }
  }

#No. 4765
#File: E:\bishe\1\AbstractSinkTestCase.java
#Comment:
    /**
     * Returns a Writer to write a test output result. The Writer writes to a File
     * <code>"target/output/test. + extension"</code>, where extension is returned by
     * {@link #outputExtension()}, in the current base directory.
     *
     * @return a Writer to write a test output result.
     * @throws java.lang.Exception if the Writer cannot be constructed.
     */

#Code:
    protected Writer getTestWriter()
        throws Exception
    {
        if ( testWriter == null )
        {
            File outputDirectory = new File( getBasedirFile(), "target/output" );

            if ( !outputDirectory.exists() )
            {
                outputDirectory.mkdirs();
            }

            testWriter = new FileWriter( new File( outputDirectory, "test." + outputExtension() ) );
        }

        return testWriter;
    }

#No. 4766
#File: E:\bishe\1\AbstractSinkTestCase.java
#Comment:
    /**
     * Returns a Reader that gives access to a common test apt file.
     *
     * @return a Reader to access the test apt resource file.
     * @throws java.lang.Exception if the Reader cannot be constructed.
     */

#Code:
    protected Reader getTestReader()
        throws Exception
    {
        InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream( "test.apt" );

        InputStreamReader reader = new InputStreamReader( is );

        return reader;
    }

#No. 4767
#File: E:\bishe\1\AbstractSinkTestCase.java
#Comment:
    /**
     * Return the current base diretory as a File.
     *
     * @return the current base diretory as a File.
     */

#Code:
    public File getBasedirFile()
    {
        return new File( getBasedir() );
    }

#No. 4768
#File: E:\bishe\1\AbstractSitemapGenerator.java
#Comment:
	/**
	 * Construct sitemap into single String
	 * 
	 * @return sitemap
	 */

#Code:
	public String constructSitemapString() {
		String[] sitemapArray = constructSitemap();
		StringBuilder result = new StringBuilder();
		for (String line : sitemapArray) {
			result.append(line);
		}
		return result.toString();
	}

#No. 4769
#File: E:\bishe\1\AbstractSitemapGenerator.java
#Comment:
	/**
	 * Save sitemap to output file
	 * 
	 * @param file
	 *            Output file
	 * @param sitemap
	 *            Sitemap as array of Strings (created by constructSitemap()
	 *            method)
	 * @throws IOException
	 *             when error
	 */

#Code:
	public void saveSitemap(File file, String[] sitemap) throws IOException {
		BufferedWriter writer = new BufferedWriter(new FileWriter(file));
		for (String string : sitemap) {
			writer.write(string);
		}
		writer.close();
	}

#No. 4770
#File: E:\bishe\1\AbstractSitemapGenerator.java
#Comment:
	/**
	 * Construct and save sitemap to output file
	 * 
	 * @param file
	 *            Output file
	 * @throws IOException
	 *             when error
	 */

#Code:
	public void constructAndSaveSitemap(File file) throws IOException {
		String[] sitemap = constructSitemap();
		saveSitemap(file, sitemap);
	}

#No. 4771
#File: E:\bishe\1\AbstractSitemapGenerator.java
#Comment:
	/**
	 * Ping Google that sitemap has changed. Will call this URL:
	 * http://www.google
	 * .com/webmasters/tools/ping?sitemap=URL_Encoded_sitemapUrl
	 * 
	 * @param sitemapUrl
	 *            sitemap url
	 */

#Code:
	public void pingGoogle(String sitemapUrl) {
		ping("http://www.google.com/webmasters/tools/ping?sitemap=", sitemapUrl);
	}

#No. 4772
#File: E:\bishe\1\AbstractSitemapGenerator.java
#Comment:
	/**
	 * Ping Bing that sitemap has changed. Will call this URL:
	 * http://www.bing.com/ping?sitemap=URL_Encoded_sitemapUrl
	 * 
	 * @param sitemapUrl
	 *            sitemap url
	 * 
	 */

#Code:
	public void pingBing(String sitemapUrl) {
		ping("http://www.bing.com/ping?sitemap=", sitemapUrl);
	}

#No. 4773
#File: E:\bishe\1\AbstractSitemapGenerator.java
#Comment:
	/**
	 * Ping Google that sitemap has changed. Sitemap must be on this location:
	 * baseUrl/sitemap.xml (for example http://www.javavids.com/sitemap.xml)
	 */

#Code:
	public void pingGoogle() {
		pingGoogle(baseUrl + "sitemap.xml");
	}

#No. 4774
#File: E:\bishe\1\AbstractSitemapGenerator.java
#Comment:
	/**
	 * Ping Google that sitemap has changed. Sitemap must be on this location:
	 * baseUrl/sitemap.xml (for example http://www.javavids.com/sitemap.xml)
	 */

#Code:
	public void pingBing() {
		pingBing(baseUrl + "sitemap.xml");
	}

#No. 4775
#File: E:\bishe\1\AbstractSiteServiceImpl.java
#Comment:
    /**
     * Update the defined entry cache.
     * 
     * @param siteIdentifier : Unique identifier of the site
     * @param isPendingMember : has a pending request to join the site
     * @param isMember : member of the site
     * @param isFavorite : member has favorite the site
     * @since 1.1.0
     */

#Code:
    protected void updateExtraPropertyCache(String siteIdentifier, boolean isPendingMember, boolean isMember,
            boolean isFavorite)
    {
        CacheSiteExtraProperties properties = extraPropertiesCache.get(siteIdentifier);
        if (properties != null)
        {
            properties.isPendingMember = isPendingMember;
            properties.isMember = isMember;
            properties.isFavorite = isFavorite;
        }
        else
        {
            properties = new CacheSiteExtraProperties(isPendingMember, isMember, isFavorite);
        }
        extraPropertiesCache.put(siteIdentifier, properties);
    }

#No. 4776
#File: E:\bishe\1\AbstractSiteServiceImpl.java
#Comment:
    /**
     * extraPropertiesCache is a LRUCache responsible to maintain extra
     * informations about the site object. Indeed it's not possible with one
     * HTTP request to obtain all this informations at one time. For client’s
     * convenience three new boolean flags to show whether the user is already a
     * member, waiting to become a member and whether they have favorited the
     * site will be added.
     * 
     * @since 1.1.0
     */

#Code:
    protected LruCache<String, CacheSiteExtraProperties> extraPropertiesCache = new LruCache<String, CacheSiteExtraProperties>(
            MAX_CACHE_ITEMS)
    {
        // By default we consider the size of any CacheSiteExtraProperties
        // equals to 1.
        protected int sizeOf(String key, CacheSiteExtraProperties value)
        {
            return 1;
        }
    };

#No. 4777
#File: E:\bishe\1\AbstractSiteServiceImpl.java
#Comment:
    /**
     * {@inheritDoc}
     * 
     * @since 1.1.0
     */

#Code:
    @Override
    public void clear()
    {
        if (extraPropertiesCache == null)
        {
            extraPropertiesCache = new LruCache<String, CacheSiteExtraProperties>(MAX_CACHE_ITEMS)
            {
                protected int sizeOf(String key, CacheSiteExtraProperties value)
                {
                    return 1;
                }
            };
        }
        extraPropertiesCache.evictAll();
    }

#No. 4778
#File: E:\bishe\1\AbstractSiteServiceImpl.java
#Comment:
    /**
     * Responsible to init the cache if the cache is empty.
     */

#Code:
    private void initExtraPropertiesCache()
    {
        if (extraPropertiesCache != null && extraPropertiesCache.size() == 0)
        {
            retrieveExtraProperties(session.getPersonIdentifier());
        }
    }

#No. 4779
#File: E:\bishe\1\AbstractSiteServiceImpl.java
#Comment:
    /**
     * Create a new site with the refreshed value from the cacheExtraProperties.
     * 
     * @param site : old site to refresh.
     * @return Newly created and updated site.
     */

#Code:
    public Site refresh(Site site)
    {
        CacheSiteExtraProperties cacheProperty = extraPropertiesCache.get(site.getIdentifier());
        return (cacheProperty == null) ? site
                : new SiteImpl(site, cacheProperty.isPendingMember, cacheProperty.isMember, cacheProperty.isFavorite);
    }

#No. 4780
#File: E:\bishe\1\AbstractSmsHandler.java
#Comment:
	/**
	 * Helper method. Builds a JSON representation of all the "unknown" properties of the message (ie. properties that don't
	 * have an associated column in the db).
	 *
	 * @param message the message from which we are retreiving the properties to build the JSON object.
	 * @return a String representation of the JSON object.
	 */

#Code:
	private String buildJSON(Message message)  {
		JSONObject obj = new JSONObject();

		for (Map.Entry<String, Object> entry : message.getProperties().entrySet()) {
			if (!isKnownProperty(entry.getKey())) {
				try {
					obj.put(entry.getKey(), entry.getValue());
				} catch (JSONException e) {
					log.error("Could not persist JSON property '" + entry.getKey() + "': " + e.getMessage(), e);
				}
			}
		}

		return obj.toString();
	}

#No. 4781
#File: E:\bishe\1\AbstractSmsHandler.java
#Comment:
	/**
	 * Helper method. Tells if a property is in the list of known properties (ie. the properties that don't have an associated
	 * column in the db).
	 *
	 * @param property the property we are testing against the known properties.
	 * @return true if it is a "known property", false otherwise.
	 */

#Code:
	private boolean isKnownProperty(String property) {
		for (String knownProperty : KNOWN_PROPERTIES) {
			if (property.equals(knownProperty)) {
				return true;
			}
		}

		return false;
	}

#No. 4782
#File: E:\bishe\1\AbstractSnapshotDeserializer.java
#Comment:
    /**
     * Returns Schema for the given {@code schemaVersionKey} from loadable cache.
     * @param schemaVersionKey schema version key
     */

#Code:
    protected S getSchema(SchemaVersionKey schemaVersionKey) {
        try {
            return schemaCache.get(schemaVersionKey);
        } catch (ExecutionException e) {
            throw new RuntimeException(e);
        }
    }

#No. 4783
#File: E:\bishe\1\AbstractSnippet.java
#Comment:
    /**
     * Snippet constructor
     *
     * @param category         Snippet category as corresponds to UI displayed sections (organization, me, groups, etc...)
     * @param descriptionArray The String array for the specified snippet
     */

#Code:
    public AbstractSnippet(
            SnippetCategory<Service> category,
            Integer descriptionArray) {
        //Get snippet configuration information from the
        //XML configuration for the snippet
        getSnippetArrayContent(category, descriptionArray);

        mService = category.mService;
    }

#No. 4784
#File: E:\bishe\1\AbstractSnippet.java
#Comment:
    /**
     * Gets the items from the specified snippet XML string array and stores the values
     * in private class fields
     *
     * @param category         Snippet category as corresponds to UI displayed sections (organization, me, groups, etc...)
     * @param descriptionArray The String array for the specified snippet
     */

#Code:
    private void getSnippetArrayContent(SnippetCategory<Service> category, Integer descriptionArray) {
        if (null != descriptionArray) {
            String[] params = SnippetApp.getApp().getResources().getStringArray(descriptionArray);

            try {
                mName = params[mNameIndex];
                mDesc = params[mDescIndex];
                mUrl = params[mUrlIndex];
                mO365Version = params[mO365VersionIndex];
                String isAdminRequired = params[mIsAdminRequiredIndex];
                mIsAdminRequired = isAdminRequired.equalsIgnoreCase("true");
            } catch (IndexOutOfBoundsException ex) {
                throw new RuntimeException(
                        "Invalid array in "
                                + category.mSection
                                + " snippet XML file"
                        , ex);
            }
        } else {
            mName = category.mSection;
            mDesc = mUrl = null;
            mO365Version = null;

        }
    }

#No. 4785
#File: E:\bishe\1\AbstractSnippet.java
#Comment:
    /**
     * Returns the version segment of the endpoint url with input from
     * XML snippet description
     *
     * @return Which version of the endpoint to use (beta, v1, etc...)
     */

#Code:
    protected String getVersion() {
        return mO365Version;
    }

#No. 4786
#File: E:\bishe\1\AbstractSocialNetworkService.java
#Comment:
    /**
     * @param searchUserUrl
     * @param parameters
     * @return
     */

#Code:
    public String buildUri(String url, Map<String, ? extends Object> parameters) {
        return URLUtils.buildUri(buildUri(url), parameters);
    }

#No. 4787
#File: E:\bishe\1\AbstractSocketSession.java
#Comment:
    /**
     * Only intended to be  invoked by threaded receiver
     * WILL BLOCK IF NOT NIO
     */

#Code:
    @Override
    public void internalConnect() {

        while ( isPaused() ) {
            _log.info( "Session " + getComponentId() + " connection on hold as session is paused" );
            synchronized( this ) {
                try {
                    this.wait();
                } catch( InterruptedException e ) {
                    //
                }
            }
            _log.info( "Session " + getComponentId() + " unpaused" );
        }
        
        if ( getSessionState() == State.Disconnected ) {

            if ( _socketConfig.isOpenUTC( System.currentTimeMillis() ) ) {
                _loggedNotInSession = false;
                
                _log.info( "Session "  + getComponentId() + " attempting to connect " );
                _socketChannel = connectSocket();
                _connectAttempts = 0;

                if ( _socketChannel != null ) {
                    setState( Session.State.Connected );
                }
            } else if ( ! _loggedNotInSession ) {
                _log.info( "Session "  + getComponentId() + " CANNOT connect as config period is not open " );
                _loggedNotInSession = true;
            }
        }
        
        synchronized( this ) {
            notifyAll();
        }
    }

#No. 4788
#File: E:\bishe\1\AbstractSocketSession.java
#Comment:
    /**
     * waitConnect is used by receive/transmit thread to be notified when reconnected
     * @param string 
     */

#Code:
    public void waitConnect( String key ) {
        
        _log.info( "Session " + getComponentId() + " " + key + " waiting for connection" );

        while( getSessionState() != State.Connected ) {
            
            Utils.delay( this, SessionConstants.CONNECT_WAIT_DELAY_MS );
        }

        _log.info( "Session " + getComponentId() + " " + key + " confirm connected" );
    }

#No. 4789
#File: E:\bishe\1\AbstractSocketSession.java
#Comment:
    /**
     * PROTECTED METHODS
     */

#Code:

    @Override
    protected final void disconnectCleanup() {
        cleanUp( _socketChannel );
    }

#No. 4790
#File: E:\bishe\1\AbstractSocketSession.java
#Comment:
    /**
     * read fixed number of expected bytes
     * @param expectedBytes
     * @return
     * @throws Exception
     */

#Code:
    protected final int readFixedExpectedBytes( final int preBuffered, int minBytes ) throws Exception {
        final int maxBytes = _inByteBuffer.remaining();        
        int totalRead = preBuffered;
        int curRead;
        if ( minBytes - preBuffered <= 0 ) return preBuffered;

        _inNativeByteBuffer.position( 0 );
        _inNativeByteBuffer.limit( maxBytes );

        while( totalRead < minBytes ) {
            curRead = _socketChannel.read();

            if ( curRead == -1 ) throw new DisconnectedException( "Detected socket disconnect" );

            totalRead += curRead;
        }
        
        _inNativeByteBuffer.flip();
        
        // @TODO bypass the soft ref creation in IOUtil.read for heap based buffers
        _inByteBuffer.put( _inNativeByteBuffer );

        return totalRead;
    }

#No. 4791
#File: E:\bishe\1\AbstractSocketSession.java
#Comment:
    /**
     * PRIVATE METHODS
     */

#Code:
    
    private void startReceiver() {
        _receiver.start();
    }

#No. 4792
#File: E:\bishe\1\AbstractSocketSession.java
#Comment:
        /**
         * keep alive adds latency, only use where we get connectivity issues like firewall dropping low use connection
         */

#Code:
        if ( _socketConfig.getKeepAlive() && ! channel.getKeepAlive() ) {
            _log.info( "Note socket " + getComponentId() + " using KeepAlive " );
            channel.setKeepAlive( true );
        }

#No. 4793
#File: E:\bishe\1\AbstractSockJsMessageCodec.java
#Comment:
    /**
     * See "JSON Unicode Encoding" section of SockJS protocol.
     */

#Code:
    private String escapeSockJsSpecialChars(char[] characters) {
        StringBuilder result = new StringBuilder();
        for (char c : characters) {
            if (isSockJsSpecialChar(c)) {
                result.append('\\').append('u');
                String hex = Integer.toHexString(c).toLowerCase();
                for (int i = 0; i < (4 - hex.length()); i++) {
                    result.append('0');
                }
                result.append(hex);
            } else {
                result.append(c);
            }
        }
        return result.toString();
    }

#No. 4794
#File: E:\bishe\1\AbstractSockJsMessageCodec.java
#Comment:
    /**
     * See `escapable_by_server` variable in the SockJS protocol test suite.
     */

#Code:
    private boolean isSockJsSpecialChar(char ch) {
        return ch <= '\u001F'
                || ch >= '\u200C' && ch <= '\u200F'
                || ch >= '\u2028' && ch <= '\u202F'
                || ch >= '\u2060' && ch <= '\u206F'
                || ch >= '\uFFF0'
                || ch >= '\uD800' && ch <= '\uDFFF';
    }

#No. 4795
#File: E:\bishe\1\AbstractSOI.java
#Comment:
    /**
     * Utility functions that return the appropriate delegate interface based on input request.
     *
     * @return the IRESTRequestHandler
     */

#Code:
    protected IRESTRequestHandler findRestRequestHandlerDelegate() throws IOException
    {
        final IPropertySet props = serverEnvironment.getProperties();
        // Check if there is an extension name set
        String extensionName;
        try
        {
            extensionName = (String) props.getProperty("ExtensionName");
        }
        catch (Exception e)
        {
            extensionName = null;
        }
        if (extensionName == null || extensionName.isEmpty())
        {
            return restRequestHandler;
        }
        else
        {
            // Get the extension reference from cache if available
            if (extensionCache.containsKey(extensionName))
            {
                return new IRESTRequestHandlerProxy(extensionCache.get(extensionName));
            }
            // This request is to be made on a specific extension
            // so we find the extension from the extension manager
            final IServerObjectExtensionManager extnMgr = new IServerObjectExtensionManagerProxy(serverObject);
            final IServerObjectExtension soe = extnMgr.findExtensionByTypeName(extensionName);
            if (TypeChecker.instanceOf(soe, IRESTRequestHandler.class))
            {
                extensionCache.put(extensionName, soe);
                return new IRESTRequestHandlerProxy(soe);
            }
            else
            {
                return null;
            }
        }
    }

#No. 4796
#File: E:\bishe\1\AbstractSolrSearchService.java
#Comment:
    /**
     * Query a particular instance of SolrServer identified by the core name
     * with a given query.
     */

#Code:
    public QueryResponse query(String solrCore, SolrQuery solrQuery) throws SolrServerException {
        SolrClient server = getSolrQueryClient();
        LOG.info("Quering {} with '{}'", getSolrServerURI(solrCore), solrQuery);
        QueryResponse solrResponse;
        try {
            solrResponse = server.query(solrCore, solrQuery);
            return solrResponse;
        } catch (IOException e) {
            e.printStackTrace();
        }
        return new QueryResponse();
    }

#No. 4797
#File: E:\bishe\1\AbstractSolrSentryTestBase.java
#Comment:
  /**
   * Set the proper user in the Solr authentication filter
   * @param solrUser
   */

#Code:
  protected void setAuthenticationUser(String solrUser) throws Exception {
    ModifiableUserAuthenticationFilter.setUser(solrUser);
  }

#No. 4798
#File: E:\bishe\1\AbstractSolrSentryTestBase.java
#Comment:
  /**
   * Get the user defined in the Solr authentication filter
   * @return - the username as String
   * @throws Exception
   */

#Code:
  protected String getAuthenticatedUser() throws Exception {
    return ModifiableUserAuthenticationFilter.getUser();
  }

#No. 4799
#File: E:\bishe\1\AbstractSolrSentryTestBase.java
#Comment:
  /**
   * Function to return the user name based on the permissions provided.
   * @param collectionName - Name of the solr collection.
   * @param isQuery - Boolean that specifies query permission.
   * @param isUpdate - Boolean that specifies update permission.
   * @param isAll - Boolean that specifies all permission.
   * @return - String which represents the Solr username.
   */

#Code:
  protected String getUsernameForPermissions(String collectionName,
                                             boolean isQuery,
                                             boolean isUpdate,
                                             boolean isAll) {
    StringBuilder finalStr = new StringBuilder();
    finalStr.append(collectionName);
    finalStr.append("_");
    StringBuilder permissions = new StringBuilder();
    if (isQuery) {
      permissions.append("q");
    }

    if (isUpdate) {
      permissions.append("u");
    }

    if (isAll) {
      permissions.append("a");
    }

    finalStr.append(permissions.toString());
    return finalStr.toString();
  }

#No. 4800
#File: E:\bishe\1\AbstractSolrSentryTestBase.java
#Comment:
  /**
   * Method to validate Solr update passes
   * @param solrUserName - User authenticated into Solr
   * @param collectionName - Name of the collection to which the data has to be updated
   * @param solrInputDoc - Instance of SolrInputDocument
   * @throws Exception
   */

#Code:
  protected void verifyUpdatePass(String solrUserName,
                                  String collectionName,
                                  SolrInputDocument solrInputDoc) throws Exception {
    String originalUser = getAuthenticatedUser();
    try {
      SolrDocumentList orginalSolrDocs = getSolrDocs(collectionName, ALL_DOCS, true);
      setAuthenticationUser(solrUserName);
      CloudSolrServer cloudSolrServer = getCloudSolrServer(collectionName);
      try {
        cloudSolrServer.add(solrInputDoc);
        cloudSolrServer.commit();
      } finally {
        cloudSolrServer.shutdown();
      }

      orginalSolrDocs.add(ClientUtils.toSolrDocument(solrInputDoc));
      SolrDocumentList solrRespDocs = getSolrDocs(collectionName, ALL_DOCS, true);
      // Validate Solr content to check whether the update command went through.
      validateSolrDocCountAndContent(orginalSolrDocs, solrRespDocs);
    }
    finally {
      setAuthenticationUser(originalUser);
    }
  }

#No. 4801
#File: E:\bishe\1\AbstractSolrSentryTestBase.java
#Comment:
  /**
   * Method to validate Solr update fails
   * @param solrUserName - User authenticated into Solr
   * @param collectionName - Name of the collection to which the data has to be updated
   * @param solrInputDoc - Instance of SolrInputDocument
   * @throws Exception
   */

#Code:
  protected void verifyUpdateFail(String solrUserName,
                                  String collectionName,
                                  SolrInputDocument solrInputDoc) throws Exception {
    String originalUser = getAuthenticatedUser();
    try {
      SolrDocumentList orginalSolrDocs = getSolrDocs(collectionName, ALL_DOCS, true);
      setAuthenticationUser(solrUserName);
      CloudSolrServer cloudSolrServer = getCloudSolrServer(collectionName);
      try {
        cloudSolrServer.add(solrInputDoc);
        cloudSolrServer.commit();
        fail("The specified user: " + solrUserName + " shouldn't get update access!");
      } catch (Exception exception) {
        assertTrue("Expected " + SENTRY_ERROR_MSG + " in " + exception.toString(),
            exception.toString().contains(SENTRY_ERROR_MSG));
      } finally {
        cloudSolrServer.shutdown();
      }

      SolrDocumentList solrRespDocs = getSolrDocs(collectionName, ALL_DOCS, true);
      // Validate Solr content to check whether the update command didn't go through.
      validateSolrDocCountAndContent(orginalSolrDocs, solrRespDocs);
    } finally {
      setAuthenticationUser(originalUser);
    }
  }

#No. 4802
#File: E:\bishe\1\AbstractSolrSentryTestBase.java
#Comment:
  /**
   * Method to validate Solr deletedocs passes
   * (This function doesn't check if there is at least one Solr document present in Solr)
   * @param solrUserName - User authenticated into Solr
   * @param collectionName - Name of the collection to which the data has to be updated
   * @param allowZeroDocs - Boolean for running this method only if there is atleast one Solr doc present.
   * @throws MalformedURLException, SolrServerException, IOException
   */

#Code:
  protected void verifyDeletedocsPass(String solrUserName,
                                      String collectionName,
                                      boolean allowZeroDocs) throws Exception {
    String originalUser = getAuthenticatedUser();
    try {
      SolrDocumentList orginalSolrDocs = getSolrDocs(collectionName, ALL_DOCS, true);
      if (allowZeroDocs == false) {
        assertTrue("Solr should contain atleast one solr doc to run this test.", orginalSolrDocs.size() > 0);
      }

      setAuthenticationUser(solrUserName);
      CloudSolrServer cloudSolrServer = getCloudSolrServer(collectionName);
      try {
        cloudSolrServer.deleteByQuery(ALL_DOCS);
        cloudSolrServer.commit();
      } finally {
        cloudSolrServer.shutdown();
      }

      // Validate Solr doc count is zero
      SolrDocumentList solrRespDocs = getSolrDocs(collectionName, ALL_DOCS, true);
      validateSolrDocCountAndContent(new SolrDocumentList(), solrRespDocs);
    } finally {
      setAuthenticationUser(originalUser);
    }
  }

#No. 4803
#File: E:\bishe\1\AbstractSolrSentryTestBase.java
#Comment:
  /**
   * Method to validate Solr deletedocs fails
   * (This function doesn't check if there is at least one Solr document present in Solr)
   * @param solrUserName - User authenticated into Solr
   * @param collectionName - Name of the collection to which the data has to be updated
   * @param allowZeroDocs - Boolean for running this method only if there is atleast one Solr doc present.
   * @throws Exception
   */

#Code:
  protected void verifyDeletedocsFail(String solrUserName,
                                      String collectionName,
                                      boolean allowZeroDocs) throws Exception {
    String originalUser = getAuthenticatedUser();
    try {
      SolrDocumentList orginalSolrDocs = getSolrDocs(collectionName, ALL_DOCS, true);
      if (allowZeroDocs == false) {
        assertTrue("Solr should contain atleast one solr doc to run this test.", orginalSolrDocs.size() > 0);
      }

      setAuthenticationUser(solrUserName);
      CloudSolrServer cloudSolrServer = getCloudSolrServer(collectionName);
      try {
        cloudSolrServer.deleteByQuery(ALL_DOCS);
        cloudSolrServer.commit();
        fail("The specified user: " + solrUserName + " shouldn't get deletedocs access!");
      } catch (Exception exception) {
        assertTrue("Expected " + SENTRY_ERROR_MSG + " in " + exception.toString(),
            exception.toString().contains(SENTRY_ERROR_MSG));
      } finally {
        cloudSolrServer.shutdown();
      }

      // Validate Solr doc count and content is same as original set.
      SolrDocumentList solrRespDocs = getSolrDocs(collectionName, ALL_DOCS, true);
      validateSolrDocCountAndContent(orginalSolrDocs, solrRespDocs);
    } finally {
      setAuthenticationUser(originalUser);
    }
  }

#No. 4804
#File: E:\bishe\1\AbstractSolrSentryTestBase.java
#Comment:
  /**
   * Method to validate Solr query passes
   * @param solrUserName - User authenticated into Solr
   * @param collectionName - Name of the collection to be queried
   * @param solrQueryStr - Query string to be searched in Solr
   * @throws Exception
   */

#Code:
  protected void verifyQueryPass(String solrUserName,
                                 String collectionName,
                                 String solrQueryStr) throws Exception {
    String originalUser = getAuthenticatedUser();
    try {
      SolrDocumentList orginalSolrDocs = getSolrDocs(collectionName, solrQueryStr, true);
      setAuthenticationUser(solrUserName);
      SolrDocumentList solrRespDocs = null;
      solrRespDocs = getSolrDocs(collectionName, solrQueryStr, false);

      // Validate Solr content to check whether the query command went through.
      validateSolrDocCountAndContent(orginalSolrDocs, solrRespDocs);
    } finally {
      setAuthenticationUser(originalUser);
    }
  }

#No. 4805
#File: E:\bishe\1\AbstractSolrSentryTestBase.java
#Comment:
  /**
   * Method to validate Solr query fails
   * @param solrUserName - User authenticated into Solr
   * @param collectionName - Name of the collection to be queried
   * @param solrQueryStr - Query string to be searched in Solr
   * @throws Exception
   */

#Code:
  protected void verifyQueryFail(String solrUserName,
                                 String collectionName,
                                 String solrQueryStr) throws Exception {
    String originalUser = getAuthenticatedUser();
    try {
      setAuthenticationUser(solrUserName);
      try {
        getSolrDocs(collectionName, solrQueryStr, false);
        fail("The specified user: " + solrUserName + " shouldn't get query access!");
      } catch (Exception exception) {
        assertTrue("Expected " + SENTRY_ERROR_MSG + " in " + exception.toString(),
            exception.toString().contains(SENTRY_ERROR_MSG));
      }
    } finally {
      setAuthenticationUser(originalUser);
    }
  }

#No. 4806
#File: E:\bishe\1\AbstractSolrSentryTestBase.java
#Comment:
  /**
   * Method to validate collection Admin operation pass
   * @param solrUserName - User authenticated into Solr
   * @param adminOp - Admin operation to be performed
   * @param collectionName - Name of the collection to be queried
   * @throws Exception
   */

#Code:
  protected void verifyCollectionAdminOpPass(String solrUserName,
                                             CollectionAction adminOp,
                                             String collectionName) throws Exception {
    verifyCollectionAdminOpPass(solrUserName, adminOp, collectionName, null);
  }

#No. 4807
#File: E:\bishe\1\AbstractSolrSentryTestBase.java
#Comment:
  /**
   * Method to validate collection Admin operation pass
   * @param solrUserName - User authenticated into Solr
   * @param adminOp - Admin operation to be performed
   * @param collectionName - Name of the collection to be queried
   * @param params - SolrParams to use
   * @throws Exception
   */

#Code:
  protected void verifyCollectionAdminOpPass(String solrUserName,
                                             CollectionAction adminOp,
                                             String collectionName,
                                             SolrParams params) throws Exception {
    String originalUser = getAuthenticatedUser();
    try {
      setAuthenticationUser(solrUserName);
      QueryRequest request = populateCollectionAdminParams(adminOp, collectionName, params);
      CloudSolrServer solrServer = createNewCloudSolrServer();
      try {
        solrServer.request(request);
        if (adminOp.compareTo(CollectionAction.CREATE) == 0) {
          // Wait for collection creation to complete.
          waitForRecoveriesToFinish(collectionName, solrServer, false);
        }
      } finally {
        solrServer.shutdown();
      }
    } finally {
      setAuthenticationUser(originalUser);
    }
  }

#No. 4808
#File: E:\bishe\1\AbstractSolrSentryTestBase.java
#Comment:
  /**
   * Method to validate collection Admin operation fail
   * @param solrUserName - User authenticated into Solr
   * @param adminOp - Admin operation to be performed
   * @param collectionName - Name of the collection to be queried
   * @throws Exception
   */

#Code:
  protected void verifyCollectionAdminOpFail(String solrUserName,
                                             CollectionAction adminOp,
                                             String collectionName) throws Exception {
    verifyCollectionAdminOpFail(solrUserName, adminOp, collectionName, null);
  }

#No. 4809
#File: E:\bishe\1\AbstractSolrSentryTestBase.java
#Comment:
  /**
   * Method to validate collection Admin operation fail
   * @param solrUserName - User authenticated into Solr
   * @param adminOp - Admin operation to be performed
   * @param collectionName - Name of the collection to be queried
   * @param params - SolrParams to use
   * @throws Exception
   */

#Code:
  protected void verifyCollectionAdminOpFail(String solrUserName,
                                             CollectionAction adminOp,
                                             String collectionName,
                                             SolrParams params) throws Exception {

    String originalUser = getAuthenticatedUser();
    try {
      setAuthenticationUser(solrUserName);
      try {
        QueryRequest request = populateCollectionAdminParams(adminOp, collectionName, params);
        CloudSolrServer solrServer = createNewCloudSolrServer();
        try {
          solrServer.request(request);
          if (adminOp.compareTo(CollectionAction.CREATE) == 0) {
            // Wait for collection creation to complete.
            waitForRecoveriesToFinish(collectionName, solrServer, false);
          }
        } finally {
          solrServer.shutdown();
        }

        fail("The specified user: " + solrUserName + " shouldn't get admin access for " + adminOp);
      } catch (Exception exception) {
        assertTrue("Expected " + SENTRY_ERROR_MSG + " in " + exception.toString(),
            exception.toString().contains(SENTRY_ERROR_MSG));
      }
    } finally {
      setAuthenticationUser(originalUser);
    }
  }

#No. 4810
#File: E:\bishe\1\AbstractSolrSentryTestBase.java
#Comment:
  /**
   * Method to populate the Solr params based on the collection admin being performed.
   * @param adminOp - Collection admin operation
   * @param collectionName - Name of the collection
   * @return - instance of QueryRequest.
   */

#Code:
  public QueryRequest populateCollectionAdminParams(CollectionAction adminOp,
                                                    String collectionName) {
    return populateCollectionAdminParams(adminOp, collectionName, null);
  }

#No. 4811
#File: E:\bishe\1\AbstractSolrSentryTestBase.java
#Comment:
  /**
   * Function to validate the count and content of two SolrDocumentList's.
   * @param solrOriginalDocs - Instance of initial set of solr docs before processing
   * @param solrResponseDocs - Instance of response solr docs after processing
   */

#Code:
  protected void validateSolrDocCountAndContent(SolrDocumentList solrOriginalDocs,
                                                SolrDocumentList solrResponseDocs) {
    assertEquals("Expected number of Solr docs: " + solrOriginalDocs.size() + "; But found:" + solrResponseDocs.size(),
        solrOriginalDocs.size(), solrResponseDocs.size());
    for (SolrDocument solrDoc : solrOriginalDocs) {
      SolrInputDocument solrInputDoc = ClientUtils.toSolrInputDocument(solrDoc);
      validateSolrDocContent(solrInputDoc, solrResponseDocs);
    }
  }

#No. 4812
#File: E:\bishe\1\AbstractSolrSentryTestBase.java
#Comment:
  /**
   * Function to query the collection and fetch the Solr docs
   * @param collectionName -  Name of the collection
   * @param solrQueryStr - Query string to be searched in Solr
   * @param runAsAdmin - Boolean to specify whether to execute the Solr query as admin user
   * @return -  Instance of SolrDocumentList
   * @throws Exception
   */

#Code:
  protected SolrDocumentList getSolrDocs(String collectionName,
                                         String solrQueryStr,
                                         boolean runAsAdmin) throws Exception {
    String originalUser = getAuthenticatedUser();
    try {
      if (runAsAdmin == true) {
        // Authenticate as user "admin"
        setAuthenticationUser(ADMIN_USER);
      }

      CloudSolrServer cloudSolrServer = getCloudSolrServer(collectionName);
      assertNotNull("Solr query shouldn't be null.", solrQueryStr);
      SolrDocumentList solrDocs = null;
      try {
        SolrQuery query = new SolrQuery(solrQueryStr);
        QueryResponse response = cloudSolrServer.query(query);
        solrDocs = response.getResults();
        return solrDocs;
      } finally {
        cloudSolrServer.shutdown();
      }
    } finally {
      setAuthenticationUser(originalUser);
    }
  }

#No. 4813
#File: E:\bishe\1\AbstractSolrSentryTestBase.java
#Comment:
  /**
   * Function to validate the content of Solr response with that of input document.
   * @param solrInputDoc - Solr doc inserted into Solr
   * @param solrRespDocs - List of Solr doc obtained as response
   * (NOTE: This function ignores "_version_" field in validating Solr doc content)
   */

#Code:
  public void validateSolrDocContent(SolrInputDocument solrInputDoc,
                                     SolrDocumentList solrRespDocs) {
    for (SolrDocument solrRespDoc : solrRespDocs) {
      String expFieldValue = (String) solrInputDoc.getFieldValue("id");
      String resFieldValue = (String) solrRespDoc.getFieldValue("id");
      if (expFieldValue.equals(resFieldValue)) {
        int expectedRespFieldCount = solrRespDoc.size();
        if (solrRespDoc.containsKey("_version_")) {
          expectedRespFieldCount = expectedRespFieldCount - 1;
        }
        int expectedOrigFieldCount = solrInputDoc.size();
        if (solrInputDoc.containsKey("_version_")) {
          expectedOrigFieldCount = expectedOrigFieldCount - 1;
        }
        assertEquals("Expected " + expectedOrigFieldCount + " fields. But, found "
              + expectedRespFieldCount + " fields", expectedOrigFieldCount , expectedRespFieldCount);
        for (String field : solrInputDoc.getFieldNames()) {
          if (field.equals("_version_") == true) {
            continue;
          }

          expFieldValue = (String) solrInputDoc.getFieldValue(field);
          resFieldValue = (String) solrRespDoc.getFieldValue(field);
          assertEquals("Expected value for field: " + field + " is " + expFieldValue
              + "; But, found " + resFieldValue, expFieldValue, resFieldValue);
        }

        return;
      }
    }

    fail("Solr doc not found in Solr collection");
  }

#No. 4814
#File: E:\bishe\1\AbstractSolrSentryTestBase.java
#Comment:
  /**
   * Function to return the instance of CloudSolrServer for the collectionName specified
   * @param collectionName - Name of the collection
   * @return instance of CloudSolrServer
   * @throws MalformedURLException
   */

#Code:
  protected CloudSolrServer getCloudSolrServer(String collectionName) throws MalformedURLException {
    CloudSolrServer cloudSolrServer = new CloudSolrServer(miniSolrCloudCluster.getZkServer().getZkAddress(),
        RANDOM.nextBoolean());
    cloudSolrServer.setDefaultCollection(collectionName);
    cloudSolrServer.connect();
    return cloudSolrServer;
  }

#No. 4815
#File: E:\bishe\1\AbstractSolrSentryTestBase.java
#Comment:
  /**
   * Function to create a solr collection with the name passed as parameter
   * (Runs commands as ADMIN user)
   * @param collectionName - Name of the collection
   * @throws Exception
   */

#Code:
  protected void setupCollection(String collectionName) throws Exception {
    verifyCollectionAdminOpPass(ADMIN_USER,
                                CollectionAction.CREATE,
                                collectionName);
  }

#No. 4816
#File: E:\bishe\1\AbstractSolrSentryTestBase.java
#Comment:
  /**
   * Function to delete a solr collection with the name passed as parameter
   * (Runs commands as ADMIN user)
   * @param collectionName - Name of the collection
   * This function will simply ignore the errors raised in deleting the collections.
   * e.g: As part of the clean up job, the tests can issue a DELETE command on the collection which doesn't exist.
   */

#Code:
  protected void deleteCollection(String collectionName) {
    try {
      verifyCollectionAdminOpPass(ADMIN_USER,
                                  CollectionAction.DELETE,
                                  collectionName);
    } catch (Exception e) {
      LOG.warn("Ignoring errors raised while deleting the collection : " + e.toString());
    }
  }

#No. 4817
#File: E:\bishe\1\AbstractSolrSentryTestBase.java
#Comment:
  /**
   * Function to clean Solr collections
   * @param collectionName - Name of the collection
   * @throws Exception
   */

#Code:
  protected void cleanSolrCollection(String collectionName)
                                     throws Exception {
    verifyDeletedocsPass(ADMIN_USER, collectionName, true);
  }

#No. 4818
#File: E:\bishe\1\AbstractSolrSentryTestBase.java
#Comment:
  /**
   * Function to create a test Solrdoc with a random number as the ID
   * @throws Exception
   */

#Code:
  protected SolrInputDocument createSolrTestDoc() throws Exception {
    SolrInputDocument solrInputDoc = new SolrInputDocument();
    String solrDocId = String.valueOf(RANDOM.nextInt());
    solrInputDoc.addField("id", solrDocId);
    solrInputDoc.addField("name", "testdoc" + solrDocId);
    return solrInputDoc;
  }

#No. 4819
#File: E:\bishe\1\AbstractSolrSentryTestBase.java
#Comment:
  /**
   * Load Solr collection with the SolrDocument passed.
   * @param collectionName - Name of the Solr collection
   * @param solrInputDoc - Solr document to be uploaded
   * (If solrInputDoc is null, then a test Solr doc will be uploaded)
   * @throws Exception
   */

#Code:
  protected void uploadSolrDoc(String collectionName,
                               SolrInputDocument solrInputDoc) throws Exception {
    if (solrInputDoc == null) {
      solrInputDoc = createSolrTestDoc();
    }

    verifyUpdatePass(ADMIN_USER, collectionName, solrInputDoc);
  }

#No. 4820
#File: E:\bishe\1\AbstractSolrSentryTestBase.java
#Comment:
  /**
   * Make a raw http request (not specifying cluster node)
   */

#Code:
  protected String makeHttpRequest(CloudSolrServer server, String httpMethod,
      String path, byte [] content, String contentType) throws Exception {
    Set<String> liveNodes =
      server.getZkStateReader().getClusterState().getLiveNodes();
    assertTrue("Expected at least one live node", !liveNodes.isEmpty());
    String firstServer = liveNodes.toArray(new String[0])[0].replace("_solr", "/solr");
    return makeHttpRequest(server, firstServer, httpMethod, path, content, contentType);
  }

#No. 4821
#File: E:\bishe\1\AbstractSolutionView.java
#Comment:
    /*
     * Solution
     */

#Code:

    @Override
    public void buildSolution(ChooserPanel solutionPanel) {
    }

#No. 4822
#File: E:\bishe\1\AbstractSolutionView.java
#Comment:
    /*
     * Multiphase
     */

#Code:
    @Override
    public void buildMultiphase(MultiphaseBuilder builder) {
    }

#No. 4823
#File: E:\bishe\1\AbstractSolutionView.java
#Comment:
    /*
     * Thermal
     */

#Code:

    @Override
    public void buildThermal(PanelBuilder builder) {
    }

#No. 4824
#File: E:\bishe\1\AbstractSolutionView.java
#Comment:
    /*
     * Dynamic
     */

#Code:
    @Override
    public void buildDynamic(PanelBuilder builder) {
    }

#No. 4825
#File: E:\bishe\1\AbstractSolutionView.java
#Comment:
    /*
     * Adjoint
     */

#Code:
    @Override
    public void buildAdjoint(PanelBuilder builder) {
    }

#No. 4826
#File: E:\bishe\1\AbstractSolutionView.java
#Comment:
    /*
     * Scalar
     */

#Code:
    @Override
    public void buildScalar(SolutionModellingPanel solutionPanel) {
    }

#No. 4827
#File: E:\bishe\1\AbstractSoneCommand.java
#Comment:
	/**
	 * Creates a simple field set from the given collection of Sones.
	 *
	 * @param sones
	 *            The Sones to encode
	 * @param prefix
	 *            The prefix for the field names (may be empty but not
	 *            {@code null})
	 * @return The simple field set containing the given Sones
	 */

#Code:
	protected static SimpleFieldSet encodeSones(Collection<? extends Sone> sones, String prefix) {
		SimpleFieldSetBuilder soneBuilder = new SimpleFieldSetBuilder();

		int soneIndex = 0;
		soneBuilder.put(prefix + "Count", sones.size());
		for (Sone sone : sones) {
			String sonePrefix = prefix + soneIndex++ + ".";
			soneBuilder.put(sonePrefix + "ID", sone.getId());
			soneBuilder.put(sonePrefix + "Name", sone.getName());
			soneBuilder.put(sonePrefix + "NiceName", SoneAccessor.getNiceName(sone));
			soneBuilder.put(sonePrefix + "Time", sone.getTime());
		}

		return soneBuilder.get();
	}

#No. 4828
#File: E:\bishe\1\AbstractSoneCommand.java
#Comment:
	/**
	 * Creates a simple field set from the given post.
	 *
	 * @param post
	 *            The post to encode
	 * @param prefix
	 *            The prefix for the field names (may be empty but not
	 *            {@code null})
	 * @param includeReplies
	 *            {@code true} to include replies, {@code false} to not include
	 *            replies
	 * @return The simple field set containing the post
	 */

#Code:
	protected SimpleFieldSet encodePost(Post post, String prefix, boolean includeReplies) {
		SimpleFieldSetBuilder postBuilder = new SimpleFieldSetBuilder();

		postBuilder.put(prefix + "ID", post.getId());
		postBuilder.put(prefix + "Sone", post.getSone().getId());
		if (post.getRecipientId().isPresent()) {
			postBuilder.put(prefix + "Recipient", post.getRecipientId().get());
		}
		postBuilder.put(prefix + "Time", post.getTime());
		postBuilder.put(prefix + "Text", encodeString(post.getText()));
		postBuilder.put(encodeLikes(core.getLikes(post), prefix + "Likes."));

		if (includeReplies) {
			List<PostReply> replies = core.getReplies(post.getId());
			postBuilder.put(encodeReplies(replies, prefix));
		}

		return postBuilder.get();
	}

#No. 4829
#File: E:\bishe\1\AbstractSoneCommand.java
#Comment:
	/**
	 * Creates a simple field set from the given collection of posts.
	 *
	 * @param posts
	 *            The posts to encode
	 * @param prefix
	 *            The prefix for the field names (may be empty but not
	 *            {@code null})
	 * @param includeReplies
	 *            {@code true} to include the replies, {@code false} to not
	 *            include the replies
	 * @return The simple field set containing the posts
	 */

#Code:
	protected SimpleFieldSet encodePosts(Collection<? extends Post> posts, String prefix, boolean includeReplies) {
		SimpleFieldSetBuilder postBuilder = new SimpleFieldSetBuilder();

		int postIndex = 0;
		postBuilder.put(prefix + "Count", posts.size());
		for (Post post : posts) {
			String postPrefix = prefix + postIndex++;
			postBuilder.put(encodePost(post, postPrefix + ".", includeReplies));
			if (includeReplies) {
				postBuilder.put(encodeReplies(Collections2.filter(core.getReplies(post.getId()), Reply.FUTURE_REPLY_FILTER), postPrefix + "."));
			}
		}

		return postBuilder.get();
	}

#No. 4830
#File: E:\bishe\1\AbstractSoneCommand.java
#Comment:
	/**
	 * Creates a simple field set from the given collection of replies.
	 *
	 * @param replies
	 *            The replies to encode
	 * @param prefix
	 *            The prefix for the field names (may be empty, but not
	 *            {@code null})
	 * @return The simple field set containing the replies
	 */

#Code:
	protected static SimpleFieldSet encodeReplies(Collection<? extends PostReply> replies, String prefix) {
		SimpleFieldSetBuilder replyBuilder = new SimpleFieldSetBuilder();

		int replyIndex = 0;
		replyBuilder.put(prefix + "Replies.Count", replies.size());
		for (PostReply reply : replies) {
			String replyPrefix = prefix + "Replies." + replyIndex++ + ".";
			replyBuilder.put(replyPrefix + "ID", reply.getId());
			replyBuilder.put(replyPrefix + "Sone", reply.getSone().getId());
			replyBuilder.put(replyPrefix + "Time", reply.getTime());
			replyBuilder.put(replyPrefix + "Text", encodeString(reply.getText()));
		}

		return replyBuilder.get();
	}

#No. 4831
#File: E:\bishe\1\AbstractSoneCommand.java
#Comment:
	/**
	 * Creates a simple field set from the given collection of Sones that like
	 * an element.
	 *
	 * @param likes
	 *            The liking Sones
	 * @param prefix
	 *            The prefix for the field names (may be empty but not
	 *            {@code null})
	 * @return The simple field set containing the likes
	 */

#Code:
	protected static SimpleFieldSet encodeLikes(Collection<? extends Sone> likes, String prefix) {
		SimpleFieldSetBuilder likesBuilder = new SimpleFieldSetBuilder();

		int likeIndex = 0;
		likesBuilder.put(prefix + "Count", likes.size());
		for (Sone sone : likes) {
			String sonePrefix = prefix + likeIndex++ + ".";
			likesBuilder.put(sonePrefix + "ID", sone.getId());
		}

		return likesBuilder.get();
	}

#No. 4832
#File: E:\bishe\1\AbstractSoneCommand.java
#Comment:
	/**
	 * {@inheritDoc}
	 */

#Code:
	@Override
	public String toString() {
		return getClass().getName() + "[writeAccess=" + writeAccess + "]";
	}

#No. 4833
#File: E:\bishe\1\AbstractSort.java
#Comment:
	/**
	 * @param array an array of comparable keys.
	 * @param i the index of the first key.
	 * @param j the index of the second key.
	 * @return {@code array[i].compareTo(array[j])}
	 */

#Code:
	protected int compareTo(T[] array, int i, int j)
	{
		comparisons++;
		return comparator.compare(array[i], array[j]);
	}

#No. 4834
#File: E:\bishe\1\AbstractSort.java
#Comment:
	/**
	 * {@code array[index] = value}
	 * @param array an array of comparable keys.
	 * @param index the index of the array to assign.
	 * @param value the value to be assigned.
	 */

#Code:
	protected void assign(T[] array, int index, T value)
	{
		assignments++;
		array[index] = value;
	}

#No. 4835
#File: E:\bishe\1\AbstractSort.java
#Comment:
	/**
	 * Swaps {@code array[i]} and {@code array[j]}. 
	 * @param array an array of comparable keys.
	 * @param i the index of the first key.
	 * @param j the index of the second key.
	 */

#Code:
	protected void swap(T[] array, int i, int j)
	{
		T t = array[i];
		assign(array, i, array[j]);
		assign(array, j, t);
	}

#No. 4836
#File: E:\bishe\1\AbstractSort.java
#Comment:
	/**
	 * Sorts the array in ascending order.
	 * @param array an array of comparable keys.
	 */

#Code:
	public void sort(T[] array)
	{
		sort(array, 0, array.length);
	}

#No. 4837
#File: E:\bishe\1\AbstractSort.java
#Comment:
	/**
	 * Sorts the array[beginIndex:endIndex] in ascending order.
	 * @param array an array of comparable keys.
	 * @param beginIndex the index of the first key to be sorted (inclusive).
	 * @param endIndex the index of the last key to be sorted (exclusive).
	 */

#Code:
	abstract public void sort(T[] array, int beginIndex, int endIndex);
}
}

#No. 4838
#File: E:\bishe\1\AbstractSortableTable.java
#Comment:
    /**
     * Get the currently selected row.
     * 
     * @return Currently selected row.
     */

#Code:
    protected TableItem[] getTableSelection() {
        return table.getSelection();
    }

#No. 4839
#File: E:\bishe\1\AbstractSoundDriver.java
#Comment:
    /**
     * Initialize 
     * 
     * @return
     */

#Code:
    protected  final void initMixBuffer() {
        for (int i = 0; i < MIXBUFFERSIZE; i += 4) {
            mixbuffer[i] =
                (byte) (((int) (0x7FFF * Math.sin(1.5 * Math.PI * (double) i
                        / MIXBUFFERSIZE)) & 0xff00) >>> 8);
            mixbuffer[i + 1] =
                (byte) ((int) (0x7FFF * Math.sin(1.5 * Math.PI * (double) i
                        / MIXBUFFERSIZE)) & 0xff);
            mixbuffer[i + 2] =
                (byte) (((int) (0x7FFF * Math.sin(1.5 * Math.PI * (double) i
                        / MIXBUFFERSIZE)) & 0xff00) >>> 8);
            mixbuffer[i + 3] =
                (byte) ((int) (0x7FFF * Math.sin(1.5 * Math.PI * (double) i
                        / MIXBUFFERSIZE)) & 0xff);

        }
    }

#No. 4840
#File: E:\bishe\1\AbstractSoundDriver.java
#Comment:
    /**
     * Loads samples in 8-bit format, forcibly converts them to the common sampling rate.
     * Used by.
     */

#Code:

    protected final void initSound8() {
        int i;

        // Initialize external data (all sounds) at start, keep static.

        for (i = 1; i < NUMSFX; i++) {
            // Alias? Example is the chaingun sound linked to pistol.
            if (sounds.S_sfx[i].link == null) {
                // Load data from WAD file.
                S_sfx[i].data = getsfx(S_sfx[i].name, lengths, i);
            } else {
                // Previously loaded already?
                S_sfx[i].data = S_sfx[i].link.data;
            }
        }
    }

#No. 4841
#File: E:\bishe\1\AbstractSoundDriver.java
#Comment:
    /**
     * This is only the common part of InitSound that caches sound data in
     * 16-bit, stereo format (used by Audiolines). INTO sfxenum_t.
     * 
     * Only used by the Clip and David "drivers".
     * 
     */

#Code:

    protected final void initSound16() {
        int i;

        // Initialize external data (all sounds) at start, keep static.

        for (i = 1; i < NUMSFX; i++) {
            // Alias? Example is the chaingun sound linked to pistol.
            if (sounds.S_sfx[i].link == null) {
                // Load data from WAD file.
                S_sfx[i].data = getsfx16(S_sfx[i].name, lengths, i);
            } else {
                // Previously loaded already?
                S_sfx[i].data = S_sfx[i].link.data;
            }
        }
    }

#No. 4842
#File: E:\bishe\1\AbstractSourceCodeAwareNodeProcessingTest.java
#Comment:
    /**
     * Default systemId for the empty namespace.
     */

#Code:
    public static final String DEFAULT_EMPTY_NAMESPACE_SYSTEM_ID = "emptyNamespaceSystemId.xsd";

    // Shared state
    protected BufferingLog log;
    protected SearchableDocumentation docs;
    protected SortedMap<String, String> namespace2GeneratedSchemaMap;
    protected SortedMap<String, Document> namespace2DocumentMap;
    protected Map<String, String> namespace2SystemIdMap;
    protected List<String> xsdGenerationWarnings;
    protected final File basedir;
    protected final File testJavaDir;
    protected JAXBContext jaxbContext;
    protected SortedMap<String, Throwable> xsdGenerationLog;

    // Internal state
    private List<Class<?>> jaxbClasses;

    public AbstractSourceCodeAwareNodeProcessingTest() {

        // Setup the basic directories.
        basedir = getBasedir();
        testJavaDir = new File(basedir, "src/test/java");
        Assert.assertTrue(testJavaDir.exists() && testJavaDir.isDirectory());
    }

#No. 4843
#File: E:\bishe\1\AbstractSourceCodeAwareNodeProcessingTest.java
#Comment:
    /**
     * @return The basedir directory, corresponding to the root of this project.
     */

#Code:
    protected File getBasedir() {

        // Use the system property if available.
        String basedirPath = System.getProperty("basedir");
        if (basedirPath == null) {
            basedirPath = new File("").getAbsolutePath();
        }

        final File toReturn = new File(basedirPath);
        Assert.assertNotNull("Could not find 'basedir'. Please set the system property 'basedir'.", toReturn);
        Assert.assertTrue("'basedir' must be an existing directory. ", toReturn.exists() && toReturn.isDirectory());

        // All done.
        return toReturn;
    }

#No. 4844
#File: E:\bishe\1\AbstractSourceCodeAwareNodeProcessingTest.java
#Comment:
    /**
     * Creates a DOM Document from the supplied XML.
     *
     * @param xmlContent The non-empty XML which should be converted into a Document.
     * @return The Document created from the supplied XML Content.
     */

#Code:
    protected final Document createDocument(final String xmlContent) {

        // Check sanity
        Validate.notEmpty(xmlContent, "xmlContent");

        // Build a DOM model of the provided xmlFileStream.
        final DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        factory.setNamespaceAware(true);

        try {
            return factory.newDocumentBuilder().parse(new InputSource(new StringReader(xmlContent)));
        } catch (Exception e) {
            throw new IllegalArgumentException("Could not create DOM Document", e);
        }
    }

#No. 4845
#File: E:\bishe\1\AbstractSourceCodeAwareNodeProcessingTest.java
#Comment:
    /**
     * Drives the supplied visitor to process the provided Node and all its children, should the recurseToChildren flag
     * be set to <code>true</code>. All attributes of the current node are processed before recursing to children (i.e.
     * breadth first recursion).
     *
     * @param node              The Node to process.
     * @param recurseToChildren if <code>true</code>, processes all children of the supplied node recursively.
     * @param visitor           The NodeProcessor instance which should process the nodes.
     */

#Code:
    public final void process(final Node node, final boolean recurseToChildren, final NodeProcessor visitor) {

        // Process the current Node, if the NodeProcessor accepts it.
        if (visitor.accept(node)) {
            onAcceptedNode(node);
            visitor.process(node);
        }

        NamedNodeMap attributes = node.getAttributes();
        for (int i = 0; i < attributes.getLength(); i++) {
            Node attribute = attributes.item(i);

            // Process the current attribute, if the NodeProcessor accepts it.
            if (visitor.accept(attribute)) {
                onAcceptedAttribute(attribute);
                visitor.process(attribute);
            }
        }

        if (recurseToChildren) {
            NodeList children = node.getChildNodes();
            for (int i = 0; i < children.getLength(); i++) {
                Node child = children.item(i);

                // Recurse to Element children.
                if (child.getNodeType() == Node.ELEMENT_NODE) {
                    process(child, true, visitor);
                }
            }
        }
    }

#No. 4846
#File: E:\bishe\1\AbstractSourceCodeAwareNodeProcessingTest.java
#Comment:
    /**
     * Event callback when a nodeProcessor has accepted a Node.
     *
     * @param aNode the accepted Node
     */

#Code:
    protected void onAcceptedNode(final Node aNode) {
        // name="firstName"
        final String nodeName = aNode.getAttributes().getNamedItem("name").getNodeValue();
        log.info("Accepted node [" + aNode.getNodeName() + "] " + nodeName);
    }

#No. 4847
#File: E:\bishe\1\AbstractSourceCodeAwareNodeProcessingTest.java
#Comment:
    /**
     * Event callback when a nodeProcessor has accepted an Attribute.
     *
     * @param anAttribute the accepted attribute.
     */

#Code:
    protected void onAcceptedAttribute(final Node anAttribute) {
        log.info("Accepted attribute [" + anAttribute.getNodeName() + "]");
    }

#No. 4848
#File: E:\bishe\1\AbstractSourceCodeAwareNodeProcessingTest.java
#Comment:
    /**
     * Utility method to read all (string formatted) data from the given classpath-relative
     * file and return the data as a string.
     *
     * @param path The classpath-relative file path.
     * @return The content of the supplied file.
     */

#Code:
    protected static String readFully(final String path) {

        final StringBuilder toReturn = new StringBuilder(50);

        try {

            // Will produce a NPE if the path was not directed to a file.
            final InputStream resource = AbstractSourceCodeAwareNodeProcessingTest
                    .class
                    .getClassLoader()
                    .getResourceAsStream(path);
            final BufferedReader tmp = new BufferedReader(new InputStreamReader(resource));

            for (String line = tmp.readLine(); line != null; line = tmp.readLine()) {
                toReturn.append(line).append(AbstractJaxbMojo.NEWLINE);
            }
        } catch (final Exception e) {
            throw new IllegalArgumentException("Resource [" + path + "] not readable.");
        }

        // All done.
        return toReturn.toString();
    }

#No. 4849
#File: E:\bishe\1\AbstractSourceCodeAwareNodeProcessingTest.java
#Comment:
    /**
     * Compares XML documents provided by the two Readers.
     *
     * @param expected The expected document data.
     * @param actual   The actual document data.
     * @return A DetailedDiff object, describing all differences in documents supplied.
     * @throws org.xml.sax.SAXException If a SAXException was raised during parsing of the two Documents.
     * @throws IOException              If an I/O-related exception was raised while acquiring the data from the Readers.
     */

#Code:
    protected static Diff compareXmlIgnoringWhitespace(final String expected, final String actual) throws SAXException,
            IOException {

        // Check sanity
        org.apache.commons.lang3.Validate.notNull(expected, "Cannot handle null expected argument.");
        org.apache.commons.lang3.Validate.notNull(actual, "Cannot handle null actual argument.");

        // Ignore whitespace - and also normalize the Documents.
        XMLUnit.setNormalize(true);
        XMLUnit.setIgnoreWhitespace(true);
        XMLUnit.setNormalize(true);

        // Compare and return
        return XMLUnit.compareXML(expected, actual);
    }

#No. 4850
#File: E:\bishe\1\AbstractSourceCodeAwareNodeProcessingTest.java
#Comment:
    /**
     * Prints the content of the supplied DOM Document as a string.
     *
     * @param doc A non-null DOM Document.
     * @return A String holding the pretty-printed version of the supplied doc.
     */

#Code:
    public static String printDocument(final Document doc) {

        try {
            // Create the Unity-Transformer
            final TransformerFactory tf = TransformerFactory.newInstance();
            final Transformer transformer = tf.newTransformer();

            // Make it pretty print stuff.
            transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, "no");
            transformer.setOutputProperty(OutputKeys.METHOD, "xml");
            transformer.setOutputProperty(OutputKeys.INDENT, "yes");
            transformer.setOutputProperty(OutputKeys.ENCODING, "UTF-8");
            transformer.setOutputProperty("{http://xml.apache.org/xslt}indent-amount", "4");

            // Harvest the result, and return.
            final StringWriter out = new StringWriter();
            transformer.transform(new DOMSource(doc), new StreamResult(out));
            return out.toString();
        } catch (Exception e) {
            throw new IllegalArgumentException("Could not print document", e);
        }
    }

#No. 4851
#File: E:\bishe\1\AbstractSourceLayer.java
#Comment:
  /**
   * Redraws the sources on this layer, after first refreshing them based on
   * the current state of the
   * {@link com.google.android.stardroid.control.AstronomerModel}.
   */

#Code:
  protected void refreshSources() {
    refreshSources(EnumSet.noneOf(UpdateType.class));
  }

#No. 4852
#File: E:\bishe\1\AbstractSourceLayer.java
#Comment:
  /**
   * Redraws the sources on this layer, after first refreshing them based on
   * the current state of the
   * {@link com.google.android.stardroid.control.AstronomerModel}.
   */

#Code:
  protected synchronized void refreshSources(EnumSet<UpdateType> updateTypes) {
    for (AstronomicalSource astroSource : astroSources) {
      updateTypes.addAll(astroSource.update());
    }

    if (!updateTypes.isEmpty()) {
      redraw(updateTypes);
    }
  }

#No. 4853
#File: E:\bishe\1\AbstractSourceLayer.java
#Comment:
  /**
   * Forcefully resets and redraws all sources on this layer everything on
   * this layer.
   */

#Code:
  @Override
  protected void redraw() {
    refreshSources(EnumSet.of(UpdateType.Reset));
  }

#No. 4854
#File: E:\bishe\1\AbstractSourceQueryCommand.java
#Comment:
    /**
     * Returns a list of projects for the given arguments.
     * 
     * @param projects the list to which the projects are added
     * @return a pair of Mode (single job, jobs from view or all) and view name -
     * where view name will be null if mode != VIEW
     */

#Code:
    void getProjects(JBotSender sender, String[] args, Collection<AbstractProject<?, ?>> projects) throws CommandException {
        projects.addAll(getJobProvider().getAllJobs());
        return;
    }

#No. 4855
#File: E:\bishe\1\AbstractSourceTest.java
#Comment:
    /*protected Context createContext(String resource) throws Exception {
        InputStream in = getClass().getResourceAsStream(resource);
        logger.info("creating context");
        Settings settings = ImmutableSettings.settingsBuilder()
                .loadFromStream("test", in)
                .build().getAsSettings("jdbc");
        Context context = newContext();
        context.setSettings(settings);
        return context;
    }*/

#Code:

    protected void createRandomProducts(String sql, int size)
            throws SQLException {
        Connection connection = source.getConnectionForWriting();
        for (int i = 0; i < size; i++) {
            long amount = Math.round(Math.random() * 1000);
            double price = (Math.random() * 10000) / 100.00;
            add(connection, sql, UUID.randomUUID().toString().substring(0, 32), amount, price);
        }
        if (!connection.getAutoCommit()) {
            connection.commit();
        }
        source.closeWriting();
    }

#No. 4856
#File: E:\bishe\1\AbstractSpaceFactoryBean.java
#Comment:
    /**
     * Returns <code>true</code> since this factory is a singleton.
     */

#Code:
    public boolean isSingleton() {
        return true;
    }

#No. 4857
#File: E:\bishe\1\AbstractSpaceFactoryBean.java
#Comment:
    /**
     * Should this space be checked to see if it is alive or not.
     */

#Code:
    public boolean isMemberAliveEnabled() {
        return memberAliveIndicator.isMemberAliveEnabled();
    }

#No. 4858
#File: E:\bishe\1\AbstractSpaceFactoryBean.java
#Comment:
    /**
     * Returns if this space is alive or not by pinging the Space and if it is considered healthy.
     */

#Code:
    public boolean isAlive() throws Exception {
        return memberAliveIndicator.isAlive();
    }

#No. 4859
#File: E:\bishe\1\AbstractSpaceFactoryBean.java
#Comment:
    /**
     * Returns if the space should register for primary backup notifications. If {@link
     * #setRegisterForSpaceModeNotifications(boolean)} was set, will return this flag. If not, will
     * register to primary backup notification if the space was found using an embedded protocol,
     * and will not register for notification if the space was found using <code>rmi</code> or
     * <code>jini</code> protocols.
     */

#Code:
    protected boolean isRegisterForSpaceModeNotifications() {
        if (registerForSpaceMode != null) {
            return registerForSpaceMode;
        }
        return !SpaceUtils.isRemoteProtocol(space);
    }

#No. 4860
#File: E:\bishe\1\AbstractSpaceFactoryBean.java
#Comment:
    /**
     * Sends {@link BeforeSpaceModeChangeEvent} events with space mode {@link SpaceMode#BACKUP} to
     * all beans in the application context that implement the {@link SpaceBeforeBackupListener}
     * interface.
     */

#Code:
    protected void fireSpaceBeforeBackupEvent() {
        if (applicationContext != null) {
            Map<String, SpaceBeforeBackupListener> beans = applicationContext.getBeansOfType(SpaceBeforeBackupListener.class);
            for (SpaceBeforeBackupListener listener : beans.values()) {
                listener.onBeforeBackup(new BeforeSpaceModeChangeEvent(space, SpaceMode.BACKUP));
            }
        }
    }

#No. 4861
#File: E:\bishe\1\AbstractSpaceFactoryBean.java
#Comment:
    /**
     * Sends {@link AfterSpaceModeChangeEvent} events with space mode {@link SpaceMode#BACKUP} to
     * all beans in the application context that implement the {@link SpaceAfterBackupListener}
     * interface.
     */

#Code:
    protected void fireSpaceAfterBackupEvent() {
        if (applicationContext != null) {
            Map<String, SpaceAfterBackupListener> beans = applicationContext.getBeansOfType(SpaceAfterBackupListener.class);
            for (SpaceAfterBackupListener listener : beans.values()) {
                listener.onAfterBackup(new AfterSpaceModeChangeEvent(space, SpaceMode.BACKUP));
            }
        }
    }

#No. 4862
#File: E:\bishe\1\AbstractSpaceFactoryBean.java
#Comment:
    /**
     * Sends {@link BeforeSpaceModeChangeEvent} events with space mode {@link SpaceMode#PRIMARY} to
     * all beans in the application context that implement the {@link SpaceBeforePrimaryListener}
     * interface.
     */

#Code:
    protected void fireSpaceBeforePrimaryEvent() {
        if (applicationContext != null) {
            Map<String, SpaceBeforePrimaryListener> beans = applicationContext.getBeansOfType(SpaceBeforePrimaryListener.class);
            for (SpaceBeforePrimaryListener listener : beans.values()) {
                listener.onBeforePrimary(new BeforeSpaceModeChangeEvent(space, SpaceMode.PRIMARY));
            }
        }
    }

#No. 4863
#File: E:\bishe\1\AbstractSpaceFactoryBean.java
#Comment:
    /**
     * Sends {@link AfterSpaceModeChangeEvent} events with space mode {@link SpaceMode#PRIMARY} to
     * all beans in the application context that implement the {@link SpaceAfterPrimaryListener}
     * interface.
     */

#Code:
    protected void fireSpaceAfterPrimaryEvent() {
        if (applicationContext != null) {
            Map<String, SpaceAfterPrimaryListener> beans = applicationContext.getBeansOfType(SpaceAfterPrimaryListener.class);
            for (SpaceAfterPrimaryListener listener : beans.values()) {
                listener.onAfterPrimary(new AfterSpaceModeChangeEvent(space, SpaceMode.PRIMARY));
            }
        }
    }

#No. 4864
#File: E:\bishe\1\AbstractSpaghettiTask.java
#Comment:
	/**
	 * Returns names of directly dependent modules. This is here so that Gradle will detect
	 * a change in inputs even if the only change is that a previously directly dependent
	 * module becomes transitively dependent, or vice versa.
	 *
	 * @return names of directly dependent modules.
	 * @throws IOException
	 */

#Code:
	@Input
	@SuppressWarnings("UnusedDeclaration")
	protected SortedSet<String> getDirectDependentBundleNames() throws IOException {
		SortedSet<String> directBundleNames = Sets.newTreeSet();
		for (ModuleBundle bundle : lookupBundles().getDirectBundles()) {
			directBundleNames.add(bundle.getName());
		}
		return directBundleNames;
	}

#No. 4865
#File: E:\bishe\1\AbstractSparqlParserTest.java
#Comment:
	// /**
	// * Parse the SQL string and then deparse it back into SQL to provide the
	// SQL
	// * string native to the parser. This is used in support of nativeSQL() in
	// * the Driver.
	// *
	// * @param sqlQuery
	// * the original SQL string
	// * @return the native SQL string
	// * @throws SQLException
	// * on error.
	// */

#Code:
	// String nativeSQL(String sqlQuery) throws SQLException;

	protected Query getQuery(final String sql) throws SQLDataException,
	JSQLParserException {
		final Statement stmt = parserManager.parse(new StringReader(sql));
		final SparqlVisitor sparqlVisitor = new SparqlVisitor(catalogs, parser,
				catalog, schema);
		stmt.accept(sparqlVisitor);
		return sparqlVisitor.getBuilder().build();
	}

#No. 4866
#File: E:\bishe\1\AbstractSpecificTypeConverter.java
#Comment:
/**
* Created by Denis on 30-Apr-15
* <File Description>
*/

#Code:
public abstract class AbstractSpecificTypeConverter<TSource, TDestination>
        extends AbstractTypeConverter<TSource, TDestination>
        implements FieldTypeMappingInstaller {
    protected final Class<TSource> sourceType;

    protected AbstractSpecificTypeConverter(Class<TSource> sourceType, Class<TDestination> destinationType) {
        super(destinationType);
        this.sourceType = sourceType;
    }

    @Override
    public void install(FieldTypeMappingRegistrar registrar) {
        registrar.registerConverter(sourceType, this);
    }
}

#No. 4867
#File: E:\bishe\1\AbstractSpectrogramTest.java
#Comment:
    /**
     * Test of isValidBin method, of class AbstractSpectrogram.
     */

#Code:
    @Test
    public void testIsValidBin() {
        System.out.println("isValidBin");
        int bin = 0;
        AbstractSpectrogram instance = new AbstractSpectrogramImpl(2048, 2048, 44100);
        boolean expResult = true;
        boolean result = instance.isValidBin(bin);
        assertEquals(expResult, result);
        bin = 2048;
        expResult = false;
        result = instance.isValidBin(bin);
        assertEquals(expResult, result);
    }

#No. 4868
#File: E:\bishe\1\AbstractSpectrogramTest.java
#Comment:
    /**
     * Test of getFrequency method, of class AbstractSpectrogram.
     */

#Code:
    @Test
    public void testGetFrequency() {
        System.out.println("getFrequency");
        
        AbstractSpectrogram instance = new AbstractSpectrogramImpl(2048, 2048, 44100);
        double totalTime = 2048 / 44100.0;
        double binWidth = 1 / totalTime;

        double expResult, result;
        for (int bin = 0; bin < 2048; bin++) {
            expResult = bin * binWidth;
            result = instance.getFrequency(bin);
            assertEquals(expResult, result, 0.0000001);
        }
    }

#No. 4869
#File: E:\bishe\1\AbstractSpectrogramTest.java
#Comment:
    /**
     * Test of getBin method, of class AbstractSpectrogram.
     */

#Code:
    @Test
    public void testGetBin() {
        System.out.println("getBin");
        double frequency = 0.0;
        AbstractSpectrogram instance = new AbstractSpectrogramImpl(2048, 2048, 44100);
        double totalTime = 2048 / 44100.0;
        double binWidth = 1 / totalTime;

        double result, expResult;
        for (int bin = 0; bin < 2048; bin++) {
            expResult = bin;
            frequency = bin * binWidth;
            result = instance.getBin(frequency);
            assertEquals(expResult, result, 0.0000001);
        }
    }

#No. 4870
#File: E:\bishe\1\AbstractSpectrogramTest.java
#Comment:
    /**
     * Test of getN method, of class AbstractSpectrogram.
     */

#Code:
    @Test
    public void testGetN() {
        System.out.println("getN");
        AbstractSpectrogram instance = new AbstractSpectrogramImpl(1024, 2048, 44100);
        int expResult = 1024;
        int result = instance.getN();
        assertEquals(expResult, result);
    }

#No. 4871
#File: E:\bishe\1\AbstractSpectrogramTest.java
#Comment:
    /**
     * Test of getSampleRate method, of class AbstractSpectrogram.
     */

#Code:
    @Test
    public void testGetSampleRate() {
        System.out.println("getSampleRate");
        AbstractSpectrogram instance = new AbstractSpectrogramImpl(2048, 2048, 44100);
        double expResult = 44100;
        double result = instance.getSampleRate();
        assertEquals(expResult, result, 0.0);
    }

#No. 4872
#File: E:\bishe\1\AbstractSpectrogramTest.java
#Comment:
    /**
     * Test of size method, of class AbstractSpectrogram.
     */

#Code:
    @Test
    public void testSize() {
        System.out.println("size");
        AbstractSpectrogram instance = new AbstractSpectrogramImpl(1024, 2048, 44100);
        int expResult = 2048;
        int result = instance.size();
        assertEquals(expResult, result);
    }

#No. 4873
#File: E:\bishe\1\AbstractSplitMode.java
#Comment:
	/**
	 * 根据设置的聚合模式，判断是否启动该
	 * 
	 * 
	 * @return
	 */

#Code:
	protected boolean isStartAct(AbstractFlowEvent event, ActivityElement activityXml) {
		String joinMode = activityXml.getJoinMode();
		boolean isStartAct = false;
		
		if(Constants.JOIN_SINGLE.equalsIgnoreCase(joinMode)) {
			//表示当该活动的若干前驱活动中只要有一个满足条件的活动完成，该活动即可被触发。
			isStartAct = true;
		} else if(Constants.JOIN_MULTI.equalsIgnoreCase(joinMode)) {
			// 表示该活动必须等到它的所有满足条件的前驱活动全部完成才可以触发。满足条件的前驱活动包括：
			// (1) 它与该活动的连线是“默认值”。
			// (2) 它与该活动连线上条件为“true”。
			List<TransitionElement> transitions = activityXml.getBeforeTrans();
			int finishCount = event.getActInstRep().findFromTransCtrls(event.getProcessInstance().getProcessInstId(), activityXml.getId());
			int count = findTransitonsForJexl(event, transitions);
			
			if(count == (++finishCount)) {
				isStartAct = true;
			}
			
		} else if (Constants.JOIN_ALL.equalsIgnoreCase(joinMode)) {
			//表示该活动必须等到它的所有前驱活动全部完成才可以触发。
			int count = event.getActInstRep().findFromTransCtrls(event.getProcessInstance().getProcessInstId(), activityXml.getId());
			List<TransitionElement> transitions = activityXml.getBeforeTrans();;
			
			if(++count == transitions.size()) {
				isStartAct = true;
			}
		}
		
		triggerActivityBeforeStartEvent(isStartAct, event, activityXml);
		return isStartAct;
	}

#No. 4874
#File: E:\bishe\1\AbstractSplitMode.java
#Comment:
	/**
	 * 启动<b>环节启动前<b>事件
	 * 
	 * @param isStartAct
	 * @param event
	 * @param activityXml
	 */

#Code:
	private void triggerActivityBeforeStartEvent(boolean isStartAct, AbstractFlowEvent event, ActivityElement activityXml) {
		if(isStartAct && activityXml.getEvents() != null) {
			ActivityInst activityInst = new ActivityInst();
			activityInst.setActivityInstId(event.getProcessInstance().getProcessInstId());
			TriggerActivityEventUtil.beforeStart(event.getProcessEngine(), activityXml, activityInst, activityXml.getEvents());
		}
	}

#No. 4875
#File: E:\bishe\1\AbstractSplitMode.java
#Comment:
	/**
	 * 
	 * @param engineManager
	 * @param transitions
	 * @return
	 */

#Code:
	private int findTransitonsForJexl(AbstractFlowEvent event, List<TransitionElement> transitions) {
		int count = 0;
		
		RelaDataManager relaDataManager = RelaDataManagerBuilder.buildRelaDataManager();
		long processInstId = event.getProcessInstance().getProcessInstId();
		String activityDefId = event.getPreActivityXml().getId();
		Map<String , Object> conditions = relaDataManager.getExpressConditions(processInstId, activityDefId);
		
		for(TransitionElement transitionXml : transitions) { //循所有的分支，寻找满足条件的分支
			boolean isDefault = transitionXml.getIsDefault();
			if(isDefault) {
				count++;
				continue;
			}
			
			IExpressionHandler expressionHandler = 
				ExpressionHandlerFactory.buildExpressionHandler(transitionXml.getIsSimpleExpression());
			
			if(expressionHandler.execute(transitionXml, conditions))
				count++;
		}
		return count;
	}

#No. 4876
#File: E:\bishe\1\AbstractSpringBeanDefinitionParser.java
#Comment:
    /**
     * <p>addPropertyValueFromElement.</p>
     *
     * @param id a {@link java.lang.String} object.
     * @param element a {@link org.w3c.dom.Element} object.
     * @param bean a {@link org.springframework.beans.factory.support.BeanDefinitionBuilder} object.
     */

#Code:
    protected void addPropertyValueFromElement(String id, Element element, BeanDefinitionBuilder bean) {
        String beanElement = element.getAttribute(id);
        bean.addPropertyValue(id, beanElement);
    }

#No. 4877
#File: E:\bishe\1\AbstractSpringBeanDefinitionParser.java
#Comment:
    /**
     * <p>addPropertyValueFromElement.</p>
     *
     * @param id a {@link java.lang.String} object.
     * @param injectionId a {@link java.lang.String} object.
     * @param element a {@link org.w3c.dom.Element} object.
     * @param bean a {@link org.springframework.beans.factory.support.BeanDefinitionBuilder} object.
     */

#Code:
    protected void addPropertyValueFromElement(String id, String injectionId, Element element,
            BeanDefinitionBuilder bean) {
        String beanElement = element.getAttribute(id);
        bean.addPropertyValue(injectionId, beanElement);
    }

#No. 4878
#File: E:\bishe\1\AbstractSpringBeanDefinitionParser.java
#Comment:
    /**
     * <p>addPropertyReferenceFromElement.</p>
     *
     * @param id a {@link java.lang.String} object.
     * @param element a {@link org.w3c.dom.Element} object.
     * @param bean a {@link org.springframework.beans.factory.support.BeanDefinitionBuilder} object.
     */

#Code:
    protected void addPropertyReferenceFromElement(String id, Element element, BeanDefinitionBuilder bean) {
        String beanElement = element.getAttribute(id);
        bean.addPropertyReference(id, beanElement);
    }

#No. 4879
#File: E:\bishe\1\AbstractSpringEnricherArchiveAppender.java
#Comment:
    /**
     * <p>Appends the properties to the auxiliary archive.</p>
     *
     * @param archive the auxiliary archive
     */

#Code:
    protected void appendProperties(JavaArchive archive) {

        archive.addAsResource(new StringAsset(SpringIntegrationConfigurationExporter.toString(configuration.get())),
                SpringIntegrationConfigurationExporter.SPRING_REMOTE_PROPERTIES);
    }

#No. 4880
#File: E:\bishe\1\AbstractSpringEnricherArchiveAppender.java
#Comment:
    /**
     * <p>Creates the auxiliary archive.</p>
     *
     * @return the created auxiliary archive
     */

#Code:
    protected JavaArchive createArchive() {

        return ShrinkWrap.create(JavaArchive.class);
    }

#No. 4881
#File: E:\bishe\1\AbstractSpringPropertyTest.java
#Comment:
/**
 * The base class for testing to use {@code <springProperty>} tag.
 */

#Code:
@RunWith(SpringRunner.class)
@SpringBootTest(
        value = {
                "logback.access.config=classpath:logback-access.propertied.xml",
                "logback.access.test.console.pattern.prefix=>>>",
                "logback.access.test.console.pattern.suffix=<<<",
        },

#No. 4882
#File: E:\bishe\1\AbstractSpringPropertyTest.java
#Comment:
    /**
     * The output capture rule.
     */

#Code:
    private final OutputCapture outputCapture = new OutputCapture();

    /**
     * The REST template.
     */
    @Autowired
    protected TestRestTemplate rest;

    /**
     * Creates a test rule.
     *
     * @return a test rule.
     */
    @Rule
    public TestRule rule() {
        return RuleChain
                .outerRule(new LogbackAccessEventQueuingAppenderRule())
                .around(new LogbackAccessEventQueuingListenerRule())
                .around(outputCapture);
    }

#No. 4883
#File: E:\bishe\1\AbstractSpringPropertyTest.java
#Comment:
    /**
     * Tests a Logback-access event.
     */

#Code:
    @Test
    public void logbackAccessEvent() {

        ResponseEntity<String> response = rest.getForEntity("/test/text", String.class);
        LogbackAccessEventQueuingListener.appendedEventQueue.pop();

        assertThat(response).hasStatusCode(HttpStatus.OK);
        assertThat(outputCapture.toString())
                .containsSequence(">>>", "127.0.0.1", "GET", "/test/text", "HTTP/1.1", "200", "<<<");

    }

#No. 4884
#File: E:\bishe\1\AbstractSpringSocialSecurityConnectionSignUp.java
#Comment:
/**
 * An abstract command that signs up a new user in the event no local user id could be
 * mapped from a Connection.
 * 
 * In SpringSocialSecurity, by default there is no need for a local user account
 * to be created outside of spring social - by default just checks and returns
 * user id associated with third party connection.
 * 
 * Returns null if user id already exists locally for a different connection
 * 
 * Default implementation is SpringSocialSecurityConnectionSignUp - alternative implementations can
 * be provided and registered should the implicit SignUp require custom behaviour.
 * 
 * @author Michael Lavelle
 */

#Code:
public abstract class AbstractSpringSocialSecurityConnectionSignUp<
P extends SpringSocialProfile,S extends SignUpService<P>,F extends AbstractSpringSocialProfileFactory<P>> implements ConnectionSignUp {

	@Autowired
	private S signUpService;
	
	@Autowired
	private F socialProfileFactory;

	public AbstractSpringSocialSecurityConnectionSignUp() {
	}

	public String execute(Connection<?> connection) {
		try
		{
			P springSocialSecurityProfile = 
				socialProfileFactory.create(connection);
			if (springSocialSecurityProfile.getUserName() != null)
			{
				signUpService
				.signUpUser(springSocialSecurityProfile);
			}
			return springSocialSecurityProfile.getUserName();
		}
		catch (UsernameAlreadyExistsException e)
		{
			return null;
		}
	}

	
}

#No. 4885
#File: E:\bishe\1\AbstractSqlConverter.java
#Comment:
    /**
     * 将Statement反解析为sql
     * 
     * @param statement
     * @return
     */

#Code:
    protected String doDeParse(Statement statement) {
        StatementDeParser deParser = new StatementDeParser(new StringBuilder());
        statement.accept(deParser);
        return deParser.getBuffer().toString();
    }

#No. 4886
#File: E:\bishe\1\AbstractSqlConverter.java
#Comment:
    /**
     * 从ShardConfigFactory中查找ShardStrategy并对表名进行修改<br>
     * 如果没有相应的ShardStrategy则对表名不做修改
     * 
     * @param tableName
     * @param suffix
     * @return
     */

#Code:
    protected String convertTableName(String tableName, String suffix) {
        return tableName + "_" + suffix;
    }

#No. 4887
#File: E:\bishe\1\AbstractSQLDatabase.java
#Comment:
    /**
     * Construct the JDBC URL without addtional connection specific attributes.
     *
     * @return The JDC URL.
     */

#Code:
    public final String getUrl() {
        return getUrl(new HashMap<String, String>());
    }

#No. 4888
#File: E:\bishe\1\AbstractSQLDatabase.java
#Comment:
    /**
     * Construct the JDBC URL with connection specific attributes.
     *
     * @param additionalAttributes The connection specific attributes.
     * @return The JDBC URL.
     */

#Code:
    public final String getUrl(final Map<String, String> additionalAttributes) {
        final StringBuilder url = new StringBuilder("jdbc:");
        url.append(getUrlProtocol());
        url.append(getDatabaseName());
        final Map<String, String> mergedAttributes = new HashMap<String, String>(getAttributes());
        mergedAttributes.putAll(additionalAttributes);
        if (mergedAttributes.size() > 0) {
            for (final Map.Entry<String, String> entry : mergedAttributes.entrySet()) {
                url.append(';');
                url.append(entry.getKey());
                url.append('=');
                url.append(entry.getValue());
            }
        }
        return url.toString();
    }

#No. 4889
#File: E:\bishe\1\AbstractSqliteDao.java
#Comment:
    /**
     * Calls {@link Entity#prePersist()} before converting to
     * {@link ContentValues}.
     * 
     * @param t
     * @return
     */

#Code:
    private ContentValues toContentValuesSave(T t) {
        t.prePersist();
        return toContentValues(t);
    }

#No. 4890
#File: E:\bishe\1\AbstractSqliteDao.java
#Comment:
    /**
     * Create a new cursor, closing the old one first.
     * 
     * @param cursor
     * @return
     */

#Code:
    private Cursor newCursor(Cursor cursor) {
        // Make sure previous resources are released
        closeCursor();
        this.cursor = cursor;
        return cursor;
    }

#No. 4891
#File: E:\bishe\1\AbstractSqliteDao.java
#Comment:
    /**
     * Delegates to
     * {@link SQLiteDatabase#query(boolean, String, String[], String, String[], String, String, String, String)}
     * , storing a reference of the cursor so it can be closed at any time via
     * {@link #closeCursor()}.
     */

#Code:
    protected Cursor query(boolean distinct, String table, String[] columns,
            String selection, String[] selectionArgs, String groupBy,
            String having, String orderBy, String limit) {
        return newCursor(db.query(distinct, table, columns, selection,
                selectionArgs, groupBy, having, orderBy, limit));
    }

#No. 4892
#File: E:\bishe\1\AbstractSqliteDao.java
#Comment:
    /**
     * Delegates to
     * {@link SQLiteDatabase#query(String, String[], String, String[], String, String, String)}
     * , storing a reference of the cursor so it can be closed at any time via
     * {@link #closeCursor()}.
     */

#Code:
    protected Cursor query(String table, String[] columns, String selection,
            String[] selectionArgs, String groupBy, String having,
            String orderBy) {
        return newCursor(db.query(table, columns, selection, selectionArgs,
                groupBy, having, orderBy));
    }

#No. 4893
#File: E:\bishe\1\AbstractSqliteDao.java
#Comment:
    /**
     * Delegates to
     * {@link SQLiteDatabase#query(String, String[], String, String[], String, String, String, String)}
     * , storing a reference of the cursor so it can be closed at any time via
     * {@link #closeCursor()}.
     */

#Code:
    protected Cursor query(String table, String[] columns, String selection,
            String[] selectionArgs, String groupBy, String having,
            String orderBy, String limit) {
        return newCursor(db.query(table, columns, selection, selectionArgs,
                groupBy, having, orderBy, limit));
    }

#No. 4894
#File: E:\bishe\1\AbstractSqliteDao.java
#Comment:
    /**
     * Delegates to
     * {@link SQLiteDatabase#query(boolean, String, String[], String, String[], String, String, String, String, CancellationSignal)}
     * , storing a reference of the cursor so it can be closed at any time via
     * {@link #closeCursor()}.
     */

#Code:
    protected Cursor query(boolean distinct, String table, String[] columns,
            String selection, String[] selectionArgs, String groupBy,
            String having, String orderBy, String limit,
            CancellationSignal cancellationSignal) {
        return newCursor(db.query(distinct, table, columns, selection,
                selectionArgs, groupBy, having, orderBy, limit,
                cancellationSignal));
    }

#No. 4895
#File: E:\bishe\1\AbstractSqliteDao.java
#Comment:
    /**
     * Delegates to
     * {@link SQLiteDatabase#queryWithFactory(CursorFactory, boolean, String, String[], String, String[], String, String, String, String, CancellationSignal)}
     * , storing a reference of the cursor so it can be closed at any time via
     * {@link #closeCursor()}.
     * 
     */

#Code:
    protected Cursor queryWithFactory(CursorFactory cursorFactory,
            boolean distinct, String table, String[] columns, String selection,
            String[] selectionArgs, String groupBy, String having,
            String orderBy, String limit, CancellationSignal cancellationSignal) {
        return newCursor(db.queryWithFactory(cursorFactory, distinct, table,
                columns, selection, selectionArgs, groupBy, having, orderBy,
                limit, cancellationSignal));
    }

#No. 4896
#File: E:\bishe\1\AbstractSqliteDao.java
#Comment:
    /**
     * Delegates to
     * {@link SQLiteDatabase#queryWithFactory(CursorFactory, boolean, String, String[], String, String[], String, String, String, String)}
     * , storing a reference of the cursor so it can be closed at any time via
     * {@link #closeCursor()}.
     */

#Code:
    protected Cursor queryWithFactory(CursorFactory cursorFactory,
            boolean distinct, String table, String[] columns, String selection,
            String[] selectionArgs, String groupBy, String having,
            String orderBy, String limit) {
        return newCursor(db.queryWithFactory(cursorFactory, distinct, table,
                columns, selection, selectionArgs, groupBy, having, orderBy,
                limit));
    }

#No. 4897
#File: E:\bishe\1\AbstractSqliteDao.java
#Comment:
    /**
     * See
     * {@link SQLiteDatabase#rawQueryWithFactory(CursorFactory, String, String[], String)}
     * , storing a reference of the cursor so it can be closed at any time via
     * {@link #closeCursor()}.
     */

#Code:
    protected Cursor rawQuery(String sql, String[] selectionArgs) {
        return newCursor(db.rawQuery(sql, selectionArgs));
    }

#No. 4898
#File: E:\bishe\1\AbstractSqliteDao.java
#Comment:
    /**
     * Delegates to
     * {@link SQLiteDatabase#rawQuery(String, String[], CancellationSignal)},
     * storing a reference of the cursor so it can be closed at any time via
     * {@link #closeCursor()}.
     */

#Code:
    protected Cursor rawQuery(String sql, String[] selectionArgs,
            CancellationSignal cancellationSignal) {
        return newCursor(db.rawQuery(sql, selectionArgs, cancellationSignal));
    }

#No. 4899
#File: E:\bishe\1\AbstractSqliteDao.java
#Comment:
    /**
     * Delegates to
     * {@link SQLiteDatabase#rawQueryWithFactory(CursorFactory, String, String[], String)}
     * , storing a reference of the cursor so it can be closed at any time via
     * {@link #closeCursor()}.
     */

#Code:
    protected Cursor rawQueryWithFactory(CursorFactory cursorFactory,
            String sql, String[] selectionArgs, String editTable) {
        return newCursor(db.rawQueryWithFactory(cursorFactory, sql,
                selectionArgs, editTable));
    }

#No. 4900
#File: E:\bishe\1\AbstractSqliteDao.java
#Comment:
    /**
     * Delegates to
     * {@link SQLiteDatabase#rawQueryWithFactory(CursorFactory, String, String[], String, CancellationSignal)}
     * , storing a reference of the cursor so it can be closed at any time via
     * {@link #closeCursor()}.
     */

#Code:
    protected Cursor rawQueryWithFactory(CursorFactory cursorFactory,
            String sql, String[] selectionArgs, String editTable,
            CancellationSignal cancellationSignal) {
        return newCursor(db.rawQueryWithFactory(cursorFactory, sql,
                selectionArgs, editTable, cancellationSignal));
    }

#No. 4901
#File: E:\bishe\1\AbstractSqlQuery.java
#Comment:
    /**
     * @param num number of times to repeat the pattern
     * @return bind variables repeated num times
     */

#Code:
    protected String getBindVariables(String pattern, int num) {
        return StringUtils.chop(StringUtils.repeat(pattern, num));
    }

#No. 4902
#File: E:\bishe\1\AbstractSqlQuery.java
#Comment:
    /**
     * if formatter != null applies the formatter to the column names. Examples of output are:
     * <br>
     * formatter == null ==&gt; [colName1, colName2]
     * <br>
     * formatter == "%s = ?" ==&gt; [colName1 = ?, colName2 = ?]
     */

#Code:
    protected Collection<String> getColumnNames(Collection<Schema.Field> columns, final String formatter) {
        return Collections2.transform(columns, new Function<Schema.Field, String>() {
            @Override
            public String apply(Schema.Field field) {
                return formatter == null ? field.getName() : String.format(formatter, field.getName());
            }
        });
    }

#No. 4903
#File: E:\bishe\1\AbstractSSTableMapper.java
#Comment:
    /**
     * Any modifications to this row key bytebuffer should be rewinded. Make sure you know what
     * you're doing if you call this.
     *
     * @return The original <code>ByteBuffer</code> representing the row key.
     */

#Code:
    protected ByteBuffer getRowKey() {
        return key;
    }

#No. 4904
#File: E:\bishe\1\AbstractSSTableMapper.java
#Comment:
    /**
     * Any modifications to the atom's name <code>ByteBuffer</code> or the atom's value
     * <code>ByteBuffer</code> needs to be rewinded. Make sure you know what you're doing if you
     * call this.
     *
     * @return The current cassandra value.
     */

#Code:
    protected CASS_VALUE getValue() {
        return value;
    }

#No. 4905
#File: E:\bishe\1\AbstractSSTableMapper.java
#Comment:
    /**
     * @param skipDeletedAtoms
     *            When set to true atoms marked for deletion will be ignored.
     */

#Code:
    public void setSkipDeletedAtoms(boolean skipDeletedAtoms) {
        this.skipDeletedAtoms = skipDeletedAtoms;
    }

#No. 4906
#File: E:\bishe\1\AbstractSSTableMapper.java
#Comment:
    /**
     * @return True if deleted atoms will be skipped false otherwise.
     */

#Code:
    public boolean isSkipDeletedAtoms() {
        return skipDeletedAtoms;
    }

#No. 4907
#File: E:\bishe\1\AbstractState.java
#Comment:
/**
 *  This class models the jsr/ret call stack
 */

#Code:

class AbstractCallStack {
  final int return_pc;
  final AbstractCallStack next;
  AbstractCallStack (int pc, AbstractCallStack n) {
    return_pc = pc;
    next = n;
  }
  public String toString () {
    if (next == null)
      return Integer.toString (return_pc);
    else
      return next.toString ()+" "+return_pc;
  }
}

#No. 4908
#File: E:\bishe\1\AbstractStatefulHash.java
#Comment:
    /**
     * Writes the output of this hash function into the given range of the given
     * byte array. The inputs have already been validated.
     * 
     * @param output the destination array for the output
     * @param index the starting index of the first output byte
     * @param length the number of bytes to write
     */

#Code:
    protected void writeBytes(byte[] output, int index, int length) {
        long temp = getLong();
        for (int i = 0; i < length; ++i) {
            output[index + i] = (byte) temp;
            temp >>>= 8;
        }
    }

#No. 4909
#File: E:\bishe\1\AbstractStatefulSocketSession.java
#Comment:
    /**
     * @return the fix controller, only for use by admin commands
     */

#Code:
    public final T_CONTROLLER getController() {
        return _controller;
    }

#No. 4910
#File: E:\bishe\1\AbstractStatefulSocketSession.java
#Comment:
    /**
     * @NOTE MUST ONLY BE CALLED IN THE RECEIVERS THREAD OF CONTROL
     */

#Code:
    @Override
    public final Message retrieve( int curMsgSeqNo ) {
        Message msg = null;
        
        try {
            int numBytes = ((IndexPersister)_outPersister).readFromIndex( curMsgSeqNo, _inBuffer, _inHdrLen );

            if ( numBytes > 0 ) {
                
                _recoveryDecoder.parseHeader( _inBuffer, _inHdrLen, numBytes );
                
                msg = _recoveryDecoder.postHeaderDecode();
                
                if ( msg instanceof BaseReject<?> )  {
                    BaseReject<?> rej = (BaseReject<?>)msg;
                    
                    _logInMsg.copy( FAILED_TO_RETRIEVE ).append( curMsgSeqNo ).append( ' ' ).append( rej.getMessage() );
                    
                    Throwable t = rej.getThrowable();
                    if ( t instanceof RuntimeDecodingException ) {
                        RuntimeDecodingException rde = (RuntimeDecodingException) t;
                        errorDumpMsg( _logInMsg, rde );
                    }
                    _log.warn( _logInMsg );
                    
                    return null;
                }
            }
            
        } catch( PersisterException e ) {
            _logInMsg.copy( FAILED_TO_RETRIEVE ).append( curMsgSeqNo ).append( e.getMessage() );
            _log.warn( _logInMsg );
        }
        
        return msg;
    }

#No. 4911
#File: E:\bishe\1\AbstractStatefulSocketSession.java
#Comment:
    /**
     * needs to be syncronised OR have a seperate decoder for in/out reccovery
     */

#Code:
    @Override
    protected synchronized Message recoveryDecode( byte[] buf, int offset, int len, boolean inBound ) {
        
        _recoveryDecoder.parseHeader( buf, offset, len );
        Message msg = _recoveryDecoder.postHeaderDecode();

        _controller.recoverContext( msg, inBound );
        
        return msg;
    }

#No. 4912
#File: E:\bishe\1\AbstractStatefulSocketSession.java
#Comment:
    /**
     * resync stream IF a header can be found in current buffered data
     * If find a partial buffer at end of the stream, then shift left and read more
     * 
     * @param bytesRead
     * @return bytesRead
     * @throws Exception 
     */

#Code:
    private final int resyncToNextHeader( int bytesRead ) throws Exception {
        
        ResyncCode code = _decoder.resync( _inBuffer, _inHdrLen, bytesRead );

        final int skippedBytes = _decoder.getSkipBytes();
        
        bytesRead -= skippedBytes;
        
        shiftInBufferLeft( bytesRead, _inHdrLen+skippedBytes );
        
        if ( code == ResyncCode.FOUND_PARTIAL_HEADER_NEED_MORE_DATA ) {
            bytesRead = readFixedExpectedBytes( bytesRead, _initialBytesToRead ); // now should have enough for header
        }
        
        _inMsgLen = _decoder.parseHeader( _inBuffer, _inHdrLen, bytesRead );  // bytesRead is at least INITIAL_READ_BYTES
        
        if ( _inMsgLen < 0 ) {
            _logInMsg.copy( FAILED_TO_RESYNC ).append( _inBuffer, _inHdrLen, _initialBytesToRead );
            _log.info( _logInMsg );
            throw new BadMessageSize( _logInMsg.toString() );
        }
        
        return bytesRead;
    }

#No. 4913
#File: E:\bishe\1\AbstractStateZipper.java
#Comment:
    /**
     * Ask the zip function to compute the states and then transition the state of the zipper.
     *
     * When no registrations are available, the zipper immediately transitions into the initial state
     * without asking the zip function for a computation.
     */

#Code:
    private void transitionStateThroughZipper() {
        Collection<S> currentStates = states.values();
        if (currentStates.isEmpty()) {
            transitionState(initialState);
        } else {
            transitionState(zipWith(currentStates));
        }
    }

#No. 4914
#File: E:\bishe\1\AbstractStateZipper.java
#Comment:
    /**
     * Helper method to export the current internal subscriptions.
     *
     * @return the internally stored subscriptions.
     */

#Code:
    protected Map<T, Subscription> currentSubscriptions() {
        return subscriptions;
    }

#No. 4915
#File: E:\bishe\1\AbstractStateZipper.java
#Comment:
    /**
     * Helper method to export the current internal states.
     *
     * Should only be used for testing.
     * @return the internally stored states.
     */

#Code:
    protected Map<T, S> currentStates() {
        return states;
    }

#No. 4916
#File: E:\bishe\1\AbstractStddevMutator.java
#Comment:
	/*
	 * We could have the variance as a child, but that would involve an extra redistribution.
	 * We delegate the operations right on the variance instead.
	 */

#Code:
	
	@Override
	public void setBeforeOffset(int v) {
		this.varianceMutator.setBeforeOffset(v);
	}

#No. 4917
#File: E:\bishe\1\AbstractSteamWebApiServiceRequestBuilder.java
#Comment:
/**
 * Skeleton of {@link SteamWebApiRequestBuilder} for request builders for
 * requests that are sent to Steam Web API <b>services</b> which require a
 * specific JSON parameter. The JSON parameter or <b>service parameter</b> can
 * be passed to {@link #addServiceParameter(SteamWebApiServiceParameter)
 * addServiceParameter} which converts the POJO to a JSON string.
 *
 * @see <a href=
 *      "https://developer.valvesoftware.com/wiki/Steam_Web_API#Calling_Service_interfaces"
 *      >https://developer.valvesoftware.com/wiki/Steam_Web_API#Calling_Service_interfaces</a>
 * @author lpradel
 *
 */

#Code:
public abstract class AbstractSteamWebApiServiceRequestBuilder extends
		AbstractSteamWebApiRequestBuilder {

	/**
	 * The request parameter name of the service-specific parameter.
	 */
	static final String REQUEST_PARAM_INPUT_JSON = "input_json";

	private final ObjectMapper mapper = new ObjectMapper();

	/**
	 * Converts the service parameter POJO to a JSON string and adds the JSON
	 * string as a normal GET parameter.
	 *
	 * @param serviceParameter
	 */
	protected void addServiceParameter(
			SteamWebApiServiceParameter serviceParameter) {

		try {
			String serviceParameterJson = mapper
					.writeValueAsString(serviceParameter);

			addParameter(REQUEST_PARAM_INPUT_JSON, serviceParameterJson);
		} catch (JsonProcessingException e) {
			throw new IllegalArgumentException(
					"The given request parameters cannot be mapped to JSON.", e);
		}
	}
}

#No. 4918
#File: E:\bishe\1\AbstractSteerSpatial.java
#Comment:
    /**
     * Runs a search for all intersecting {@link SpatialEntity}s with the circle centered on {@link SteerSubject} with radius {@link #query}.
     * 
     * @param steerSubject
     *        The {@link SteerSubject} to search around.
     * @return The number of {@link SpatialEntity}s found around the given subject that met the criteria.
     */

#Code:
    protected int search( SteerSubject<V> steerSubject )
    {
        subject = steerSubject;

        return space.intersects( steerSubject.getPosition(), minimumRadius, max, groups, this );
    }

#No. 4919
#File: E:\bishe\1\AbstractStep.java
#Comment:
    /**
     * Unique identifier for this step. This is auto-generated for new steps
     * when not set explicitly.
     */

#Code:
    public String getUid() {
        return uid;
    }

#No. 4920
#File: E:\bishe\1\AbstractStep.java
#Comment:
    /**
     * Set unique identifier for this step. It's not recommended to set this
     * explicitly as it will be auto-generated when step is added first time
     * into Gantt and UID is not already set.
     */

#Code:
    public void setUid(String uid) {
        this.uid = uid;
    }

#No. 4921
#File: E:\bishe\1\AbstractStep.java
#Comment:
    /**
     * Set progress between 0-100%.
     */

#Code:
    public void setProgress(double progress) {
        this.progress = progress;
    }

#No. 4922
#File: E:\bishe\1\AbstractStepWidget.java
#Comment:
    /**
     * Set data source for this widget. Called when {@linkplain StepState} is
     * changed.
     *
     * @param step
     */

#Code:
    public void setStep(AbstractStep step) {
        this.step = step;
        updateBackground();
        updateStyle();
        updateCaption();
        updateProgress();
    }

#No. 4923
#File: E:\bishe\1\AbstractStepWidget.java
#Comment:
    /**
     * Get state object. read-only. Changes to the Step object on client side
     * are not registered to the server side.
     */

#Code:
    public AbstractStep getStep() {
        return step;
    }

#No. 4924
#File: E:\bishe\1\AbstractStepWidget.java
#Comment:
    /**
     * Updates width of this widget to match the Gantt chart's timeline.
     */

#Code:
    public void updateWidth() {
        if (gantt == null || !getElement().hasParentElement()) {
            return;
        }

        getElement().getStyle().clearVisibility();

        if (start != step.getStartDate() || end != step.getEndDate()) {

            // sanity check
            if (step.getStartDate() < 0 || step.getEndDate() < 0 || step.getEndDate() <= step.getStartDate()) {
                getElement().addClassName(STYLE_INVALID);
            } else {
                updatePositionAndWidth();
            }
        }
    }

#No. 4925
#File: E:\bishe\1\AbstractStopAndRouteSelectionWidget.java
#Comment:
  /****
   *
   ****/

#Code:

  protected void initialize() {
    _addStopAnchor.setHref("#addStop");    
  }

#No. 4926
#File: E:\bishe\1\AbstractStorage.java
#Comment:
    /**
     * Default implementation uses a CSV parser to extract the first value, then sets the raw line of text on the summary
     * to make it available to other plugins. Note that any overriding implementation *must* catch Exception from
     * {@link #createSummary(String)} and return a new zero-sized {@link ObjectSummary} for the identifier
     */

#Code:
    @Override
    public ObjectSummary parseListLine(String listLine) {
        try {
            CSVRecord record = CSVFormat.EXCEL.parse(new StringReader(listLine)).iterator().next();

            ObjectSummary summary;
            try {
                summary = createSummary(record.get(0));
            } catch (Exception e) {
                summary = new ObjectSummary(record.get(0), false, 0);
            }

            summary.setListFileRow(listLine);
            return summary;

        } catch (IOException e) {
            throw new RuntimeException("could not parse list-file line", e);
        }
    }

#No. 4927
#File: E:\bishe\1\AbstractStorageEngine.java
#Comment:
    /**
     * This method is called after the object serialization. It moves all the not-serializable BigMap references from
     * the Map back to the provided object. The main idea is that once the serialization is completed, we are allowed to
     * restore back all the references which were removed by the preSerializer.
     *
     * @param serializableObject
     * @param objReferences
     * @param <T>
     */

#Code:
    protected <T extends Serializable> void postSerializer(T serializableObject, Map<String, Object> objReferences) {
        for(Field field : ReflectionMethods.getAllFields(new LinkedList<>(), serializableObject.getClass())) {
            String fieldName = field.getName();

            Object ref = objReferences.remove(fieldName);
            if(ref != null) { //if a reference is found in the map
                field.setAccessible(true);

                try {
                    //restore the reference in the object
                    field.set(serializableObject, ref);
                }
                catch (IllegalAccessException ex) {
                    throw new RuntimeException(ex);
                }
            }
        }
    }

#No. 4928
#File: E:\bishe\1\AbstractStorageEngine.java
#Comment:
    /**
     * This method is called after the object deserialization. It initializes all BigMaps of the serializable object which
     * have a null value. The main idea is that once an object is deserialized it will contain nulls in all the BigMap fields
     * which were not serialized. For all of those fields we call their initialization methods.
     *
     * @param serializableObject
     * @param <T>
     */

#Code:
    protected <T extends Serializable> void postDeserializer(T serializableObject) {
        Method method = null;
        for(Field field : ReflectionMethods.getAllFields(new LinkedList<>(), serializableObject.getClass())) {
            if (field.isAnnotationPresent(BigMap.class)) { //look only for BigMaps
                field.setAccessible(true);
                try {
                    if(field.get(serializableObject) == null) { //initialize it only if null. this makes it safe it the BigMap was serialized in the file.

                        //lazy initialize the correct method once
                        if(method == null) {
                            method = ReflectionMethods.findMethod(serializableObject, "initializeBigMapField", this, field);
                        }

                        ReflectionMethods.invokeMethod(serializableObject, method, this, field);
                    }
                }
                catch (IllegalAccessException ex) {
                    throw new RuntimeException(ex);
                }
            }
        }

    }

#No. 4929
#File: E:\bishe\1\AbstractStorageManager.java
#Comment:
  /**
   * Cache of scanner handlers for each storage type.
   */

#Code:
  protected static final Map<String, Class<? extends Scanner>> SCANNER_HANDLER_CACHE
      = new ConcurrentHashMap<String, Class<? extends Scanner>>();

  /**
   * Cache of appender handlers for each storage type.
   */
  protected static final Map<String, Class<? extends FileAppender>> APPENDER_HANDLER_CACHE
      = new ConcurrentHashMap<String, Class<? extends FileAppender>>();

  /**
   * Cache of constructors for each class. Pins the classes so they
   * can't be garbage collected until ReflectionUtils can be collected.
   */
  private static final Map<Class<?>, Constructor<?>> CONSTRUCTOR_CACHE =
      new ConcurrentHashMap<Class<?>, Constructor<?>>();

  public abstract Class<? extends Scanner> getScannerClass(CatalogProtos.StoreType storeType) throws IOException;

  public abstract Scanner getScanner(TableMeta meta, Schema schema, Fragment fragment, Schema target) throws IOException;

  protected AbstractStorageManager(TajoConf conf) throws IOException {
    this.conf = conf;
    this.tableBaseDir = TajoConf.getWarehouseDir(conf);
    this.fs = tableBaseDir.getFileSystem(conf);
    this.blocksMetadataEnabled = conf.getBoolean(DFSConfigKeys.DFS_HDFS_BLOCKS_METADATA_ENABLED,
        DFSConfigKeys.DFS_HDFS_BLOCKS_METADATA_ENABLED_DEFAULT);
    if (!this.blocksMetadataEnabled)
      LOG.warn("does not support block metadata. ('dfs.datanode.hdfs-blocks-metadata.enabled')");
  }

#No. 4930
#File: E:\bishe\1\AbstractStorageManager.java
#Comment:
  /**
   * This method deletes only data contained in the given path.
   *
   * @param path The path in which data are deleted.
   * @throws IOException
   */

#Code:
  public void deleteData(Path path) throws IOException {
    FileSystem fileSystem = path.getFileSystem(conf);
    FileStatus[] fileLists = fileSystem.listStatus(path);
    for (FileStatus status : fileLists) {
      fileSystem.delete(status.getPath(), true);
    }
  }

#No. 4931
#File: E:\bishe\1\AbstractStorageManager.java
#Comment:
  /**
   * Is the given filename splitable? Usually, true, but if the file is
   * stream compressed, it will not be.
   * <p/>
   * <code>FileInputFormat</code> implementations can override this and return
   * <code>false</code> to ensure that individual input files are never split-up
   * so that Mappers process entire files.
   *
   *
   * @param filename the file name to check
   * @return is this file isSplittable?
   */

#Code:
  protected boolean isSplittable(TableMeta meta, Schema schema, Path filename) throws IOException {
    Scanner scanner = getFileScanner(meta, schema, filename);
    return scanner.isSplittable();
  }

#No. 4932
#File: E:\bishe\1\AbstractStorageManager.java
#Comment:
  /**
   * A factory that makes the split for this class. It can be overridden
   * by sub-classes to make sub-types
   */

#Code:
  protected FileFragment makeSplit(String fragmentId, TableMeta meta, Path file, long start, long length) {
    return new FileFragment(fragmentId, file, start, length);
  }

#No. 4933
#File: E:\bishe\1\AbstractStorageManager.java
#Comment:
  /**
   * Get the minimum split size
   *
   * @return the minimum number of bytes that can be in a split
   */

#Code:
  public long getMinSplitSize() {
    return conf.getLongVar(TajoConf.ConfVars.MINIMUM_SPLIT_SIZE);
  }

#No. 4934
#File: E:\bishe\1\AbstractStorageManager.java
#Comment:
  /**
   * Get Disk Ids by Volume Bytes
   */

#Code:
  private int[] getDiskIds(VolumeId[] volumeIds) {
    int[] diskIds = new int[volumeIds.length];
    for (int i = 0; i < volumeIds.length; i++) {
      int diskId = -1;
      if (volumeIds[i] != null && volumeIds[i].isValid()) {
        String volumeIdString = volumeIds[i].toString();
        byte[] volumeIdBytes = Base64.decodeBase64(volumeIdString);

        if (volumeIdBytes.length == 4) {
          diskId = Bytes.toInt(volumeIdBytes);
        } else if (volumeIdBytes.length == 1) {
          diskId = (int) volumeIdBytes[0];  // support hadoop-2.0.2
        }
      }
      diskIds[i] = diskId;
    }
    return diskIds;
  }

#No. 4935
#File: E:\bishe\1\AbstractStorageManager.java
#Comment:
  /**
   * Generate the map of host and make them into Volume Ids.
   *
   */

#Code:
  private Map<String, Set<Integer>> getVolumeMap(List<FileFragment> frags) {
    Map<String, Set<Integer>> volumeMap = new HashMap<String, Set<Integer>>();
    for (FileFragment frag : frags) {
      String[] hosts = frag.getHosts();
      int[] diskIds = frag.getDiskIds();
      for (int i = 0; i < hosts.length; i++) {
        Set<Integer> volumeList = volumeMap.get(hosts[i]);
        if (volumeList == null) {
          volumeList = new HashSet<Integer>();
          volumeMap.put(hosts[i], volumeList);
        }

        if (diskIds.length > 0 && diskIds[i] > -1) {
          volumeList.add(diskIds[i]);
        }
      }
    }

    return volumeMap;
  }

#No. 4936
#File: E:\bishe\1\AbstractStorageManager.java
#Comment:
  /**
   * create a scanner instance.
   */

#Code:
  public static <T> T newScannerInstance(Class<T> theClass, Configuration conf, Schema schema, TableMeta meta,
                                         Fragment fragment) {
    T result;
    try {
      Constructor<T> meth = (Constructor<T>) CONSTRUCTOR_CACHE.get(theClass);
      if (meth == null) {
        meth = theClass.getDeclaredConstructor(DEFAULT_SCANNER_PARAMS);
        meth.setAccessible(true);
        CONSTRUCTOR_CACHE.put(theClass, meth);
      }
      result = meth.newInstance(new Object[]{conf, schema, meta, fragment});
    } catch (Exception e) {
      throw new RuntimeException(e);
    }

    return result;
  }

#No. 4937
#File: E:\bishe\1\AbstractStorageManager.java
#Comment:
  /**
   * create a scanner instance.
   */

#Code:
  public static <T> T newAppenderInstance(Class<T> theClass, Configuration conf, TableMeta meta, Schema schema,
                                          Path path) {
    T result;
    try {
      Constructor<T> meth = (Constructor<T>) CONSTRUCTOR_CACHE.get(theClass);
      if (meth == null) {
        meth = theClass.getDeclaredConstructor(DEFAULT_APPENDER_PARAMS);
        meth.setAccessible(true);
        CONSTRUCTOR_CACHE.put(theClass, meth);
      }
      result = meth.newInstance(new Object[]{conf, schema, meta, path});
    } catch (Exception e) {
      throw new RuntimeException(e);
    }

    return result;
  }

#No. 4938
#File: E:\bishe\1\AbstractStorageModule.java
#Comment:
  /**
   * @since 2007-06-01
   * @param aMsg
   *        The source message
   * @param sFileParam
   *        The parameter name including the filename
   * @param sAction
   *        Action name
   * @return File The {@link File} to be used
   * @throws IOException
   *         In case of IO error
   * @throws OpenAS2Exception
   *         In case of error
   */

#Code:
  protected File getFile (final IMessage aMsg, final String sFileParam, final String sAction) throws IOException,
                                                                                              OpenAS2Exception
  {
    final String sFilename = getFilename (aMsg, sFileParam, sAction);

    // make sure the parent directories exist
    final File aFile = new File (sFilename);
    IOHelper.getFileOperationManager ().createDirRecursiveIfNotExisting (aFile.getParentFile ());
    // don't overwrite existing files
    return IOHelper.getUniqueFile (aFile.getParentFile (), FilenameHelper.getAsSecureValidFilename (aFile.getName ()));
  }

#No. 4939
#File: E:\bishe\1\AbstractStoredList.java
#Comment:
    /**
     * get the next element in scan order
     */

#Code:
    public IStoredListIterator<T> next(IStoredListIterator<T> slh) {
        if (!nextPos((StoredListIterator<T>) slh)) {
            slh.release();
            return null;
        }
        return slh;

    }

#No. 4940
#File: E:\bishe\1\AbstractStoredList.java
#Comment:
    /**
     * @param slh
     */

#Code:
    public abstract boolean nextPos(StoredListIterator<T> slh);

    /**
     * this method is called  by outside scan that want to quit the scan and return the slholder to
     * the factory
     */
    public void freeSLHolder(IStoredListIterator<T> slh) {
        if (slh != null)
            slh.release();
    }

#No. 4941
#File: E:\bishe\1\AbstractStoredList.java
#Comment:
        /**
         * This class is the information unit in the list
         */

#Code:
        private ObjectInfo<T> _backwrd; // towards tail (fifo)
        private ObjectInfo<T> _fwrd;   // towards head ( lifo)
        private int _pos;    // serial pos in list
        private T _subject; // stored object

        public ObjectInfo(T subject) {
            setSubject(subject);
        }

#No. 4942
#File: E:\bishe\1\AbstractStoredList.java
#Comment:
        /**
         * @param subject The subject to set.
         */

#Code:
        public void setSubject(T subject) {
            _subject = subject;
        }

#No. 4943
#File: E:\bishe\1\AbstractStoredList.java
#Comment:
        /**
         * @return Returns the subject.
         */

#Code:
        public T getSubject() {
            return _subject;
        }

#No. 4944
#File: E:\bishe\1\AbstractStoredList.java
#Comment:
        /**
         * @param backwrd The backwrd to set.
         */

#Code:
        public void setBackwardsRef(ObjectInfo<T> backwrd) {
            this._backwrd = backwrd;
        }

#No. 4945
#File: E:\bishe\1\AbstractStoredList.java
#Comment:
        /**
         * @return Returns the backwrd.
         */

#Code:
        protected ObjectInfo<T> getBackwardsRef() {
            return _backwrd;
        }

#No. 4946
#File: E:\bishe\1\AbstractStoredList.java
#Comment:
        /**
         * @param fwrd The fwrd to set.
         */

#Code:
        public void setForwardRef(ObjectInfo<T> fwrd) {
            _fwrd = fwrd;
        }

#No. 4947
#File: E:\bishe\1\AbstractStoredList.java
#Comment:
        /**
         * @return Returns the fwrd.
         */

#Code:
        public ObjectInfo<T> getForwardRef() {
            return _fwrd;
        }

#No. 4948
#File: E:\bishe\1\AbstractStoredList.java
#Comment:
        /**
         * @param pos The pos to set.
         */

#Code:
        public void setPosInList(int pos) {
            this._pos = pos;
        }

#No. 4949
#File: E:\bishe\1\AbstractStoredList.java
#Comment:
        /**
         * @return Returns the pos.
         */

#Code:
        public int getPosInList() {
            return _pos;
        }

#No. 4950
#File: E:\bishe\1\AbstractStoryPartBasedScanner.java
#Comment:
    /**
     * Configures the scanner by providing access to the document range that should be scanned.
     * 
     * @see org.eclipse.jface.text.rules.ITokenScanner#setRange(org.eclipse.jface.text.IDocument, int, int)
     */

#Code:
    public void setRange(IDocument document, int offset, int length) {
        log.debug("Range(offset: " +  offset + ", length: " + length + ", document length: " + document.getLength() + ")");
        if((offset+length)>document.getLength())
            throw new IllegalArgumentException("Range is outside the document");

        fragments = New.arrayList();
        cursor = -1;
        this.document = document;
        this.range = new Region(offset, length);
    }

#No. 4951
#File: E:\bishe\1\AbstractStreamingHashFunction.java
#Comment:
    /**
     * This is invoked for the last bytes of the input, which are not enough to
     * fill a whole chunk. The passed {@code ByteBuffer} is guaranteed to be
     * non-empty.
     *
     * <p>This implementation simply pads with zeros and delegates to
     * {@link #process(ByteBuffer)}.
     */

#Code:
    protected void processRemaining(ByteBuffer bb) {
      bb.position(bb.limit()); // move at the end
      bb.limit(chunkSize + 7); // get ready to pad with longs
      while (bb.position() < chunkSize) {
        bb.putLong(0);
      }
      bb.limit(chunkSize);
      bb.flip();
      process(bb);
    }

#No. 4952
#File: E:\bishe\1\AbstractStreamingProcess.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public void write(T entity, OutputStream output, Long pos, Long length) throws IOException {
        InputStream in = getInputStream(entity);
        if (pos != null && pos > 0) {
            in.skip(pos);
        }
        if (length != null && length > 0) {
            in = ByteStreams.limit(in, length);
        }
        try {
            ReaderWriter.writeTo(in, output);
        } finally {
            IOUtils.closeQuietly(in);
        }
    }

#No. 4953
#File: E:\bishe\1\AbstractStreamMemoryTransformer.java
#Comment:
	/**
	 * Adds a new consumer to this instance
	 *
	 * @return new consumer
	 */

#Code:
	public final StreamConsumer<I> newInput() {
		return addInput(new InputConsumer());
	}

#No. 4954
#File: E:\bishe\1\AbstractStreamMemoryTransformer.java
#Comment:
	/**
	 * On receiving data it calls function apply which must be defined
	 *
	 * @param item receiving item
	 */

#Code:
	@Override
	public void onData(I item) {
		apply(state, item);
	}

#No. 4955
#File: E:\bishe\1\AbstractStreamOp.java
#Comment:
    /**
     * Fail with current <i>owner</i> and its reason <i>t</i>
     *
     * @param cause
     *          failure reason
     */

#Code:
    @Override
    public void fail(Throwable cause) {
        if (cause instanceof OwnershipAcquireFailedException) {
            // Ownership exception is a control exception, not an error, so we don't stat
            // it with the other errors.
            OwnershipAcquireFailedException oafe = (OwnershipAcquireFailedException) cause;
            fail(ResponseUtils.ownerToHeader(oafe.getCurrentOwner()));
        } else {
            opStatsLogger.registerFailedEvent(stopwatch.elapsed(TimeUnit.MICROSECONDS));
            fail(ResponseUtils.exceptionToHeader(cause));
        }
    }

#No. 4956
#File: E:\bishe\1\AbstractStreamOp.java
#Comment:
    /**
     * Return the full response, header and body.
     *
     * @return A future containing the response or the exception
     *      encountered by the op if it failed.
     */

#Code:
    public Future<Response> result() {
        return result;
    }

#No. 4957
#File: E:\bishe\1\AbstractStreamSplitter.java
#Comment:
	/**
	 * Creates a new instance of this object
	 *
	 * @param eventloop event loop in which this consumer will run
	 */

#Code:
	public AbstractStreamSplitter(Eventloop eventloop) {
		super(eventloop);
	}

#No. 4958
#File: E:\bishe\1\AbstractStreamTransformer_1_N.java
#Comment:
	/**
	 * Creates a new instance of this object
	 *
	 * @param eventloop event loop in which this consumer will run
	 */

#Code:
	public AbstractStreamTransformer_1_N(Eventloop eventloop) {
		this.eventloop = eventloop;
	}

#No. 4959
#File: E:\bishe\1\AbstractStreamTransformer_1_N.java
#Comment:
	/**
	 * Checks if all producers of this consumer are ready
	 *
	 * @return true if all are ready, false else
	 */

#Code:
	protected boolean allOutputsResumed() {
		return suspendedProducersCount == 0;
	}

#No. 4960
#File: E:\bishe\1\AbstractStreamTransformer_N_1.java
#Comment:
	/**
	 * Creates a new instance of this object
	 *
	 * @param eventloop event loop in which this producer will run
	 */

#Code:
	public AbstractStreamTransformer_N_1(Eventloop eventloop) {
		this.eventloop = eventloop;
	}

#No. 4961
#File: E:\bishe\1\AbstractStreamTransformer_N_1.java
#Comment:
	/**
	 * Adds a new stream consumer to this producer
	 *
	 * @param <T>              type of stream consumer
	 * @param upstreamConsumer stream consumer events handler
	 */

#Code:
	protected <T> StreamConsumer<T> addInput(final AbstractInputConsumer<T> upstreamConsumer) {
		checkNotNull(upstreamConsumer);
		upstreamConsumer.index = inputConsumers.size();
		inputConsumers.add(upstreamConsumer);
		return upstreamConsumer;
	}

#No. 4962
#File: E:\bishe\1\AbstractStressScript.java
#Comment:
    /**
     * Returns integer system property property.
     *
     * @param key   key.
     * @param def   default value.
     *
     * @return value.
     */

#Code:
    protected static int getIntSystemProperty(String key, int def)
    {
        int value = def;

        String valueStr = System.getProperty(key);
        try
        {
            if (valueStr != null) value = Integer.parseInt(valueStr);
        } catch (NumberFormatException e)
        {
        }

        return value;
    }

#No. 4963
#File: E:\bishe\1\AbstractStressScript.java
#Comment:
    /**
     * Returns the value of system property.
     *
     * @param key   key of the property.
     * @param def   default value.
     *
     * @return value.
     */

#Code:
    protected String getSystemProperty(String key, String def)
    {
        String value = def;

        String val = System.getProperty(key);
        if (val != null) value = val;

        return value;
    }

#No. 4964
#File: E:\bishe\1\AbstractStressScript.java
#Comment:
    /**
     * Returns user preferences.
     *
     * @return user preferences.
     */

#Code:
    protected UserPreferences getUserPreferences()
    {
        return getModel().getUserPreferences();
    }

#No. 4965
#File: E:\bishe\1\AbstractStressScript.java
#Comment:
    /**
     * Returns active guide set.
     *
     * @return active guide set.
     */

#Code:
    protected GuidesSet getGuidesSet()
    {
        return getModel().getGuidesSet();
    }

#No. 4966
#File: E:\bishe\1\AbstractStressScript.java
#Comment:
    /**
     * Returns active channel guide model.
     *
     * @return active channel guide model.
     */

#Code:
    protected GuideModel getGuideModel()
    {
        return getModel().getGuideModel();
    }

#No. 4967
#File: E:\bishe\1\AbstractStressScript.java
#Comment:
    /**
     * Returns current model.
     *
     * @return current model.
     */

#Code:
    protected GlobalModel getModel()
    {
        return getController().getModel();
    }

#No. 4968
#File: E:\bishe\1\AbstractStressScript.java
#Comment:
    /**
     * Returns current article list.
     *
     * @return current article list.
     */

#Code:
    protected IFeedDisplay getArticleList()
    {
        return null; //getController().getMainFrame().getArticlesListPanel().getArticleList();
    }

#No. 4969
#File: E:\bishe\1\AbstractStressScript.java
#Comment:
    /**
     * Returns current channel list.
     *
     * @return current channel list.
     */

#Code:
    protected JList getChannelList()
    {
        return getChannelListPanel().getFeedsList();
    }

#No. 4970
#File: E:\bishe\1\AbstractStressScript.java
#Comment:
    /**
     * Returns channel list panel.
     *
     * @return channel list panel.
     */

#Code:
    protected FeedsPanel getChannelListPanel()
    {
        return getController().getMainFrame().getFeedsPanel();
    }

#No. 4971
#File: E:\bishe\1\AbstractStressScript.java
#Comment:
    /**
     * Returns current controller.
     *
     * @return current controller.
     */

#Code:
    protected GlobalController getController()
    {
        return GlobalController.SINGLETON;
    }

#No. 4972
#File: E:\bishe\1\AbstractStressScript.java
#Comment:
    /**
     * Sets the parameters of cleanup.
     *
     * @param period        period in minutes.
     * @param maxArticles   maximum articles in feed to leave.
     */

#Code:
    protected void setCleanupParameters(int period, int maxArticles)
    {
        UserPreferences prefs = getUserPreferences();
        prefs.setAutoPurgeIntervalMinutes(period);
        prefs.setPurgeCount(maxArticles);
    }

#No. 4973
#File: E:\bishe\1\AbstractStressScript.java
#Comment:
    /**
     * Removes all guides.
     */

#Code:
    protected void removeGuides()
    {
        GuidesSet set = getGuidesSet();
        set.clear();
    }

#No. 4974
#File: E:\bishe\1\AbstractStressScript.java
#Comment:
    /**
     * Removes guide from current guides set.
     *
     * @param aGuide    guide.
     */

#Code:
    protected void removeGuide(final IGuide aGuide)
    {
        if (UifUtilities.isEDT())
        {
            removeGuide0(aGuide);
        } else
        {
            try
            {
                SwingUtilities.invokeAndWait(new Runnable()
                {
                    public void run()
                    {
                        removeGuide0(aGuide);
                    }
                });
            } catch (Exception e)
            {
                throw new StressScriptException("Couldn't remove guide.", e);
            }
        }
    }

#No. 4975
#File: E:\bishe\1\AbstractStressScript.java
#Comment:
    /**
     * Removes guide from current guides set.
     *
     * @param aGuide    guide.
     *
     * @edt
     */

#Code:
    private void removeGuide0(IGuide aGuide)
    {
        GuidesSet set = getGuidesSet();
        set.remove(aGuide);
    }

#No. 4976
#File: E:\bishe\1\AbstractStressScript.java
#Comment:
    /**
     * Creates given number of guides.
     *
     * @param guides number of guides to create.
     */

#Code:
    protected void createGuides(final int guides)
    {
        for (int i = 0; i < guides; i++)
        {
            createGuide(Integer.toString(i));
        }
    }

#No. 4977
#File: E:\bishe\1\AbstractStressScript.java
#Comment:
    /**
     * Creates guide with a given title.
     *
     * @param title title of the guide.
     */

#Code:
    protected void createGuide(final String title)
    {
        if (UifUtilities.isEDT())
        {
            createGuide0(title);
        } else
        {
            try
            {
                SwingUtilities.invokeAndWait(new Runnable()
                {
                    public void run()
                    {
                        createGuide0(title);
                    }
                });
            } catch (Exception e)
            {
                throw new StressScriptException("Couldn't create guide.", e);
            }
        }
    }

#No. 4978
#File: E:\bishe\1\AbstractStressScript.java
#Comment:
    /**
     * Creates single guide.
     *
     * @param title title of the guide.
     *
     * @edt
     */

#Code:
    private void createGuide0(String title)
    {
        getController().createStandardGuide(title, null, false);
    }

#No. 4979
#File: E:\bishe\1\AbstractStressScript.java
#Comment:
    /**
     * Populates each guide from the guides set with <code>feedPerGuide</code> number of feeds.
     * Feeds are initialized from <code>urlTemplate</code> URL. In the URL <code>{rnd}</code>
     * is replaced with current feed sequential number, which is unique to current population
     * session. The <code>{items}</code> is replaced with <code>articlesPerFeed</code> value.
     * If <code>waitForInit</code> is set then the engine will wait for feeds initialization
     * (when articles are loaded) once per guide, meaning that it will populate the guide with
     * feeds and then wait for their complete initialization.
     *
     * @param feedsPerGuide     number of feeds to create per guide.
     * @param articlesPerFeed   number of articles per feed to generate.
     * @param urlTemplate       template of feed URL.
     * @param waitForInit       TRUE to wait for initialization of all feeds in the guide.
     */

#Code:
    protected void populateGuides(int feedsPerGuide, int articlesPerFeed, String urlTemplate,
        boolean waitForInit)
    {
        int feedNumber = 0;

        GuidesSet set = getModel().getGuidesSet();
//        synchronized (set)
//        {
            int count = set.getGuidesCount();
            for (int i = 0; i < count; i++)
            {
                populateGuide(set.getGuideAt(i), feedNumber, feedsPerGuide, articlesPerFeed,
                    urlTemplate, waitForInit);
                feedNumber += feedsPerGuide;
            }
//        }
    }

#No. 4980
#File: E:\bishe\1\AbstractStressScript.java
#Comment:
    /**
     * Populates the given guide with <code>feedsPerGuide</code> number of feeds. For detailed
     * description of options see {@link AbstractStressScript#populateGuides}.
     *
     * @param guide             guide to populate with feeds.
     * @param feedNumber        first feed sequential number.
     * @param feedsPerGuide     number of feeds to create in the guide.
     * @param articlesPerFeed   number of articles per feed to generate.
     * @param urlTemplate       template of feed URL.
     * @param waitForInit       TRUE to wait for initialization of all feeds in the guide.
     */

#Code:
    protected void populateGuide(IGuide guide, int feedNumber, int feedsPerGuide,
        int articlesPerFeed, String urlTemplate, boolean waitForInit)
    {
        getController().selectGuideAndFeed(guide);
        waitForPendingEvents();

        DirectFeed[] feeds = new DirectFeed[feedsPerGuide];
        for (int i = 0; i < feedsPerGuide; i++)
        {
            String feedUrl = expandTemplate(urlTemplate, feedNumber + i, articlesPerFeed);
            feeds[i] = getController().createDirectFeed(feedUrl, false);
        }

        if (waitForInit)
        {
            for (int i = 0; i < feeds.length; i++)
            {
                DirectFeed feed = feeds[i];
                if (!waitForInitialization(feed))
                {
                    throw new StressScriptException("Failed to initialize feed " +
                        "with URL: " + feed.getXmlURL());
                }
            }
        }
    }

#No. 4981
#File: E:\bishe\1\AbstractStressScript.java
#Comment:
    /**
     * Waits for feed initialization; checks every second.
     *
     * @param feed  feed to wait for.
     *
     * @return TRUE if not invalid.
     */

#Code:
    protected boolean waitForInitialization(DataFeed feed)
    {
        while (!feed.isInitialized() && !feed.isInvalid())
        {
            try
            {
                Thread.sleep(1000);
            } catch (InterruptedException e)
            {
            }
        }

        return !feed.isInvalid();
    }

#No. 4982
#File: E:\bishe\1\AbstractStressScript.java
#Comment:
    /**
     * Expands URL template by replacing <code>{rnd}</code> and <code>{items}</code> markers with
     * <code>aRnd</code> and <code>aItems</code>.
     *
     * @param urlTemplate       template.
     * @param aRnd              <code>{rnd}</code> replacement.
     * @param aItems            <code>{items}</code> replacement.
     *
     * @return prepared URL.
     */

#Code:
    private String expandTemplate(String urlTemplate, int aRnd, int aItems)
    {
        String text = urlTemplate;

        text = PAT_RANDOM.matcher(text).replaceAll(Integer.toString(aRnd));
        text = PAT_ITEMS.matcher(text).replaceAll(Integer.toString(aItems));

        return text;
    }

#No. 4983
#File: E:\bishe\1\AbstractStressScript.java
#Comment:
    /**
     * Marks all guides as (un)read.
     *
     * @param read TRUE if read.
     */

#Code:
    protected void markAllGuidesRead(boolean read)
    {
        getGuidesSet().setRead(read);

        waitForPendingEvents();
    }

#No. 4984
#File: E:\bishe\1\AbstractStressScript.java
#Comment:
    /**
     * Waits until all events in EDT queue scheduled by this moment are dispatched.
     */

#Code:
    protected void waitForPendingEvents()
    {
        try
        {
            SwingUtilities.invokeAndWait(new Runnable()
            {
                public void run()
                {
                    // Simply do noting
                }
            });
        } catch (Exception e)
        {
            throw new StressScriptException("Couldn't finish waiting for pending events " +
                "dispatching.", e);
        }
    }

#No. 4985
#File: E:\bishe\1\AbstractStressScript.java
#Comment:
    /**
     * Merges two guides.
     *
     * @param aGuide1   first guide (will be removed).
     * @param aGuide2   second guide.
     */

#Code:
    protected void mergeGuides(final StandardGuide aGuide1, final StandardGuide aGuide2)
    {
        if (UifUtilities.isEDT())
        {
            getController().mergeGuides(new IGuide[] { aGuide1 }, aGuide2);
        } else
        {
            try
            {
                SwingUtilities.invokeAndWait(new Runnable()
                {
                    public void run()
                    {
                        getController().mergeGuides(new IGuide[] { aGuide1 }, aGuide2);
                    }
                });
            } catch (Exception e)
            {
                throw new StressScriptException("Couldn't merge two guides: " + aGuide1 +
                    " and " + aGuide2, e);
            }
        }
    }

#No. 4986
#File: E:\bishe\1\AbstractStringBuilder.java
#Comment:
    /**
     * Returns the number of Unicode code points in the specified text
     * range of this sequence. The text range begins at the specified
     * <code>beginIndex</code> and extends to the <code>char</code> at
     * index <code>endIndex - 1</code>. Thus the length (in
     * <code>char</code>s) of the text range is
     * <code>endIndex-beginIndex</code>. Unpaired surrogates within
     * this sequence count as one code point each.
     *
     * @param beginIndex the index to the first <code>char</code> of
     * the text range.
     * @param endIndex the index after the last <code>char</code> of
     * the text range.
     * @return the number of Unicode code points in the specified text
     * range
     * @exception IndexOutOfBoundsException if the
     * <code>beginIndex</code> is negative, or <code>endIndex</code>
     * is larger than the length of this sequence, or
     * <code>beginIndex</code> is larger than <code>endIndex</code>.
     */

#Code:
    public int codePointCount(int beginIndex, int endIndex) {
        if (beginIndex < 0 || endIndex > count || beginIndex > endIndex) {
            throw new IndexOutOfBoundsException();
        }
        return Character.codePointCountImpl(value, beginIndex, endIndex-beginIndex);
    }

#No. 4987
#File: E:\bishe\1\AbstractStringBuilder.java
#Comment:
    /**
     * Returns the index within this sequence that is offset from the
     * given <code>index</code> by <code>codePointOffset</code> code
     * points. Unpaired surrogates within the text range given by
     * <code>index</code> and <code>codePointOffset</code> count as
     * one code point each.
     *
     * @param index the index to be offset
     * @param codePointOffset the offset in code points
     * @return the index within this sequence
     * @exception IndexOutOfBoundsException if <code>index</code>
     *   is negative or larger then the length of this sequence,
     *   or if <code>codePointOffset</code> is positive and the subsequence
     *   starting with <code>index</code> has fewer than
     *   <code>codePointOffset</code> code points,
     *   or if <code>codePointOffset</code> is negative and the subsequence
     *   before <code>index</code> has fewer than the absolute value of
     *   <code>codePointOffset</code> code points.
     */

#Code:
    public int offsetByCodePoints(int index, int codePointOffset) {
        if (index < 0 || index > count) {
            throw new IndexOutOfBoundsException();
        }
        return Character.offsetByCodePointsImpl(value, 0, count,
                                                index, codePointOffset);
    }

#No. 4988
#File: E:\bishe\1\AbstractStringBuilder.java
#Comment:
    /**
     * Characters are copied from this sequence into the
     * destination character array <code>dst</code>. The first character to
     * be copied is at index <code>srcBegin</code>; the last character to
     * be copied is at index <code>srcEnd-1</code>. The total number of
     * characters to be copied is <code>srcEnd-srcBegin</code>. The
     * characters are copied into the subarray of <code>dst</code> starting
     * at index <code>dstBegin</code> and ending at index:
     * <p><blockquote><pre>
     * dstbegin + (srcEnd-srcBegin) - 1
     * </pre></blockquote>
     *
     * @param      srcBegin   start copying at this offset.
     * @param      srcEnd     stop copying at this offset.
     * @param      dst        the array to copy the data into.
     * @param      dstBegin   offset into <code>dst</code>.
     * @throws     NullPointerException if <code>dst</code> is
     *             <code>null</code>.
     * @throws     IndexOutOfBoundsException  if any of the following is true:
     *             <ul>
     *             <li><code>srcBegin</code> is negative
     *             <li><code>dstBegin</code> is negative
     *             <li>the <code>srcBegin</code> argument is greater than
     *             the <code>srcEnd</code> argument.
     *             <li><code>srcEnd</code> is greater than
     *             <code>this.length()</code>.
     *             <li><code>dstBegin+srcEnd-srcBegin</code> is greater than
     *             <code>dst.length</code>
     *             </ul>
     */

#Code:
    public void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)
    {
        if (srcBegin < 0)
            throw new StringIndexOutOfBoundsException(srcBegin);
        if ((srcEnd < 0) || (srcEnd > count))
            throw new StringIndexOutOfBoundsException(srcEnd);
        if (srcBegin > srcEnd)
            throw new StringIndexOutOfBoundsException("srcBegin > srcEnd");
        System.arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin);
    }

#No. 4989
#File: E:\bishe\1\AbstractStringBuilder.java
#Comment:
    /**
     * The character at the specified index is set to <code>ch</code>. This
     * sequence is altered to represent a new character sequence that is
     * identical to the old character sequence, except that it contains the
     * character <code>ch</code> at position <code>index</code>.
     * <p>
     * The index argument must be greater than or equal to
     * <code>0</code>, and less than the length of this sequence.
     *
     * @param      index   the index of the character to modify.
     * @param      ch      the new character.
     * @throws     IndexOutOfBoundsException  if <code>index</code> is
     *             negative or greater than or equal to <code>length()</code>.
     */

#Code:
    public void setCharAt(int index, char ch) {
        if ((index < 0) || (index >= count))
            throw new StringIndexOutOfBoundsException(index);
        value[index] = ch;
    }

#No. 4990
#File: E:\bishe\1\AbstractStringBuilder.java
#Comment:
    /**
     * Appends the string representation of the {@code Object} argument.
     * <p>
     * The overall effect is exactly as if the argument were converted
     * to a string by the method {@link String#valueOf(Object)},
     * and the characters of that string were then
     * {@link #append(String) appended} to this character sequence.
     *
     * @param   obj   an {@code Object}.
     * @return  a reference to this object.
     */

#Code:
    public AbstractStringBuilder append(Object obj) {
        return append(String.valueOf(obj));
    }

#No. 4991
#File: E:\bishe\1\AbstractStringBuilder.java
#Comment:
    /**
     * Appends the specified string to this character sequence.
     * <p>
     * The characters of the {@code String} argument are appended, in
     * order, increasing the length of this sequence by the length of the
     * argument. If {@code str} is {@code null}, then the four
     * characters {@code "null"} are appended.
     * <p>
     * Let <i>n</i> be the length of this character sequence just prior to
     * execution of the {@code append} method. Then the character at
     * index <i>k</i> in the new character sequence is equal to the character
     * at index <i>k</i> in the old character sequence, if <i>k</i> is less
     * than <i>n</i>; otherwise, it is equal to the character at index
     * <i>k-n</i> in the argument {@code str}.
     *
     * @param   str   a string.
     * @return  a reference to this object.
     */

#Code:
    public AbstractStringBuilder append(String str) {
        if (str == null) str = "null";
        int len = str.length();
        ensureCapacityInternal(count + len);
        str.getChars(0, len, value, count);
        count += len;
        return this;
    }

#No. 4992
#File: E:\bishe\1\AbstractStringBuilder.java
#Comment:
    /**
     * Appends a subsequence of the specified {@code CharSequence} to this
     * sequence.
     * <p>
     * Characters of the argument {@code s}, starting at
     * index {@code start}, are appended, in order, to the contents of
     * this sequence up to the (exclusive) index {@code end}. The length
     * of this sequence is increased by the value of {@code end - start}.
     * <p>
     * Let <i>n</i> be the length of this character sequence just prior to
     * execution of the {@code append} method. Then the character at
     * index <i>k</i> in this character sequence becomes equal to the
     * character at index <i>k</i> in this sequence, if <i>k</i> is less than
     * <i>n</i>; otherwise, it is equal to the character at index
     * <i>k+start-n</i> in the argument {@code s}.
     * <p>
     * If {@code s} is {@code null}, then this method appends
     * characters as if the s parameter was a sequence containing the four
     * characters {@code "null"}.
     *
     * @param   s the sequence to append.
     * @param   start   the starting index of the subsequence to be appended.
     * @param   end     the end index of the subsequence to be appended.
     * @return  a reference to this object.
     * @throws     IndexOutOfBoundsException if
     *             {@code start} is negative, or
     *             {@code start} is greater than {@code end} or
     *             {@code end} is greater than {@code s.length()}
     */

#Code:
    public AbstractStringBuilder append(CharSequence s, int start, int end) {
        if (s == null)
            s = "null";
        if ((start < 0) || (start > end) || (end > s.length()))
            throw new IndexOutOfBoundsException(
                "start " + start + ", end " + end + ", s.length() "
                + s.length());
        int len = end - start;
        ensureCapacityInternal(count + len);
        for (int i = start, j = count; i < end; i++, j++)
            value[j] = s.charAt(i);
        count += len;
        return this;
    }

#No. 4993
#File: E:\bishe\1\AbstractStringBuilder.java
#Comment:
    /**
     * Appends the string representation of the {@code char} array
     * argument to this sequence.
     * <p>
     * The characters of the array argument are appended, in order, to
     * the contents of this sequence. The length of this sequence
     * increases by the length of the argument.
     * <p>
     * The overall effect is exactly as if the argument were converted
     * to a string by the method {@link String#valueOf(char[])},
     * and the characters of that string were then
     * {@link #append(String) appended} to this character sequence.
     *
     * @param   str   the characters to be appended.
     * @return  a reference to this object.
     */

#Code:
    public AbstractStringBuilder append(char[] str) {
        int len = str.length;
        ensureCapacityInternal(count + len);
        System.arraycopy(str, 0, value, count, len);
        count += len;
        return this;
    }

#No. 4994
#File: E:\bishe\1\AbstractStringBuilder.java
#Comment:
    /**
     * Appends the string representation of a subarray of the
     * {@code char} array argument to this sequence.
     * <p>
     * Characters of the {@code char} array {@code str}, starting at
     * index {@code offset}, are appended, in order, to the contents
     * of this sequence. The length of this sequence increases
     * by the value of {@code len}.
     * <p>
     * The overall effect is exactly as if the arguments were converted
     * to a string by the method {@link String#valueOf(char[],int,int)},
     * and the characters of that string were then
     * {@link #append(String) appended} to this character sequence.
     *
     * @param   str      the characters to be appended.
     * @param   offset   the index of the first {@code char} to append.
     * @param   len      the number of {@code char}s to append.
     * @return  a reference to this object.
     * @throws IndexOutOfBoundsException
     *         if {@code offset < 0} or {@code len < 0}
     *         or {@code offset+len > str.length}
     */

#Code:
    public AbstractStringBuilder append(char str[], int offset, int len) {
        if (len > 0)                // let arraycopy report AIOOBE for len < 0
            ensureCapacityInternal(count + len);
        System.arraycopy(str, offset, value, count, len);
        count += len;
        return this;
    }

#No. 4995
#File: E:\bishe\1\AbstractStringBuilder.java
#Comment:
    /**
     * Appends the string representation of the {@code boolean}
     * argument to the sequence.
     * <p>
     * The overall effect is exactly as if the argument were converted
     * to a string by the method {@link String#valueOf(boolean)},
     * and the characters of that string were then
     * {@link #append(String) appended} to this character sequence.
     *
     * @param   b   a {@code boolean}.
     * @return  a reference to this object.
     */

#Code:
    public AbstractStringBuilder append(boolean b) {
        if (b) {
            ensureCapacityInternal(count + 4);
            value[count++] = 't';
            value[count++] = 'r';
            value[count++] = 'u';
            value[count++] = 'e';
        } else {
            ensureCapacityInternal(count + 5);
            value[count++] = 'f';
            value[count++] = 'a';
            value[count++] = 'l';
            value[count++] = 's';
            value[count++] = 'e';
        }
        return this;
    }

#No. 4996
#File: E:\bishe\1\AbstractStringBuilder.java
#Comment:
    /**
     * Appends the string representation of the {@code char}
     * argument to this sequence.
     * <p>
     * The argument is appended to the contents of this sequence.
     * The length of this sequence increases by {@code 1}.
     * <p>
     * The overall effect is exactly as if the argument were converted
     * to a string by the method {@link String#valueOf(char)},
     * and the character in that string were then
     * {@link #append(String) appended} to this character sequence.
     *
     * @param   c   a {@code char}.
     * @return  a reference to this object.
     */

#Code:
    public AbstractStringBuilder append(char c) {
        ensureCapacityInternal(count + 1);
        value[count++] = c;
        return this;
    }

#No. 4997
#File: E:\bishe\1\AbstractStringBuilder.java
#Comment:
    /**
     * Appends the string representation of the {@code int}
     * argument to this sequence.
     * <p>
     * The overall effect is exactly as if the argument were converted
     * to a string by the method {@link String#valueOf(int)},
     * and the characters of that string were then
     * {@link #append(String) appended} to this character sequence.
     *
     * @param   i   an {@code int}.
     * @return  a reference to this object.
     */

#Code:
    public AbstractStringBuilder append(int i) {
        if (i == Integer.MIN_VALUE) {
            append("-2147483648");
            return this;
        }
        int appendedLength = (i < 0) ? Integer.stringSize(-i) + 1
                                     : Integer.stringSize(i);
        int spaceNeeded = count + appendedLength;
        ensureCapacityInternal(spaceNeeded);
        Integer.getChars(i, spaceNeeded, value);
        count = spaceNeeded;
        return this;
    }

#No. 4998
#File: E:\bishe\1\AbstractStringBuilder.java
#Comment:
    /**
     * Appends the string representation of the {@code long}
     * argument to this sequence.
     * <p>
     * The overall effect is exactly as if the argument were converted
     * to a string by the method {@link String#valueOf(long)},
     * and the characters of that string were then
     * {@link #append(String) appended} to this character sequence.
     *
     * @param   l   a {@code long}.
     * @return  a reference to this object.
     */

#Code:
    public AbstractStringBuilder append(long l) {
        if (l == Long.MIN_VALUE) {
            append("-9223372036854775808");
            return this;
        }
        int appendedLength = (l < 0) ? Long.stringSize(-l) + 1
                                     : Long.stringSize(l);
        int spaceNeeded = count + appendedLength;
        ensureCapacityInternal(spaceNeeded);
        Long.getChars(l, spaceNeeded, value);
        count = spaceNeeded;
        return this;
    }

#No. 4999
#File: E:\bishe\1\AbstractStringBuilder.java
#Comment:
    /**
     * Appends the string representation of the {@code float}
     * argument to this sequence.
     * <p>
     * The overall effect is exactly as if the argument were converted
     * to a string by the method {@link String#valueOf(float)},
     * and the characters of that string were then
     * {@link #append(String) appended} to this character sequence.
     *
     * @param   f   a {@code float}.
     * @return  a reference to this object.
     */

#Code:
    public AbstractStringBuilder append(float f) {
        new FloatingDecimal(f).appendTo(this);
        return this;
    }

#No. 5000
#File: E:\bishe\1\AbstractStringBuilder.java
#Comment:
    /**
     * Appends the string representation of the {@code double}
     * argument to this sequence.
     * <p>
     * The overall effect is exactly as if the argument were converted
     * to a string by the method {@link String#valueOf(double)},
     * and the characters of that string were then
     * {@link #append(String) appended} to this character sequence.
     *
     * @param   d   a {@code double}.
     * @return  a reference to this object.
     */

#Code:
    public AbstractStringBuilder append(double d) {
        new FloatingDecimal(d).appendTo(this);
        return this;
    }

#No. 5001
#File: E:\bishe\1\AbstractStringBuilder.java
#Comment:
    /**
     * Removes the characters in a substring of this sequence.
     * The substring begins at the specified {@code start} and extends to
     * the character at index {@code end - 1} or to the end of the
     * sequence if no such character exists. If
     * {@code start} is equal to {@code end}, no changes are made.
     *
     * @param      start  The beginning index, inclusive.
     * @param      end    The ending index, exclusive.
     * @return     This object.
     * @throws     StringIndexOutOfBoundsException  if {@code start}
     *             is negative, greater than {@code length()}, or
     *             greater than {@code end}.
     */

#Code:
    public AbstractStringBuilder delete(int start, int end) {
        if (start < 0)
            throw new StringIndexOutOfBoundsException(start);
        if (end > count)
            end = count;
        if (start > end)
            throw new StringIndexOutOfBoundsException();
        int len = end - start;
        if (len > 0) {
            System.arraycopy(value, start+len, value, start, count-end);
            count -= len;
        }
        return this;
    }

#No. 5002
#File: E:\bishe\1\AbstractStringBuilder.java
#Comment:
    /**
     * Appends the string representation of the {@code codePoint}
     * argument to this sequence.
     *
     * <p> The argument is appended to the contents of this sequence.
     * The length of this sequence increases by
     * {@link Character#charCount(int) Character.charCount(codePoint)}.
     *
     * <p> The overall effect is exactly as if the argument were
     * converted to a {@code char} array by the method
     * {@link Character#toChars(int)} and the character in that array
     * were then {@link #append(char[]) appended} to this character
     * sequence.
     *
     * @param   codePoint   a Unicode code point
     * @return  a reference to this object.
     * @exception IllegalArgumentException if the specified
     * {@code codePoint} isn't a valid Unicode code point
     */

#Code:
    public AbstractStringBuilder appendCodePoint(int codePoint) {
        final int count = this.count;

        if (Character.isBmpCodePoint(codePoint)) {
            ensureCapacityInternal(count + 1);
            value[count] = (char) codePoint;
            this.count = count + 1;
        } else if (Character.isValidCodePoint(codePoint)) {
            ensureCapacityInternal(count + 2);
            Character.toSurrogates(codePoint, value, count);
            this.count = count + 2;
        } else {
            throw new IllegalArgumentException();
        }
        return this;
    }

#No. 5003
#File: E:\bishe\1\AbstractStringBuilder.java
#Comment:
    /**
     * Removes the <code>char</code> at the specified position in this
     * sequence. This sequence is shortened by one <code>char</code>.
     *
     * <p>Note: If the character at the given index is a supplementary
     * character, this method does not remove the entire character. If
     * correct handling of supplementary characters is required,
     * determine the number of <code>char</code>s to remove by calling
     * <code>Character.charCount(thisSequence.codePointAt(index))</code>,
     * where <code>thisSequence</code> is this sequence.
     *
     * @param       index  Index of <code>char</code> to remove
     * @return      This object.
     * @throws      StringIndexOutOfBoundsException  if the <code>index</code>
     *              is negative or greater than or equal to
     *              <code>length()</code>.
     */

#Code:
    public AbstractStringBuilder deleteCharAt(int index) {
        if ((index < 0) || (index >= count))
            throw new StringIndexOutOfBoundsException(index);
        System.arraycopy(value, index+1, value, index, count-index-1);
        count--;
        return this;
    }

#No. 5004
#File: E:\bishe\1\AbstractStringBuilder.java
#Comment:
    /**
     * Replaces the characters in a substring of this sequence
     * with characters in the specified <code>String</code>. The substring
     * begins at the specified <code>start</code> and extends to the character
     * at index <code>end - 1</code> or to the end of the
     * sequence if no such character exists. First the
     * characters in the substring are removed and then the specified
     * <code>String</code> is inserted at <code>start</code>. (This
     * sequence will be lengthened to accommodate the
     * specified String if necessary.)
     *
     * @param      start    The beginning index, inclusive.
     * @param      end      The ending index, exclusive.
     * @param      str   String that will replace previous contents.
     * @return     This object.
     * @throws     StringIndexOutOfBoundsException  if <code>start</code>
     *             is negative, greater than <code>length()</code>, or
     *             greater than <code>end</code>.
     */

#Code:
    public AbstractStringBuilder replace(int start, int end, String str) {
        if (start < 0)
            throw new StringIndexOutOfBoundsException(start);
        if (start > count)
            throw new StringIndexOutOfBoundsException("start > length()");
        if (start > end)
            throw new StringIndexOutOfBoundsException("start > end");

        if (end > count)
            end = count;
        int len = str.length();
        int newCount = count + len - (end - start);
        ensureCapacityInternal(newCount);

        System.arraycopy(value, end, value, start + len, count - end);
        str.getChars(value, start);
        count = newCount;
        return this;
    }

#No. 5005
#File: E:\bishe\1\AbstractStringBuilder.java
#Comment:
    /**
     * Returns a new <code>String</code> that contains a subsequence of
     * characters currently contained in this character sequence. The
     * substring begins at the specified index and extends to the end of
     * this sequence.
     *
     * @param      start    The beginning index, inclusive.
     * @return     The new string.
     * @throws     StringIndexOutOfBoundsException  if <code>start</code> is
     *             less than zero, or greater than the length of this object.
     */

#Code:
    public String substring(int start) {
        return substring(start, count);
    }

#No. 5006
#File: E:\bishe\1\AbstractStringBuilder.java
#Comment:
    /**
     * Returns a new character sequence that is a subsequence of this sequence.
     *
     * <p> An invocation of this method of the form
     *
     * <blockquote><pre>
     * sb.subSequence(begin,&nbsp;end)</pre></blockquote>
     *
     * behaves in exactly the same way as the invocation
     *
     * <blockquote><pre>
     * sb.substring(begin,&nbsp;end)</pre></blockquote>
     *
     * This method is provided so that this class can
     * implement the {@link CharSequence} interface. </p>
     *
     * @param      start   the start index, inclusive.
     * @param      end     the end index, exclusive.
     * @return     the specified subsequence.
     *
     * @throws  IndexOutOfBoundsException
     *          if <tt>start</tt> or <tt>end</tt> are negative,
     *          if <tt>end</tt> is greater than <tt>length()</tt>,
     *          or if <tt>start</tt> is greater than <tt>end</tt>
     * @spec JSR-51
     */

#Code:
    public CharSequence subSequence(int start, int end) {
        return substring(start, end);
    }

#No. 5007
#File: E:\bishe\1\AbstractStringBuilder.java
#Comment:
    /**
     * Returns a new <code>String</code> that contains a subsequence of
     * characters currently contained in this sequence. The
     * substring begins at the specified <code>start</code> and
     * extends to the character at index <code>end - 1</code>.
     *
     * @param      start    The beginning index, inclusive.
     * @param      end      The ending index, exclusive.
     * @return     The new string.
     * @throws     StringIndexOutOfBoundsException  if <code>start</code>
     *             or <code>end</code> are negative or greater than
     *             <code>length()</code>, or <code>start</code> is
     *             greater than <code>end</code>.
     */

#Code:
    public String substring(int start, int end) {
        if (start < 0)
            throw new StringIndexOutOfBoundsException(start);
        if (end > count)
            throw new StringIndexOutOfBoundsException(end);
        if (start > end)
            throw new StringIndexOutOfBoundsException(end - start);
        return new String(value, start, end - start);
    }

#No. 5008
#File: E:\bishe\1\AbstractStringBuilder.java
#Comment:
    /**
     * Inserts the string representation of a subarray of the {@code str}
     * array argument into this sequence. The subarray begins at the
     * specified {@code offset} and extends {@code len} {@code char}s.
     * The characters of the subarray are inserted into this sequence at
     * the position indicated by {@code index}. The length of this
     * sequence increases by {@code len} {@code char}s.
     *
     * @param      index    position at which to insert subarray.
     * @param      str       A {@code char} array.
     * @param      offset   the index of the first {@code char} in subarray to
     *             be inserted.
     * @param      len      the number of {@code char}s in the subarray to
     *             be inserted.
     * @return     This object
     * @throws     StringIndexOutOfBoundsException  if {@code index}
     *             is negative or greater than {@code length()}, or
     *             {@code offset} or {@code len} are negative, or
     *             {@code (offset+len)} is greater than
     *             {@code str.length}.
     */

#Code:
    public AbstractStringBuilder insert(int index, char[] str, int offset,
                                        int len)
    {
        if ((index < 0) || (index > length()))
            throw new StringIndexOutOfBoundsException(index);
        if ((offset < 0) || (len < 0) || (offset > str.length - len))
            throw new StringIndexOutOfBoundsException(
                "offset " + offset + ", len " + len + ", str.length "
                + str.length);
        ensureCapacityInternal(count + len);
        System.arraycopy(value, index, value, index + len, count - index);
        System.arraycopy(str, offset, value, index, len);
        count += len;
        return this;
    }

#No. 5009
#File: E:\bishe\1\AbstractStringBuilder.java
#Comment:
    /**
     * Inserts the string representation of the {@code Object}
     * argument into this character sequence.
     * <p>
     * The overall effect is exactly as if the second argument were
     * converted to a string by the method {@link String#valueOf(Object)},
     * and the characters of that string were then
     * {@link #insert(int,String) inserted} into this character
     * sequence at the indicated offset.
     * <p>
     * The {@code offset} argument must be greater than or equal to
     * {@code 0}, and less than or equal to the {@linkplain #length() length}
     * of this sequence.
     *
     * @param      offset   the offset.
     * @param      obj      an {@code Object}.
     * @return     a reference to this object.
     * @throws     StringIndexOutOfBoundsException  if the offset is invalid.
     */

#Code:
    public AbstractStringBuilder insert(int offset, Object obj) {
        return insert(offset, String.valueOf(obj));
    }

#No. 5010
#File: E:\bishe\1\AbstractStringBuilder.java
#Comment:
    /**
     * Inserts the string into this character sequence.
     * <p>
     * The characters of the {@code String} argument are inserted, in
     * order, into this sequence at the indicated offset, moving up any
     * characters originally above that position and increasing the length
     * of this sequence by the length of the argument. If
     * {@code str} is {@code null}, then the four characters
     * {@code "null"} are inserted into this sequence.
     * <p>
     * The character at index <i>k</i> in the new character sequence is
     * equal to:
     * <ul>
     * <li>the character at index <i>k</i> in the old character sequence, if
     * <i>k</i> is less than {@code offset}
     * <li>the character at index <i>k</i>{@code -offset} in the
     * argument {@code str}, if <i>k</i> is not less than
     * {@code offset} but is less than {@code offset+str.length()}
     * <li>the character at index <i>k</i>{@code -str.length()} in the
     * old character sequence, if <i>k</i> is not less than
     * {@code offset+str.length()}
     * </ul><p>
     * The {@code offset} argument must be greater than or equal to
     * {@code 0}, and less than or equal to the {@linkplain #length() length}
     * of this sequence.
     *
     * @param      offset   the offset.
     * @param      str      a string.
     * @return     a reference to this object.
     * @throws     StringIndexOutOfBoundsException  if the offset is invalid.
     */

#Code:
    public AbstractStringBuilder insert(int offset, String str) {
        if ((offset < 0) || (offset > length()))
            throw new StringIndexOutOfBoundsException(offset);
        if (str == null)
            str = "null";
        int len = str.length();
        ensureCapacityInternal(count + len);
        System.arraycopy(value, offset, value, offset + len, count - offset);
        str.getChars(value, offset);
        count += len;
        return this;
    }

#No. 5011
#File: E:\bishe\1\AbstractStringBuilder.java
#Comment:
    /**
     * Inserts the string representation of the {@code char} array
     * argument into this sequence.
     * <p>
     * The characters of the array argument are inserted into the
     * contents of this sequence at the position indicated by
     * {@code offset}. The length of this sequence increases by
     * the length of the argument.
     * <p>
     * The overall effect is exactly as if the second argument were
     * converted to a string by the method {@link String#valueOf(char[])},
     * and the characters of that string were then
     * {@link #insert(int,String) inserted} into this character
     * sequence at the indicated offset.
     * <p>
     * The {@code offset} argument must be greater than or equal to
     * {@code 0}, and less than or equal to the {@linkplain #length() length}
     * of this sequence.
     *
     * @param      offset   the offset.
     * @param      str      a character array.
     * @return     a reference to this object.
     * @throws     StringIndexOutOfBoundsException  if the offset is invalid.
     */

#Code:
    public AbstractStringBuilder insert(int offset, char[] str) {
        if ((offset < 0) || (offset > length()))
            throw new StringIndexOutOfBoundsException(offset);
        int len = str.length;
        ensureCapacityInternal(count + len);
        System.arraycopy(value, offset, value, offset + len, count - offset);
        System.arraycopy(str, 0, value, offset, len);
        count += len;
        return this;
    }

#No. 5012
#File: E:\bishe\1\AbstractStringBuilder.java
#Comment:
    /**
     * Inserts the specified {@code CharSequence} into this sequence.
     * <p>
     * The characters of the {@code CharSequence} argument are inserted,
     * in order, into this sequence at the indicated offset, moving up
     * any characters originally above that position and increasing the length
     * of this sequence by the length of the argument s.
     * <p>
     * The result of this method is exactly the same as if it were an
     * invocation of this object's
     * {@link #insert(int,CharSequence,int,int) insert}(dstOffset, s, 0, s.length())
     * method.
     *
     * <p>If {@code s} is {@code null}, then the four characters
     * {@code "null"} are inserted into this sequence.
     *
     * @param      dstOffset   the offset.
     * @param      s the sequence to be inserted
     * @return     a reference to this object.
     * @throws     IndexOutOfBoundsException  if the offset is invalid.
     */

#Code:
    public AbstractStringBuilder insert(int dstOffset, CharSequence s) {
        if (s == null)
            s = "null";
        if (s instanceof String)
            return this.insert(dstOffset, (String)s);
        return this.insert(dstOffset, s, 0, s.length());
    }

#No. 5013
#File: E:\bishe\1\AbstractStringBuilder.java
#Comment:
    /**
     * Inserts a subsequence of the specified {@code CharSequence} into
     * this sequence.
     * <p>
     * The subsequence of the argument {@code s} specified by
     * {@code start} and {@code end} are inserted,
     * in order, into this sequence at the specified destination offset, moving
     * up any characters originally above that position. The length of this
     * sequence is increased by {@code end - start}.
     * <p>
     * The character at index <i>k</i> in this sequence becomes equal to:
     * <ul>
     * <li>the character at index <i>k</i> in this sequence, if
     * <i>k</i> is less than {@code dstOffset}
     * <li>the character at index <i>k</i>{@code +start-dstOffset} in
     * the argument {@code s}, if <i>k</i> is greater than or equal to
     * {@code dstOffset} but is less than {@code dstOffset+end-start}
     * <li>the character at index <i>k</i>{@code -(end-start)} in this
     * sequence, if <i>k</i> is greater than or equal to
     * {@code dstOffset+end-start}
     * </ul><p>
     * The {@code dstOffset} argument must be greater than or equal to
     * {@code 0}, and less than or equal to the {@linkplain #length() length}
     * of this sequence.
     * <p>The start argument must be nonnegative, and not greater than
     * {@code end}.
     * <p>The end argument must be greater than or equal to
     * {@code start}, and less than or equal to the length of s.
     *
     * <p>If {@code s} is {@code null}, then this method inserts
     * characters as if the s parameter was a sequence containing the four
     * characters {@code "null"}.
     *
     * @param      dstOffset   the offset in this sequence.
     * @param      s       the sequence to be inserted.
     * @param      start   the starting index of the subsequence to be inserted.
     * @param      end     the end index of the subsequence to be inserted.
     * @return     a reference to this object.
     * @throws     IndexOutOfBoundsException  if {@code dstOffset}
     *             is negative or greater than {@code this.length()}, or
     *              {@code start} or {@code end} are negative, or
     *              {@code start} is greater than {@code end} or
     *              {@code end} is greater than {@code s.length()}
     */

#Code:
     public AbstractStringBuilder insert(int dstOffset, CharSequence s,
                                         int start, int end) {
        if (s == null)
            s = "null";
        if ((dstOffset < 0) || (dstOffset > this.length()))
            throw new IndexOutOfBoundsException("dstOffset "+dstOffset);
        if ((start < 0) || (end < 0) || (start > end) || (end > s.length()))
            throw new IndexOutOfBoundsException(
                "start " + start + ", end " + end + ", s.length() "
                + s.length());
        int len = end - start;
        ensureCapacityInternal(count + len);
        System.arraycopy(value, dstOffset, value, dstOffset + len,
                         count - dstOffset);
        for (int i=start; i<end; i++)
            value[dstOffset++] = s.charAt(i);
        count += len;
        return this;
    }

#No. 5014
#File: E:\bishe\1\AbstractStringBuilder.java
#Comment:
    /**
     * Inserts the string representation of the {@code boolean}
     * argument into this sequence.
     * <p>
     * The overall effect is exactly as if the second argument were
     * converted to a string by the method {@link String#valueOf(boolean)},
     * and the characters of that string were then
     * {@link #insert(int,String) inserted} into this character
     * sequence at the indicated offset.
     * <p>
     * The {@code offset} argument must be greater than or equal to
     * {@code 0}, and less than or equal to the {@linkplain #length() length}
     * of this sequence.
     *
     * @param      offset   the offset.
     * @param      b        a {@code boolean}.
     * @return     a reference to this object.
     * @throws     StringIndexOutOfBoundsException  if the offset is invalid.
     */

#Code:
    public AbstractStringBuilder insert(int offset, boolean b) {
        return insert(offset, String.valueOf(b));
    }

#No. 5015
#File: E:\bishe\1\AbstractStringBuilder.java
#Comment:
    /**
     * Inserts the string representation of the {@code char}
     * argument into this sequence.
     * <p>
     * The overall effect is exactly as if the second argument were
     * converted to a string by the method {@link String#valueOf(char)},
     * and the character in that string were then
     * {@link #insert(int,String) inserted} into this character
     * sequence at the indicated offset.
     * <p>
     * The {@code offset} argument must be greater than or equal to
     * {@code 0}, and less than or equal to the {@linkplain #length() length}
     * of this sequence.
     *
     * @param      offset   the offset.
     * @param      c        a {@code char}.
     * @return     a reference to this object.
     * @throws     IndexOutOfBoundsException  if the offset is invalid.
     */

#Code:
    public AbstractStringBuilder insert(int offset, char c) {
        ensureCapacityInternal(count + 1);
        System.arraycopy(value, offset, value, offset + 1, count - offset);
        value[offset] = c;
        count += 1;
        return this;
    }

#No. 5016
#File: E:\bishe\1\AbstractStringBuilder.java
#Comment:
    /**
     * Inserts the string representation of the second {@code int}
     * argument into this sequence.
     * <p>
     * The overall effect is exactly as if the second argument were
     * converted to a string by the method {@link String#valueOf(int)},
     * and the characters of that string were then
     * {@link #insert(int,String) inserted} into this character
     * sequence at the indicated offset.
     * <p>
     * The {@code offset} argument must be greater than or equal to
     * {@code 0}, and less than or equal to the {@linkplain #length() length}
     * of this sequence.
     *
     * @param      offset   the offset.
     * @param      i        an {@code int}.
     * @return     a reference to this object.
     * @throws     StringIndexOutOfBoundsException  if the offset is invalid.
     */

#Code:
    public AbstractStringBuilder insert(int offset, int i) {
        return insert(offset, String.valueOf(i));
    }

#No. 5017
#File: E:\bishe\1\AbstractStringBuilder.java
#Comment:
    /**
     * Inserts the string representation of the {@code long}
     * argument into this sequence.
     * <p>
     * The overall effect is exactly as if the second argument were
     * converted to a string by the method {@link String#valueOf(long)},
     * and the characters of that string were then
     * {@link #insert(int,String) inserted} into this character
     * sequence at the indicated offset.
     * <p>
     * The {@code offset} argument must be greater than or equal to
     * {@code 0}, and less than or equal to the {@linkplain #length() length}
     * of this sequence.
     *
     * @param      offset   the offset.
     * @param      l        a {@code long}.
     * @return     a reference to this object.
     * @throws     StringIndexOutOfBoundsException  if the offset is invalid.
     */

#Code:
    public AbstractStringBuilder insert(int offset, long l) {
        return insert(offset, String.valueOf(l));
    }

#No. 5018
#File: E:\bishe\1\AbstractStringBuilder.java
#Comment:
    /**
     * Inserts the string representation of the {@code float}
     * argument into this sequence.
     * <p>
     * The overall effect is exactly as if the second argument were
     * converted to a string by the method {@link String#valueOf(float)},
     * and the characters of that string were then
     * {@link #insert(int,String) inserted} into this character
     * sequence at the indicated offset.
     * <p>
     * The {@code offset} argument must be greater than or equal to
     * {@code 0}, and less than or equal to the {@linkplain #length() length}
     * of this sequence.
     *
     * @param      offset   the offset.
     * @param      f        a {@code float}.
     * @return     a reference to this object.
     * @throws     StringIndexOutOfBoundsException  if the offset is invalid.
     */

#Code:
    public AbstractStringBuilder insert(int offset, float f) {
        return insert(offset, String.valueOf(f));
    }

#No. 5019
#File: E:\bishe\1\AbstractStringBuilder.java
#Comment:
    /**
     * Inserts the string representation of the {@code double}
     * argument into this sequence.
     * <p>
     * The overall effect is exactly as if the second argument were
     * converted to a string by the method {@link String#valueOf(double)},
     * and the characters of that string were then
     * {@link #insert(int,String) inserted} into this character
     * sequence at the indicated offset.
     * <p>
     * The {@code offset} argument must be greater than or equal to
     * {@code 0}, and less than or equal to the {@linkplain #length() length}
     * of this sequence.
     *
     * @param      offset   the offset.
     * @param      d        a {@code double}.
     * @return     a reference to this object.
     * @throws     StringIndexOutOfBoundsException  if the offset is invalid.
     */

#Code:
    public AbstractStringBuilder insert(int offset, double d) {
        return insert(offset, String.valueOf(d));
    }

#No. 5020
#File: E:\bishe\1\AbstractStringBuilder.java
#Comment:
    /**
     * Returns the index within this string of the first occurrence of the
     * specified substring. The integer returned is the smallest value
     * <i>k</i> such that:
     * <blockquote><pre>
     * this.toString().startsWith(str, <i>k</i>)
     * </pre></blockquote>
     * is <code>true</code>.
     *
     * @param   str   any string.
     * @return  if the string argument occurs as a substring within this
     *          object, then the index of the first character of the first
     *          such substring is returned; if it does not occur as a
     *          substring, <code>-1</code> is returned.
     * @throws  java.lang.NullPointerException if <code>str</code> is
     *          <code>null</code>.
     */

#Code:
    public int indexOf(String str) {
        return indexOf(str, 0);
    }

#No. 5021
#File: E:\bishe\1\AbstractStringBuilder.java
#Comment:
    /**
     * Returns the index within this string of the first occurrence of the
     * specified substring, starting at the specified index.  The integer
     * returned is the smallest value <tt>k</tt> for which:
     * <blockquote><pre>
     *     k >= Math.min(fromIndex, this.length()) &&
     *                   this.toString().startsWith(str, k)
     * </pre></blockquote>
     * If no such value of <i>k</i> exists, then -1 is returned.
     *
     * @param   str         the substring for which to search.
     * @param   fromIndex   the index from which to start the search.
     * @return  the index within this string of the first occurrence of the
     *          specified substring, starting at the specified index.
     * @throws  java.lang.NullPointerException if <code>str</code> is
     *            <code>null</code>.
     */

#Code:
    public int indexOf(String str, int fromIndex) {
        return String.indexOf(value, 0, count,
                              str.toCharArray(), 0, str.length(), fromIndex);
    }

#No. 5022
#File: E:\bishe\1\AbstractStringBuilder.java
#Comment:
    /**
     * Returns the index within this string of the rightmost occurrence
     * of the specified substring.  The rightmost empty string "" is
     * considered to occur at the index value <code>this.length()</code>.
     * The returned index is the largest value <i>k</i> such that
     * <blockquote><pre>
     * this.toString().startsWith(str, k)
     * </pre></blockquote>
     * is true.
     *
     * @param   str   the substring to search for.
     * @return  if the string argument occurs one or more times as a substring
     *          within this object, then the index of the first character of
     *          the last such substring is returned. If it does not occur as
     *          a substring, <code>-1</code> is returned.
     * @throws  java.lang.NullPointerException  if <code>str</code> is
     *          <code>null</code>.
     */

#Code:
    public int lastIndexOf(String str) {
        return lastIndexOf(str, count);
    }

#No. 5023
#File: E:\bishe\1\AbstractStringBuilder.java
#Comment:
    /**
     * Returns the index within this string of the last occurrence of the
     * specified substring. The integer returned is the largest value <i>k</i>
     * such that:
     * <blockquote><pre>
     *     k <= Math.min(fromIndex, this.length()) &&
     *                   this.toString().startsWith(str, k)
     * </pre></blockquote>
     * If no such value of <i>k</i> exists, then -1 is returned.
     *
     * @param   str         the substring to search for.
     * @param   fromIndex   the index to start the search from.
     * @return  the index within this sequence of the last occurrence of the
     *          specified substring.
     * @throws  java.lang.NullPointerException if <code>str</code> is
     *          <code>null</code>.
     */

#Code:
    public int lastIndexOf(String str, int fromIndex) {
        return String.lastIndexOf(value, 0, count,
                              str.toCharArray(), 0, str.length(), fromIndex);
    }

#No. 5024
#File: E:\bishe\1\AbstractStringBuilder.java
#Comment:
    /**
     * Causes this character sequence to be replaced by the reverse of
     * the sequence. If there are any surrogate pairs included in the
     * sequence, these are treated as single characters for the
     * reverse operation. Thus, the order of the high-low surrogates
     * is never reversed.
     *
     * Let <i>n</i> be the character length of this character sequence
     * (not the length in <code>char</code> values) just prior to
     * execution of the <code>reverse</code> method. Then the
     * character at index <i>k</i> in the new character sequence is
     * equal to the character at index <i>n-k-1</i> in the old
     * character sequence.
     *
     * <p>Note that the reverse operation may result in producing
     * surrogate pairs that were unpaired low-surrogates and
     * high-surrogates before the operation. For example, reversing
     * "&#92;uDC00&#92;uD800" produces "&#92;uD800&#92;uDC00" which is
     * a valid surrogate pair.
     *
     * @return  a reference to this object.
     */

#Code:
    public AbstractStringBuilder reverse() {
        boolean hasSurrogate = false;
        int n = count - 1;
        for (int j = (n-1) >> 1; j >= 0; --j) {
            char temp = value[j];
            char temp2 = value[n - j];
            if (!hasSurrogate) {
                hasSurrogate = (temp >= Character.MIN_SURROGATE && temp <= Character.MAX_SURROGATE)
                    || (temp2 >= Character.MIN_SURROGATE && temp2 <= Character.MAX_SURROGATE);
            }
            value[j] = temp2;
            value[n - j] = temp;
        }
        if (hasSurrogate) {
            // Reverse back all valid surrogate pairs
            for (int i = 0; i < count - 1; i++) {
                char c2 = value[i];
                if (Character.isLowSurrogate(c2)) {
                    char c1 = value[i + 1];
                    if (Character.isHighSurrogate(c1)) {
                        value[i++] = c1;
                        value[i] = c2;
                    }
                }
            }
        }
        return this;
    }

#No. 5025
#File: E:\bishe\1\AbstractStringBuilder.java
#Comment:
    /**
     * Returns a string representing the data in this sequence.
     * A new <code>String</code> object is allocated and initialized to
     * contain the character sequence currently represented by this
     * object. This <code>String</code> is then returned. Subsequent
     * changes to this sequence do not affect the contents of the
     * <code>String</code>.
     *
     * @return  a string representation of this sequence of characters.
     */

#Code:
    public abstract String toString();

    /**
     * Needed by <tt>String</tt> for the contentEquals method.
     */
    final char[] getValue() {
        return value;
    }

#No. 5026
#File: E:\bishe\1\AbstractStringColumnDataParser.java
#Comment:
    /**
     * 当前字段是否是string
     *
     * @param meta 字段元数据
     *
     * @return boolean
     */

#Code:
    protected boolean isString(ColumnMeta meta) {
        String columnType = meta.getGeneralColumnType().toLowerCase();
        if (columnType.endsWith("text")
                || columnType.endsWith("char")) {
            return true;
        }
        return false;
    }

#No. 5027
#File: E:\bishe\1\AbstractStringColumnDataParser.java
#Comment:
    /**
     * 字段映射到java的类型
     *
     * @param meta 字段元数据
     *
     * @return java类型
     */

#Code:
    protected int getStringJavaType(ColumnMeta meta) {
        String columnType = meta.getColumnType().toLowerCase();
        if (columnType.endsWith("text")) {
            return Types.LONGVARCHAR;
        }
        if (columnType.equals("char")) {
            return Types.CHAR;
        }
        return Types.VARCHAR;
    }

#No. 5028
#File: E:\bishe\1\AbstractStringColumnDataParser.java
#Comment:
    /**
     * 获取字符串值
     *
     * @param buf  bytes
     * @param meta 字段元数据
     *
     * @return string value
     */

#Code:
    protected String getString(ByteBuffer buf, ColumnMeta meta) {
        if (null != meta.getShortCharset()) {
            return UnsignedNumberHelper.convertByteArray2String(parseByteArray(buf, meta),
                    CharsetSupport.convertDbCharset2Java(meta.getShortCharset()));
        } else {
            return UnsignedNumberHelper.convertByteArray2String(parseByteArray(buf, meta));
        }
    }

#No. 5029
#File: E:\bishe\1\AbstractStringColumnDataParser.java
#Comment:
    /**
     * 从ByteBuffer解析有效bytes
     *
     * @param buf  ByteBuffer
     * @param meta 字段元数据
     *
     * @return 有效bytes
     */

#Code:
    protected byte[] parseByteArray(ByteBuffer buf, ColumnMeta meta) {
        return MysqlValueHelper.getFixedBytes(buf, getPayloadLen(buf, meta));
    }

#No. 5030
#File: E:\bishe\1\AbstractStrongCache.java
#Comment:
    /**
     * call this method, you should make sure has initialized cache
     *
     * @return 更新操作是否有更改
     * 如果是删除操作, 看原先是否为null,如果就是null活着不存在,则认为没有更改,返回false
     * 如果是更新操作, 看原先两者是不是{@link Objects#equals(Object, Object)}
     */

#Code:
    protected boolean updateValue(K key, V val) {
        if (cache == null) return false;
        V before;
        if (val == null) {
            before = cache.remove(key);
        } else {
            before = cache.put(key, val);
        }
        return !Objects.equals(val, before);
    }

#No. 5031
#File: E:\bishe\1\AbstractStrongCache.java
#Comment:
    /**
     * 返回值保证不为null
     */

#Code:
    @Override
    public final Map<K, V> getAllCache() {
        if (cache == null) {
            init();
        }
        return Collections.unmodifiableMap(cache);
    }

#No. 5032
#File: E:\bishe\1\AbstractStrongCache.java
#Comment:
    /**
     * 提供reload 函数
     */

#Code:
    @Override
    public final synchronized int reload() {
        clear();
        return init();
    }

#No. 5033
#File: E:\bishe\1\AbstractSTRtree.java
#Comment:
  /**
   * Sorts the childBoundables then divides them into groups of size M, where
   * M is the node capacity.
   */

#Code:
  protected List createParentBoundables(List childBoundables, int newLevel) {
    Assert.isTrue(!childBoundables.isEmpty());
    ArrayList parentBoundables = new ArrayList();
    parentBoundables.add(createNode(newLevel));
    ArrayList sortedChildBoundables = new ArrayList(childBoundables);
    Collections.sort(sortedChildBoundables, getComparator());
    for (Iterator i = sortedChildBoundables.iterator(); i.hasNext(); ) {
      Boundable childBoundable = (Boundable) i.next();
      if (lastNode(parentBoundables).getChildBoundables().size() == getNodeCapacity()) {
        parentBoundables.add(createNode(newLevel));
      }
      lastNode(parentBoundables).addChildBoundable(childBoundable);
    }
    return parentBoundables;
  }

#No. 5034
#File: E:\bishe\1\AbstractSTRtree.java
#Comment:
  /**
   * Creates the levels higher than the given level
   *
   * @param boundablesOfALevel
   *            the level to build on
   * @param level
   *            the level of the Boundables, or -1 if the boundables are item
   *            boundables (that is, below level 0)
   * @return the root, which may be a ParentNode or a LeafNode
   */

#Code:
  private AbstractNode createHigherLevels(List boundablesOfALevel, int level) {
    Assert.isTrue(!boundablesOfALevel.isEmpty());
    List parentBoundables = createParentBoundables(boundablesOfALevel, level + 1);
    if (parentBoundables.size() == 1) {
      return (AbstractNode) parentBoundables.get(0);
    }
    return createHigherLevels(parentBoundables, level + 1);
  }

#No. 5035
#File: E:\bishe\1\AbstractSTRtree.java
#Comment:
  /**
   * Gets a tree structure (as a nested list) 
   * corresponding to the structure of the items and nodes in this tree.
   * <p>
   * The returned {@link List}s contain either {@link Object} items, 
   * or Lists which correspond to subtrees of the tree
   * Subtrees which do not contain any items are not included.
   * <p>
   * Builds the tree if necessary.
   * 
   * @return a List of items and/or Lists
   */

#Code:
  public List itemsTree()
  {
    if (!built) { build(); }

    List valuesTree = itemsTree(root);
    if (valuesTree == null)
      return new ArrayList();
    return valuesTree;
  }

#No. 5036
#File: E:\bishe\1\AbstractSTRtree.java
#Comment:
  /**
   * Removes an item from the tree.
   * (Builds the tree, if necessary.)
   */

#Code:
  protected boolean remove(Object searchBounds, Object item) {
    if (!built) { build(); }
    if (itemBoundables.isEmpty()) {
      Assert.isTrue(root.getBounds() == null);
    }
    if (getIntersectsOp().intersects(root.getBounds(), searchBounds)) {
      return remove(searchBounds, root, item);
    }
    return false;
  }

#No. 5037
#File: E:\bishe\1\AbstractSTRtree.java
#Comment:
  /**
   * @param level -1 to get items
   */

#Code:
  private void boundablesAtLevel(int level, AbstractNode top, Collection boundables) {
    Assert.isTrue(level > -2);
    if (top.getLevel() == level) {
      boundables.add(top);
      return;
    }
    for (Iterator i = top.getChildBoundables().iterator(); i.hasNext(); ) {
      Boundable boundable = (Boundable) i.next();
      if (boundable instanceof AbstractNode) {
        boundablesAtLevel(level, (AbstractNode)boundable, boundables);
      }
      else {
        Assert.isTrue(boundable instanceof ItemBoundable);
        if (level == -1) { boundables.add(boundable); }
      }
    }
    return;
  }

#No. 5038
#File: E:\bishe\1\AbstractStructuredOutput.java
#Comment:
        /**
         * Finally creates the tag or object with the given name and attributes.
         */

#Code:
        public void build() {
            beginObject(name, attributes.toArray(new Attribute[attributes.size()]));
        }

#No. 5039
#File: E:\bishe\1\AbstractStructuredOutput.java
#Comment:
    /**
     * Creates a new object using the returned tag builder
     *
     * @param name the name of the object to create
     * @return a tag builder to fluently create a new object
     */

#Code:
    @CheckReturnValue
    public TagBuilder buildObject(@Nonnull String name) {
        return new TagBuilder(name);
    }

    @Override
    public StructuredOutput endArray() {
        if (nesting.isEmpty()) {
            throw new IllegalArgumentException("Invalid result structure. No array to close");
        }
        Element e = nesting.get(0);
        nesting.remove(0);
        if (e.getType() != ElementType.ARRAY) {
            throw new IllegalArgumentException("Invalid result structure. No array to close");
        }
        endArray(e.getName());
        return this;
    }

#No. 5040
#File: E:\bishe\1\AbstractStyleEditorDialog.java
#Comment:
	/**
	 * Initialize and display the SWT shell. This is a blocking call.
	 */

#Code:
	public void open() {
		Shell shell = new Shell(getParent(), getStyle());
		shell.setImage(GUIHelper.getImage("preferences"));
		shell.setText(getText());

		initComponents(shell);
		createButtons(shell);

		shell.pack();
		shell.open();
		Display display = shell.getDisplay();
		while (!shell.isDisposed()) {
			if (!display.readAndDispatch())
				display.sleep();
		}
	}

#No. 5041
#File: E:\bishe\1\AbstractStylesheet.java
#Comment:
    /**
     * Parses the stylesheet and applies.
     *
     * @param newSS new stylesheet text.
     */

#Code:
    protected void applyChanges(String newSS)
    {
        rules = Parser.parse(newSS);
    }

#No. 5042
#File: E:\bishe\1\AbstractStylesheet.java
#Comment:
    /**
     * Returns the font for the element with the given set of classes.
     *
     * @param el        element.
     * @param classes   classes.
     *
     * @return the font object or <code>NULL</code> if the default should be used.
     */

#Code:
    public Font getFont(String el, String[] classes)
    {
        return getRule(el, classes).getFont();
    }

#No. 5043
#File: E:\bishe\1\AbstractStylesheet.java
#Comment:
    /**
     * Returns the color for the element with the given set of classes.
     *
     * @param el        element.
     * @param classes   classes.
     *
     * @return the color or <code>NULL</code> if the default should be used.
     */

#Code:
    public Color getColor(String el, String[] classes)
    {
        return getRule(el, classes).getColor();
    }

#No. 5044
#File: E:\bishe\1\AbstractStylesheet.java
#Comment:
    /**
     * Returns the icon for the element with the given set of classes.
     *
     * @param el        element.
     * @param classes   classes.
     *
     * @return the icon or <code>NULL</code> if the default should be used.
     *
     * @throws IOException if loading of icon failed.
     */

#Code:
    public Icon getIcon(String el, String[] classes)
        throws IOException
    {
        IRule rule = getRule(el, classes);
        return rule != null ? rule.getIcon() : null;
    }

#No. 5045
#File: E:\bishe\1\AbstractStylesheet.java
#Comment:
    /**
     * Returns base URL of this stylesheet to resolveURI relative icon addresses (can be <code>NULL</code>).
     *
     * @return base URL.
     */

#Code:
    protected URL getStylesheetBaseURL()
    {
        return null;
    }

#No. 5046
#File: E:\bishe\1\AbstractStylesheet.java
#Comment:
    /**
     * Returns the loader to use.
     *
     * @return loader.
     */

#Code:
    protected ILoader getLoader()
    {
        return DEFAULT_LOADER;
    }

#No. 5047
#File: E:\bishe\1\AbstractStylesheet.java
#Comment:
    /**
     * Returns the consolidated rule for the given set of classes.
     *
     * @param el        element.
     * @param classes   classes.
     *
     * @return rule.
     */

#Code:
    public IRule getRule(String el, String[] classes)
    {
        IRule rule;

        if (classes == null || classes.length == 0)
        {
            rule = getRule(el);
        } else
        {
            IRule rootClass;
            IRule elemDef, elemClass;

            Map rootClasses = getElementClasses(null, false);

            // Get root rules
            rule = getRule(rootClasses, null);
            for (int i = 0; i < classes.length; i++)
            {
                rootClass = getRule(rootClasses, classes[i]);
                rule = rule.overrideWith(rootClass);
            }

            // Get element rules
            if (el != null)
            {
                Map elemClasses = getElementClasses(el, false);
                elemDef = getRule(elemClasses, null);
                rule = rule.overrideWith(elemDef);
                for (int i = 0; i < classes.length; i++)
                {
                    elemClass = getRule(elemClasses, classes[i]);
                    rule = rule.overrideWith(elemClass);
                }
            }
        }

        return rule == null ? null : new AutoImageRule(rule);
    }

#No. 5048
#File: E:\bishe\1\AbstractStylesheet.java
#Comment:
    /**
     * Gets no-class rule.
     *
     * @param el element.
     *
     * @return rule.
     */

#Code:
    private IRule getRule(String el)
    {
        IRule rule;

        Map rootClasses = getElementClasses(null, false);

        // Get root rules
        rule = getRule(rootClasses, null);

        // Get element rules
        if (el != null)
        {
            Map elemClasses = getElementClasses(el, false);
            rule = rule.overrideWith(getRule(elemClasses, null));
        }

        return rule;
    }

#No. 5049
#File: E:\bishe\1\AbstractStylesheet.java
#Comment:
    /**
     * Takes the rule from the classes. If classes are not defined, or the rule isn't set,
     * the result will be <code>EMPTY_RULE</code>.
     *
     * @param classes   classes map for some element.
     * @param clazz     class name.
     *
     * @return rule.
     */

#Code:
    private IRule getRule(Map classes, String clazz)
    {
        IRule rule = null;
        if (classes != null)
        {
            rule = (IRule)classes.get(clazz);
        }

        return rule == null ? EMPTY_RULE : rule;
    }

#No. 5050
#File: E:\bishe\1\AbstractStylesheet.java
#Comment:
    /**
     * Returns the element classes to rules map.
     *
     * @param el                element.
     * @param createIfMissing   when <code>TRUE</code> and the map is missing, it's created.
     *
     * @return map.
     */

#Code:
    private Map getElementClasses(String el, boolean createIfMissing)
    {
        Map m = (Map)rules.get(el);

        if (m == null && createIfMissing)
        {
            m = new HashMap();
            rules.put(el, m);
        }

        return m;
    }

#No. 5051
#File: E:\bishe\1\AbstractStylesheet.java
#Comment:
    /**
     * Resets the cache.
     */

#Code:
    public void resetIconsCache()
    {
        synchronized (cachedIcons)
        {
            cachedIcons.clear();
        }
    }

#No. 5052
#File: E:\bishe\1\AbstractSubscribeManager.java
#Comment:
    /**
     * 当同一个 dataId-groupId 的callback 被清楚完成之后的动作。同于同一个 dataId-groupId，此方法不会并发
     * 
     * @param dataId
     * @param groupId
     * @param callback
     */

#Code:
    protected void doWhenCallbackEmpty(String dataId, String groupId, SubscribeCallback callback) {
        // for subclass to close some resources
    }

#No. 5053
#File: E:\bishe\1\AbstractSubscribeManager.java
#Comment:
    /**
     * 注册监听器之后的方法，同于同一个 dataId-groupId，此方法不会并发
     * 
     * @param dataId
     * @param groupId
     * @param callback
     */

#Code:
    protected void postRegisterCallback(String dataId, String groupId, SubscribeCallback callback) {
        // for subclass to extend
    }

#No. 5054
#File: E:\bishe\1\AbstractSuggestionCursorWrapper.java
#Comment:
/**
 * A SuggestionCursor that delegates all calls to other suggestions.
 */

#Code:
public abstract class AbstractSuggestionCursorWrapper extends AbstractSuggestionWrapper
        implements SuggestionCursor {

    private final String mUserQuery;

    public AbstractSuggestionCursorWrapper(String userQuery) {
        mUserQuery = userQuery;
    }

    public String getUserQuery() {
        return mUserQuery;
    }
}

#No. 5055
#File: E:\bishe\1\AbstractSuperGuiComponent.java
#Comment:
	/**
	 * <p>Constructor for AbstractSuperGuiComponent.</p>
	 *
	 * @param parent a {@link lupos.gui.operatorgraph.OperatorGraph} object.
	 * @param gw a {@link lupos.gui.operatorgraph.graphwrapper.GraphWrapper} object.
	 * @param movable a boolean.
	 */

#Code:
	protected AbstractSuperGuiComponent(OperatorGraph parent, GraphWrapper gw, boolean movable) {
		this.parent = parent;
		this.gw = gw;
		this.movable = movable;

		this.setOpaque(false);
		this.setBorder(new EmptyBorder(1, 1, 1, 1));
		this.addMouseListener(this);
		this.addMouseMotionListener(this);
	}

#No. 5056
#File: E:\bishe\1\AbstractSuperGuiComponent.java
#Comment:
	/**
	 * <p>Getter for the field <code>box</code>.</p>
	 *
	 * @return a {@link lupos.gui.operatorgraph.GraphBox} object.
	 */

#Code:
	public GraphBox getBox() {
		if(this.box == null) { // if the box does not exist...
			this.box = this.parent.getBoxes().get(this.gw); // get it from the parent
		}

		return this.box; // return the box
	}

#No. 5057
#File: E:\bishe\1\AbstractSuperGuiComponent.java
#Comment:
	/**
	 * This method checks whether the given panel is overlapping with this one
	 * or other way round.
	 *
	 * @param panel
	 *            the panel to check with
	 * @return true if the two panels overlap, otherwise false
	 */

#Code:
	public boolean isOverlapping(AbstractSuperGuiComponent panel) {
		return this.overlaps(panel) || panel.overlaps(this);
	}

#No. 5058
#File: E:\bishe\1\AbstractSuperGuiComponent.java
#Comment:
	/**
	 * This method checks if the given panel is overlapping with this one.
	 *
	 * @param panel the panel to check with
	 * @return a boolean.
	 */

#Code:
	protected boolean overlaps(AbstractSuperGuiComponent panel) {
		Point topLeft = panel.getLocation();
		Dimension size = panel.getPreferredSize();

		// check all four corners of the given panel. if one of them lies in this panel. return true, else return false...
		return this.isIn(topLeft.x, topLeft.y) || this.isIn(topLeft.x + size.width, topLeft.y) || this.isIn(topLeft.x, topLeft.y + size.height) || this.isIn(topLeft.x + size.width, topLeft.y + size.height);
	}

#No. 5059
#File: E:\bishe\1\AbstractSuperGuiComponent.java
#Comment:
	/**
	 * Checks whether a point is in this panel.
	 *
	 * @param x the x coordinate of the point to check
	 * @param y the y coordinate of the point to check
	 * @return a boolean.
	 */

#Code:
	protected boolean isIn(int x, int y) {
		Point topLeft = this.getLocation();
		Dimension size = this.getPreferredSize();

		// point is between left and right edge of the panel...
		if(topLeft.x <= x && x <= topLeft.x + size.width) {
			// point is between top and bottom edge of the panel...
			if(topLeft.y <= y && y <= topLeft.y + size.height) {
				return true;
			}
		}

		return false;
	}

#No. 5060
#File: E:\bishe\1\AbstractSuperGuiComponent.java
#Comment:
	/**
	 * <p>Setter for the field <code>movable</code>.</p>
	 *
	 * @param movable a boolean.
	 */

#Code:
	public void setMovable(boolean movable) {
		this.movable = movable;
	}

#No. 5061
#File: E:\bishe\1\AbstractSuperGuiComponent.java
#Comment:
	/**
	 * <p>isAnnotation.</p>
	 *
	 * @return a boolean.
	 */

#Code:
	public boolean isAnnotation() {
		return !this.movable;
	}

#No. 5062
#File: E:\bishe\1\AbstractSuperGuiComponent.java
#Comment:
	/**
	 * <p>getMyBorder.</p>
	 *
	 * @return a {@link javax.swing.border.Border} object.
	 */

#Code:
	public Border getMyBorder() {
		return this.border;
	}

#No. 5063
#File: E:\bishe\1\AbstractSuperGuiComponent.java
#Comment:
	/**
	 * <p>setBorderNoRemember.</p>
	 *
	 * @param border a {@link javax.swing.border.Border} object.
	 */

#Code:
	public void setBorderNoRemember(Border border) {
		super.setBorder(border);
	}

#No. 5064
#File: E:\bishe\1\AbstractSwingFilter.java
#Comment:
    /**
     * Invoked when tag detected.
     *
     * @param name     name of tag.
     * @param full     full tag text.
     * @param closeTag TRUE if tag is closing tag.
     */

#Code:
    public void onTag(String name, String full, boolean closeTag)
    {
        if ("script".equals(name))
        {
            scriptTagCount = scriptTagCount + (closeTag ? -1 : 1);
            return;
        } else if (scriptTagCount > 0) return;

        if (!isAllowedTag(name)) return;

        if (name.equals(TAG_P))
        {
            if (!closeTag)
            {
                lastTagP = full;
                tagPArmed = true;
                whiteSpace = null;
            }

            return;
        } else
        {
            outputTagPIfNecessary(false);

            if (name.equals(TAG_STRONG))
            {
                name = TAG_B;
                if (closeTag) full = TAG_B_CLOSE_FULL; else full = TAG_B_FULL;
            }
        }

        super.onTag(name, full, closeTag);
    }

#No. 5065
#File: E:\bishe\1\AbstractSwingFilter.java
#Comment:
    /**
     * Invoked when text block detected.
     *
     * @param text text.
     */

#Code:
    public void onText(String text)
    {
        if (scriptTagCount > 0) return;

        if (tagPArmed && text.trim().length() == 0)
        {
            whiteSpace = text;
            return;
        }

        outputTagPIfNecessary(false);

        super.onText(text);
    }

#No. 5066
#File: E:\bishe\1\AbstractSwingFilter.java
#Comment:
    /**
     * Invoked on document parsing finish.
     */

#Code:
    public void onFinish()
    {
        outputTagPIfNecessary(true);

        super.onFinish();
    }

#No. 5067
#File: E:\bishe\1\AbstractSwingFilter.java
#Comment:
    /**
     * Outputs P-tag if they are currently groupped.
     *
     * @param noWhiteSpace TRUE when no whitespace requied.
     */

#Code:
    private void outputTagPIfNecessary(boolean noWhiteSpace)
    {
        if (tagPArmed)
        {
            super.onTag(TAG_P, lastTagP, false);
            if (whiteSpace != null)
            {
                if (!noWhiteSpace) super.onText(whiteSpace);
                whiteSpace = null;
            }

            lastTagP = null;
            tagPArmed = false;
        }
    }

#No. 5068
#File: E:\bishe\1\AbstractSwingFilter.java
#Comment:
    /**
     * Returns TRUE if tag in the list of allowed tags.
     *
     * @param tag tag to check.
     *
     * @return TRUE if tag in the list of allowed tags.
     */

#Code:
    private boolean isAllowedTag(String tag)
    {
        return getAllowedTags().contains(tag);
    }

#No. 5069
#File: E:\bishe\1\AbstractSwitchYardServiceCommand.java
#Comment:
    /**
     * Aggregates the patterns in the list into a patterns[0]|patterns[1]|...
     * 
     * @param patterns list of patterns
     * @return a compiled Pattern
     */

#Code:
    protected Pattern compilePattern(List<String> patterns, boolean isRegex) {
        if (patterns == null || patterns.size() == 0) {
            patterns = Collections.singletonList(".*");
            isRegex = true;
        }
        final StringBuffer regex = new StringBuffer();
        for (String name : patterns) {
            if (!isRegex) {
                regex.append("\\Q");
            }
            regex.append(name);
            if (!isRegex) {
                regex.append("\\E");
            }
            regex.append('|');
        }
        regex.deleteCharAt(regex.length() - 1);
        return Pattern.compile(regex.toString());
    }

#No. 5070
#File: E:\bishe\1\AbstractSwordContentIngester.java
#Comment:
	/**
	 * Add the current date to the item metadata.  This looks up
	 * the field in which to store this metadata in the configuration
	 * sword.updated.field
	 *
	 * @param item
	 * @throws DSpaceSwordException
	 */

#Code:
	protected void setUpdatedDate(Item item, VerboseDescription verboseDescription)
			throws DSpaceSwordException
	{
		String field = ConfigurationManager.getProperty("swordv2-server", "updated.field");
		if (field == null || "".equals(field))
		{
			throw new DSpaceSwordException("No configuration, or configuration is invalid for: sword.updated.field");
		}

		MDValue dc = this.configToDC(field, null);
		item.clearMetadata(dc.getSchema(), dc.getElement(), dc.getQualifier(), MDValue.ANY);
		item.addMetadata(dc.getSchema(), dc.getElement(), dc.getQualifier(), null, Utils.asISO8601(new Date()));

		verboseDescription.append("Updated date added to response from item metadata where available");
	}

#No. 5071
#File: E:\bishe\1\AbstractSwordContentIngester.java
#Comment:
	/**
	 * Store the given slug value (which is used for suggested identifiers,
	 * and which DSpace ignores) in the item metadata.  This looks up the
	 * field in which to store this metadata in the configuration
	 * sword.slug.field
	 *
	 * @param item
	 * @param slugVal
	 * @throws DSpaceSwordException
	 */

#Code:
	protected void setSlug(Item item, String slugVal, VerboseDescription verboseDescription)
			throws DSpaceSwordException
	{
		// if there isn't a slug value, don't set it
		if (slugVal == null)
		{
			return;
		}

		String field = ConfigurationManager.getProperty("swordv2-server", "slug.field");
		if (field == null || "".equals(field))
		{
			throw new DSpaceSwordException("No configuration, or configuration is invalid for: sword.slug.field");
		}

		MDValue dc = this.configToDC(field, null);
		item.clearMetadata(dc.getSchema(), dc.getElement(), dc.getQualifier(), MDValue.ANY);
		item.addMetadata(dc.getSchema(), dc.getElement(), dc.getQualifier(), null, slugVal);

		verboseDescription.append("Slug value set in response where available");
	}

#No. 5072
#File: E:\bishe\1\AbstractSwordContentIngester.java
#Comment:
	/**
	 * Utility method to turn given metadata fields of the form
	 * schema.element.qualifier into MDValue objects which can be
	 * used to access metadata in items.
	 *
	 * The def parameter should be null, * or "" depending on how
	 * you intend to use the MDValue object.
	 *
	 * @param config
	 * @param def
	 */

#Code:
	protected MDValue configToDC(String config, String def)
	{
		String schema = def;
		String element = def;
		String qualifier = def;

		StringTokenizer stz = new StringTokenizer(config, ".");
		schema = stz.nextToken();
		element = stz.nextToken();
		if (stz.hasMoreTokens())
		{
			qualifier = stz.nextToken();
		}

		return new MDValue(schema, element, qualifier, null, null);
	}

#No. 5073
#File: E:\bishe\1\AbstractSWTBotEclipseTest.java
#Comment:
	/**
	 * @throws WidgetNotFoundException
	 */

#Code:
	private void saveAndCloseAllEditors() {
		List<? extends SWTBotEditor> editors = bot.editors();
		for (SWTBotEditor editor : editors) {
			editor.saveAndClose();
		}
	}

#No. 5074
#File: E:\bishe\1\AbstractSWTBotFormsTest.java
#Comment:
	/**
	 * @throws WidgetNotFoundException
	 */

#Code:
	private void saveAndCloseAllEditors() {
		List<? extends SWTBotEditor> editors = workbench.editors();
		for (SWTBotEditor editor : editors) {
			editor.saveAndClose();
		}
	}

#No. 5075
#File: E:\bishe\1\AbstractSWTBotTests.java
#Comment:
			/*
			 * on the server the unit test fails with an NPE :S
			 */

#Code:
			throw new AssertionFailedError(e.getMessage());
		}
	}
	
	@AfterClass
	public static void tearDown() throws CoreException {
		IProject[] projects = ResourcesPlugin.getWorkspace().getRoot().getProjects();
		for (IProject iProject : projects) {
			iProject.delete(true, new NullProgressMonitor());
		}
	}

#No. 5076
#File: E:\bishe\1\AbstractSymbolTable.java
#Comment:
  /**
   * Returns the id of the symbol or throws an exception if this symbol isnt in the table
   */

#Code:
  @Override
  public int get(String symbol) {
    int id = symbolToId.getOrDefault(symbol, -1);
    if (id < 0) {
      throw new IllegalArgumentException("No symbol exists for key " + symbol);
    }
    return id;
  }

#No. 5077
#File: E:\bishe\1\AbstractSyncAction.java
#Comment:
    /**
     * Records the state of sentiments configuration.
     */

#Code:
    private void recordSentimentsConfig()
    {
        SentimentsConfig.syncOut(sentimentsConfig);
    }

#No. 5078
#File: E:\bishe\1\AbstractSyncAction.java
#Comment:
    /**
     * Compares current sentiments configuration to saved.
     *
     * @return TRUE if changed.
     */

#Code:
    private boolean sentimentsConfigChanged()
    {
        Map cfg = new HashMap();
        SentimentsConfig.syncOut(cfg);

        try
        {
            if (cfg.size() != sentimentsConfig.size()) return true;
            Set<Map.Entry<Object, Object>> entries = cfg.entrySet();
            for (Map.Entry<Object, Object> entry : entries)
            {
                Object key  = entry.getKey();
                byte[] val1 = (byte[])entry.getValue();
                byte[] val2 = (byte[])sentimentsConfig.get(key);

                if (val2 == null) return true;
                if (!Arrays.equals(val1, val2)) return true;
            }
        } catch (Exception e)
        {
            return true;
        }

        return false;
    }

#No. 5079
#File: E:\bishe\1\AbstractSyncAdapter.java
#Comment:
	/**
	 * Number of I/O errors that will be tolerated before we abort the sync with
	 * an error.
	 */

#Code:
	private static int MAXIMUM_NETWORK_RETRIES = 3;

	/**
	 * Array of retry intervals. This length of time is slept between each
	 * successive retry.
	 */
	private static final int[] NETWORK_RETRY_DELAY = new int[] {
		5000, 30000, 50000
	};

#No. 5080
#File: E:\bishe\1\AbstractSynchronization.java
#Comment:
    /**
     * Reports start of the synchronization process.
     *
     * @param progressListener listener.
     */

#Code:
    private void reportProcessStart(IProgressListener progressListener)
    {
        if (progressListener != null)
        {
            progressListener.processStarted(getProcessStartMessage(), getSynchronizationSteps());
        }
    }

#No. 5081
#File: E:\bishe\1\AbstractSynchronization.java
#Comment:
    /**
     * Reports finish of the synchronization process.
     *
     * @param progressListener listener.
     * @param stats            synchronization stats.
     */

#Code:
    private void reportProcessFinish(IProgressListener progressListener, Stats stats)
    {
        String message;

        if (stats == null)
        {
            message = Strings.message("service.sync.failed.to.perform");
        } else
        {
            message = stats.getStatsText();

            if (stats.hasFailed())
            {
                if (message == null)
                {
                    message = Strings.message("service.sync.communication.problem");
                } else
                {
                    message = MessageFormat.format(Strings.message("service.sync.failed.for.some.reason"),
                        new Object[] { message });
                }
            }
        }

        if (progressListener != null) progressListener.processFinished(message);
    }

#No. 5082
#File: E:\bishe\1\AbstractSynchronization.java
#Comment:
    /**
     * Returns TRUE if the automatic sync can occur as it doesn't break the schedule.
     *
     * @return TRUE if sync can proceed.
     */

#Code:
    public boolean isSyncTime()
    {
        int syncMode = servicePreferences.getSyncMode();
        Date lastSyncOutDate = servicePreferences.getLastSyncOutDate();
        int syncPeriod = servicePreferences.getSyncPeriod();

        return syncSettingsProvided() &&
            syncMode != ServicePreferences.SYNC_MODE_MANUAL &&
            (syncMode == ServicePreferences.SYNC_MODE_EACH_RUN ||
             DateUtils.dayDiffFromToday(lastSyncOutDate) >= syncPeriod * Constants.MILLIS_IN_DAY);
    }

#No. 5083
#File: E:\bishe\1\AbstractSynchronization.java
#Comment:
    /**
     * Checks if all settings provided and we can continue making synchronization.
     *
     * @return TRUE if its OK.
     */

#Code:
    protected boolean syncSettingsProvided()
    {
        return servicePreferences.getEmail() != null &&
            servicePreferences.getEmail().length() > 0 &&
            servicePreferences.getPassword() != null &&
            servicePreferences.getPassword().length() > 0;
    }

#No. 5084
#File: E:\bishe\1\AbstractSynchronization.java
#Comment:
    /**
     * Prepares start message.
     *
     * @param action    action message (synchronizing, loading, saving).
     * @param prefs     preferences message.
     * @param feeds     feeds message.
     * @param service   service message.
     *
     * @return complete string.
     */

#Code:
    protected String prepareProcessStartMessage(String action, String prefs, String feeds, String service)
    {
        boolean syncFeeds = servicePreferences.isSyncFeeds();
        boolean syncPreferences = servicePreferences.isSyncPreferences();

        StringBuffer message = new StringBuffer(action);
        if (syncPreferences) message.append(" ").append(prefs);
        if (syncFeeds)
        {
            if (syncPreferences) message.append(",");
            message.append(" ").append(feeds);
        }
        message.append(" ").append(service);

        return message.toString();
    }

#No. 5085
#File: E:\bishe\1\AbstractSynRunnable.java
#Comment:
    /**
     * 是否正在执行，true:正在执行，false：不是正在执行
     */

#Code:
    private boolean isRunning = false;

    /**
     * 是否在执行列表中，true:是的，false:没有纳入计划执行列表
     */
    private boolean isInSchedule = false;

    @Override
    public void setRunning(boolean isRunning)
    {
        this.isRunning = isRunning;
    }

#No. 5086
#File: E:\bishe\1\AbstractSynRunnable.java
#Comment:
    /**
     * @param args
     */

#Code:
    public static void main(String[] args)
    {

    }

#No. 5087
#File: E:\bishe\1\AbstractSyslogMessageSender.java
#Comment:
    /**
     * Format of messages accepted by the remote syslog server
     * ({@link com.cloudbees.syslog.MessageFormat#RFC_3164 RFC_3164} or
     * {@link com.cloudbees.syslog.MessageFormat#RFC_5424 RFC_5424})
     */

#Code:
    protected MessageFormat messageFormat = DEFAULT_SYSLOG_MESSAGE_FORMAT;
    // statistics
    protected final AtomicInteger sendCounter = new AtomicInteger();
    protected final AtomicLong sendDurationInNanosCounter = new AtomicLong();
    protected final AtomicInteger sendErrorCounter = new AtomicInteger();

    /**
     * Send the given text message
     *
     * @param message
     * @throws java.io.IOException
     */
    @Override
    public void sendMessage(CharArrayWriter message) throws IOException {

        SyslogMessage syslogMessage = new SyslogMessage()
                .withAppName(defaultAppName)
                .withFacility(defaultFacility)
                .withHostname(defaultMessageHostname)
                .withSeverity(defaultSeverity)
                .withMsg(message);

        sendMessage(syslogMessage);
    }

#No. 5088
#File: E:\bishe\1\AbstractSyslogMessageSender.java
#Comment:
    /**
     * Send the given {@link com.cloudbees.syslog.SyslogMessage}.
     *
     * @param message the message to send
     * @throws IOException
     */

#Code:
    public abstract void sendMessage(@Nonnull SyslogMessage message) throws IOException;

    public String getDefaultAppName() {
        return defaultAppName;
    }

#No. 5089
#File: E:\bishe\1\AbstractSyslogMessageSender.java
#Comment:
    /**
     * Human readable view of {@link #getSendDurationInNanos()}
     *
     * @return total duration spent sending syslog messages
     */

#Code:
    public long getSendDurationInMillis() {
        return TimeUnit.MILLISECONDS.convert(getSendDurationInNanos(), TimeUnit.NANOSECONDS);
    }

#No. 5090
#File: E:\bishe\1\AbstractSyslogMessageSender.java
#Comment:
    /**
     * Human readable view of {@link #getSendDurationInNanos()}
     *
     * @return total duration spent sending syslog messages
     */

#Code:
    public long getSendDurationInNanos() {
        return sendDurationInNanosCounter.get();
    }

#No. 5091
#File: E:\bishe\1\AbstractTable.java
#Comment:
	/**
	 * Returns the column index for hte name or -1 if not found
	 *
	 * @param columnName
	 *            The name to search for
	 * @return the column index (0 based) or -1 if not found.
	 */

#Code:
	@Override
	public int getColumnIndex(final String columnName) {
		final List<? extends Column> cols = getColumnList();
		for (int i = 0; i < cols.size(); i++) {
			if (cols.get(i).getName().equals(columnName)) {
				return i;
			}
		}
		return -1;
	}

#No. 5092
#File: E:\bishe\1\AbstractTableBlock.java
#Comment:
	/**
	 * Persist table settings into the give dialog store, prefixed with the
	 * given key.
	 */

#Code:
	public void saveColumnSettings() {
		int columnCount = getTable().getColumnCount();
		for (int i = 0; i < columnCount; i++) {
			getDialogSettings()
					.put(
							getQualifier() + ".columnWidth" + i, getTable().getColumn(i).getWidth()); //$NON-NLS-1$
		}
		getDialogSettings().put(getQualifier() + ".sortColumn", fSortColumn); //$NON-NLS-1$
	}

#No. 5093
#File: E:\bishe\1\AbstractTableBlock.java
#Comment:
	/**
	 * Restore table settings from the given dialog store using the given key.
	 */

#Code:
	public void restoreColumnSettings() {
		getTable().layout(true);
		restoreColumnWidths(getDialogSettings(), getQualifier());
		int col = 0;
		try {
			col = getDialogSettings().getInt(getQualifier() + ".sortColumn"); //$NON-NLS-1$
		} catch (NumberFormatException e) {
			col = 1;
		}
		setSortColumn(col);
	}

#No. 5094
#File: E:\bishe\1\AbstractTableItem.java
#Comment:
	/**
	 * See {@link TreeItem}.
	 *
	 * @param check the new checked
	 */

#Code:
	@Override
	public void setChecked(final boolean check) {
		log.info((check ? "Check" : "Uncheck") + " table Item " + getText()
				+ ":");
		TableItemHandler.getInstance().setChecked(swtWidget, check);
	}

#No. 5095
#File: E:\bishe\1\AbstractTableMatcher.java
#Comment:
    /**
     * pattern是否是正则表达时
     *
     * @param pattern pattern
     *
     * @return boolean
     */

#Code:
    private boolean isRegex(String pattern) {
        char[] array = pattern.toCharArray();

        for (char c : array) {
            if (c == '^' || c == '$' || c == '*' || c == '?') {
                return true;
            }
        }
        return false;
    }

#No. 5096
#File: E:\bishe\1\AbstractTableMerger.java
#Comment:
	/**
	 * Print excessive debug of each entry being merged.
	 */

#Code:
	private static final boolean DEBUG_ENTRIES = true;

	protected final SQLiteDatabase mDb;
	protected final String mTable;
	protected final String mDeletedTable;
	protected final Uri mTableUri;
	protected final Uri mDeletedTableUri;

	public interface SyncableColumns extends BaseColumns
	{
		/**
		 * Timestamp of last modification.
		 */
		public static final String _SYNC_TIME = "_sync_time";

		/**
		 * Sync id corresponding to the main (non-temporary) provider.
		 */
		public static final String _SYNC_ID = "_sync_id";
	}

#No. 5097
#File: E:\bishe\1\AbstractTableMerger.java
#Comment:
			/*
			 * Step 1: process server intiated deletes. This is done first in
			 * case the id has been re-used by the server (for instance, server
			 * deleted id 1, then inserted a new record to fill that same id).
			 */

#Code:
			Log.d(TAG, mTable + ": applying server deletions...");
			int deleteCount = mergeServerDeletions(context, syncContext, serverDiffs);

			/*
			 * Step 2: process server initiated inserts and modifications.
			 */
			Log.d(TAG, mTable + ": applying server modifications...");
			int diffCount = mergeServerChanges(context, syncContext, serverDiffs);

			Log.d(TAG, mTable + ": table merge complete, processed " +
					deleteCount + " deletes, " +
					diffCount + " inserts/updates");
		} catch (Exception e) {
			/* Aiiee!! How can we capture this failure? */
			Log.e(TAG, mTable + ": table merge failed!", e);
			syncContext.mergeError = true;
			syncContext.errorMessage = e.toString();
		}

#No. 5098
#File: E:\bishe\1\AbstractTableOperation.java
#Comment:
    /**
     * Constructor for AbstractTableOperation
     *
     * @param id        the operation id
     * @param tableName the table name
     * @param itemId    the item id
     * @param createdAt the creation time
     */

#Code:
    public AbstractTableOperation(String id, String tableName, String itemId, Date createdAt, MobileServiceTableOperationState state, JsonObject item) {
        this.mId = id;
        this.mTableName = tableName;
        this.mItemId = itemId;
        this.mCreatedAt = createdAt;
        this.mOperationState = state;
        this.mItem = item;
    }

#No. 5099
#File: E:\bishe\1\AbstractTableOperation.java
#Comment:
    /**
     * Constructor for AbstractTableOperation
     *
     * @param tableName the table name
     * @param itemId    the item id
     */

#Code:
    public AbstractTableOperation(String tableName, String itemId) {
        this(UUID.randomUUID().toString(), tableName, itemId, new Date(), MobileServiceTableOperationState.Pending, null);
    }

#No. 5100
#File: E:\bishe\1\AbstractTableOperation.java
#Comment:
    /**
     * Gets the operation state
     *
     * @return The operation state
     */

#Code:
    @Override
    public MobileServiceTableOperationState getOperationState() {
        return this.mOperationState;
    }

#No. 5101
#File: E:\bishe\1\AbstractTableOperation.java
#Comment:
    /**
     * Sets the operation state
     *
     * @param operationState the Operation State
     */

#Code:
    @Override
    public void setOperationState(MobileServiceTableOperationState operationState) {
        this.mOperationState = operationState;
    }

#No. 5102
#File: E:\bishe\1\AbstractTableReport.java
#Comment:
    /**
     * Called to create a label component for an entity.
     *
     * @param id    entity ID.
     * @param title entity title.
     *
     * @return component.
     */

#Code:
    protected JComponent createLabel(long id, String title)
    {
        return new JLabel(title);
    }

#No. 5103
#File: E:\bishe\1\AbstractTableReport.java
#Comment:
    /**
     * A link label to open the complete report.
     */

#Code:
    private class SeeAllLinkLabel extends LinkLabel
    {
        /**
         * Creates pure link label without link.
         *
         * @param text text to put.
         */
        private SeeAllLinkLabel(String text)
        {
            super(text);
        }

        @Override
        protected void doAction()
        {
            setEnabled(false);

            table.removeAll();
            createDataTable(table, Integer.MAX_VALUE);
            table.revalidate();
        }
    }

#No. 5104
#File: E:\bishe\1\AbstractTabList.java
#Comment:
	/**
	 * The constructor
	 *
	 * @param nPlayer tablist owner
	 */

#Code:
	public AbstractTabList(NovaPlayer nPlayer) {
		this.nPlayer = nPlayer;
		clear();
	}

#No. 5105
#File: E:\bishe\1\AbstractTabStackNavigationActivity.java
#Comment:
  /**
   * Gets the tab info object of the currently selected tab
   * 
   * @return TabInfo
   */

#Code:
  public TabInfo getCurrentTabInfo() {
    final int index = getSupportActionBar().getSelectedNavigationIndex();
    final TabInfo tabInfo = tabMap.get(index);
    return tabInfo;
  }

#No. 5106
#File: E:\bishe\1\AbstractTabStackNavigationActivity.java
#Comment:
  /**
   * pop the current fragment from the tabs back stack and show the previous
   * fragment
   */

#Code:
  public void popFragment() {
    Log.d(LOGTAG, "popFragment()");
    final TabInfo tabInfo = getCurrentTabInfo();
    if (tabInfo.stack.size() <= 1) {
      Log.d(LOGTAG, "popFragment() - nothing to pop...");
      return;
    }
    final FragmentManager fragmentManager = getSupportFragmentManager();
    final FragmentTransaction ft = fragmentManager.beginTransaction();
    tabInfo.detachFragment(ft, tabInfo.stack.pop());
    tabInfo.attachFragment(ft, tabInfo.stack.peek());
    ft.commit();
  }

#No. 5107
#File: E:\bishe\1\AbstractTabStackNavigationActivity.java
#Comment:
  /**
   * Pushes a new fragment onto the tabs back stack and shows the new fragment
   * 
   * @param tabInfo
   *          tabinfo where the fragment should be pushed
   * @param fragment
   *          the fragment to show
   */

#Code:
  public void pushFragment(final TabInfo tabInfo, final Fragment fragment) {
    pushOrReplaceFragment(tabInfo, fragment, false, true);
  }

#No. 5108
#File: E:\bishe\1\AbstractTabStackNavigationActivity.java
#Comment:
  /**
   * pushs a new fragment onto the tabs back stack and shows the new fragment
   * 
   * @param tabInfo
   *          tabinfo where the fragment should be pushed
   * @param fragment
   *          the fragment to show
   * @param replaceInsteadOfPush
   *          if true, the current fragment is replaced instead of pushed.
   *          Replacement of fragments does not push anything on the back stack.
   * @param pushEvenIfSameClassAsTopFragment
   *          if false, the fragment is pushed only if it is of a different
   *          class than the currently shown fragment of that tab - instead it
   *          replaces the current fragment. If true, then the fragment is
   *          pushed in any case.
   */

#Code:
  public void pushOrReplaceFragment(final TabInfo tabInfo, final Fragment fragment, final boolean replaceInsteadOfPush,
      final boolean pushEvenIfSameClassAsTopFragment) {
    Log.d(LOGTAG, "pushFragment(" + fragment + ")");
    final boolean onWrongTab = getCurrentTabInfo() != tabInfo;
    if (onWrongTab) {
      pushBackAction(new SwitchTabBackAction(this, getCurrentTabInfo().tag));
    }
    final boolean newFragmentIsOfSameClassAsOldFragment = tabInfo.stack.size() > 0
        && tabInfo.stack.peek().getClass().equals(fragment.getClass());
    final boolean justReplacePreviousFragment = replaceInsteadOfPush
        || (newFragmentIsOfSameClassAsOldFragment && !pushEvenIfSameClassAsTopFragment);
    final FragmentManager fragmentManager = getSupportFragmentManager();
    final FragmentTransaction ft = fragmentManager.beginTransaction();
    tabInfo.detachFragment(ft, tabInfo.stack.peek());
    if (justReplacePreviousFragment) {
      Log.d(LOGTAG, "replace previous fragment because it's of same class");
      tabInfo.stack.pop();
    }
    tabInfo.stack.push(fragment);
    tabInfo.attachFragment(ft, fragment);
    ft.commit();
    if (!justReplacePreviousFragment) {
      pushBackAction(new PopTabStackBackAction(this, tabInfo.tag));
    }
    if (onWrongTab) {
      Log.d(LOGTAG, "on wrong tab, select tab " + tabInfo.tag);
      changeOfStackAllowedForTabListener = false;
      try {
        getSupportActionBar().setSelectedNavigationItem(tabInfo.tag);
      } finally {
        changeOfStackAllowedForTabListener = true;
      }
    }
    setUpButtonDependingStack();
  }

#No. 5109
#File: E:\bishe\1\AbstractTabStackNavigationActivity.java
#Comment:
  /**
   * Replace the current fragment with the new fragment. Replacement of
   * fragments does not push anything on the back stack.
   * 
   * @param tabInfo
   *          tabinfo where the fragment should be pushed
   * @param fragment
   *          the fragment to show
   */

#Code:
  public void replaceFragment(final TabInfo tabInfo, final Fragment fragment) {
    pushOrReplaceFragment(tabInfo, fragment, true, true);
  }

#No. 5110
#File: E:\bishe\1\AbstractTabularInput.java
#Comment:
    /**
     * Reads all data from the current position on into a List<List<String>>.
     *
     * @return
     */

#Code:
    public List<List<String>> readAll() {
        List<List<String>> data = new ArrayList<List<String>>();
        while (hasNext()) {
            data.add(next());
        }
        return data;
    }

#No. 5111
#File: E:\bishe\1\AbstractTabularInput.java
#Comment:
    /**
     * Reads all data from the current position but does not return anything.
     * This method is only useful in connection with registering observers.
     *
     * @return
     */

#Code:
    public void visitAll() {
        while (hasNext()) {
            next();
        }
    }

#No. 5112
#File: E:\bishe\1\AbstractTabularInput.java
#Comment:
    /**
     *
     */

#Code:
    private void closeReader() throws TabularInputException {
        if (this.reader != null) {
            try {
                this.reader.close();
            } catch (IOException e) {
                throw new TabularInputException(e, this.rowNum, -1);
            }
        }
    }

#No. 5113
#File: E:\bishe\1\AbstractTabularOutput.java
#Comment:
    /**
     * empty implementation
     */

#Code:
    public void printFooter() {
        //empty implementation
    }

#No. 5114
#File: E:\bishe\1\AbstractTag.java
#Comment:
	/**
	 * Stores the tag name.
	 */

#Code:
	protected String name;

	/**
	 * Stores the parent tag.
	 */
	protected ITagContainer parent = null;

	/**
	 * Constructs a new AbstractTag.
	 * @param name The tag name.
	 */
	public AbstractTag (@Nonnull String name) {
		this.setName (name);
	}

	/**
	 * Constructs a new AbstractTag.
	 * @param inputStream
	 * @param anonymous
	 * @throws java.io.IOException
	 */
	public AbstractTag (@Nonnull NbtInputStream inputStream, boolean anonymous) throws IOException {
		// validate arguments
		Preconditions.checkNotNull (inputStream, "inputStream");

		// read name
		if (!anonymous) {
			// read name size
			int nameSize = inputStream.readShort ();
			byte[] nameBytes = new byte[nameSize];

			// read name
			inputStream.readFully (nameBytes);
			this.setName (new String (nameBytes, STRING_CHARSET));
		}

#No. 5115
#File: E:\bishe\1\AbstractTag.java
#Comment:
	/**
	 * {@inheritDoc}
	 */

#Code:
	@Override
	public String getName () {
		return this.name;
	}

#No. 5116
#File: E:\bishe\1\AbstractTag.java
#Comment:
	/**
	 * {@inheritDoc}
	 */

#Code:
	@Override
	public byte[] getNameBytes () {
		return this.name.getBytes (STRING_CHARSET);
	}

#No. 5117
#File: E:\bishe\1\AbstractTag.java
#Comment:
	/**
	 * {@inheritDoc}
	 */

#Code:
	@Override
	public ITagContainer getParent () {
		return this.parent;
	}

#No. 5118
#File: E:\bishe\1\AbstractTag.java
#Comment:
	/**
	 * {@inheritDoc}
	 */

#Code:
	@Override
	public abstract byte getTagID ();

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void setName (@Nonnull String name) {
		// check arguments
		Preconditions.checkNotNull (name, "name");

		// remove previous tag
		if (this.getParent () != null) this.getParent ().removeTag (this);

		// update name
		this.name = name;

		// add new tag
		if (this.getParent () != null) {
			if (this.getParent () instanceof IAnonymousTagContainer)
				((IAnonymousTagContainer) this.getParent ()).addTag (this);
			else
				((INamedTagContainer) this.getParent ()).setTag (this);
		}

#No. 5119
#File: E:\bishe\1\AbstractTag.java
#Comment:
	/**
	 * {@inheritDoc}
	 */

#Code:
	@Override
	public void setParent (@Nullable ITagContainer parent) {
		// remove from old parent
		if (this.getParent () != null) this.getParent ().removeTag (this);

		// set new parent
		this.parent = parent;
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void write (NbtOutputStream outputStream, boolean anonymous) throws IOException {
		// write name
		if (!anonymous) {
			// get name
			byte[] name = this.getNameBytes ();

			// write size
			outputStream.writeShort (name.length);

			// write bytes
			outputStream.write (name);
		}
	};

#No. 5120
#File: E:\bishe\1\AbstractTagsDialog.java
#Comment:
    /**
     * Sets all fields at once. Apply reasonable defaults for the labels where possible.
     *
     * @param title         title of the object.
     * @param url           URL of the object.
     * @param description   textual description.
     * @param extended      extended description.
     * @param tags          user tags assigned.
     */

#Code:
    protected void setTaggableData(String title, String url, String description,
                                   String extended, String[] tags)
    {
        URL link = null;
        try
        {
            link = new URL(url);
        } catch (MalformedURLException e)
        {
            // Bad of course, but it's just presentation layer
            LOG.log(Level.WARNING, MessageFormat.format(
                Strings.error("invalid.url"), url), e);
        }

        if (StringUtils.isEmpty(title)) title = url;

        tfTitle.setText(title);
        tfTitle.setForeground(Color.BLUE);
        tfTitle.setLink(link);

        if (StringUtils.isEmpty(description)) description = title;

        tfDescription.setText(description);
        tfExtended.setText(extended);

        tfTags.setText(tags == null ? null : StringUtils.join(tags, " "));
    }

#No. 5121
#File: E:\bishe\1\AbstractTagsDialog.java
#Comment:
    /**
     * This operation is not supported.
     */

#Code:
    public void open()
    {
        throw new UnsupportedOperationException(Strings.error("use.open.itaggable.method"));
    }

#No. 5122
#File: E:\bishe\1\AbstractTagsDialog.java
#Comment:
    /**
     * Filter out all taggables without links which can be tagged.
     *
     * @param aTaggables taggables.
     *
     * @return only these taggables with links.
     */

#Code:
    private ITaggable[] filterLinkless(ITaggable[] aTaggables)
    {
        List<ITaggable> havingLinks = new ArrayList<ITaggable>(aTaggables.length);

        for (ITaggable taggable : aTaggables)
        {
            if (taggable.getTaggableLink() != null) havingLinks.add(taggable);
        }

        return havingLinks.toArray(new ITaggable[havingLinks.size()]);
    }

#No. 5123
#File: E:\bishe\1\AbstractTagsDialog.java
#Comment:
    /**
     * Accepts entry if it's valid and otherwise displays the error and moves back to editing.
     */

#Code:
    public void doAccept()
    {
        // If we do untagging, everything else doesn't matter
        if (untagging || validateAndWarn()) super.doAccept();
    }

#No. 5124
#File: E:\bishe\1\AbstractTagsDialog.java
#Comment:
    /**
     * Move changes from dialog controls to the dialog.
     *
     * @param taggable          taggable object.
     * @param oldDescription    old description text.
     * @param oldExtended       old extended description text.
     * @param oldUserTags       old user tags.
     */

#Code:
    private void propagateChanges(ITaggable taggable, String oldDescription,
                                  String oldExtended, String[] oldUserTags)
    {
        boolean changed = false;

        String newDescription = "";
        String newExtended = "";
        String[] newUserTags =  new String[0];

        // if not untagging, read what user has entered
        if (!untagging)
        {
            newDescription = getNewDescription(taggable);
            newExtended = tfExtended.getText();
            newUserTags = getEnteredTags();
        }

        if (!newDescription.equals(oldDescription))
        {
            taggable.setTagsDescription(newDescription);
            changed = true;
        }

        if (!newExtended.equals(oldExtended))
        {
            taggable.setTagsExtended(newExtended);
            changed = true;
        }

        if (!Arrays.equals(newUserTags, oldUserTags))
        {
            taggable.setUserTags(newUserTags);
            changed = true;
        }

        if (changed) taggable.setUnsavedUserTags(true);
    }

#No. 5125
#File: E:\bishe\1\AbstractTagsDialog.java
#Comment:
    /**
     * Returns the entered description if entry was allowed (single object mode) and
     * title of the object if description field wasn't editable (multi object mode).
     *
     * @param taggable  taggable.
     *
     * @return new description.
     */

#Code:
    private String getNewDescription(ITaggable taggable)
    {
        return tfDescription.isEditable() ? tfDescription.getText() : taggable.getTitle();
    }

#No. 5126
#File: E:\bishe\1\AbstractTagsDialog.java
#Comment:
    /**
     * Returns the list of currently entered tags.
     *
     * @return entered tags.
     */

#Code:
    private String[] getEnteredTags()
    {
        return StringUtils.split(tfTags.getText(), " ");
    }

#No. 5127
#File: E:\bishe\1\AbstractTagsDialog.java
#Comment:
    /**
     * Puts the list of tags in form controls.
     *
     * @param aNewTags new tags to put.
     */

#Code:
    private void enterTags(String[] aNewTags)
    {
        String tagsText = aNewTags == null ? null : StringUtils.join(aNewTags, " ");
        tfTags.setText(tagsText);
    }

#No. 5128
#File: E:\bishe\1\AbstractTagsDialog.java
#Comment:
    /**
     * Creates tags summary from list of tags. Empty list of tags may mean
     * two things: error during fetching or not attempted to fetch yet.
     *
     * @param aSharedTags   tags to convert to summary.
     * @param anAuthorTags  tags, set by an author.
     * @param emptyIsError  <code>TRUE</code> to treat <code>NULL</code> as
     *                      a fetching failure, otherwise as non-fetched yet.
     *
     * @return summary string.
     */

#Code:
    private static String createSummary(String[] aSharedTags, String[] anAuthorTags, boolean emptyIsError)
    {
        String summary;
        if (aSharedTags == null)
        {
            if (emptyIsError)
            {
                summary = Strings.message("tags.fetching.failed");
            } else
            {
                summary = Strings.message("tags.fetching.not.fetched");
            }
        } else
        {
            String[] aTags = new String[aSharedTags.length + anAuthorTags.length];
            for (int i = 0; i < aSharedTags.length; i++) aTags[i] = aSharedTags[i];
            for (int i = 0; i < anAuthorTags.length; i++)
            {
                aTags[aSharedTags.length + i] = anAuthorTags[i];
            }

            if (aTags.length == 0)
            {
                summary = Strings.message("tags.fetching.no.other.tags");
            } else
            {
                summary = TagsUtils.createTagsSummary(aTags);
            }
        }

        return summary;
    }

#No. 5129
#File: E:\bishe\1\AbstractTagsDialog.java
#Comment:
    /**
     * Returns TRUE if 'other tags' field should be italics because the text there is just a
     * message to the user, and FALSE if they are actual tags fetched.
     *
     * @param aTags - tags to analyze
     * @return true: if label should be italics, false otherwise
     */

#Code:
    private boolean isTagLabelItalics(String[] aTags)
    {
        return (aTags == null || aTags.length == 0);
    }

#No. 5130
#File: E:\bishe\1\AbstractTagsDialog.java
#Comment:
    /**
     * Returns <code>TRUE</code> if entry is valid. If entry is invalid the dialog
     * box with error will be shown.
     *
     * @return <code>TRUE</code> if entry is valid.
     */

#Code:
    private boolean validateAndWarn()
    {
        String error = validate(tfDescription.getText(), tfTags.getText());
        boolean valid = error == null;

        if (!valid)
        {
            JOptionPane.showMessageDialog(this, error, Strings.message("tags.validation.dialog.title"),
                JOptionPane.WARNING_MESSAGE);
        }

        return valid;
    }

#No. 5131
#File: E:\bishe\1\AbstractTagsDialog.java
#Comment:
    /**
     * Validates data entered and returns the error messages.
     *
     * @param aDescription  description entered.
     * @param aTags         targs list entered.
     *
     * @return error message or <code>NULL</code> if everything is fine.
     */

#Code:
    static String validate(String aDescription, String aTags)
    {
        String error = null;

        if (aDescription == null || aDescription.trim().length() == 0)
        {
            error = ERR_DESCRIPTION_EMPTY;
        } else if (aTags == null || aTags.trim().length() == 0)
        {
            error = ERR_TAGS_EMPTY;
        } else if (aTags.indexOf('"') != -1)
        {
            error = ERR_MULTIWORD_TAGS;
        }

        return error;
    }

#No. 5132
#File: E:\bishe\1\AbstractTagsDialog.java
#Comment:
    /**
     * Calls the suggestion window with list of available tags.
     */

#Code:
    private class SuggestTagsAction extends AbstractAction
    {
        /**
         * Creates action.
         */
        public SuggestTagsAction()
        {
            super(Strings.message("tags.suggest.action"));
            putValue(Action.SHORT_DESCRIPTION, Strings.message("tags.suggest.description"));

        }

        /**
         * Invoked when an action occurs.
         *
         * @param e action object.
         */
        public void actionPerformed(ActionEvent e)
        {
            SuggestedTagsDialog dialog = new SuggestedTagsDialog(AbstractTagsDialog.this);
            Set<String> usedTags = TagsRepository.getInstance().getUsedTags();
            String[] enteredTags = getEnteredTags();

            String[] newTags = dialog.open(usedTags, enteredTags);
            if (!Arrays.equals(newTags, enteredTags)) enterTags(newTags);
        }
    }

#No. 5133
#File: E:\bishe\1\AbstractTagValidator.java
#Comment:
	/**
	 * Determines whether the IStructuredDocumentRegion is a XML "start tag"
	 * since they need to be checked for proper XML attribute region sequences
	 * 
	 * @param structuredDocumentRegion
	 * 
	 */

#Code:
	private boolean isStartTag(
			IStructuredDocumentRegion structuredDocumentRegion) {
		if ((structuredDocumentRegion == null)
				|| structuredDocumentRegion.isDeleted()) {
			return false;
		}
		return structuredDocumentRegion.getFirstRegion().getType() == DOMRegionContext.XML_TAG_OPEN;
	}

#No. 5134
#File: E:\bishe\1\AbstractTagValidator.java
#Comment:
	/**
	 * Determines if the IStructuredDocumentRegion is XML Content
	 * 
	 * @param structuredDocumentRegion
	 * 
	 */

#Code:
	private boolean isXMLContent(
			IStructuredDocumentRegion structuredDocumentRegion) {
		if ((structuredDocumentRegion == null)
				|| structuredDocumentRegion.isDeleted()) {
			return false;
		}
		return structuredDocumentRegion.getFirstRegion().getType() == DOMRegionContext.XML_CONTENT;
	}

#No. 5135
#File: E:\bishe\1\AbstractTalkServiceImplIT.java
#Comment:
    /**
     * create {@link #EXPECTED_VALUES} values with PID {@link #TEST_PID}.
     */

#Code:
    protected void createTestdata(String userUUID1, String userUUID2, String userUUID3){
        getTalkService().save(createTestValue(TEST_PID, userUUID1), userUUID1);
        getTalkService().save(createTestValue(TEST_PID, userUUID2), userUUID2);
        getTalkService().save(createTestValue(TEST_PID, userUUID3), userUUID3);
        getTalkService().save(createTestValue("2", userUUID1), userUUID1);
        getTalkService().save(createTestValue("2", userUUID2), userUUID2);
    }

#No. 5136
#File: E:\bishe\1\AbstractTaskLauncherIntegrationTests.java
#Comment:
	/**
	 * Subclasses should call this method to interact with the AppDeployer under test.
	 * Returns a wrapper around the deployer returned by {@link #provideTaskLauncher()}, that keeps
	 * track of which apps have been deployed and undeployed.
	 */

#Code:
	protected TaskLauncher taskLauncher() {
		return launcherWrapper;
	}

#No. 5137
#File: E:\bishe\1\AbstractTaskLauncherIntegrationTests.java
#Comment:
	/**
	 * Tests that command line args can be passed in.
	 */

#Code:
	@Test
	public void testCommandLineArgs() {
		Map<String, String> properties = new HashMap<>();
		properties.put("killDelay", "1000");
		AppDefinition definition = new AppDefinition(randomName(), properties);
		Resource resource = testApplication();
		AppDeploymentRequest request = new AppDeploymentRequest(definition, resource, Collections.<String, String>emptyMap(),
				Collections.singletonList("--exitCode=0"));
		log.info("Launching {}...", request.getDefinition().getName());
		String deploymentId = taskLauncher().launch(request);

		Timeout timeout = deploymentTimeout();
		assertThat(deploymentId, eventually(hasStatusThat(
				Matchers.<TaskStatus>hasProperty("state", Matchers.is(complete))), timeout.maxAttempts, timeout.pause));
		taskLauncher().destroy(definition.getName());
	}

#No. 5138
#File: E:\bishe\1\AbstractTaskLauncherIntegrationTests.java
#Comment:
	/**
	 * Tests support for DeployerEnvironmentInfo is implemented.
	 */

#Code:
	@Test
	public void testEnvironmentInfo() {
		RuntimeEnvironmentInfo info = taskLauncher().environmentInfo();
		assertNotNull(info.getImplementationVersion());
		assertNotNull(info.getPlatformType());
		assertNotNull(info.getPlatformClientVersion());
		assertNotNull(info.getPlatformHostVersion());
	}

#No. 5139
#File: E:\bishe\1\AbstractTaskLauncherIntegrationTests.java
#Comment:
	/**
	 * A Hamcrest Matcher that queries the deployment status for some task id.
	 */

#Code:
	protected Matcher<String> hasStatusThat(final Matcher<TaskStatus> statusMatcher) {
		return new BaseMatcher<String>() {

			private TaskStatus status;

			@Override
			public boolean matches(Object item) {
				status = taskLauncher().status((String) item);
				return statusMatcher.matches(status);
			}

			@Override
			public void describeMismatch(Object item, Description mismatchDescription) {
				mismatchDescription.appendText("status of ").appendValue(item).appendText(" ");
				statusMatcher.describeMismatch(status, mismatchDescription);
			}


			@Override
			public void describeTo(Description description) {
				statusMatcher.describeTo(description);
			}
		};
	}

#No. 5140
#File: E:\bishe\1\AbstractTaskRunnable.java
#Comment:
    /**
     * @param keyCharBuf buf for the characters of a key
     * @return a byte buffer big enough to hold the capacity of keyCharBuf with the current encoder
     */

#Code:
    private ByteBuffer getByteBuffer(CharBuffer keyCharBuf) {
        return ByteBuffer.allocate(keyCharBuf.capacity() * ((int) Math.ceil(encoder.maxBytesPerChar()) + 1));
    }

#No. 5141
#File: E:\bishe\1\AbstractTaskScheduler.java
#Comment:
  /**
   * Construct the service.
   *
   * @param name service name
   */

#Code:
  public AbstractTaskScheduler(String name) {
    super(name);
  }

#No. 5142
#File: E:\bishe\1\AbstractTemplateCacheLoader.java
#Comment:
    /**
     * Constructor.
     *
     * @param store event store
     */

#Code:
    public AbstractTemplateCacheLoader(final EventStore store, final long nbEventBeforePersiste) {
        this.store = store;
        this.nbEventBeforePersiste = nbEventBeforePersiste;
    }

#No. 5143
#File: E:\bishe\1\AbstractTemplateCacheLoader.java
#Comment:
    /**
     * Return store.
     *
     * @return event store
     */

#Code:
    protected EventStore getStore() {
        return store;
    }

#No. 5144
#File: E:\bishe\1\AbstractTemplateCacheLoader.java
#Comment:
    /**
     * Return Nb event before store in cache.
     *
     * @return long
     */

#Code:
    protected long getNbEventBeforePersiste() {
        return this.nbEventBeforePersiste;
    }

#No. 5145
#File: E:\bishe\1\AbstractTemplateCacheLoader.java
#Comment:
    /**
     * Generate key to search in database.
     *
     * @param moduleKey module key
     *
     * @return db key
     */

#Code:
    protected String generateDbKey(final ModuleKey moduleKey) {
        // Redis key pattern to search all application platform
        return String.format("%s-%s",
                getStreamPrefix(), moduleKey.getEntityName());
    }

#No. 5146
#File: E:\bishe\1\AbstractTemplateCacheLoader.java
#Comment:
    /**
     * Return list of modules.
     *
     * @return list of modules
     */

#Code:
    public abstract List<Template> getAllTemplates();

    /**
     * Store object in snapshot.
     *
     * @param namespace key of cache (same as cache.get(K))
     * @param object object
     */
    public void saveSnapshot(final String namespace, final T object) {
        final ModuleKey moduleKey = new ModuleKey(namespace);

        // Don't store snapshot of release, cause release contain only one event
        if (moduleKey.isWorkingCopy()) {
            final String redisKey = generateDbKey(moduleKey);

            // Now store snapshot
            store.storeSnapshot(redisKey, object, nbEventBeforePersiste);
        }
    }

#No. 5147
#File: E:\bishe\1\AbstractTemplateCacheLoader.java
#Comment:
    /**
     * Store object in snapshot.
     *
     * @param namespace key of cache (same as cache.get(K))
     * @param object object
     */

#Code:
    public void forceSaveSnapshot(final String namespace, final T object, final long nbEvent) {
        final ModuleKey moduleKey = new ModuleKey(namespace);

        // Don't store snapshot of release, cause release contain only one event
        if (moduleKey.isWorkingCopy()) {
            final String redisKey = generateDbKey(moduleKey);

            // Now store snapshot
            store.createSnapshot(redisKey, object, nbEvent);
        }
    }

#No. 5148
#File: E:\bishe\1\AbstractTemporalDatasetWriter.java
#Comment:
/**
 * Abstract base class implementation of the TemporalDatasetWriter interface.
 * Provides implementations for all but the
 * {@link timeBench.data.io.TemporalDatasetWriter#writeData(TemporalDataset,OutputStream)}
 * method.
 * 
 * Based on {@link prefuse.data.io.AbstractGraphWriter}.
 * 
 * @author Alexander Rind
 */

#Code:
public abstract class AbstractTemporalDatasetWriter implements
        TemporalDatasetWriter {

    @Override
    public void writeData(TemporalDataset tmpds, String filename)
            throws DataIOException {
        writeData(tmpds, new File(filename));
    }

    @Override
    public void writeData(TemporalDataset tmpds, File f) throws DataIOException {
        try {
            writeData(tmpds, new FileOutputStream(f));
        } catch (FileNotFoundException e) {
            throw new DataIOException(e);
        }
    }
}

#No. 5149
#File: E:\bishe\1\AbstractTerminatableThread.java
#Comment:
	/**
	 * 
	 * @param terminationToken 线程间共享的线程终止标志实例
	 */

#Code:
	public AbstractTerminatableThread(TerminationToken terminationToken) {
		super();
		this.terminationToken = terminationToken;
	}

#No. 5150
#File: E:\bishe\1\AbstractTerminatableThread.java
#Comment:
				/*
				 * 在执行线程的处理逻辑前先判断线程停止的标志。
				 */

#Code:
				if (terminationToken.isToShutdown()
				    && terminationToken.reservations.get()<=0) {
					break;
				}

#No. 5151
#File: E:\bishe\1\AbstractTermOperator.java
#Comment:
		/**
		 * <p>prepareToCreateVariableTerm.</p>
		 *
		 * @param varName a {@link java.lang.String} object.
		 * @return a {@link lupos.gui.operatorgraph.visualeditor.visualrif.util.Term} object.
		 */

#Code:
		public Term prepareToCreateVariableTerm(final String varName) {
			final Term term = new Term(varName);
			term.setVariable( true );
			return term;
		}

#No. 5152
#File: E:\bishe\1\AbstractTermOperator.java
#Comment:
		/**
		 * <p>prepareToCreateConstantTerm.</p>
		 *
		 * @param prefix a {@link java.lang.String} object.
		 * @param name a {@link java.lang.String} object.
		 * @param comboBoxEntries an array of {@link java.lang.String} objects.
		 * @return a {@link lupos.gui.operatorgraph.visualeditor.visualrif.util.Term} object.
		 */

#Code:
		public Term prepareToCreateConstantTerm(final String prefix, final String name, final String[] comboBoxEntries) {
			final Term term = new Term(name);
			term.setConstant(true);
			term.setSelectedPrefix(prefix);
			term.setComboEntries(comboBoxEntries);
			return term;
		}

#No. 5153
#File: E:\bishe\1\AbstractTermOperator.java
#Comment:
		/**
		 * <p>prepareToCreateUnitermTerm.</p>
		 *
		 * @param unitermOperator a {@link lupos.gui.operatorgraph.visualeditor.visualrif.operators.UnitermOperator} object.
		 * @param comboBoxEntries an array of {@link java.lang.String} objects.
		 * @return a {@link lupos.gui.operatorgraph.visualeditor.visualrif.util.Term} object.
		 */

#Code:
		public Term prepareToCreateUnitermTerm(final UnitermOperator unitermOperator, final String[] comboBoxEntries) {
			final Term term = new Term();
			term.setUniterm(true);
			term.setAbstractTermOperator(unitermOperator);
			term.setComboEntries(comboBoxEntries);
			term.setSucceedingOperator(new GraphWrapperOperator(unitermOperator));
			this.addSucceedingOperator(new OperatorIDTuple<Operator>(unitermOperator, 0));
			unitermOperator.addPrecedingOperator(this);
			return term;
		}

#No. 5154
#File: E:\bishe\1\AbstractTermOperator.java
#Comment:
		/**
		 * <p>prepareToCreateListTerm.</p>
		 *
		 * @param listOperator a {@link lupos.gui.operatorgraph.visualeditor.visualrif.operators.ListOperator} object.
		 * @param comboBoxEntries an array of {@link java.lang.String} objects.
		 * @return a {@link lupos.gui.operatorgraph.visualeditor.visualrif.util.Term} object.
		 */

#Code:
		public Term prepareToCreateListTerm(final ListOperator listOperator,
				final String[] comboBoxEntries) {
			final Term term = new Term();
			term.setList(true);
			term.setAbstractTermOperator(listOperator);
			term.setComboEntries(comboBoxEntries);
			term.setSucceedingOperator(new GraphWrapperOperator(listOperator));
			this.addSucceedingOperator(new OperatorIDTuple<Operator>(listOperator, 0));
			listOperator.addPrecedingOperator(this);
			return term;
		}

#No. 5155
#File: E:\bishe\1\AbstractTermOperator.java
#Comment:
		/**
		 * <p>prepareToCreateFrameTerm.</p>
		 *
		 * @param listOperator a {@link lupos.gui.operatorgraph.visualeditor.visualrif.operators.ListOperator} object.
		 * @param comboBoxEntries an array of {@link java.lang.String} objects.
		 * @return a {@link lupos.gui.operatorgraph.visualeditor.visualrif.util.Term} object.
		 */

#Code:
		public Term prepareToCreateFrameTerm(final ListOperator listOperator,
				final String[] comboBoxEntries) {
			final Term term = new Term();
			term.setFrame(true);
			term.setAbstractTermOperator(listOperator);
			term.setComboEntries(comboBoxEntries);
			term.setSucceedingOperator(new GraphWrapperOperator(listOperator));
			this.addSucceedingOperator(new OperatorIDTuple<Operator>(listOperator, 0));
			listOperator.addPrecedingOperator(this);
			return term;
		}

#No. 5156
#File: E:\bishe\1\AbstractTermOperator.java
#Comment:
		/**
		 * <p>getTermSucceedingElements.</p>
		 *
		 * @return a {@link java.util.List} object.
		 */

#Code:
		public List<Operator> getTermSucceedingElements(){
			final LinkedList<Operator> list = new LinkedList<Operator>();
			for( final Term term : this.getTerms()){
				System.out.println(term.isUniterm());
				if( (term.isList() || term.isUniterm()) ){
					final GraphWrapper childGW = term.getSucceedingOperator();
					if(childGW==null){
						final Operator dummyOperator = term.getDummyOperator();
						if(dummyOperator==null){
							continue;
						}
						list.add(dummyOperator);

					} else {
						list.add((Operator)childGW.getElement());
					}
				}
			}
			System.out.println("AbstractTermOperator. getTermSucceedingElements() "+list.size());
			return list;
		}

#No. 5157
#File: E:\bishe\1\AbstractTermOperator.java
#Comment:
		/**
		 * <p>getSucceedingElementsWithoutTermSucceedingElements.</p>
		 *
		 * @return a {@link java.util.List} object.
		 */

#Code:
		public List<Operator> getSucceedingElementsWithoutTermSucceedingElements(){
			final LinkedList<Operator> list = new LinkedList<Operator>();
			for(final OperatorIDTuple<Operator> opIDTuple : this.getSucceedingOperators()){
				list.add(opIDTuple.getOperator());
			}
			list.removeAll(this.getTermSucceedingElements());
			return list;
		}

#No. 5158
#File: E:\bishe\1\AbstractTermOperator.java
#Comment:
		/**
		 * up = true , down = false
		 *
		 * @param term a {@link lupos.gui.operatorgraph.visualeditor.visualrif.util.Term} object.
		 * @param upOrDown a boolean.
		 */

#Code:
		public void swapTerms(final Term term, final boolean upOrDown){
			if ( this.terms.size() > 1 ){
				// Up
				if ( upOrDown ){
					for (int i = 0; i < this.terms.size() ; i++) {
						if ( this.terms.get(i) == term && (i != 0)){
							final Term tmp = this.terms.get(i);
							this.terms.remove(this.terms.get(i));
							this.terms.add(i-1, tmp);
							break;
						}
					}

				} // end up
				// down
				else {
					for (int i = 0; i < this.terms.size(); i++) {
						if (this.terms.get(i) == term && (i != this.terms.size()-1)) {
							final Term tmp = this.terms.get(i);
							this.terms.remove(this.terms.get(i));
							this.terms.add(i + 1, tmp);
							break;
						}
					}
				}// end down
			}
		}

#No. 5159
#File: E:\bishe\1\AbstractTermOperator.java
#Comment:
		/**
		 * <p>hasElements.</p>
		 *
		 * @return a boolean.
		 */

#Code:
		public boolean hasElements() {
			return !this.terms.isEmpty();
		}

#No. 5160
#File: E:\bishe\1\AbstractTermOperator.java
#Comment:
		/**
		 * Sets the ComboBox entries for UniTermComboBox and the
		 * ConstantComboBox
		 *
		 * @param comboBoxEntries an array of {@link java.lang.String} objects.
		 */

#Code:
		public void setConstantComboBoxEntries(final String[] comboBoxEntries){
			this.comboBoxEntries = comboBoxEntries;
			this.getUniTermComboBox().removeAllItems();
			this.getConstantComboBox().removeAllItems();

			// UniTermPrefix
			for (final String s : comboBoxEntries){
				this.getUniTermComboBox().addItem(s);
			}

			this.getUniTermComboBox().setSelectedItem(this.getUniTermPrefix());

			int constantCnt = 0;
			int termCnt = 0;

			for (int i = 0 ; i < this.getTerms().size() ; i++){
				if( this.getTerms().get(i).isConstant() ){
					this.getTerms().get(i).getConstantCombo().removeAllItems();
					for (final String s : comboBoxEntries){
						this.getTerms().get(i).getConstantCombo().addItem(s);
					}
					final JComboBox tmp = this.getTerms().get(i).getConstantCombo();
					tmp.setSelectedItem(this.getSavedPrefixes().get(constantCnt));
					constantCnt++;
				}

				if( this.isNamed() ) {
					this.getTerms().get(i).getNameComboBox().removeAllItems();
					for (final String s : comboBoxEntries){
						this.getTerms().get(i).getNameComboBox().addItem(s);
					}
					final JComboBox tmp = this.getTerms().get(i).getNameComboBox();
					final LinkedList<String> l = this.getSavedNamePrefixes();
					tmp.setSelectedItem(l.get(termCnt));
					termCnt++;
				}
			}
		}

#No. 5161
#File: E:\bishe\1\AbstractTermOperator.java
#Comment:
		/**
		 * <p>sortTerms.</p>
		 *
		 * @param unsortedTerms a {@link java.util.HashMap} object.
		 * @return a {@link java.util.LinkedList} object.
		 */

#Code:
		protected LinkedList<Term> sortTerms(final HashMap<String, Term> unsortedTerms) {
			final LinkedList<Term> terms = new LinkedList<Term>();
			final TreeMap<String, Term> treeMap = new TreeMap<String, Term>();
			treeMap.putAll(unsortedTerms);
			for (final Entry<String, Term> entry : treeMap.entrySet()) {
				terms.add(entry.getValue());
			}
			return terms;
		}

#No. 5162
#File: E:\bishe\1\AbstractTermOperator.java
#Comment:
		/**
		 * <p>getSavedTerms.</p>
		 *
		 * @param termsObject a {@link org.json.JSONObject} object.
		 * @param operator a {@link lupos.gui.operatorgraph.visualeditor.visualrif.operators.AbstractTermOperator} object.
		 * @return a {@link java.util.HashMap} object.
		 * @throws org.json.JSONException if any.
		 */

#Code:
		protected HashMap<String, Term> getSavedTerms(final JSONObject termsObject, final AbstractTermOperator operator) throws JSONException {
			final HashMap<String,Term> unsortedTerms = new HashMap<String,Term>();
			@SuppressWarnings("unchecked")
			final
			Iterator<String> key = termsObject.keys();
			while(key.hasNext()) {
				final String termName = key.next();
				final JSONObject termObj = termsObject.getJSONObject(termName);
				if (termObj.get("TYPE").equals("variable")) {
					final String value = termObj.getString("VALUE");
					final Term term = operator.prepareToCreateVariableTerm(value);
					unsortedTerms.put(termName, term);
				}
				if (termObj.get("TYPE").equals("constant")) {
					final String prefix = termObj.getString("PREFIXVALUE");
					final String value = termObj.getString("VALUE");
					final Term term = operator.prepareToCreateConstantTerm(prefix, value, this.visualRifEditor.getDocumentContainer().getActiveDocument().getDocumentEditorPane().getPrefixList());
					unsortedTerms.put(termName, term);
				}
			}
			return unsortedTerms;
		}

#No. 5163
#File: E:\bishe\1\AbstractTermOperator.java
#Comment:
		/**
		 * Checks whether the name of
		 * the operator is already used.
		 *
		 * @param basename a {@link java.lang.String} object.
		 * @param newname a {@link java.lang.String} object.
		 * @param index a int.
		 * @return a new auto-generated name for the new rule
		 */

#Code:
		public String checkName(final String basename, String newname, int index) {
			boolean exists = false;
			if (!this.termNames.isEmpty()) {
				for (int i = 0; i < this.termNames.size(); i++) {
					if (newname.equalsIgnoreCase(this.termNames.get(i))) {
						newname = basename + index;
						index += 1;
						exists = true;

						break;
					}
				}
				if (exists) {
					newname = this.checkName(basename, newname, index);
				}
			}
			this.termNames.add(newname);
			return newname;
		}

#No. 5164
#File: E:\bishe\1\AbstractTermOperator.java
#Comment:
		/* ***************** **
		 * Getter and Setter **
		 * ***************** */

#Code:
 		/**
 		 * <p>Getter for the field <code>selectedPrefix</code>.</p>
 		 *
 		 * @return a {@link java.lang.String} object.
 		 */
 		public String getSelectedPrefix() {
			return this.selectedPrefix;
		}

#No. 5165
#File: E:\bishe\1\AbstractTermOperator.java
#Comment:
		/**
		 * <p>Setter for the field <code>selectedPrefix</code>.</p>
		 *
		 * @param selectedPrefix a {@link java.lang.String} object.
		 */

#Code:
		public void setSelectedPrefix(final String selectedPrefix) {
			this.selectedPrefix = selectedPrefix;
		}

#No. 5166
#File: E:\bishe\1\AbstractTermOperator.java
#Comment:
		/**
		 * <p>Getter for the field <code>terms</code>.</p>
		 *
		 * @return a {@link java.util.LinkedList} object.
		 */

#Code:
		public LinkedList<Term> getTerms() {
			return this.terms;
		}

#No. 5167
#File: E:\bishe\1\AbstractTermOperator.java
#Comment:
		/**
		 * <p>Setter for the field <code>terms</code>.</p>
		 *
		 * @param terms a {@link java.util.LinkedList} object.
		 */

#Code:
		public void setTerms(final LinkedList<Term> terms) {
			this.terms = terms;
		}

#No. 5168
#File: E:\bishe\1\AbstractTermOperator.java
#Comment:
		/**
		 * <p>Getter for the field <code>termName</code>.</p>
		 *
		 * @return a {@link java.lang.String} object.
		 */

#Code:
		public String getTermName() {
			return this.termName;
		}

#No. 5169
#File: E:\bishe\1\AbstractTermOperator.java
#Comment:
		/**
		 * <p>Setter for the field <code>termName</code>.</p>
		 *
		 * @param termName a {@link java.lang.String} object.
		 */

#Code:
		public void setTermName(final String termName) {
			this.termName = termName;
		}

#No. 5170
#File: E:\bishe\1\AbstractTermOperator.java
#Comment:
		/**
		 * <p>Getter for the field <code>uniTermComboBox</code>.</p>
		 *
		 * @return a {@link javax.swing.JComboBox} object.
		 */

#Code:
		public JComboBox getUniTermComboBox() {
			return this.uniTermComboBox;
		}

#No. 5171
#File: E:\bishe\1\AbstractTermOperator.java
#Comment:
		/**
		 * <p>Setter for the field <code>uniTermComboBox</code>.</p>
		 *
		 * @param comboBox a {@link javax.swing.JComboBox} object.
		 */

#Code:
		public void setUniTermComboBox(final JComboBox comboBox) {
			this.uniTermComboBox = comboBox;
		}

#No. 5172
#File: E:\bishe\1\AbstractTermOperator.java
#Comment:
		/**
		 * <p>Getter for the field <code>constantComboBox</code>.</p>
		 *
		 * @return a {@link javax.swing.JComboBox} object.
		 */

#Code:
		public JComboBox getConstantComboBox() {
			return this.constantComboBox;
		}

#No. 5173
#File: E:\bishe\1\AbstractTermOperator.java
#Comment:
		/**
		 * <p>Setter for the field <code>constantComboBox</code>.</p>
		 *
		 * @param constantComboBox a {@link javax.swing.JComboBox} object.
		 */

#Code:
		public void setConstantComboBox(final JComboBox constantComboBox) {
			this.constantComboBox = constantComboBox;
		}

#No. 5174
#File: E:\bishe\1\AbstractTermOperator.java
#Comment:
		/**
		 * <p>Getter for the field <code>variables</code>.</p>
		 *
		 * @return a {@link java.util.LinkedList} object.
		 */

#Code:
		public LinkedList<String> getVariables() {
			this.addVariabelesToList();
			return this.variables;
		}

#No. 5175
#File: E:\bishe\1\AbstractTermOperator.java
#Comment:
		/**
		 * <p>Setter for the field <code>variables</code>.</p>
		 *
		 * @param variables a {@link java.util.LinkedList} object.
		 */

#Code:
		public void setVariables(final LinkedList<String> variables) {
			this.variables = variables;
		}

#No. 5176
#File: E:\bishe\1\AbstractTermOperator.java
#Comment:
		/**
		 * <p>Setter for the field <code>nextTermCombo</code>.</p>
		 *
		 * @param nextTermCombo a {@link javax.swing.JComboBox} object.
		 */

#Code:
		public void setNextTermCombo(final JComboBox nextTermCombo) {
			this.nextTermCombo = nextTermCombo;
		}

#No. 5177
#File: E:\bishe\1\AbstractTermOperator.java
#Comment:
		/**
		 * <p>Getter for the field <code>nextTermCombo</code>.</p>
		 *
		 * @return a {@link javax.swing.JComboBox} object.
		 */

#Code:
		public JComboBox getNextTermCombo() {
			return this.nextTermCombo;
		}

#No. 5178
#File: E:\bishe\1\AbstractTermOperator.java
#Comment:
		/**
		 * <p>saveUnitermPrefix.</p>
		 */

#Code:
		public void saveUnitermPrefix(){
			this.setUniTermPrefix(this.getSelectedPrefix());

		}

#No. 5179
#File: E:\bishe\1\AbstractTermOperator.java
#Comment:
		/**
		 * <p>savePrefixes.</p>
		 */

#Code:
		public void savePrefixes() {
			this.savedPrefixes = new LinkedList<String>();
			for (int i = 0 ; i < this.getTerms().size() ; i++){
				if(this.getTerms().get(i).isConstant()){
					this.savedPrefixes.add(this.getTerms().get(i).getSelectedPrefix());
				}
			}
		}

#No. 5180
#File: E:\bishe\1\AbstractTermOperator.java
#Comment:
		/**
		 * <p>saveNamePrefixes.</p>
		 */

#Code:
		public void saveNamePrefixes(){
			this.savedNamePrefixes = new LinkedList<String>();
			for (int i = 0; i < this.getTerms().size(); i++) {
				this.savedNamePrefixes.add(this.getTerms().get(i).getPrefixForName());
			}
		}

#No. 5181
#File: E:\bishe\1\AbstractTermOperator.java
#Comment:
		/**
		 * <p>Getter for the field <code>savedPrefixes</code>.</p>
		 *
		 * @return a {@link java.util.LinkedList} object.
		 */

#Code:
		public LinkedList<String> getSavedPrefixes() {
			return this.savedPrefixes;
		}

#No. 5182
#File: E:\bishe\1\AbstractTermOperator.java
#Comment:
		/**
		 * <p>Setter for the field <code>savedPrefixes</code>.</p>
		 *
		 * @param savedPrefixes a {@link java.util.LinkedList} object.
		 */

#Code:
		public void setSavedPrefixes(final LinkedList<String> savedPrefixes) {
			this.savedPrefixes = savedPrefixes;
		}

#No. 5183
#File: E:\bishe\1\AbstractTermOperator.java
#Comment:
		/**
		 * <p>Setter for the field <code>uniTermPrefix</code>.</p>
		 *
		 * @param uniTermPrefix a {@link java.lang.String} object.
		 */

#Code:
		public void setUniTermPrefix(final String uniTermPrefix) {
			this.uniTermPrefix = uniTermPrefix;
		}

#No. 5184
#File: E:\bishe\1\AbstractTermOperator.java
#Comment:
		/**
		 * <p>Getter for the field <code>uniTermPrefix</code>.</p>
		 *
		 * @return a {@link java.lang.String} object.
		 */

#Code:
		public String getUniTermPrefix() {
			return this.uniTermPrefix;
		}

#No. 5185
#File: E:\bishe\1\AbstractTermOperator.java
#Comment:
		/**
		 * <p>Setter for the field <code>external</code>.</p>
		 *
		 * @param external a boolean.
		 */

#Code:
		public void setExternal(final boolean external) {
			this.external = external;
		}

#No. 5186
#File: E:\bishe\1\AbstractTermOperator.java
#Comment:
		/**
		 * <p>isExternal.</p>
		 *
		 * @return a boolean.
		 */

#Code:
		public boolean isExternal() {
			return this.external;
		}

#No. 5187
#File: E:\bishe\1\AbstractTermOperator.java
#Comment:
		/**
		 * <p>Getter for the field <code>selectedRadioButton</code>.</p>
		 *
		 * @return an array of boolean.
		 */

#Code:
		public boolean[] getSelectedRadioButton() {
			return this.selectedRadioButton;
		}

#No. 5188
#File: E:\bishe\1\AbstractTermOperator.java
#Comment:
		/**
		 * <p>Setter for the field <code>selectedRadioButton</code>.</p>
		 *
		 * @param selectedRadioButton an array of boolean.
		 */

#Code:
		public void setSelectedRadioButton(final boolean[] selectedRadioButton) {
			this.selectedRadioButton = selectedRadioButton;
		}

#No. 5189
#File: E:\bishe\1\AbstractTermOperator.java
#Comment:
		/**
		 * <p>isChild.</p>
		 *
		 * @return a boolean.
		 */

#Code:
		public boolean isChild() {
			return this.isChild;
		}

#No. 5190
#File: E:\bishe\1\AbstractTermOperator.java
#Comment:
		/**
		 * <p>setChild.</p>
		 *
		 * @param isChild a boolean.
		 */

#Code:
		public void setChild(final boolean isChild) {
			this.isChild = isChild;
		}

#No. 5191
#File: E:\bishe\1\AbstractTermOperator.java
#Comment:
		/**
		 * <p>Getter for the field <code>selectedClassification</code>.</p>
		 *
		 * @return a {@link java.lang.String} object.
		 */

#Code:
		public String getSelectedClassification() {
			return this.selectedClassification;
		}

#No. 5192
#File: E:\bishe\1\AbstractTermOperator.java
#Comment:
		/**
		 * <p>Setter for the field <code>selectedClassification</code>.</p>
		 *
		 * @param selectedClassification a {@link java.lang.String} object.
		 */

#Code:
		public void setSelectedClassification(final String selectedClassification) {
			this.selectedClassification = selectedClassification;
		}

#No. 5193
#File: E:\bishe\1\AbstractTermOperator.java
#Comment:
		/**
		 * <p>isParent.</p>
		 *
		 * @return a boolean.
		 */

#Code:
		public boolean isParent() {
			return this.parent;
		}

#No. 5194
#File: E:\bishe\1\AbstractTermOperator.java
#Comment:
		/**
		 * <p>Setter for the field <code>parent</code>.</p>
		 *
		 * @param parent a boolean.
		 */

#Code:
		public void setParent(final boolean parent) {
			this.parent = parent;
		}

#No. 5195
#File: E:\bishe\1\AbstractTermOperator.java
#Comment:
		/**
		 * <p>isNamed.</p>
		 *
		 * @return a boolean.
		 */

#Code:
		public boolean isNamed() {
			return this.named;
		}

#No. 5196
#File: E:\bishe\1\AbstractTermOperator.java
#Comment:
		/**
		 * <p>Setter for the field <code>named</code>.</p>
		 *
		 * @param named a boolean.
		 */

#Code:
		public void setNamed(final boolean named) {
			this.named = named;
		}

#No. 5197
#File: E:\bishe\1\AbstractTermOperator.java
#Comment:
		/**
		 * <p>Getter for the field <code>savedNamePrefixes</code>.</p>
		 *
		 * @return a {@link java.util.LinkedList} object.
		 */

#Code:
		public LinkedList<String> getSavedNamePrefixes() {
			return this.savedNamePrefixes;
		}

#No. 5198
#File: E:\bishe\1\AbstractTermOperator.java
#Comment:
		/**
		 * <p>Setter for the field <code>savedNamePrefixes</code>.</p>
		 *
		 * @param savedNamePrefixes a {@link java.util.LinkedList} object.
		 */

#Code:
		public void setSavedNamePrefixes(final LinkedList<String> savedNamePrefixes) {
			this.savedNamePrefixes = savedNamePrefixes;
		}

#No. 5199
#File: E:\bishe\1\AbstractTermOperator.java
#Comment:
		/**
		 * <p>Getter for the field <code>visualRifEditor</code>.</p>
		 *
		 * @return a {@link lupos.gui.operatorgraph.visualeditor.visualrif.VisualRifEditor} object.
		 */

#Code:
		public VisualRifEditor getVisualRifEditor() {
			return this.visualRifEditor;
		}

#No. 5200
#File: E:\bishe\1\AbstractTermOperator.java
#Comment:
		/**
		 * <p>Setter for the field <code>visualRifEditor</code>.</p>
		 *
		 * @param visualRifEditor a {@link lupos.gui.operatorgraph.visualeditor.visualrif.VisualRifEditor} object.
		 */

#Code:
		public void setVisualRifEditor(final VisualRifEditor visualRifEditor) {
			this.visualRifEditor = visualRifEditor;
		}

#No. 5201
#File: E:\bishe\1\AbstractTermOperator.java
#Comment:
		/**
		 * <p>Getter for the field <code>comboBoxEntries</code>.</p>
		 *
		 * @return an array of {@link java.lang.String} objects.
		 */

#Code:
		public String[] getComboBoxEntries() {
			return this.comboBoxEntries;
		}

#No. 5202
#File: E:\bishe\1\AbstractTermOperator.java
#Comment:
		/**
		 * <p>getFactOperatorPanel.</p>
		 *
		 * @return a {@link lupos.gui.operatorgraph.visualeditor.visualrif.guielements.operatorPanel.UnitermOperatorPanel} object.
		 */

#Code:
		public UnitermOperatorPanel getFactOperatorPanel(){
			return (UnitermOperatorPanel) this.panel;
		}

#No. 5203
#File: E:\bishe\1\AbstractTermOperator.java
#Comment:
		/**
		 * <p>getFrameOperatorPanel.</p>
		 *
		 * @return a {@link lupos.gui.operatorgraph.visualeditor.visualrif.guielements.operatorPanel.FrameOperatorPanel} object.
		 */

#Code:
		public FrameOperatorPanel getFrameOperatorPanel(){
			return (FrameOperatorPanel) this.panel;
		}

#No. 5204
#File: E:\bishe\1\AbstractTermOperator.java
#Comment:
		/**
		 * <p>getListOperatorPanel.</p>
		 *
		 * @return a {@link lupos.gui.operatorgraph.visualeditor.visualrif.guielements.operatorPanel.ListOperatorPanel} object.
		 */

#Code:
		public ListOperatorPanel getListOperatorPanel(){
			return (ListOperatorPanel) this.panel;
		}

#No. 5205
#File: E:\bishe\1\AbstractTestBase.java
#Comment:
    /**
     * Stops the Jetty container.
     */

#Code:
    @AfterClass
    public static void cleanupServletContainer () throws Exception
    {
        tester.stop();
        RestAssured.reset();
    }

#No. 5206
#File: E:\bishe\1\AbstractTestDatabase.java
#Comment:
    /**
     * Prepare for test case execute by creating, configuring and starting the main test fixture.
     */

#Code:
    @Before
    public void setUp() {
        initMocks(this);
        database = createDatabaseServer();
        database.configure("database", "test", logger);
        database.configure("username", "sa", logger);
        database.configure("password", "", logger);
        database.start(logger);
    }

#No. 5207
#File: E:\bishe\1\AbstractTestDatabase.java
#Comment:
    /**
     * Clean up after test case execution by stopping the main test fixture.
     */

#Code:
    @After
    public void tearDown() {
        database.stop(logger);
    }

#No. 5208
#File: E:\bishe\1\AbstractTestDatabase.java
#Comment:
    /**
     * Verify that the database server starts and stops cleanly.
     */

#Code:
    @Test
    public void testStartStop() {
    }

#No. 5209
#File: E:\bishe\1\AbstractTestDatabase.java
#Comment:
    /**
     * Verify that a valid DDL/DML script can be loaded.
     */

#Code:
    @Test
    public void testLoadScript() {
        final Script source = new Script();
        source.setSourceFile("src/test/resources/create_database.sql");
        ((Database)database).load(logger, source);
    }

#No. 5210
#File: E:\bishe\1\AbstractTestDatabase.java
#Comment:
    /**
     * Verify than an exception is thrown when the script does not exist.
     */

#Code:
    @Test
    public void testLoadNonExistantScript() {
        final Script source = new Script();
        source.setSourceFile("src/test/resources/create_database1.sql");
        ((Database)database).load(logger, source);
    }

#No. 5211
#File: E:\bishe\1\AbstractTestDatabase.java
#Comment:
    /**
     * Verify than an exception is thrown when the script is invalid.
     */

#Code:
    @Test
    public void testLoadInvalidScript() throws MojoFailureException {
        final Script source = new Script();
        source.setSourceFile("src/test/resources/create_database2.sql");
        ((Database)database).load(logger, source);
    }

#No. 5212
#File: E:\bishe\1\AbstractTestDatabase.java
#Comment:
    /**
     * Verify than an exception is thrown when {@code null} is passed as
     * the source file.
     */

#Code:
    @Test
    public void testLoadNull() throws MojoFailureException {
        ((Database)database).load(logger, null);
    }

#No. 5213
#File: E:\bishe\1\AbstractTestDatabase.java
#Comment:
    /**
     * Verify than an exception is thrown when the source file is actually a
     * directory.
     */

#Code:
    @Test
    public void testLoadDirectory() throws MojoFailureException {
        final Script source = new Script();
        source.setSourceFile("src/test/resources");
        ((Database)database).load(logger, source);
    }

#No. 5214
#File: E:\bishe\1\AbstractTestDatabase.java
#Comment:
    /**
     * Verify that a valid DBUnit XML data set can be loaded.
     */

#Code:
    @Test
    public void testLoadDBUnitXML() {
        final Script script = new Script();
        script.setSourceFile("src/test/resources/create_database.sql");
        ((Database)database).load(logger, script);
        final DataSet source = new DataSet();
        source.setSourceFile("src/test/resources/users.dbunit.xml");
        ((Database)database).load(logger, source);
    }

#No. 5215
#File: E:\bishe\1\AbstractTestDatabase.java
#Comment:
    /**
     * Verify that a valid DBUinit Flat XML data set can be loaded.
     */

#Code:
    @Test
    public void testLoadDBUnitFlatXML() {
        final Script script = new Script();
        script.setSourceFile("src/test/resources/create_database.sql");
        ((Database)database).load(logger, script);
        final DataSet source = new DataSet();
        source.setSourceFile("src/test/resources/users.xml");
        ((Database)database).load(logger, source);
    }

#No. 5216
#File: E:\bishe\1\AbstractTestDatabase.java
#Comment:
    /**
     * Verify that a valid DBUinit CSV data set can be loaded.
     */

#Code:
    @Test
    public void testLoadDBUnitCSV() {
        final Script script = new Script();
        script.setSourceFile("src/test/resources/create_database.sql");
        ((Database)database).load(logger, script);
        final DataSet source = new DataSet();
        source.setSourceFile("src/test/resources/users.csv");
        ((Database)database).load(logger, source);
    }

#No. 5217
#File: E:\bishe\1\AbstractTestDatabase.java
#Comment:
    /**
     * Verify that a valid DBUinit XLS data set can be loaded.
     */

#Code:
    @Test
    public void testLoadDBUnitXLS() {
        final Script script = new Script();
        script.setSourceFile("src/test/resources/create_database.sql");
        ((Database)database).load(logger, script);
        final DataSet source = new DataSet();
        source.setSourceFile("src/test/resources/users.xls");
        ((Database)database).load(logger, source);
    }

#No. 5218
#File: E:\bishe\1\AbstractTester.java
#Comment:
	/**
	 * 运行默认测试用例
	 */

#Code:
	@Test
	public final void runDefault(){
		defaultCase();
	}

#No. 5219
#File: E:\bishe\1\AbstractTestMap.java
#Comment:
    /**
     * Returns the set of values in the mappings used to test the map.  This
     * method must return an array with the same length as
     * {@link #getSampleKeys()}.  The default implementation constructs a set of
     * String values and includes a single null value if
     * {@link #isAllowNullValue()} returns <code>true</code>, and includes
     * two values that are the same if {@link #isAllowDuplicateValues()} returns
     * <code>true</code>.
     */

#Code:
    public Object[] getSampleValues() {
        Object[] result = new Object[]{"blahv", "foov", "barv", "bazv", "tmpv", "goshv", "gollyv", "geev", "hellov", "goodbyev", "we'llv", "seev", "youv", "allv", "againv", (isAllowNullValue() && !JDK12) ? null : "nonnullvalue", "value", (isAllowDuplicateValues()) ? "value" : "value2", };
        return result;
    }

#No. 5220
#File: E:\bishe\1\AbstractTestMap.java
#Comment:
    /**
     * Returns a the set of values that can be used to replace the values
     * returned from {@link #getSampleValues()}.  This method must return an
     * array with the same length as {@link #getSampleValues()}.  The values
     * returned from this method should not be the same as those returned from
     * {@link #getSampleValues()}.  The default implementation constructs a
     * set of String values and includes a single null value if
     * {@link #isAllowNullValue()} returns <code>true</code>, and includes two values
     * that are the same if {@link #isAllowDuplicateValues()} returns
     * <code>true</code>.
     */

#Code:
    public Object[] getNewSampleValues() {
        Object[] result = new Object[]{(isAllowNullValue() && !JDK12 && isAllowDuplicateValues()) ? null : "newnonnullvalue", "newvalue", (isAllowDuplicateValues()) ? "newvalue" : "newvalue2", "newblahv", "newfoov", "newbarv", "newbazv", "newtmpv", "newgoshv", "newgollyv", "newgeev", "newhellov", "newgoodbyev", "newwe'llv", "newseev", "newyouv", "newallv", "newagainv", };
        return result;
    }

#No. 5221
#File: E:\bishe\1\AbstractTestMap.java
#Comment:
    /**
     * Helper method to add all the mappings described by
     * {@link #getSampleKeys()} and {@link #getSampleValues()}.
     */

#Code:
    public void addSampleMappings(Map m) {

        Object[] keys = getSampleKeys();
        Object[] values = getSampleValues();

        for (int i = 0; i < keys.length; i++) {
            try {
                m.put(keys[i], values[i]);
            } catch (NullPointerException exception) {
                assertTrue("NullPointerException only allowed to be thrown " + "if either the key or value is null.", keys[i] == null || values[i] == null);

                assertTrue("NullPointerException on null key, but " + "isAllowNullKey is not overridden to return false.", keys[i] == null || !isAllowNullKey());

                assertTrue("NullPointerException on null value, but " + "isAllowNullValue is not overridden to return false.", values[i] == null || !isAllowNullValue());

                assertTrue("Unknown reason for NullPointer.", false);
            }
        }
        assertEquals("size must reflect number of mappings added.", keys.length, m.size());
    }

#No. 5222
#File: E:\bishe\1\AbstractTestMap.java
#Comment:
    /**
     * Return a new, empty {@link Map} to be used for testing.
     *
     * @return the map to be tested
     */

#Code:
    public abstract Map makeEmptyMap();

    /**
     * Return a new, populated map.  The mappings in the map should match the
     * keys and values returned from {@link #getSampleKeys()} and
     * {@link #getSampleValues()}.  The default implementation uses makeEmptyMap()
     * and calls {@link #addSampleMappings} to add all the mappings to the
     * map.
     *
     * @return the map to be tested
     */
    public Map makeFullMap() {
        Map m = makeEmptyMap();
        addSampleMappings(m);
        return m;
    }

#No. 5223
#File: E:\bishe\1\AbstractTestMap.java
#Comment:
    /**
     * Implements the superclass method to return the map to be tested.
     *
     * @return the map to be tested
     */

#Code:
    public Object makeObject() {
        return makeEmptyMap();
    }

#No. 5224
#File: E:\bishe\1\AbstractTestMap.java
#Comment:
    /**
     * Override to return a map other than HashMap as the confirmed map.
     *
     * @return a map that is known to be valid
     */

#Code:
    public Map makeConfirmedMap() {
        return new HashMap();
    }

#No. 5225
#File: E:\bishe\1\AbstractTestMap.java
#Comment:
    /**
     * Creates a new Map Entry that is independent of the first and the map.
     */

#Code:
    public Map.Entry cloneMapEntry(Map.Entry entry) {
        HashMap map = new HashMap();
        map.put(entry.getKey(), entry.getValue());
        return (Map.Entry) map.entrySet().iterator().next();
    }

#No. 5226
#File: E:\bishe\1\AbstractTestMap.java
#Comment:
    /**
     * Gets the compatability version, needed for package access.
     */

#Code:
    public String getCompatibilityVersion() {
        return super.getCompatibilityVersion();
    }

#No. 5227
#File: E:\bishe\1\AbstractTestMap.java
#Comment:
    /**
     * Test to ensure the test setup is working properly.  This method checks
     * to ensure that the getSampleKeys and getSampleValues methods are
     * returning results that look appropriate.  That is, they both return a
     * non-null array of equal length.  The keys array must not have any
     * duplicate values, and may only contain a (single) null key if
     * isNullKeySupported() returns true.  The values array must only have a null
     * value if useNullValue() is true and may only have duplicate values if
     * isAllowDuplicateValues() returns true.
     */

#Code:
    public void testSampleMappings() {
        Object[] keys = getSampleKeys();
        Object[] values = getSampleValues();
        Object[] newValues = getNewSampleValues();

        assertTrue("failure in test: Must have keys returned from " + "getSampleKeys.", keys != null);

        assertTrue("failure in test: Must have values returned from " + "getSampleValues.", values != null);

        // verify keys and values have equivalent lengths (in case getSampleX are
        // overridden)
        assertEquals("failure in test: not the same number of sample " + "keys and values.", keys.length, values.length);

        assertEquals("failure in test: not the same number of values and new values.", values.length, newValues.length);

        // verify there aren't duplicate keys, and check values
        for (int i = 0; i < keys.length - 1; i++) {
            for (int j = i + 1; j < keys.length; j++) {
                assertTrue("failure in test: duplicate null keys.", (keys[i] != null || keys[j] != null));
                assertTrue("failure in test: duplicate non-null key.", (keys[i] == null || keys[j] == null || (!keys[i].equals(keys[j]) && !keys[j].equals(keys[i]))));
            }
            assertTrue("failure in test: found null key, but isNullKeySupported " + "is false.", keys[i] != null || isAllowNullKey());
            assertTrue("failure in test: found null value, but isNullValueSupported " + "is false.", values[i] != null || isAllowNullValue());
            assertTrue("failure in test: found null new value, but isNullValueSupported " + "is false.", newValues[i] != null || isAllowNullValue());
            assertTrue("failure in test: values should not be the same as new value", values[i] != newValues[i] && (values[i] == null || !values[i].equals(newValues[i])));
        }
    }

#No. 5228
#File: E:\bishe\1\AbstractTestMap.java
#Comment:
    /**
     * Test to ensure that makeEmptyMap and makeFull returns a new non-null
     * map with each invocation.
     */

#Code:
    public void testMakeMap() {
        Map em = makeEmptyMap();
        assertTrue("failure in test: makeEmptyMap must return a non-null map.", em != null);

        Map em2 = makeEmptyMap();
        assertTrue("failure in test: makeEmptyMap must return a non-null map.", em != null);

        assertTrue("failure in test: makeEmptyMap must return a new map " + "with each invocation.", em != em2);

        Map fm = makeFullMap();
        assertTrue("failure in test: makeFullMap must return a non-null map.", fm != null);

        Map fm2 = makeFullMap();
        assertTrue("failure in test: makeFullMap must return a non-null map.", fm != null);

        assertTrue("failure in test: makeFullMap must return a new map " + "with each invocation.", fm != fm2);
    }

#No. 5229
#File: E:\bishe\1\AbstractTestMap.java
#Comment:
    /**
     * Tests Map.isEmpty()
     */

#Code:
    public void testMapIsEmpty() {
        resetEmpty();
        assertEquals("Map.isEmpty() should return true with an empty map", true, map.isEmpty());
        verify();

        resetFull();
        assertEquals("Map.isEmpty() should return false with a non-empty map", false, map.isEmpty());
        verify();
    }

#No. 5230
#File: E:\bishe\1\AbstractTestMap.java
#Comment:
    /**
     * Tests Map.size()
     */

#Code:
    public void testMapSize() {
        resetEmpty();
        assertEquals("Map.size() should be 0 with an empty map", 0, map.size());
        verify();

        resetFull();
        assertEquals("Map.size() should equal the number of entries " + "in the map", getSampleKeys().length, map.size());
        verify();
    }

#No. 5231
#File: E:\bishe\1\AbstractTestMap.java
#Comment:
    /**
     * Tests {@link Map#clear()}.  If the map {@link #isRemoveSupported()}
     * can add and remove elements}, then {@link Map#size()} and
     * {@link Map#isEmpty()} are used to ensure that map has no elements after
     * a call to clear.  If the map does not support adding and removing
     * elements, this method checks to ensure clear throws an
     * UnsupportedOperationException.
     */

#Code:
    public void testMapClear() {
        if (!isRemoveSupported()) {
            try {
                resetFull();
                map.clear();
                fail("Expected UnsupportedOperationException on clear");
            } catch (UnsupportedOperationException ex) {
            }
            return;
        }

        resetEmpty();
        map.clear();
        confirmed.clear();
        verify();

        resetFull();
        map.clear();
        confirmed.clear();
        verify();
    }

#No. 5232
#File: E:\bishe\1\AbstractTestMap.java
#Comment:
    /**
     * Tests Map.containsKey(Object) by verifying it returns false for all
     * sample keys on a map created using an empty map and returns true for
     * all sample keys returned on a full map.
     */

#Code:
    public void testMapContainsKey() {
        Object[] keys = getSampleKeys();

        resetEmpty();
        for (int i = 0; i < keys.length; i++) {
            assertTrue("Map must not contain key when map is empty", !map.containsKey(keys[i]));
        }
        verify();

        resetFull();
        for (int i = 0; i < keys.length; i++) {
            assertTrue("Map must contain key for a mapping in the map. " + "Missing: " + keys[i], map.containsKey(keys[i]));
        }
        verify();
    }

#No. 5233
#File: E:\bishe\1\AbstractTestMap.java
#Comment:
    /**
     * Tests Map.containsValue(Object) by verifying it returns false for all
     * sample values on an empty map and returns true for all sample values on
     * a full map.
     */

#Code:
    public void testMapContainsValue() {
        Object[] values = getSampleValues();

        resetEmpty();
        for (int i = 0; i < values.length; i++) {
            assertTrue("Empty map must not contain value", !map.containsValue(values[i]));
        }
        verify();

        resetFull();
        for (int i = 0; i < values.length; i++) {
            assertTrue("Map must contain value for a mapping in the map.", map.containsValue(values[i]));
        }
        verify();
    }

#No. 5234
#File: E:\bishe\1\AbstractTestMap.java
#Comment:
    /**
     * Tests Map.equals(Object)
     */

#Code:
    public void testMapEquals() {
        resetEmpty();
        assertTrue("Empty maps unequal.", map.equals(confirmed));
        verify();

        resetFull();
        assertTrue("Full maps unequal.", map.equals(confirmed));
        verify();

        resetFull();
        // modify the HashMap created from the full map and make sure this
        // change results in map.equals() to return false.
        Iterator iter = confirmed.keySet().iterator();
        iter.next();
        iter.remove();
        assertTrue("Different maps equal.", !map.equals(confirmed));

        resetFull();
        assertTrue("equals(null) returned true.", !map.equals(null));
        assertTrue("equals(new Object()) returned true.", !map.equals(new Object()));
        verify();
    }

#No. 5235
#File: E:\bishe\1\AbstractTestMap.java
#Comment:
    /**
     * Tests Map.get(Object)
     */

#Code:
    public void testMapGet() {
        resetEmpty();

        Object[] keys = getSampleKeys();
        Object[] values = getSampleValues();

        for (int i = 0; i < keys.length; i++) {
            assertTrue("Empty map.get() should return null.", map.get(keys[i]) == null);
        }
        verify();

        resetFull();
        for (int i = 0; i < keys.length; i++) {
            assertEquals("Full map.get() should return value from mapping.", values[i], map.get(keys[i]));
        }
    }

#No. 5236
#File: E:\bishe\1\AbstractTestMap.java
#Comment:
    /**
     * Tests Map.hashCode()
     */

#Code:
    public void testMapHashCode() {
        resetEmpty();
        assertTrue("Empty maps have different hashCodes.", map.hashCode() == confirmed.hashCode());

        resetFull();
        assertTrue("Equal maps have different hashCodes.", map.hashCode() == confirmed.hashCode());
    }

#No. 5237
#File: E:\bishe\1\AbstractTestMap.java
#Comment:
    /**
     * Tests Map.toString().  Since the format of the string returned by the
     * toString() method is not defined in the Map interface, there is no
     * common way to test the results of the toString() method.  Thereforce,
     * it is encouraged that Map implementations override this test with one
     * that checks the format matches any format defined in its API.  This
     * default implementation just verifies that the toString() method does
     * not return null.
     */

#Code:
    public void testMapToString() {
        resetEmpty();
        assertTrue("Empty map toString() should not return null", map.toString() != null);
        verify();

        resetFull();
        assertTrue("Empty map toString() should not return null", map.toString() != null);
        verify();
    }

#No. 5238
#File: E:\bishe\1\AbstractTestMap.java
#Comment:
    /**
     * Compare the current serialized form of the Map
     * against the canonical version in CVS.
     */

#Code:
    public void testEmptyMapCompatibility() throws Exception {
        /**
         * Create canonical objects with this code
         Map map = makeEmptyMap();
         if (!(map instanceof Serializable)) return;

         writeExternalFormToDisk((Serializable) map, getCanonicalEmptyCollectionName(map));
         */

        // test to make sure the canonical form has been preserved
        // GenericsNote: Serialized compatibility with older class versions is not supported for now
        //Map map = makeEmptyMap();
        //if (map instanceof Serializable && !skipSerializedCanonicalTests() && isTestSerialization()) {
        //    Map map2 = (Map) readExternalFormFromDisk(getCanonicalEmptyCollectionName(map));
        //    assertEquals("Map is empty", 0, map2.size());
        //}
    }

#No. 5239
#File: E:\bishe\1\AbstractTestMap.java
#Comment:
    /**
     * Compare the current serialized form of the Map
     * against the canonical version in CVS.
     */

#Code:
    public void testFullMapCompatibility() throws Exception {
        /**
         * Create canonical objects with this code
         Map map = makeFullMap();
         if (!(map instanceof Serializable)) return;

         writeExternalFormToDisk((Serializable) map, getCanonicalFullCollectionName(map));
         */

        // test to make sure the canonical form has been preserved
        // GenericsNote: Serialized compatibility with older class versions is not supported for now
        //Map map = makeFullMap();
        //if (map instanceof Serializable && !skipSerializedCanonicalTests() && isTestSerialization()) {
        //    Map map2 = (Map) readExternalFormFromDisk(getCanonicalFullCollectionName(map));
        //    assertEquals("Map is the right size", getSampleKeys().length, map2.size());
        //}
    }

#No. 5240
#File: E:\bishe\1\AbstractTestMap.java
#Comment:
    /**
     * Tests Map.put(null, value)
     */

#Code:
    public void testMapPutNullKey() {
        resetFull();
        Object[] values = getSampleValues();

        if (isPutAddSupported()) {
            if (isAllowNullKey()) {
                map.put(null, values[0]);
            } else {
                try {
                    map.put(null, values[0]);
                    fail("put(null, value) should throw NPE/IAE");
                } catch (NullPointerException ex) {
                } catch (IllegalArgumentException ex) {
                }
            }
        }
    }

#No. 5241
#File: E:\bishe\1\AbstractTestMap.java
#Comment:
    /**
     * Tests Map.put(null, value)
     */

#Code:
    public void testMapPutNullValue() {
        resetFull();
        Object[] keys = getSampleKeys();

        if (isPutAddSupported()) {
            if (isAllowNullValue()) {
                map.put(keys[0], null);
            } else {
                try {
                    map.put(keys[0], null);
                    fail("put(key, null) should throw NPE/IAE");
                } catch (NullPointerException ex) {
                } catch (IllegalArgumentException ex) {
                }
            }
        }
    }

#No. 5242
#File: E:\bishe\1\AbstractTestMap.java
#Comment:
    /**
     * Tests Map.putAll(map)
     */

#Code:
    public void testMapPutAll() {
        if (!isPutAddSupported()) {
            if (!isPutChangeSupported()) {
                Map temp = makeFullMap();
                resetEmpty();
                try {
                    map.putAll(temp);
                    fail("Expected UnsupportedOperationException on putAll");
                } catch (UnsupportedOperationException ex) {
                }
            }
            return;
        }

        resetEmpty();

        Map m2 = makeFullMap();

        map.putAll(m2);
        confirmed.putAll(m2);
        verify();

        resetEmpty();

        m2 = makeConfirmedMap();
        Object[] keys = getSampleKeys();
        Object[] values = getSampleValues();
        for (int i = 0; i < keys.length; i++) {
            m2.put(keys[i], values[i]);
        }

        map.putAll(m2);
        confirmed.putAll(m2);
        verify();
    }

#No. 5243
#File: E:\bishe\1\AbstractTestMap.java
#Comment:
    /**
     * Tests that the {@link Map#values} collection is backed by
     * the underlying map for clear().
     */

#Code:
    public void testValuesClearChangesMap() {
        if (!isRemoveSupported()) return;
        
        // clear values, reflected in map
        resetFull();
        Collection values = map.values();
        assertTrue(map.size() > 0);
        assertTrue(values.size() > 0);
        values.clear();
        assertTrue(map.size() == 0);
        assertTrue(values.size() == 0);
        
        // clear map, reflected in values
        resetFull();
        values = map.values();
        assertTrue(map.size() > 0);
        assertTrue(values.size() > 0);
        map.clear();
        assertTrue(map.size() == 0);
        assertTrue(values.size() == 0);
    }

#No. 5244
#File: E:\bishe\1\AbstractTestMap.java
#Comment:
    /**
     * Tests that the {@link Map#keySet} collection is backed by
     * the underlying map for clear().
     */

#Code:
    public void testKeySetClearChangesMap() {
        if (!isRemoveSupported()) return;
        
        // clear values, reflected in map
        resetFull();
        Set keySet = map.keySet();
        assertTrue(map.size() > 0);
        assertTrue(keySet.size() > 0);
        keySet.clear();
        assertTrue(map.size() == 0);
        assertTrue(keySet.size() == 0);
        
        // clear map, reflected in values
        resetFull();
        keySet = map.keySet();
        assertTrue(map.size() > 0);
        assertTrue(keySet.size() > 0);
        map.clear();
        assertTrue(map.size() == 0);
        assertTrue(keySet.size() == 0);
    }

#No. 5245
#File: E:\bishe\1\AbstractTestMap.java
#Comment:
    /**
     * Tests that the {@link Map#entrySet()} collection is backed by
     * the underlying map for clear().
     */

#Code:
    public void testEntrySetClearChangesMap() {
        if (!isRemoveSupported()) return;
        
        // clear values, reflected in map
        resetFull();
        Set entrySet = map.entrySet();
        assertTrue(map.size() > 0);
        assertTrue(entrySet.size() > 0);
        entrySet.clear();
        assertTrue(map.size() == 0);
        assertTrue(entrySet.size() == 0);
        
        // clear map, reflected in values
        resetFull();
        entrySet = map.entrySet();
        assertTrue(map.size() > 0);
        assertTrue(entrySet.size() > 0);
        map.clear();
        assertTrue(map.size() == 0);
        assertTrue(entrySet.size() == 0);
    }

#No. 5246
#File: E:\bishe\1\AbstractTestMap.java
#Comment:
    /**
     * Tests that the {@link Map#values} collection is backed by
     * the underlying map by removing from the values collection
     * and testing if the value was removed from the map.
     * <p/>
     * We should really test the "vice versa" case--that values removed
     * from the map are removed from the values collection--also,
     * but that's a more difficult test to construct (lacking a
     * "removeValue" method.)
     * </p>
     * <p/>
     * See bug <a href="http://issues.apache.org/bugzilla/show_bug.cgi?id=9573">
     * 9573</a>.
     * </p>
     */

#Code:
    public void testValuesRemoveChangesMap() {
        resetFull();
        Object[] sampleValues = getSampleValues();
        Collection values = map.values();
        for (int i = 0; i < sampleValues.length; i++) {
            if (map.containsValue(sampleValues[i])) {
                int j = 0;  // loop counter prevents infinite loops when remove is broken
                while (values.contains(sampleValues[i]) && j < 10000) {
                    try {
                        values.remove(sampleValues[i]);
                    } catch (UnsupportedOperationException e) {
                        // if values.remove is unsupported, just skip this test
                        return;
                    }
                    j++;
                }
                assertTrue("values().remove(obj) is broken", j < 10000);
                assertTrue("Value should have been removed from the underlying map.", !map.containsValue(sampleValues[i]));
            }
        }
    }

#No. 5247
#File: E:\bishe\1\AbstractTestMap.java
#Comment:
    /**
     * Tests that the {@link Map#keySet} set is backed by
     * the underlying map by removing from the keySet set
     * and testing if the key was removed from the map.
     */

#Code:
    public void testKeySetRemoveChangesMap() {
        resetFull();
        Object[] sampleKeys = getSampleKeys();
        Set keys = map.keySet();
        for (int i = 0; i < sampleKeys.length; i++) {
            try {
                keys.remove(sampleKeys[i]);
            } catch (UnsupportedOperationException e) {
                // if key.remove is unsupported, just skip this test
                return;
            }
            assertTrue("Key should have been removed from the underlying map.", !map.containsKey(sampleKeys[i]));
        }
    }

#No. 5248
#File: E:\bishe\1\AbstractTestMap.java
#Comment:
    /**
     * Utility methods to create an array of Map.Entry objects
     * out of the given key and value arrays.<P>
     *
     * @param keys   the array of keys
     * @param values the array of values
     * @return an array of Map.Entry of those keys to those values
     */

#Code:
    private Map.Entry[] makeEntryArray(Object[] keys, Object[] values) {
        Map.Entry[] result = new Map.Entry[keys.length];
        for (int i = 0; i < keys.length; i++) {
            Map map = makeConfirmedMap();
            map.put(keys[i], values[i]);
            result[i] = (Map.Entry) map.entrySet().iterator().next();
        }
        return result;
    }

#No. 5249
#File: E:\bishe\1\AbstractTestMap.java
#Comment:
    /**
     * Bulk test {@link Map#entrySet()}.  This method runs through all of
     * the tests in {@link AbstractTestSet}.
     * After modification operations, {@link #verify()} is invoked to ensure
     * that the map and the other collection views are still valid.
     *
     * @return a {@link AbstractTestSet} instance for testing the map's entry set
     */

#Code:
    public BulkTest bulkTestMapEntrySet() {
        return new TestMapEntrySet();
    }

#No. 5250
#File: E:\bishe\1\AbstractTestMap.java
#Comment:
    /**
     * Bulk test {@link Map#keySet()}.  This method runs through all of
     * the tests in {@link AbstractTestSet}.
     * After modification operations, {@link #verify()} is invoked to ensure
     * that the map and the other collection views are still valid.
     *
     * @return a {@link AbstractTestSet} instance for testing the map's key set
     */

#Code:
    public BulkTest bulkTestMapKeySet() {
        return new TestMapKeySet();
    }

#No. 5251
#File: E:\bishe\1\AbstractTestMap.java
#Comment:
    /**
     * Bulk test {@link Map#values()}.  This method runs through all of
     * the tests in {@link AbstractTestCollection}.
     * After modification operations, {@link #verify()} is invoked to ensure
     * that the map and the other collection views are still valid.
     *
     * @return a {@link AbstractTestCollection} instance for testing the map's
     *         values collection
     */

#Code:
    public BulkTest bulkTestMapValues() {
        return new TestMapValues();
    }

#No. 5252
#File: E:\bishe\1\AbstractTestMap.java
#Comment:
    /**
     * Resets the {@link #map}, {@link #entrySet}, {@link #keySet},
     * {@link #values} and {@link #confirmed} fields to empty.
     */

#Code:
    public void resetEmpty() {
        this.map = makeEmptyMap();
        views();
        this.confirmed = makeConfirmedMap();
    }

#No. 5253
#File: E:\bishe\1\AbstractTestMap.java
#Comment:
    /**
     * Resets the {@link #map}, {@link #entrySet}, {@link #keySet},
     * {@link #values} and {@link #confirmed} fields to full.
     */

#Code:
    public void resetFull() {
        this.map = makeFullMap();
        views();
        this.confirmed = makeConfirmedMap();
        Object[] k = getSampleKeys();
        Object[] v = getSampleValues();
        for (int i = 0; i < k.length; i++) {
            confirmed.put(k[i], v[i]);
        }
    }

#No. 5254
#File: E:\bishe\1\AbstractTestMap.java
#Comment:
    /**
     * Resets the collection view fields.
     */

#Code:
    private void views() {
        this.keySet = map.keySet();
        this.values = map.values();
        this.entrySet = map.entrySet();
    }

#No. 5255
#File: E:\bishe\1\AbstractTestMap.java
#Comment:
    /**
     * Verifies that {@link #map} is still equal to {@link #confirmed}.
     * This method checks that the map is equal to the HashMap,
     * <I>and</I> that the map's collection views are still equal to
     * the HashMap's collection views.  An <Code>equals</Code> test
     * is done on the maps and their collection views; their size and
     * <Code>isEmpty</Code> results are compared; their hashCodes are
     * compared; and <Code>containsAll</Code> tests are run on the
     * collection views.
     */

#Code:
    public void verify() {
        verifyMap();
        verifyEntrySet();
        verifyKeySet();
        verifyValues();
    }

#No. 5256
#File: E:\bishe\1\AbstractTestMap.java
#Comment:
    /**
     * Erases any leftover instance variables by setting them to null.
     */

#Code:
    public void tearDown() throws Exception {
        map = null;
        keySet = null;
        entrySet = null;
        values = null;
        confirmed = null;
    }

#No. 5257
#File: E:\bishe\1\AbstractTestMultiMap.java
#Comment:
    /**
     * Returns the set of values in the mappings used to test the map.  This
     * method must return an array with the same length as
     * {@link #getSampleKeys()}.  The default implementation constructs a set of
     * String values and includes a single null value if
     * {@link #isAllowNullValue()} returns <code>true</code>, and includes
     * two values that are the same if {@link #isAllowDuplicateValues()} returns
     * <code>true</code>.
     */

#Code:
    public Object[] getSampleValues() {
        Object[] result = new Object[]{"blahv", "foov", "barv", "bazv", "tmpv", "goshv", "gollyv", "geev", "hellov", "goodbyev", "we'llv", "seev", "youv", "allv", "againv", (isAllowNullValue() && !JDK12) ? null : "nonnullvalue", "value", (isAllowDuplicateValues()) ? "value" : "value2", };
        return result;
    }

#No. 5258
#File: E:\bishe\1\AbstractTestMultiMap.java
#Comment:
    /**
     * Returns a the set of values that can be used to replace the values
     * returned from {@link #getSampleValues()}.  This method must return an
     * array with the same length as {@link #getSampleValues()}.  The values
     * returned from this method should not be the same as those returned from
     * {@link #getSampleValues()}.  The default implementation constructs a
     * set of String values and includes a single null value if
     * {@link #isAllowNullValue()} returns <code>true</code>, and includes two values
     * that are the same if {@link #isAllowDuplicateValues()} returns
     * <code>true</code>.
     */

#Code:
    public Object[] getNewSampleValues() {
        Object[] result = new Object[]{(isAllowNullValue() && !JDK12 && isAllowDuplicateValues()) ? null : "newnonnullvalue", "newvalue", (isAllowDuplicateValues()) ? "newvalue" : "newvalue2", "newblahv", "newfoov", "newbarv", "newbazv", "newtmpv", "newgoshv", "newgollyv", "newgeev", "newhellov", "newgoodbyev", "newwe'llv", "newseev", "newyouv", "newallv", "newagainv", };
        return result;
    }

#No. 5259
#File: E:\bishe\1\AbstractTestMultiMap.java
#Comment:
    /**
     * Helper method to add all the mappings described by
     * {@link #getSampleKeys()} and {@link #getSampleValues()}.
     */

#Code:
    public void addSampleMappings(MultiMap m) {

        Object[] keys = getSampleKeys();
        Object[] values = getSampleValues();

        for (int i = 0; i < keys.length; i++) {
            try {
                m.put(keys[i], values[i]);
            } catch (NullPointerException exception) {
                assertTrue("NullPointerException only allowed to be thrown " + "if either the key or value is null.", keys[i] == null || values[i] == null);

                assertTrue("NullPointerException on null key, but " + "isAllowNullKey is not overridden to return false.", keys[i] == null || !isAllowNullKey());

                assertTrue("NullPointerException on null value, but " + "isAllowNullValue is not overridden to return false.", values[i] == null || !isAllowNullValue());

                assertTrue("Unknown reason for NullPointer.", false);
            }
        }
        assertEquals("size must reflect number of mappings added.", keys.length, m.size());
    }

#No. 5260
#File: E:\bishe\1\AbstractTestMultiMap.java
#Comment:
    /**
     * Return a new, empty {@link java.util.Map} to be used for testing.
     *
     * @return the map to be tested
     */

#Code:
    public abstract MultiMap makeEmptyMap();

    /**
     * Return a new, populated map.  The mappings in the map should match the
     * keys and values returned from {@link #getSampleKeys()} and
     * {@link #getSampleValues()}.  The default implementation uses makeEmptyMap()
     * and calls {@link #addSampleMappings} to add all the mappings to the
     * map.
     *
     * @return the map to be tested
     */
    public MultiMap makeFullMap() {
        MultiMap m = makeEmptyMap();
        addSampleMappings(m);
        return m;
    }

#No. 5261
#File: E:\bishe\1\AbstractTestMultiMap.java
#Comment:
    /**
     * Implements the superclass method to return the map to be tested.
     *
     * @return the map to be tested
     */

#Code:
    public Object makeObject() {
        return makeEmptyMap();
    }

#No. 5262
#File: E:\bishe\1\AbstractTestMultiMap.java
#Comment:
    /**
     * Override to return a map other than HashMap as the confirmed map.
     *
     * @return a map that is known to be valid
     */

#Code:
    public MultiMap makeConfirmedMap() {
        return new MultiHashMap();
    }

#No. 5263
#File: E:\bishe\1\AbstractTestMultiMap.java
#Comment:
    /**
     * Creates a new Map Entry that is independent of the first and the map.
     */

#Code:
    public Map.Entry cloneMapEntry(Map.Entry entry) {
        HashMap map = new HashMap();
        map.put(entry.getKey(), entry.getValue());
        return (Map.Entry) map.entrySet().iterator().next();
    }

#No. 5264
#File: E:\bishe\1\AbstractTestMultiMap.java
#Comment:
    /**
     * Gets the compatability version, needed for package access.
     */

#Code:
    public String getCompatibilityVersion() {
        return super.getCompatibilityVersion();
    }

#No. 5265
#File: E:\bishe\1\AbstractTestMultiMap.java
#Comment:
    /**
     * Test to ensure the test setup is working properly.  This method checks
     * to ensure that the getSampleKeys and getSampleValues methods are
     * returning results that look appropriate.  That is, they both return a
     * non-null array of equal length.  The keys array must not have any
     * duplicate values, and may only contain a (single) null key if
     * isNullKeySupported() returns true.  The values array must only have a null
     * value if useNullValue() is true and may only have duplicate values if
     * isAllowDuplicateValues() returns true.
     */

#Code:
    public void testSampleMappings() {
        Object[] keys = getSampleKeys();
        Object[] values = getSampleValues();
        Object[] newValues = getNewSampleValues();

        assertTrue("failure in test: Must have keys returned from " + "getSampleKeys.", keys != null);

        assertTrue("failure in test: Must have values returned from " + "getSampleValues.", values != null);

        // verify keys and values have equivalent lengths (in case getSampleX are
        // overridden)
        assertEquals("failure in test: not the same number of sample " + "keys and values.", keys.length, values.length);

        assertEquals("failure in test: not the same number of values and new values.", values.length, newValues.length);

        // verify there aren't duplicate keys, and check values
        for (int i = 0; i < keys.length - 1; i++) {
            for (int j = i + 1; j < keys.length; j++) {
                assertTrue("failure in test: duplicate null keys.", (keys[i] != null || keys[j] != null));
                assertTrue("failure in test: duplicate non-null key.", (keys[i] == null || keys[j] == null || (!keys[i].equals(keys[j]) && !keys[j].equals(keys[i]))));
            }
            assertTrue("failure in test: found null key, but isNullKeySupported " + "is false.", keys[i] != null || isAllowNullKey());
            assertTrue("failure in test: found null value, but isNullValueSupported " + "is false.", values[i] != null || isAllowNullValue());
            assertTrue("failure in test: found null new value, but isNullValueSupported " + "is false.", newValues[i] != null || isAllowNullValue());
            assertTrue("failure in test: values should not be the same as new value", values[i] != newValues[i] && (values[i] == null || !values[i].equals(newValues[i])));
        }
    }

#No. 5266
#File: E:\bishe\1\AbstractTestMultiMap.java
#Comment:
    /**
     * Test to ensure that makeEmptyMap and makeFull returns a new non-null
     * map with each invocation.
     */

#Code:
    public void testMakeMap() {
        MultiMap em = makeEmptyMap();
        assertTrue("failure in test: makeEmptyMap must return a non-null map.", em != null);

        MultiMap em2 = makeEmptyMap();
        assertTrue("failure in test: makeEmptyMap must return a non-null map.", em != null);

        assertTrue("failure in test: makeEmptyMap must return a new map " + "with each invocation.", em != em2);

        MultiMap fm = makeFullMap();
        assertTrue("failure in test: makeFullMap must return a non-null map.", fm != null);

        MultiMap fm2 = makeFullMap();
        assertTrue("failure in test: makeFullMap must return a non-null map.", fm != null);

        assertTrue("failure in test: makeFullMap must return a new map " + "with each invocation.", fm != fm2);
    }

#No. 5267
#File: E:\bishe\1\AbstractTestMultiMap.java
#Comment:
    /**
     * Tests Map.isEmpty()
     */

#Code:
    public void testMapIsEmpty() {
        resetEmpty();
        assertEquals("Map.isEmpty() should return true with an empty map", true, map.isEmpty());
        verify();

        resetFull();
        assertEquals("Map.isEmpty() should return false with a non-empty map", false, map.isEmpty());
        verify();
    }

#No. 5268
#File: E:\bishe\1\AbstractTestMultiMap.java
#Comment:
    /**
     * Tests Map.size()
     */

#Code:
    public void testMapSize() {
        resetEmpty();
        assertEquals("Map.size() should be 0 with an empty map", 0, map.size());
        verify();

        resetFull();
        assertEquals("Map.size() should equal the number of entries " + "in the map", getSampleKeys().length, map.size());
        verify();
    }

#No. 5269
#File: E:\bishe\1\AbstractTestMultiMap.java
#Comment:
    /**
     * Tests {@link java.util.Map#clear()}.  If the map {@link #isRemoveSupported()}
     * can add and remove elements}, then {@link java.util.Map#size()} and
     * {@link java.util.Map#isEmpty()} are used to ensure that map has no elements after
     * a call to clear.  If the map does not support adding and removing
     * elements, this method checks to ensure clear throws an
     * UnsupportedOperationException.
     */

#Code:
    public void testMapClear() {
        if (!isRemoveSupported()) {
            try {
                resetFull();
                map.clear();
                fail("Expected UnsupportedOperationException on clear");
            } catch (UnsupportedOperationException ex) {
            }
            return;
        }

        resetEmpty();
        map.clear();
        confirmed.clear();
        verify();

        resetFull();
        map.clear();
        confirmed.clear();
        verify();
    }

#No. 5270
#File: E:\bishe\1\AbstractTestMultiMap.java
#Comment:
    /**
     * Tests Map.containsKey(Object) by verifying it returns false for all
     * sample keys on a map created using an empty map and returns true for
     * all sample keys returned on a full map.
     */

#Code:
    public void testMapContainsKey() {
        Object[] keys = getSampleKeys();

        resetEmpty();
        for (int i = 0; i < keys.length; i++) {
            assertTrue("Map must not contain key when map is empty", !map.containsKey(keys[i]));
        }
        verify();

        resetFull();
        for (int i = 0; i < keys.length; i++) {
            assertTrue("Map must contain key for a mapping in the map. " + "Missing: " + keys[i], map.containsKey(keys[i]));
        }
        verify();
    }

#No. 5271
#File: E:\bishe\1\AbstractTestMultiMap.java
#Comment:
    /**
     * Tests Map.containsValue(Object) by verifying it returns false for all
     * sample values on an empty map and returns true for all sample values on
     * a full map.
     */

#Code:
    public void testMapContainsValue() {
        Object[] values = getSampleValues();

        resetEmpty();
        for (int i = 0; i < values.length; i++) {
            assertTrue("Empty map must not contain value", !map.containsValue(values[i]));
        }
        verify();

        resetFull();
        for (int i = 0; i < values.length; i++) {
            assertTrue("Map must contain value for a mapping in the map.", map.containsValue(values[i]));
        }
        verify();
    }

#No. 5272
#File: E:\bishe\1\AbstractTestMultiMap.java
#Comment:
    /**
     * Tests Map.equals(Object)
     */

#Code:
    public void testMapEquals() {
        resetEmpty();
        assertTrue("Empty maps unequal.", map.equals(confirmed));
        verify();

        resetFull();
        assertTrue("Full maps unequal.", map.equals(confirmed));
        verify();

        resetFull();
        // modify the HashMap created from the full map and make sure this
        // change results in map.equals() to return false.
        Iterator iter = confirmed.keySet().iterator();
        iter.next();
        iter.remove();
        assertTrue("Different maps equal.", !map.equals(confirmed));

        resetFull();
        assertTrue("equals(null) returned true.", !map.equals(null));
        assertTrue("equals(new Object()) returned true.", !map.equals(new Object()));
        verify();
    }

#No. 5273
#File: E:\bishe\1\AbstractTestMultiMap.java
#Comment:
    /**
     * Tests Map.get(Object)
     */

#Code:
    public void testMapGet() {
        resetEmpty();

        Object[] keys = getSampleKeys();
        Object[] values = getSampleValues();

        for (int i = 0; i < keys.length; i++) {
            assertTrue("Empty map.get() should return null.", map.get(keys[i]) == null);
        }
        verify();

        resetFull();
        for (int i = 0; i < keys.length; i++) {
            assertEquals("Full map.get() should return value from mapping.", values[i], map.get(keys[i]));
        }
    }

#No. 5274
#File: E:\bishe\1\AbstractTestMultiMap.java
#Comment:
    /**
     * Tests Map.hashCode()
     */

#Code:
    public void testMapHashCode() {
        resetEmpty();
        assertTrue("Empty maps have different hashCodes.", map.hashCode() == confirmed.hashCode());

        resetFull();
        assertTrue("Equal maps have different hashCodes.", map.hashCode() == confirmed.hashCode());
    }

#No. 5275
#File: E:\bishe\1\AbstractTestMultiMap.java
#Comment:
    /**
     * Tests Map.toString().  Since the format of the string returned by the
     * toString() method is not defined in the Map interface, there is no
     * common way to test the results of the toString() method.  Thereforce,
     * it is encouraged that Map implementations override this test with one
     * that checks the format matches any format defined in its API.  This
     * default implementation just verifies that the toString() method does
     * not return null.
     */

#Code:
    public void testMapToString() {
        resetEmpty();
        assertTrue("Empty map toString() should not return null", map.toString() != null);
        verify();

        resetFull();
        assertTrue("Empty map toString() should not return null", map.toString() != null);
        verify();
    }

#No. 5276
#File: E:\bishe\1\AbstractTestMultiMap.java
#Comment:
    /**
     * Compare the current serialized form of the Map
     * against the canonical version in CVS.
     */

#Code:
    public void testEmptyMapCompatibility() throws Exception {
        /**
         * Create canonical objects with this code
         Map map = makeEmptyMap();
         if (!(map instanceof Serializable)) return;

         writeExternalFormToDisk((Serializable) map, getCanonicalEmptyCollectionName(map));
         */

        // test to make sure the canonical form has been preserved
        // GenericsNote: Serialized compatibility with older class versions is not supported for now
        //Map map = makeEmptyMap();
        //if (map instanceof Serializable && !skipSerializedCanonicalTests() && isTestSerialization()) {
        //    Map map2 = (Map) readExternalFormFromDisk(getCanonicalEmptyCollectionName(map));
        //    assertEquals("Map is empty", 0, map2.size());
        //}
    }

#No. 5277
#File: E:\bishe\1\AbstractTestMultiMap.java
#Comment:
    /**
     * Compare the current serialized form of the Map
     * against the canonical version in CVS.
     */

#Code:
    public void testFullMapCompatibility() throws Exception {
        /**
         * Create canonical objects with this code
         Map map = makeFullMap();
         if (!(map instanceof Serializable)) return;

         writeExternalFormToDisk((Serializable) map, getCanonicalFullCollectionName(map));
         */

        // test to make sure the canonical form has been preserved
        // GenericsNote: Serialized compatibility with older class versions is not supported for now
        //Map map = makeFullMap();
        //if (map instanceof Serializable && !skipSerializedCanonicalTests() && isTestSerialization()) {
        //    Map map2 = (Map) readExternalFormFromDisk(getCanonicalFullCollectionName(map));
        //    assertEquals("Map is the right size", getSampleKeys().length, map2.size());
        //}
    }

#No. 5278
#File: E:\bishe\1\AbstractTestMultiMap.java
#Comment:
    /**
     * Tests Map.put(null, value)
     */

#Code:
    public void testMapPutNullKey() {
        resetFull();
        Object[] values = getSampleValues();

        if (isPutAddSupported()) {
            if (isAllowNullKey()) {
                map.put(null, values[0]);
            } else {
                try {
                    map.put(null, values[0]);
                    fail("put(null, value) should throw NPE/IAE");
                } catch (NullPointerException ex) {
                } catch (IllegalArgumentException ex) {
                }
            }
        }
    }

#No. 5279
#File: E:\bishe\1\AbstractTestMultiMap.java
#Comment:
    /**
     * Tests Map.put(null, value)
     */

#Code:
    public void testMapPutNullValue() {
        resetFull();
        Object[] keys = getSampleKeys();

        if (isPutAddSupported()) {
            if (isAllowNullValue()) {
                map.put(keys[0], null);
            } else {
                try {
                    map.put(keys[0], null);
                    fail("put(key, null) should throw NPE/IAE");
                } catch (NullPointerException ex) {
                } catch (IllegalArgumentException ex) {
                }
            }
        }
    }

#No. 5280
#File: E:\bishe\1\AbstractTestMultiMap.java
#Comment:
    /**
     * Tests Map.putAll(map)
     */

#Code:
    public void testMapPutAll() {
        if (!isPutAddSupported()) {
            if (!isPutChangeSupported()) {
                MultiMap temp = makeFullMap();
                resetEmpty();
                try {
                    map.putAll(temp);
                    fail("Expected UnsupportedOperationException on putAll");
                } catch (UnsupportedOperationException ex) {
                }
            }
            return;
        }

        resetEmpty();

        MultiMap m2 = makeFullMap();

        map.putAll(m2);
        confirmed.putAll(m2);
        verify();

        resetEmpty();

        m2 = makeConfirmedMap();
        Object[] keys = getSampleKeys();
        Object[] values = getSampleValues();
        for (int i = 0; i < keys.length; i++) {
            m2.put(keys[i], values[i]);
        }

        map.putAll(m2);
        confirmed.putAll(m2);
        verify();
    }

#No. 5281
#File: E:\bishe\1\AbstractTestMultiMap.java
#Comment:
    /**
     * Tests that the {@link java.util.Map#values} collection is backed by
     * the underlying map for clear().
     */

#Code:
    public void testValuesClearChangesMap() {
        if (!isRemoveSupported()) return;
        
        // clear values, reflected in map
        resetFull();
        Collection values = map.values();
        assertTrue(map.size() > 0);
        assertTrue(values.size() > 0);
        values.clear();
        assertTrue(map.size() == 0);
        assertTrue(values.size() == 0);
        
        // clear map, reflected in values
        resetFull();
        values = map.values();
        assertTrue(map.size() > 0);
        assertTrue(values.size() > 0);
        map.clear();
        assertTrue(map.size() == 0);
        assertTrue(values.size() == 0);
    }

#No. 5282
#File: E:\bishe\1\AbstractTestMultiMap.java
#Comment:
    /**
     * Tests that the {@link java.util.Map#keySet} collection is backed by
     * the underlying map for clear().
     */

#Code:
    public void testKeySetClearChangesMap() {
        if (!isRemoveSupported()) return;
        
        // clear values, reflected in map
        resetFull();
        Set keySet = map.keySet();
        assertTrue(map.size() > 0);
        assertTrue(keySet.size() > 0);
        keySet.clear();
        assertTrue(map.size() == 0);
        assertTrue(keySet.size() == 0);
        
        // clear map, reflected in values
        resetFull();
        keySet = map.keySet();
        assertTrue(map.size() > 0);
        assertTrue(keySet.size() > 0);
        map.clear();
        assertTrue(map.size() == 0);
        assertTrue(keySet.size() == 0);
    }

#No. 5283
#File: E:\bishe\1\AbstractTestMultiMap.java
#Comment:
    /**
     * Tests that the {@link java.util.Map#entrySet()} collection is backed by
     * the underlying map for clear().
     */

#Code:
    public void testEntrySetClearChangesMap() {
        if (!isRemoveSupported()) return;
        
        // clear values, reflected in map
        resetFull();
        Set entrySet = map.entrySet();
        assertTrue(map.size() > 0);
        assertTrue(entrySet.size() > 0);
        entrySet.clear();
        assertTrue(map.size() == 0);
        assertTrue(entrySet.size() == 0);
        
        // clear map, reflected in values
        resetFull();
        entrySet = map.entrySet();
        assertTrue(map.size() > 0);
        assertTrue(entrySet.size() > 0);
        map.clear();
        assertTrue(map.size() == 0);
        assertTrue(entrySet.size() == 0);
    }

#No. 5284
#File: E:\bishe\1\AbstractTestMultiMap.java
#Comment:
    /**
     * Tests that the {@link java.util.Map#values} collection is backed by
     * the underlying map by removing from the values collection
     * and testing if the value was removed from the map.
     * <p/>
     * We should really test the "vice versa" case--that values removed
     * from the map are removed from the values collection--also,
     * but that's a more difficult test to construct (lacking a
     * "removeValue" method.)
     * </p>
     * <p/>
     * See bug <a href="http://issues.apache.org/bugzilla/show_bug.cgi?id=9573">
     * 9573</a>.
     * </p>
     */

#Code:
    public void testValuesRemoveChangesMap() {
        resetFull();
        Object[] sampleValues = getSampleValues();
        Collection values = map.values();
        for (int i = 0; i < sampleValues.length; i++) {
            if (map.containsValue(sampleValues[i])) {
                int j = 0;  // loop counter prevents infinite loops when remove is broken
                while (values.contains(sampleValues[i]) && j < 10000) {
                    try {
                        values.remove(sampleValues[i]);
                    } catch (UnsupportedOperationException e) {
                        // if values.remove is unsupported, just skip this test
                        return;
                    }
                    j++;
                }
                assertTrue("values().remove(obj) is broken", j < 10000);
                assertTrue("Value should have been removed from the underlying map.", !map.containsValue(sampleValues[i]));
            }
        }
    }

#No. 5285
#File: E:\bishe\1\AbstractTestMultiMap.java
#Comment:
    /**
     * Tests that the {@link java.util.Map#keySet} set is backed by
     * the underlying map by removing from the keySet set
     * and testing if the key was removed from the map.
     */

#Code:
    public void testKeySetRemoveChangesMap() {
        resetFull();
        Object[] sampleKeys = getSampleKeys();
        Set keys = map.keySet();
        for (int i = 0; i < sampleKeys.length; i++) {
            try {
                keys.remove(sampleKeys[i]);
            } catch (UnsupportedOperationException e) {
                // if key.remove is unsupported, just skip this test
                return;
            }
            assertTrue("Key should have been removed from the underlying map.", !map.containsKey(sampleKeys[i]));
        }
    }

#No. 5286
#File: E:\bishe\1\AbstractTestMultiMap.java
#Comment:
    /**
     * Utility methods to create an array of Map.Entry objects
     * out of the given key and value arrays.<P>
     *
     * @param keys   the array of keys
     * @param values the array of values
     * @return an array of Map.Entry of those keys to those values
     */

#Code:
    private Map.Entry[] makeEntryArray(Object[] keys, Object[] values) {
        Map.Entry[] result = new Map.Entry[keys.length];
        for (int i = 0; i < keys.length; i++) {
            MultiMap map = makeConfirmedMap();
            map.put(keys[i], values[i]);
            result[i] = (Map.Entry) map.entrySet().iterator().next();
        }
        return result;
    }

#No. 5287
#File: E:\bishe\1\AbstractTestMultiMap.java
#Comment:
    /**
     * Bulk test {@link java.util.Map#entrySet()}.  This method runs through all of
     * the tests in {@link org.apache.commons.collections15.set.AbstractTestSet}.
     * After modification operations, {@link #verify()} is invoked to ensure
     * that the map and the other collection views are still valid.
     *
     * @return a {@link org.apache.commons.collections15.set.AbstractTestSet} instance for testing the map's entry set
     */

#Code:
    public BulkTest bulkTestMapEntrySet() {
        return new TestMapEntrySet();
    }

#No. 5288
#File: E:\bishe\1\AbstractTestMultiMap.java
#Comment:
    /**
     * Bulk test {@link java.util.Map#keySet()}.  This method runs through all of
     * the tests in {@link org.apache.commons.collections15.set.AbstractTestSet}.
     * After modification operations, {@link #verify()} is invoked to ensure
     * that the map and the other collection views are still valid.
     *
     * @return a {@link org.apache.commons.collections15.set.AbstractTestSet} instance for testing the map's key set
     */

#Code:
    public BulkTest bulkTestMapKeySet() {
        return new TestMapKeySet();
    }

#No. 5289
#File: E:\bishe\1\AbstractTestMultiMap.java
#Comment:
    /**
     * Bulk test {@link java.util.Map#values()}.  This method runs through all of
     * the tests in {@link org.apache.commons.collections15.collection.AbstractTestCollection}.
     * After modification operations, {@link #verify()} is invoked to ensure
     * that the map and the other collection views are still valid.
     *
     * @return a {@link org.apache.commons.collections15.collection.AbstractTestCollection} instance for testing the map's
     *         values collection
     */

#Code:
    public BulkTest bulkTestMapValues() {
        return new TestMapValues();
    }

#No. 5290
#File: E:\bishe\1\AbstractTestMultiMap.java
#Comment:
    /**
     * Resets the {@link #map}, {@link #entrySet}, {@link #keySet},
     * {@link #values} and {@link #confirmed} fields to empty.
     */

#Code:
    public void resetEmpty() {
        this.map = makeEmptyMap();
        views();
        this.confirmed = makeConfirmedMap();
    }

#No. 5291
#File: E:\bishe\1\AbstractTestMultiMap.java
#Comment:
    /**
     * Resets the {@link #map}, {@link #entrySet}, {@link #keySet},
     * {@link #values} and {@link #confirmed} fields to full.
     */

#Code:
    public void resetFull() {
        this.map = makeFullMap();
        views();
        this.confirmed = makeConfirmedMap();
        Object[] k = getSampleKeys();
        Object[] v = getSampleValues();
        for (int i = 0; i < k.length; i++) {
            confirmed.put(k[i], v[i]);
        }
    }

#No. 5292
#File: E:\bishe\1\AbstractTestMultiMap.java
#Comment:
    /**
     * Resets the collection view fields.
     */

#Code:
    private void views() {
        this.keySet = map.keySet();
        this.values = map.values();
        this.entrySet = map.entrySet();
    }

#No. 5293
#File: E:\bishe\1\AbstractTestMultiMap.java
#Comment:
    /**
     * Verifies that {@link #map} is still equal to {@link #confirmed}.
     * This method checks that the map is equal to the HashMap,
     * <I>and</I> that the map's collection views are still equal to
     * the HashMap's collection views.  An <Code>equals</Code> test
     * is done on the maps and their collection views; their size and
     * <Code>isEmpty</Code> results are compared; their hashCodes are
     * compared; and <Code>containsAll</Code> tests are run on the
     * collection views.
     */

#Code:
    public void verify() {
        verifyMap();
        verifyEntrySet();
        verifyKeySet();
        verifyValues();
    }

#No. 5294
#File: E:\bishe\1\AbstractTestMultiMap.java
#Comment:
    /**
     * Erases any leftover instance variables by setting them to null.
     */

#Code:
    public void tearDown() throws Exception {
        map = null;
        keySet = null;
        entrySet = null;
        values = null;
        confirmed = null;
    }

#No. 5295
#File: E:\bishe\1\AbstractTestReporter.java
#Comment:
    /*
     * This method exists only in order to compensate for the existence of "reportTestEnd", which is needed in order
     * to count the amount of ok/failed tests, execution times, etc.
     */

#Code:
    protected void reportTestStart(final String executionId, final int nestingLevel, final ITest test, final String testName) {
        // Nothing here, meant to be overriden
    }

#No. 5296
#File: E:\bishe\1\AbstractTestRunMojo.java
#Comment:
    /**
     * Get the name of the database table used for testing.
     *
     * @return The name of the database table.
     */

#Code:
    private String getTableName() {
        return getType() + "_users";
    }

#No. 5297
#File: E:\bishe\1\AbstractTestRunMojo.java
#Comment:
    /**
     * Get the relative path of the database script used to create the database schema.
     *
     * @return The relative path of the script.
     */

#Code:
    private String getCreateScript() {
        return "src/test/resources/create_" + getType() + "_database.sql";
    }

#No. 5298
#File: E:\bishe\1\AbstractTestRunMojo.java
#Comment:
    /**
     * Prepare for test execution by initialising the mock objects and test fixture.
     *
     * @throws Exception If there was an error configuring the test fixture.
     */

#Code:
    @Before
    public void setUp() throws Exception {
        initMocks(this);
        Class.forName(getDriverClassName());
        mojo = new RunMojo();
        ReflectionUtils.setVariableValueInObject(mojo, "monitorPort", getMonitorPort());
        ReflectionUtils.setVariableValueInObject(mojo, "monitorKey", "inmemdb");
        ReflectionUtils.setVariableValueInObject(mojo, "type", getType());
        ReflectionUtils.setVariableValueInObject(mojo, "database", "test");
        final Script source = new Script();
        source.setSourceFile(getCreateScript());
        final List<Source> sources = new ArrayList<Source>();
        sources.add(source);
        ReflectionUtils.setVariableValueInObject(mojo, "sources", sources);
    }

#No. 5299
#File: E:\bishe\1\AbstractTestRunMojo.java
#Comment:
    /**
     * Verify that we can start the server.
     *
     * @throws Exception If there was an error.
     */

#Code:
    @Test
    public void testRun() throws Exception {
        ReflectionUtils.setVariableValueInObject(mojo, "daemon", Boolean.FALSE);

        final Thread mojoThread = new Thread(new Runnable() {
            public void run() {
                try {
                    mojo.execute();
                } catch (final Exception e) {
                }
            }
        });
        mojoThread.start();
        try {
            Thread.sleep(5000);

            final Connection jdbcConnection = DriverManager.getConnection(getConnectionString());
            final IDatabaseConnection connection = new DatabaseConnection(jdbcConnection);
            IDataSet databaseDataSet = connection.createDataSet();
            assertNotNull(databaseDataSet.getTable(getTableName()));

            connection.close();
            jdbcConnection.close();
        } finally {
            final Timer timer = new Timer();
            timer.schedule(new TimerTask() {
                @Override
                public void run() {
                    signalStop();
                }
            }, 5000L);
            mojoThread.join(15000L);
        }
    }

#No. 5300
#File: E:\bishe\1\AbstractTestRunMojo.java
#Comment:
    /**
     * Verify that we can start the server as a daemon.
     *
     * @throws Exception If there was an error.
     */

#Code:
    @Test
    public void testRunDaemon() throws Exception {
        ReflectionUtils.setVariableValueInObject(mojo, "daemon", Boolean.TRUE);
        try {
            mojo.execute();
            Thread.sleep(5000L);
            final Connection jdbcConnection = DriverManager.getConnection(getConnectionString());
            final IDatabaseConnection connection = new DatabaseConnection(jdbcConnection);
            IDataSet databaseDataSet = connection.createDataSet();
            assertNotNull(databaseDataSet.getTable(getTableName()));

            connection.close();
            jdbcConnection.close();
        } finally {
            signalStop();
        }
    }

#No. 5301
#File: E:\bishe\1\AbstractTestRunMojo.java
#Comment:
    /**
     * Send a stop signal to monitor controlling the server.
     */

#Code:
    private void signalStop() {
        new Monitor("inmemdb", getMonitorPort()).sendCommand("stop", logger);
    }

#No. 5302
#File: E:\bishe\1\AbstractTestSuiteChunkerImpl.java
#Comment:
    /**
     * Get the internal test index for a junit runner delegate based on the
     * "real" original test index. For example, the test may need to run a
     * single test, for example the test with index 3. However since PowerMock
     * may have chunked the test suite to use many classloaders and junit
     * delegators the index (3) must be mapped to an internal representation for
     * the specific junit runner delegate. This is what this method does. I.e.
     * it will iterate through all junit runner delegates and see if they
     * contain the test with index 3, in the internal index of this test
     * delegator is returned.
     * 
     * @param originalTestIndex
     *            The original test index as seen by the test runner.
     * @return The internal test index as seen by PowerMock or {@code -1}
     *         if no index was found.
     * 
     */

#Code:
    public int getInternalTestIndex(int originalTestIndex) {
        Set<Entry<Integer, List<Integer>>> delegatorEntrySet = testAtDelegateMapper.entrySet();
        for (Entry<Integer, List<Integer>> entry : delegatorEntrySet) {
            final List<Integer> testIndexesForThisDelegate = entry.getValue();
            final int internalIndex = testIndexesForThisDelegate.indexOf(originalTestIndex);
            if (internalIndex != INTERNAL_INDEX_NOT_FOUND) {
                return internalIndex;
            }
        }
        return INTERNAL_INDEX_NOT_FOUND;
    }

#No. 5303
#File: E:\bishe\1\AbstractTestSuiteChunkerImpl.java
#Comment:
    /**
     * Get the junit runner delegate that handles the test at index
     * {@code testIndex}. Throws a {@link RuntimeException} if a delegator
     * is not found for the specific test index.
     * 
     * @param testIndex
     *            The test index that a delegator should hold.
     * @return The index for of the junit runner delegate as seen by JTestRack.
     */

#Code:
    public int getDelegatorIndex(int testIndex) {
        int delegatorIndex = -1;
        Set<Entry<Integer, List<Integer>>> entrySet = testAtDelegateMapper.entrySet();
        for (Entry<Integer, List<Integer>> entry : entrySet) {
            // If the delegator contains the test case, return the index of the
            // delegator.
            if (entry.getValue().contains(testIndex)) {
                delegatorIndex = entry.getKey();
                break;
            }
        }

        if (delegatorIndex == -1) {
            throw new RuntimeException("Internal error: Failed to find the delgator index.");
        }
        return delegatorIndex;
    }

#No. 5304
#File: E:\bishe\1\AbstractTextAction.java
#Comment:
    /**
     * @return true, only if this action is intended to be run (chained) always
     * just before "save" operation.
     */

#Code:
    public boolean isUsedOnSave() {
        return isUsedOnSave;
    }

#No. 5305
#File: E:\bishe\1\AbstractTextAction.java
#Comment:
    /**
     * @param isUsedOnSave true, only if this action is intended to be run
     * (chained) always just before "save" operation.
     */

#Code:
    public void setUsedOnSave(boolean isUsedOnSave) {
        this.isUsedOnSave = isUsedOnSave;
    }

#No. 5306
#File: E:\bishe\1\AbstractTextDisplayViewer.java
#Comment:
/**
 * Implements the UI-independent elements of a text viewer.
 * 
 * @author Lee Kamentsky
 */

#Code:
public abstract class AbstractTextDisplayViewer extends
	AbstractDisplayViewer<String> implements TextDisplayViewer
{

	@Override
	public TextDisplay getDisplay() {
		return (TextDisplay) super.getDisplay();
	}
}

#No. 5307
#File: E:\bishe\1\AbstractTextFormat.java
#Comment:
/**
 * Abstract superclass of {@link TextFormat} implementations.
 * 
 * @author Curtis Rueden
 */

#Code:
public abstract class AbstractTextFormat extends AbstractHandlerPlugin<File>
	implements TextFormat
{
	// NB: No implementation needed.
}

#No. 5308
#File: E:\bishe\1\AbstractTextParser.java
#Comment:
/**
 * An abstract class that defines some convenience methods for <code>Text</code> parsers.
 *
 * @author <a href="mailto:vincent.siveton@gmail.com">Vincent Siveton</a>
 * @version $Id$
 * @since 1.0
 */

#Code:
public abstract class AbstractTextParser
    extends AbstractParser
    implements TextMarkup
{
    /** {@inheritDoc} */
    @Override
    public final int getType()
    {
        return TXT_TYPE;
    }
}

#No. 5309
#File: E:\bishe\1\AbstractTextSink.java
#Comment:
/**
 * An abstract <code>Sink</code> for text markup syntax.
 *
 * @author <a href="mailto:vincent.siveton@gmail.com">Vincent Siveton</a>
 * @version $Id$
 */

#Code:
public abstract class AbstractTextSink
    extends SinkAdapter
    implements TextMarkup
{
    // nop
}

#No. 5310
#File: E:\bishe\1\AbstractThirdPartyReportMojo.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    protected MavenProject getProject()
    {
        return project;
    }

#No. 5311
#File: E:\bishe\1\AbstractThirdPartyReportMojo.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    protected String getOutputDirectory()
    {
        if ( !outputDirectory.isAbsolute() )
        {
            outputDirectory = new File( project.getBasedir(), outputDirectory.getPath() );
        }

        return outputDirectory.getAbsolutePath();
    }

#No. 5312
#File: E:\bishe\1\AbstractThirdPartyReportMojo.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    protected Renderer getSiteRenderer()
    {
        return siteRenderer;
    }

#No. 5313
#File: E:\bishe\1\AbstractThirdPartyReportMojo.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public String getDescription( Locale locale )
    {
        return i18n.getString( getOutputName(), locale, "report.description" );
    }

#No. 5314
#File: E:\bishe\1\AbstractThirdPartyReportMojo.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public String getName( Locale locale )
    {
        return i18n.getString( getOutputName(), locale, "report.title" );
    }

#No. 5315
#File: E:\bishe\1\AbstractThirdPartyReportMojo.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public List<String> getExcludedScopes()
    {
        return MojoHelper.getParams( excludedScopes );
    }

#No. 5316
#File: E:\bishe\1\AbstractThirdPartyReportMojo.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public List<String> getIncludedScopes()
    {
        return MojoHelper.getParams( includedScopes );
    }

#No. 5317
#File: E:\bishe\1\AbstractThirdPartyReportMojo.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public String getExcludedGroups()
    {
        return excludedGroups;
    }

#No. 5318
#File: E:\bishe\1\AbstractThirdPartyReportMojo.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public String getIncludedGroups()
    {
        return includedGroups;
    }

#No. 5319
#File: E:\bishe\1\AbstractThirdPartyReportMojo.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public String getExcludedArtifacts()
    {
        return excludedArtifacts;
    }

#No. 5320
#File: E:\bishe\1\AbstractThirdPartyReportMojo.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public String getIncludedArtifacts()
    {
        return includedArtifacts;
    }

#No. 5321
#File: E:\bishe\1\AbstractThirdPartyReportMojo.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public boolean isIncludeTransitiveDependencies()
    {
        return includeTransitiveDependencies;
    }

#No. 5322
#File: E:\bishe\1\AbstractThirdPartyReportMojo.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public boolean isExcludeTransitiveDependencies()
    {
        return excludeTransitiveDependencies;
    }

#No. 5323
#File: E:\bishe\1\AbstractThirdPartyReportMojo.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public boolean isVerbose()
    {
        return verbose;
    }

#No. 5324
#File: E:\bishe\1\AbstractThreadAggregate.java
#Comment:
    /**
     * Aggregate managed by DropWizard
     * Start requires replaying the events
     *
     * @throws Exception
     */

#Code:
    @Override
    public void start() throws Exception {
        // Nothing
    }

#No. 5325
#File: E:\bishe\1\AbstractThreadAggregate.java
#Comment:
    /**
     * Aggregate managed by DropWizard
     * Nothing especial needed for stop
     *
     * @throws Exception
     */

#Code:
    @Override
    public void stop() throws Exception {
        // Nothing
    }

#No. 5326
#File: E:\bishe\1\AbstractThreadAggregate.java
#Comment:
    /**
     * Allow to regenerate cache at startup.
     */

#Code:
    protected void regenerateCache(final String keySearch) {
        final Set<String> listStream = store.getStreamsLike(keySearch);

        for (String key : listStream) {
            LOGGER.info("Regenerate cache for stream {}.", key);

            clearCacheInDatabase(key);

            replay(key);
        }
    }

#No. 5327
#File: E:\bishe\1\AbstractThreadAggregateTest.java
#Comment:
        /**
         * Convenient class that wraps the thread executor of the aggregate.
         */

#Code:
        private ExecutorService singleThreadPool;

        protected AggregateTestImpl() {
            super(new EventBus(), eventStore);

            final ThreadFactory threadFactory = new ThreadFactoryBuilder()
                    .setDaemon(false)
                    .setNameFormat("TEST-%d")
                    .build();

            this.singleThreadPool = Executors.newFixedThreadPool(1, threadFactory);
        }

#No. 5328
#File: E:\bishe\1\AbstractThreadedColumnBuiltConsumer.java
#Comment:
/**
 * Abstract base class of {@link ColumnBuiltConsumer}s that handles calling the {@link ExecutablePlanStep} correctly
 * when there is new data.
 *
 * @author Bastian Gloeckle
 */

#Code:
public abstract class AbstractThreadedColumnBuiltConsumer extends AbstractPlanStepBasedGenericConsumer
    implements ColumnBuiltConsumer {

  public AbstractThreadedColumnBuiltConsumer(AbstractThreadedExecutablePlanStep planStep) {
    super(planStep);
  }

  @Override
  public void columnBuilt(String colName) {
    doColumnBuilt(colName);
    if (planStep != null)
      planStep.continueProcessing();
  }

  abstract protected void doColumnBuilt(String colName);

}

#No. 5329
#File: E:\bishe\1\AbstractThreadedColumnDictIdConsumer.java
#Comment:
/**
 * Abstract base class of {@link ColumnDictIdConsumer}s that handles calling the {@link ExecutablePlanStep} correctly
 * when there is new data.
 *
 * @author Bastian Gloeckle
 */

#Code:
public abstract class AbstractThreadedColumnDictIdConsumer extends AbstractPlanStepBasedGenericConsumer
    implements ColumnDictIdConsumer {

  public AbstractThreadedColumnDictIdConsumer(AbstractThreadedExecutablePlanStep planStep) {
    super(planStep);
  }

  @Override
  public void consume(ExecutionEnvironment env, String colName, Map<Long, Long> rowIdToColumnDictId) {
    doConsume(env, colName, rowIdToColumnDictId);
    if (planStep != null)
      planStep.continueProcessing();
  }

  abstract protected void doConsume(ExecutionEnvironment env, String colName, Map<Long, Long> rowIdToColumnDictId);

}

#No. 5330
#File: E:\bishe\1\AbstractThreadedColumnVersionBuiltConsumer.java
#Comment:
/**
 * Abstract base class of of {@link ColumnVersionBuiltConsumer}.
 *
 * @author Bastian Gloeckle
 */

#Code:
public abstract class AbstractThreadedColumnVersionBuiltConsumer extends AbstractPlanStepBasedGenericConsumer
    implements ColumnVersionBuiltConsumer {

  public AbstractThreadedColumnVersionBuiltConsumer(AbstractThreadedExecutablePlanStep planStep) {
    super(planStep);
  }

  @Override
  public void columnVersionBuilt(VersionedExecutionEnvironment env, String colName, Set<Long> adjustedRowIds) {
    doColumnBuilt(env, colName, adjustedRowIds);
    if (planStep != null)
      planStep.continueProcessing();
  }

  abstract protected void doColumnBuilt(VersionedExecutionEnvironment env, String colName, Set<Long> adjustedRowIds);

}

#No. 5331
#File: E:\bishe\1\AbstractThreadedGroupDeltaConsumer.java
#Comment:
/**
 * Abstract base class of {@link GroupDeltaConsumer}s that handles calling the {@link ExecutablePlanStep} correctly when
 * there is new data.
 * 
 * @author Bastian Gloeckle
 */

#Code:
public abstract class AbstractThreadedGroupDeltaConsumer extends AbstractPlanStepBasedGenericConsumer
    implements GroupDeltaConsumer {

  public AbstractThreadedGroupDeltaConsumer(AbstractThreadedExecutablePlanStep planStep) {
    super(planStep);
  }

  @Override
  public void consumeGroupDeltas(Map<Long, List<Long>> lastChangedGroups) {
    doConsumeGroupDeltas(lastChangedGroups);
    if (planStep != null)
      planStep.continueProcessing();
  }

  abstract protected void doConsumeGroupDeltas(Map<Long, List<Long>> lastChangedGroups);

}

#No. 5332
#File: E:\bishe\1\AbstractThreadedOrderedRowIdConsumer.java
#Comment:
/**
 * Abstract base class of {@link OrderedRowIdConsumer}s that handles calling the {@link ExecutablePlanStep} correctly
 * when there is new data.
 *
 * @author Bastian Gloeckle
 */

#Code:
public abstract class AbstractThreadedOrderedRowIdConsumer extends AbstractPlanStepBasedGenericConsumer
    implements OrderedRowIdConsumer {

  public AbstractThreadedOrderedRowIdConsumer(AbstractThreadedExecutablePlanStep planStep) {
    super(planStep);
  }

  @Override
  public void consumeOrderedRowIds(List<Long> rowIds) {
    doConsumeOrderedRowIds(rowIds);
    if (planStep != null)
      planStep.continueProcessing();
  }

  abstract protected void doConsumeOrderedRowIds(List<Long> rowIds);

}

#No. 5333
#File: E:\bishe\1\AbstractThreadedOverwritingRowIdConsumer.java
#Comment:
/**
 * Abstract base class of {@link OverwritingRowIdConsumer}s that handles calling the {@link ExecutablePlanStep}
 * correctly when there is new data.
 *
 * @author Bastian Gloeckle
 */

#Code:
public abstract class AbstractThreadedOverwritingRowIdConsumer extends AbstractPlanStepBasedGenericConsumer
    implements OverwritingRowIdConsumer {

  public AbstractThreadedOverwritingRowIdConsumer(AbstractThreadedExecutablePlanStep planStep) {
    super(planStep);
  }

  @Override
  public void consume(ExecutionEnvironment env, Long[] rowIds) {
    doConsume(env, rowIds);
    if (planStep != null)
      planStep.continueProcessing();
  }

  abstract protected void doConsume(ExecutionEnvironment env, Long[] rowIds);

}

#No. 5334
#File: E:\bishe\1\AbstractThreadedRowIdConsumer.java
#Comment:
/**
 * Abstract base class of {@link RowIdConsumer}s that handles calling the {@link ExecutablePlanStep} correctly when
 * there is new data.
 *
 * @author Bastian Gloeckle
 */

#Code:
public abstract class AbstractThreadedRowIdConsumer extends AbstractPlanStepBasedGenericConsumer
    implements RowIdConsumer {

  public AbstractThreadedRowIdConsumer(AbstractThreadedExecutablePlanStep planStep) {
    super(planStep);
  }

  @Override
  public void consume(Long[] rowIds) {
    doConsume(rowIds);
    if (planStep != null)
      planStep.continueProcessing();
  }

  abstract protected void doConsume(Long[] rowIds);

}

#No. 5335
#File: E:\bishe\1\AbstractThreadLocalAllocatedMemoryStorage.java
#Comment:
        /*
         * This field is used to support happens-before (HB) and synchronized access 
         * between memory allocator/disposer thread and allocated memory iterator thread(s).
         * Note that HB is supported by CAS and volatile write on this field.
         * 
         * There will be no blocking from the allocator/disposer thread's perspective, 
         * because this storage is thread-local and always will be accessed by same thread.
         * So there will be no concurrent mutating accesses into here.
         * 
         * However, there can be different thread(s) to iterate on allocated memories.
         * From their perspective, they can block each other and they be blocked each other.
         * Also, they can block allocator/disposer thread and they be blocked allocator/disposer thread.
         * But since iterating will not be frequently, we can live with locking in these cases.
         * 
         */

#Code:
        @SuppressWarnings("unused")
        private volatile int state = AVAILABLE;
        
        protected AbstractInternalThreadLocalAllocatedMemoryStorage(Unsafe unsafe) {
            UNSAFE = unsafe;
            try {
                stateFieldOffset = 
                        UNSAFE.objectFieldOffset(
                                AbstractInternalThreadLocalAllocatedMemoryStorage.class.getDeclaredField("state"));
            } catch (Throwable t) {
                throw new IllegalStateException(t);
            }
        }

#No. 5336
#File: E:\bishe\1\AbstractThreadLocalCallerInfoStorage.java
#Comment:
        /*
         * This field is used to support happens-before (HB) and synchronized access 
         * between memory allocator/disposer thread and allocated memory iterator thread(s).
         * Note that HB is supported by CAS and volatile write on this field.
         * 
         * There will be no blocking from the allocator/disposer thread's perspective, 
         * because this storage is thread-local and always will be accessed by same thread.
         * So there will be no concurrent mutating accesses into here.
         * 
         * However, there can be different thread(s) to iterate on allocated memories.
         * From their perspective, they can block each other and they be blocked each other.
         * Also, they can block allocator/disposer thread and they be blocked allocator/disposer thread.
         * But since iterating will not be frequently, we can live with locking in these cases.
         */

#Code:
        @SuppressWarnings("unused")
        private volatile int state = AVAILABLE;
        
        protected AbstractInternalThreadLocalCallerInfoStorage(Unsafe unsafe) {
            UNSAFE = unsafe;
            try {
                stateFieldOffset = 
                        UNSAFE.objectFieldOffset(
                                AbstractInternalThreadLocalCallerInfoStorage.class.getDeclaredField("state"));
            } catch (Throwable t) {
                throw new IllegalStateException(t);
            }
        }

#No. 5337
#File: E:\bishe\1\AbstractThreadSafeBackoff.java
#Comment:
	/**
	 * Records that the attempt succeeded, reseting the failure count. Has no
	 * effect if {@link #recordFailure(State)} or {@link #recordSuccess(State)}
	 * was previously called on an {@code Attempt} with the same backoff state.
	 * 
	 * @param oldState
	 */

#Code:
	public void recordSuccess(State oldState) {
		state.compareAndSet(oldState, NO_BACKOFF);
	}

#No. 5338
#File: E:\bishe\1\AbstractThreadSafeBackoff.java
#Comment:
	/**
	 * Records that the attempt failed, incrementing the failure count. Has no
	 * effect if {@link #recordFailure(State)} or {@link #recordSuccess(State)}
	 * was previously called on an {@code Attempt} with the same backoff state.
	 * 
	 * @param oldState
	 */

#Code:
	public void recordFailure(State oldState) {
		state.compareAndSet(oldState, increment(oldState));
	}

#No. 5339
#File: E:\bishe\1\AbstractThreadSafeBackoff.java
#Comment:
	/**
	 * Increments the failure count (up to the specified maximum) and computes
	 * the new expiry time.
	 * 
	 * @param state
	 *            the current state
	 * @return the incremented state
	 */

#Code:
	private State increment(State state) {
		int count = state.count();
		count = count < maxCount ? count + 1 : count;
		return new State(count, System.currentTimeMillis()
				+ computeInterval(count));
	}

#No. 5340
#File: E:\bishe\1\AbstractThriftConnectionStrategy.java
#Comment:
	/*
	 * @see
	 * com.wmz7year.thrift.pool.ThriftConnectionStrategy#cleanupConnection(com.
	 * wmz7year.thrift.pool.ThriftConnectionHandle,
	 * com.wmz7year.thrift.pool.ThriftConnectionHandle)
	 */

#Code:
	@Override
	public void cleanupConnection(ThriftConnectionHandle<T> oldHandler, ThriftConnectionHandle<T> newHandler) {
		// do nothing
	}

#No. 5341
#File: E:\bishe\1\AbstractTileFramework.java
#Comment:
  /**
   * This stops read/writeCommon(). It should be set when calling
   * super.read/writeCustom() as it calls read/writeCommon(). This doesn't mesh
   * well with our 3-tier nbt-handling.
   * 
   * <p>
   * Remember:
   * 
   * <ul>
   * <li>packet handler calls custom,
   * <li>save/load calls custom,
   * <li>reading from/writing to itemstack calls common,
   * <li>custom calls common
   * </ul>
   */

#Code:
  private boolean noCommon = false;

  // Note: The "final"s are only to catch errors while converting classes.

  @Override
  public final void readCustomNBT(NBTTagCompound nbtRoot) {
    try {
      noCommon = true;
      super.readCustomNBT(nbtRoot);
    } finally {
      noCommon = false;
    }
    Reader.read(SAVE, nbtRoot, this);
  }

#No. 5342
#File: E:\bishe\1\AbstractTitle.java
#Comment:
	/**
	 * The constructor
	 */

#Code:
	public AbstractTitle() {
		this("", "", -1, -1, -1);
	}

#No. 5343
#File: E:\bishe\1\AbstractTitle.java
#Comment:
	/**
	 * The constructor
	 *
	 * @param title title string
	 */

#Code:
	public AbstractTitle(String title) {
		this(title, "", -1, -1, -1);
	}

#No. 5344
#File: E:\bishe\1\AbstractTitle.java
#Comment:
	/**
	 * The constructor
	 *
	 * @param title    title string
	 * @param subtitle subtitle string
	 */

#Code:
	public AbstractTitle(String title, String subtitle) {
		this(title, subtitle, -1, -1, -1);
	}

#No. 5345
#File: E:\bishe\1\AbstractTitle.java
#Comment:
	/**
	 * Copy title
	 *
	 * @param title Title
	 */

#Code:
	public AbstractTitle(Title title) {
		this(title.getTitle(), title.getSubtitle(), title.getFadeInTime(), title.getStayTime(), title.getFadeOutTime());
		titleColor = title.getTitleColor();
		subtitleColor = title.getSubtitleColor();
		ticks = title.getTicks();
	}

#No. 5346
#File: E:\bishe\1\AbstractTitle.java
#Comment:
	/**
	 * Create a new title
	 *
	 * @param title       Title text
	 * @param subtitle    Subtitle text
	 * @param fadeInTime  Fade in time
	 * @param stayTime    Stay on screen time
	 * @param fadeOutTime Fade out time
	 */

#Code:
	public AbstractTitle(String title, String subtitle, int fadeInTime, int stayTime, int fadeOutTime) {
		this.title = title;
		this.subtitle = subtitle;
		this.fadeInTime = fadeInTime;
		this.stayTime = stayTime;
		this.fadeOutTime = fadeOutTime;
	}

#No. 5347
#File: E:\bishe\1\AbstractTMListener.java
#Comment:
    /**
     * Default constructor assumes that default is the threshold level.
     */

#Code:
    AbstractTMListener() {
        threshold = DEFAULT_THRESHOLD;
    }

#No. 5348
#File: E:\bishe\1\AbstractTmx2File.java
#Comment:
	/**
	 * 初始化 TMXReader
	 *
	 * @param    tmxFile
	**/

#Code:
	public void OpenTmxFile(File tmxFile) {
	
	}

#No. 5349
#File: E:\bishe\1\AbstractTmx2File.java
#Comment:
	/**
	 * Update by Yule 2013-8-23 添加进度参数
	 * @param tmxFile
	 * @param targetFile
	 * @param monitor
	 *          ：monitor的开始 ，进度控制 ，结束都在方法内部完成。是一个子任务<br/>
	 *          : 注意任务取消得情况
	 * @throws Exception ;
	 */

#Code:
	public abstract void doCovnerter(String tmxFile, File targetFile,IProgressMonitor monitor) throws Exception;
}
}

#No. 5350
#File: E:\bishe\1\AbstractTmxDataAccess.java
#Comment:
	/**
	 * @return TMX 中存在的语言类型，不包括源语言;
	 */

#Code:
	public List<String> getLangList() {
		return langList;
	}

#No. 5351
#File: E:\bishe\1\AbstractTmxDataAccess.java
#Comment:
	/**
	 * Note: 如果是 TMDB 则返属只会包含目标语言属性 Get TMX 文件相关属性，
	 * @return null or <code>TmxPropertiesBean</code>;
	 */

#Code:
	public TmxPropertiesBean getTmxProperties() {
		if (tmxPropertiesBean == null) {
			tmxPropertiesBean = loadTmxProperties();
		}
		return tmxPropertiesBean;
	}

#No. 5352
#File: E:\bishe\1\AbstractTokenMakerFactory.java
#Comment:
    /**
     * Returns a {@link TokenMaker} for the specified key.
     * 
     * @param key
     *            The key.
     * @return The corresponding <code>TokenMaker</code>, or <code>null</code> if none matches the specified key.
     */

#Code:
    protected TokenMaker getTokenMakerImpl(String key) {
        String clazz = (String) tokenMakerMap.get(key);
        if (clazz != null) {
            try {
                return (TokenMaker) Class.forName(clazz).newInstance();
            } catch (RuntimeException re) { // FindBugs
                throw re;
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return null;
    }

#No. 5353
#File: E:\bishe\1\AbstractTokenMakerFactory.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public Set keySet() {
        return tokenMakerMap.keySet();
    }

#No. 5354
#File: E:\bishe\1\AbstractTokenMakerFactory.java
#Comment:
    /**
     * Adds a mapping from a key to a <code>TokenMaker</code> implementation class name.
     * 
     * @param key
     *            The key.
     * @param className
     *            The <code>TokenMaker</code> class name.
     * @return The previous value for the specified key, or <code>null</code> if there was none.
     */

#Code:
    public String putMapping(String key, String className) {
        return (String) tokenMakerMap.put(key, className);
    }

#No. 5355
#File: E:\bishe\1\AbstractTooltipEvent.java
#Comment:
    /**
     * Return the {@see GQuery} object wrapping the tooltip.
     */

#Code:
    public GQuery getTooltip() {
        return tooltip;
    }

#No. 5356
#File: E:\bishe\1\AbstractTooltipEvent.java
#Comment:
    /**
     * Return the {@see GQuery} object of the element triggering the tooltip.
     */

#Code:
    public GQuery getTooltipTrigger() {
        return tooltipTrigger;
    }

#No. 5357
#File: E:\bishe\1\AbstractTopology.java
#Comment:
    /**
     * Partition which contains all hosts.  This is the fallback partition when no tokens are provided.
     */

#Code:
    private TokenHostConnectionPoolPartition<CL> allPools;

    /**
     * Strategy used to score hosts within a partition.
     */
    private LatencyScoreStrategy strategy;

    public AbstractTopology(LatencyScoreStrategy strategy) {
        this.strategy = strategy;
        this.allPools = new TokenHostConnectionPoolPartition<CL>(null, this.strategy);
    }

#No. 5358
#File: E:\bishe\1\AbstractTopology.java
#Comment:
    /**
     * Update the list of pools using the provided mapping of start token to collection of hosts
     * that own the token
     */

#Code:
    public synchronized boolean setPools(Collection<HostConnectionPool<CL>> ring) {
        boolean didChange = false;
        Set<HostConnectionPool<CL>> allPools = Sets.newHashSet();
        
        // Create a mapping of end token to a list of hosts that own the token
        for (HostConnectionPool<CL> pool : ring) {
            allPools.add(pool);
            if (!this.allPools.hasPool(pool))
                didChange = true;
        }

        return didChange;
    }

#No. 5359
#File: E:\bishe\1\AbstractTouchService.java
#Comment:
		/**
		 * 5 6 7 4 + 0 3 2 1
		 */

#Code:
		touchpos ret = null;
		switch (p.intValue()) {
		case 0:
			ret = new touchpos(_ballgap, 0);
			break;
		case 1:
			ret = new touchpos(_ballgap, _ballgap);
			break;
		case 2:
			ret = new touchpos(0, _ballgap);
			break;
		case 3:
			ret = new touchpos(-_ballgap, _ballgap);
			break;
		case 4:
			ret = new touchpos(-_ballgap, 0);
			break;
		case 5:
			ret = new touchpos(-_ballgap, -_ballgap);
			break;
		case 6:
			ret = new touchpos(0, -_ballgap);
			break;
		case 7:
			ret = new touchpos(_ballgap, -_ballgap);
			break;
		}

#No. 5360
#File: E:\bishe\1\AbstractTradesFastFeed.java
#Comment:
        /*        for (final ConnectionThread connectionThread : replayConnectionThreads) {
         connectionThread.start();
         }*/

#Code:
    }

    public abstract MarketID getMarketID();

    public abstract MessageHandler createTradesIncrementalMessageHandler();

    @PreDestroy
    public void preDestroy() {

        for (final ConnectionThread connectionThread : incConnectionThreads) {
            connectionThread.stopConnection();
        }
    }

#No. 5361
#File: E:\bishe\1\AbstractTrainer.java
#Comment:
    /**
     * Generates a name for the KnowledgeBase.
     *
     * @param storageName
     * @param separator
     * @return
     */

#Code:
    protected final String createKnowledgeBaseName(String storageName, String separator) {
        return storageName + separator + getClass().getSimpleName();
    }

#No. 5362
#File: E:\bishe\1\AbstractTransactionalDataRegion.java
#Comment:
/**
 * Abstract base class of all regions
 *
 * @author Leo Kim (lkim@limewire.com)
 * @param <Cache> implementation type of RegionCache
 */

#Code:
public abstract class AbstractTransactionalDataRegion<Cache extends RegionCache> extends AbstractHazelcastRegion<Cache>
        implements
        TransactionalDataRegion {

    private final CacheDataDescription metadata;
    private final Cache cache;

    protected AbstractTransactionalDataRegion(final HazelcastInstance instance, final String regionName,
                                              final Properties props, final CacheDataDescription metadata, final Cache cache) {
        super(instance, regionName, props);
        this.metadata = metadata;
        this.cache = cache;
    }

    /**
     * @see org.hibernate.cache.TransactionalDataRegion#getCacheDataDescription()
     */
    @Override
    public CacheDataDescription getCacheDataDescription() {
        return metadata;
    }

    /**
     * @see org.hibernate.cache.TransactionalDataRegion#isTransactionAware()
     */
    @Override
    public boolean isTransactionAware() {
        return false;
    }

    @Override
    public Cache getCache() {
        return cache;
    }
}

#No. 5363
#File: E:\bishe\1\AbstractTransactionApiDto.java
#Comment:
	/**
	 * The transaction type.
	 */

#Code:
	public TransactionType type;
	/**
	 * The number of seconds elapsed since the creation of the nemesis block.
	 */
	public TimeValue       timeStamp;
	/**
	 * The version of the structure.
	 */
	public NetworkVersion  version;
	/**
	 * The fee for the transaction.
	 * The higher the fee, the higher the priority of the transaction.
	 * Transactions with high priority get included in a block before transactions with lower priority.
	 */
	public Xems            fee;
	/**
	 * The deadline of the transaction.
	 * The deadline is given as the number of seconds elapsed since the creation of the nemesis block.
	 * If a transaction does not get included in a block before the deadline is reached, it is deleted.
	 */
	public TimeValue       deadline;
	/**
	 * The public key of the account that created the transaction.
	 */
	public NacPublicKey    signer;

	public boolean isSigner(final AddressValue account) {
		return AddressValue.fromPublicKey(signer).equals(account);
	}

#No. 5364
#File: E:\bishe\1\AbstractTransactionApiDto.java
#Comment:
	/**
	 * Returns inner transaction if object is Multisig transaction, and "this" if not
	 */

#Code:
	@NonNull
	public AbstractTransactionApiDto unwrapTransaction() {
		return type == TransactionType.MULTISIG_TRANSACTION ? ((MultisigTransactionApiDto)this).otherTrans : this;
	}

#No. 5365
#File: E:\bishe\1\AbstractTransactionDraft.java
#Comment:
	/**
	 * Sets transaction fee. If set to null, minimum calculated fee will be used.
	 *
	 * @throws NacException if fee is smaller than minimum fee.
	 */

#Code:
	public void setFee(@Nullable Xems fee)
			throws NacException {
		if (fee == null) {
			this.fee = null;
			return;
		}
		if (calculateMinimumFee().isMoreThan(fee)) {
			throw new NacException("Fee is smaller than minimum!");
		}
		this.fee = fee;
	}

#No. 5366
#File: E:\bishe\1\AbstractTransactionDraft.java
#Comment:
	/**
	 * Writes this transaction into outputStream as described in specs.
	 *
	 * @throws NacException if serialization failed
	 */

#Code:
	public final void serialize(@NonNull final ByteArrayOutputStream outputStream)
			throws NacException {
		AssertUtils.notNull(signer);

		try {
			if (timestamp.equals(TimeValue.INVALID)) {
				timestamp = NodeInfoProvider.instance().getNetworkTime();
			}
			if (deadline.equals(TimeValue.INVALID)) {
				deadline = timestamp.addDefaultDeadline();
			}
			if (fee == null) {
				fee = calculateMinimumFee();
			}

			writeAsLeBytes(outputStream, getType().getValue());
			writeAsLeBytes(outputStream, version);
			writeAsLeBytes(outputStream, timestamp.getValue());
			writeAsLeBytes(outputStream, signer.length());
			outputStream.write(signer.getRaw());
			writeAsLeBytes(outputStream, fee.getAsMicro());
			writeAsLeBytes(outputStream, deadline.getValue());
			serializeAdditional(outputStream);
		} catch (IOException e) {
			throw new NacException("Failed to serialize transaction", e);
		}
	}

#No. 5367
#File: E:\bishe\1\AbstractTransactionDraft.java
#Comment:
	/**
	 * Returns minimum transaction fee
	 */

#Code:
	@NonNull
	public abstract Xems calculateMinimumFee();

	@NonNull
	public abstract TransactionType getType();

	/**
	 * This method will be called after serializing common transaction data
	 * when calling {@link AbstractTransactionDraft#serialize(java.io.ByteArrayOutputStream)}
	 * Any subclass implementing it should serialize only its own data here.
	 */
	protected abstract void serializeAdditional(@NonNull final ByteArrayOutputStream outputStream)
			throws IOException;

	protected void writeAsLeBytes(@NonNull final OutputStream outputStream, final int value)
			throws IOException {
		outputStream.write(ConvertUtils.toLeBytes(value));
	}

#No. 5368
#File: E:\bishe\1\AbstractTransactionLog.java
#Comment:
  /*
   * Appends new writes to the pendingWrites. It is better to keep it in
   * our own queue rather than writing it to the HDFS output stream because
   * HDFSOutputStream.writeChunk is not lightweight at all.
   */

#Code:
  private void append(Entry e) throws IOException {
    pendingWrites.add(e);
  }

#No. 5369
#File: E:\bishe\1\AbstractTransferListener.java
#Comment:
/**
 * A skeleton implementation for custom transfer listeners. The callback methods in this class do nothing.
 */

#Code:
public abstract class AbstractTransferListener
    implements TransferListener
{

    /**
     * Enables subclassing.
     */
    protected AbstractTransferListener()
    {
    }

    public void transferInitiated( TransferEvent event )
        throws TransferCancelledException
    {
    }

    public void transferStarted( TransferEvent event )
        throws TransferCancelledException
    {
    }

    public void transferProgressed( TransferEvent event )
        throws TransferCancelledException
    {
    }

    public void transferCorrupted( TransferEvent event )
        throws TransferCancelledException
    {
    }

    public void transferSucceeded( TransferEvent event )
    {
    }

    public void transferFailed( TransferEvent event )
    {
    }

}

#No. 5370
#File: E:\bishe\1\AbstractTransformer.java
#Comment:
    /**
     * Fits, transforms and normalizes the data of the provided dataset.
     * 
     * @param trainingData
     */

#Code:
    public void fit_transform(Dataframe trainingData) {
        fit(trainingData);
        transform(trainingData);
    }

#No. 5371
#File: E:\bishe\1\AbstractTransformer.java
#Comment:
    /**
     * Applies an irreversible trasformation to the the provided dataset.
     * 
     * @param newData 
     */

#Code:
    public void transform(Dataframe newData) {
        logger.info("transform()");

        _transform(newData);
    }

#No. 5372
#File: E:\bishe\1\AbstractTransformerWriterTest.java
#Comment:
    /**
     * <a href="https://jira.talendforge.org/browse/TDP-3188>TDP-3188</a>
     * 
     */

#Code:
    @Test(expected = IllegalStateException.class)
    public void should_only_write_values_in_columns_order_TDP_3188() throws Exception {

        final Map<String, String> values = new HashMap<>();
        values.put("key", "value");
        DataSetRow row = new DataSetRow(new RowMetadata(), values);

        writer.write(row);
    }

#No. 5373
#File: E:\bishe\1\AbstractTransformingList.java
#Comment:
			/*
			 * This cast can not fail due to erasure but the following call to 'transformToInner' might. In that case a
			 * 'ClassCastException' will be thrown which is in accordance with the contract of 'indexOf'. If
			 * 'isOuterElement' does its job well (which can be hard due to erasure) this will not happen.
			 */

#Code:
			O outerElement = (O) object;
			I innerElement = transformToInner(outerElement);
			return getInnerList().indexOf(innerElement);
		} else
			return -1;
	}

	@Override
	public int lastIndexOf(Object object) {
		if (isOuterElement(object)) {
			@SuppressWarnings("unchecked")
			/*
			 * This cast can not fail due to erasure but the following call to 'transformToInner' might. In that case a
			 * 'ClassCastException' will be thrown which is in accordance with the contract of 'lastIndexOf'. If
			 * 'isOuterElement' does its job well (which can be hard due to erasure) this will not happen.
			 */
			O outerElement = (O) object;
			I innerElement = transformToInner(outerElement);
			return getInnerList().lastIndexOf(innerElement);
		} else
			return -1;
	}

#No. 5374
#File: E:\bishe\1\AbstractTransformingList.java
#Comment:
	/**
	 * Wraps the specified collection into a transformation and calls {@link List#addAll(int, Collection) addAll} on the
	 * {@link #getInnerList() innerList}.
	 * <p>
	 * Subclasses may choose to use this method if they override {@link #addAll(int, Collection)}.
	 * <p>
	 * Accessing the wrapped collection will lead to {@link ClassCastException}s when its elements are not of this
	 * list's outer type {@code O}. Consider using {@link #callAddOnThis(int, Collection)}.
	 *
	 * @param startIndex
	 *            index at which to insert the first element from the specified collection
	 * @param otherCollection
	 *            the parameter to {@code addAll}
	 * @return result of the call to {@code addAll}
	 */

#Code:
	protected final boolean callAddAllOnInner(int startIndex, Collection<? extends O> otherCollection) {
		Collection<I> asInnerCollection = new TransformToReadOnlyInnerCollection<>(otherCollection);
		return getInnerList().addAll(startIndex, asInnerCollection);
	}

#No. 5375
#File: E:\bishe\1\AbstractTransformingList.java
#Comment:
	/**
	 * Iterates over the specified collection and calls {@link #add(int, Object) add()} (on this list) for each element.
	 * <p>
	 * Subclasses may choose to use this method if they override {@link #addAll(int, Collection)}.
	 * <p>
	 * Manually iterating over the specified collection and calling {@code this.}{@link #add(int, Object)} individually
	 * might break guarantees (e.g. regarding atomicity) or optimizations made by the inner collection. Consider using
	 * {@link #callAddAllOnInner(int, Collection)}.
	 *
	 * @param startIndex
	 *            index at which to insert the first element from the specified collection
	 * @param otherCollection
	 *            the collection whose elements are passed to {@code add}
	 * @return true if at least one call to {@code add} returns true; otherwise false
	 */

#Code:
	protected final boolean callAddOnThis(int startIndex, Collection<? extends O> otherCollection) {
		boolean changed = false;
		int currentIndex = startIndex;
		for (O entry : otherCollection) {
			add(currentIndex, entry);
			currentIndex++;
			changed = true;
		}
		return changed;
	}

#No. 5376
#File: E:\bishe\1\AbstractTransformingMap.java
#Comment:
			/*
			 * This cast is not safe! But since this class only allows reading operations, it can not cause trouble.
			 */

#Code:
			Map<OK, OV> unsafelyTypedMap = (Map<OK, OV>) transformedMap;
			return unsafelyTypedMap;
		}

		@Override
		protected boolean isInnerKey(Object object) {
			return AbstractTransformingMap.this.isOuterKey(object);
		}

#No. 5377
#File: E:\bishe\1\AbstractTransformingSpliterator.java
#Comment:
	/**
	 * Transforms the specified element of type {@code I} with {@link #transformToOuter(Object) transformToOuter} before
	 * passing it to the specified consumer.
	 *
	 * @param action
	 *            the {@link Consumer} of outer elements to which the transformed element will be passed
	 * @return a {@link Consumer} of inner elements
	 */

#Code:
	private Consumer<I> transformThen(Consumer<? super O> action) {
		return innerElement -> {
			O asOuterElement = transformToOuter(innerElement);
			action.accept(asOuterElement);
		};
	}

#No. 5378
#File: E:\bishe\1\AbstractTransformTask.java
#Comment:
    /**
     * returns transformation for source class
     * 
     * @param classInfo
     *            class information 
     *            class name := classInfo[ 0 ] 
     *            super class  name := classInfo[ 1 ]
     *            interfaces := classInfo[ >1 ]
     */

#Code:
    abstract protected ClassTransformer getClassTransformer(String[] classInfo);

    protected Attribute[] attributes() {
        return null;
    }

#No. 5379
#File: E:\bishe\1\AbstractTransformTask.java
#Comment:
    /**
     * @param file
     * @throws Exception
     * @throws FileNotFoundException
     * @throws IOException
     * @throws MalformedURLException
     */

#Code:
    private void processClassFile(File file) throws Exception,
            FileNotFoundException, IOException, MalformedURLException {

        ClassReader reader = getClassReader(file);
        String name[] = ClassNameReader.getClassInfo(reader);
        DebuggingClassWriter w =
        	new DebuggingClassWriter(ClassWriter.COMPUTE_FRAMES);
        ClassTransformer t = getClassTransformer(name);
        if (t != null) {

            if (verbose) {
                log("processing " + file.toURI());
            }
            new TransformingClassGenerator(new ClassReaderGenerator(
                    getClassReader(file), attributes(), getFlags()), t)
                    .generateClass(w);
            FileOutputStream fos = new FileOutputStream(file);
            try {
                fos.write(w.toByteArray());
            } finally {
                fos.close();
            }

        }

    }

#No. 5380
#File: E:\bishe\1\AbstractTransformTask.java
#Comment:
    /**
     * @param bytes
     * @return
     * @throws IOException
     * @throws Exception
     */

#Code:
    private byte[] process(byte[] bytes) throws Exception {

        ClassReader reader = new ClassReader(new ByteArrayInputStream(bytes));
        String name[] = ClassNameReader.getClassInfo(reader);
        DebuggingClassWriter w =
        	new DebuggingClassWriter(ClassWriter.COMPUTE_FRAMES);
        ClassTransformer t = getClassTransformer(name);
        if (t != null) {
            if (verbose) {
                log("processing " + name[0]);
            }
            new TransformingClassGenerator(new ClassReaderGenerator(
                    new ClassReader(new ByteArrayInputStream(bytes)),
                    attributes(), getFlags()), t).generateClass(w);
            ByteArrayOutputStream out = new ByteArrayOutputStream();
            out.write(w.toByteArray());
            return out.toByteArray();
        }
        return bytes;
    }

#No. 5381
#File: E:\bishe\1\AbstractTransformTask.java
#Comment:
    /**
     * @param zip
     * @return
     * @throws IOException
     */

#Code:
    private byte[] getBytes(ZipInputStream zip) throws IOException {

        ByteArrayOutputStream bout = new ByteArrayOutputStream();
        InputStream in = new BufferedInputStream(zip);
        int b;
        while ((b = in.read()) != -1) {
            bout.write(b);
        }
        return bout.toByteArray();
    }

#No. 5382
#File: E:\bishe\1\AbstractTransitiveExplorableCompressedLongArray.java
#Comment:
/**
 * Abstract base implementation for {@link TransitiveExplorableCompressedLongArray}.
 *
 * @param <T>
 *          Thrift class this long array can be serialized to/from.
 * 
 * @author Bastian Gloeckle
 */

#Code:
public abstract class AbstractTransitiveExplorableCompressedLongArray<T extends TBase<?, ?>>
    extends AbstractExplorableCompressedLongArray<T>implements TransitiveExplorableCompressedLongArray<T> {

  @Override
  public double expectedCompressionRatio(long[] inputArray, boolean isSorted,
      TransitiveCompressionRatioCalculator transitiveCalculator) throws IllegalStateException {
    if (!State.EXPLORING.equals(state))
      throw new IllegalStateException("Not in Exploring state.");
    prepareCompression(inputArray, isSorted);
    return doTransitiveExpectedCompressionRatio(inputArray, isSorted, transitiveCalculator);
  }

  /**
   * @see TransitiveExplorableCompressedLongArray#expectedCompressionRatio(long[], boolean,
   *      org.diqube.data.types.lng.array.ExplorableCompressedLongArray.TransitiveCompressionRatioCalculator)
   */
  abstract protected double doTransitiveExpectedCompressionRatio(long[] inputArray, boolean isSorted,
      TransitiveCompressionRatioCalculator transitiveCalculator);
}

#No. 5383
#File: E:\bishe\1\AbstractTranslator.java
#Comment:
    /**
     * Delegates the actual translation to the child implementation.
     * @param term text to translate
     * @param targetLanguageCode target language code
     * @return translated text
     */

#Code:
    abstract String doTranslate(final String term, final String targetLanguageCode);
}
}

#No. 5384
#File: E:\bishe\1\AbstractTranslet.java
#Comment:
    /************************************************************************
     * Index(es) for <xsl:key> / key() / id()
     ************************************************************************/

#Code:

    // Container for all indexes for xsl:key elements
    private Hashtable _keyIndexes = null;
    private KeyIndex  _emptyKeyIndex = null;
    private int       _indexSize = 0;
    private int       _currentRootForKeys = 0;

    /**
     * This method is used to pass the largest DOM size to the translet.
     * Needed to make sure that the translet can index the whole DOM.
     */
    public void setIndexSize(int size) {
	if (size > _indexSize) _indexSize = size;
    }

#No. 5385
#File: E:\bishe\1\AbstractTranslet.java
#Comment:
    /**
     * Creates a KeyIndex object of the desired size - don't want to resize!!!
     */

#Code:
    public KeyIndex createKeyIndex() {
	return(new KeyIndex(_indexSize));
    }

#No. 5386
#File: E:\bishe\1\AbstractTranslet.java
#Comment:
    /**
     * Adds a value to a key/id index
     *   @param name is the name of the index (the key or ##id)
     *   @param node is the node handle of the node to insert
     *   @param value is the value that will look up the node in the given index
     */

#Code:
    public void buildKeyIndex(String name, int node, Object value) {
	if (_keyIndexes == null) _keyIndexes = new Hashtable();
	
	KeyIndex index = (KeyIndex)_keyIndexes.get(name);
	if (index == null) {
	    _keyIndexes.put(name, index = new KeyIndex(_indexSize));
	}
	index.add(value, node, _currentRootForKeys);
    }

#No. 5387
#File: E:\bishe\1\AbstractTranslet.java
#Comment:
    /**
     * Create an empty KeyIndex in the DOM case
     *   @param name is the name of the index (the key or ##id)
     *   @param dom is the DOM
     */

#Code:
    public void buildKeyIndex(String name, DOM dom) {
	if (_keyIndexes == null) _keyIndexes = new Hashtable();
	
	KeyIndex index = (KeyIndex)_keyIndexes.get(name);
	if (index == null) {
	    _keyIndexes.put(name, index = new KeyIndex(_indexSize));
	}
	index.setDom(dom);
    }

#No. 5388
#File: E:\bishe\1\AbstractTranslet.java
#Comment:
    /**
     * Returns the index for a given key (or id).
     * The index implements our internal iterator interface
     */

#Code:
    public KeyIndex getKeyIndex(String name) {
	// Return an empty key index iterator if none are defined
	if (_keyIndexes == null) {
	    return (_emptyKeyIndex != null) 
	        ? _emptyKeyIndex
	        : (_emptyKeyIndex = new KeyIndex(1)); 
	} 

	// Look up the requested key index
	final KeyIndex index = (KeyIndex)_keyIndexes.get(name);

	// Return an empty key index iterator if the requested index not found
	if (index == null) {
	    return (_emptyKeyIndex != null) 
	        ? _emptyKeyIndex
	        : (_emptyKeyIndex = new KeyIndex(1)); 
	}

	return(index);
    }

#No. 5389
#File: E:\bishe\1\AbstractTranslet.java
#Comment:
    /**
     * This method builds key indexes - it is overridden in the compiled
     * translet in cases where the <xsl:key> element is used
     */

#Code:
    public void buildKeys(DOM document, DTMAxisIterator iterator,
			  SerializationHandler handler,
			  int root) throws TransletException {
			  	
    }

#No. 5390
#File: E:\bishe\1\AbstractTranslet.java
#Comment:
    /**
     * This method builds key indexes - it is overridden in the compiled
     * translet in cases where the <xsl:key> element is used
     */

#Code:
    public void setKeyIndexDom(String name, DOM document) {
    	getKeyIndex(name).setDom(document);
			  	
    }

#No. 5391
#File: E:\bishe\1\AbstractTranslet.java
#Comment:
    /************************************************************************
     * DOM cache handling
     ************************************************************************/

#Code:

    // Hold the DOM cache (if any) used with this translet
    private DOMCache _domCache = null;

    /**
     * Sets the DOM cache used for additional documents loaded using the
     * document() function.
     */
    public void setDOMCache(DOMCache cache) {
	_domCache = cache;
    }

#No. 5392
#File: E:\bishe\1\AbstractTranslet.java
#Comment:
    /**
     * Returns the DOM cache used for this translet. Used by the LoadDocument
     * class (if present) when the document() function is used.
     */

#Code:
    public DOMCache getDOMCache() {
	return(_domCache);
    }

#No. 5393
#File: E:\bishe\1\AbstractTranslet.java
#Comment:
    /************************************************************************
     * Multiple output document extension.
     * See compiler/TransletOutput for actual implementation.
     ************************************************************************/

#Code:

    public SerializationHandler openOutputHandler(String filename, boolean append) 
	throws TransletException 
    {
	try {
	    final TransletOutputHandlerFactory factory 
		= TransletOutputHandlerFactory.newInstance();

            String dirStr = new File(filename).getParent();
            if ((null != dirStr) && (dirStr.length() > 0)) {
               File dir = new File(dirStr);
               dir.mkdirs();
            }

	    factory.setEncoding(_encoding);
	    factory.setOutputMethod(_method);
	    factory.setWriter(new FileWriter(filename, append));
	    factory.setOutputType(TransletOutputHandlerFactory.STREAM);

	    final SerializationHandler handler 
		= factory.getSerializationHandler();

	    transferOutputSettings(handler);
	    handler.startDocument();
	    return handler;
	}
	catch (Exception e) {
	    throw new TransletException(e);
	}
    }

#No. 5394
#File: E:\bishe\1\AbstractTranslet.java
#Comment:
    /************************************************************************
     * Native API transformation methods - _NOT_ JAXP/TrAX
     ************************************************************************/

#Code:

    /**
     * Main transform() method - this is overridden by the compiled translet
     */
    public abstract void transform(DOM document, DTMAxisIterator iterator,
				   SerializationHandler handler)
	throws TransletException;

    /**
     * Calls transform() with a given output handler
     */
    public final void transform(DOM document, SerializationHandler handler) 
	throws TransletException {
        try {
            transform(document, document.getIterator(), handler);
        } finally {
            _keyIndexes = null;
        }
    }

#No. 5395
#File: E:\bishe\1\AbstractTranslet.java
#Comment:
    /**
     * Used by some compiled code as a shortcut for passing strings to the
     * output handler
     */

#Code:
    public final void characters(final String string,
				 SerializationHandler handler) 
	throws TransletException {
        if (string != null) {
           //final int length = string.length();
           try {
               handler.characters(string);
           } catch (Exception e) {
               throw new TransletException(e);
           }
        }   
    }

#No. 5396
#File: E:\bishe\1\AbstractTranslet.java
#Comment:
    /**
     * Add's a name of an element whose text contents should be output as CDATA
     */

#Code:
    public void addCdataElement(String name) {
	if (_cdata == null) {
            _cdata = new Vector();
        }

        int lastColon = name.lastIndexOf(':');

        if (lastColon > 0) {
            String uri = name.substring(0, lastColon);
            String localName = name.substring(lastColon+1);
	    _cdata.addElement(uri);
	    _cdata.addElement(localName);
        } else {
	    _cdata.addElement(null);
	    _cdata.addElement(name);
        }
    }

#No. 5397
#File: E:\bishe\1\AbstractTranslet.java
#Comment:
    /************************************************************************
     * DOMImplementation caching for basis library
     ************************************************************************/

#Code:
    protected DOMImplementation _domImplementation = null;
    
    public Document newDocument(String uri, String qname) 
        throws ParserConfigurationException 
    {
        if (_domImplementation == null) {
            _domImplementation = DocumentBuilderFactory.newInstance()
                .newDocumentBuilder().getDOMImplementation();
        }
        return _domImplementation.createDocument(uri, qname, null);
    }

#No. 5398
#File: E:\bishe\1\AbstractTransmutator.java
#Comment:
    /**
     * Check if subclass implemented has a @Transmutator annotation necessary for MapProcessor
     */

#Code:
    void assertAnnotation(){
        assert this.getClass().isAnnotationPresent(Transmutator.class) : "The Transmutator should have a @Transmutator annotation";
    }

#No. 5399
#File: E:\bishe\1\AbstractTransmutator.java
#Comment:
    /**
     * init mapper, set from and to class types necessary for mapProcessor search
     */

#Code:
     void init(){
        Transmutator transmutatorAnnnotation = this.getClass().getAnnotation(Transmutator.class);
         fromClass = transmutatorAnnnotation.fromClass();
         toClass = transmutatorAnnnotation.toClass();
     }

#No. 5400
#File: E:\bishe\1\AbstractTransmutator.java
#Comment:
    /**
     * Some assertions needs to be skip or they fail
     */

#Code:
    private boolean skip(Class fromFieldClass, Class toFieldClass){

        if(fromFieldClass.equals(int.class) && toFieldClass.equals(Integer.class)){
            return true;
        }

        if(fromFieldClass.equals(Integer.class) && toFieldClass.equals(int.class)){
            return true;
        }

        return false;
    }

#No. 5401
#File: E:\bishe\1\AbstractTranspiler.java
#Comment:
	/**
	 * @return the source extension
	 */

#Code:
	public String getSourceExtension() {
		return sourceExtension;
	}

#No. 5402
#File: E:\bishe\1\AbstractTranspiler.java
#Comment:
	/**
	 * @return the destination extension
	 */

#Code:
	public String getDestinationExtension() {
		return destinationExtension;
	}

#No. 5403
#File: E:\bishe\1\AbstractTranspiler.java
#Comment:
	/**
	 * @return the cmd
	 */

#Code:
	public String getCmd() {
		return cmd;
	}

#No. 5404
#File: E:\bishe\1\AbstractTransportTest.java
#Comment:
    /**
     * Test of getNextLine method, of class AbstractTransport.
     */

#Code:
    public void testGetNextLine() throws Exception {
        System.out.println("getNextLine");
        int newlineCount = 0;
        String expResult = "";
        String result = instance.getNextLine(newlineCount);
        assertEquals(expResult, result);
    }

#No. 5405
#File: E:\bishe\1\AbstractTransportTest.java
#Comment:
    /**
     * Test of disconnect method, of class AbstractTransport.
     */

#Code:
    public void testDisconnect() {
        System.out.println("disconnect");
        instance.disconnect();
    }

#No. 5406
#File: E:\bishe\1\AbstractTransportTest.java
#Comment:
    /**
     * Test of test method, of class AbstractTransport.
     */

#Code:
    public void testTest() {
        System.out.println("test");
        boolean expResult = false;
        boolean result = instance.test();
        assertEquals(expResult, result);
    }

#No. 5407
#File: E:\bishe\1\AbstractTransportTest.java
#Comment:
    /**
     * Test of startWithMetrics method, of class AbstractTransport.
     */

#Code:
    public void testStartWithMetrics() throws Exception {
        System.out.println("startWithMetrics");
        String[] metricsArray = {"cpu"};
        instance.startWithMetrics(metricsArray);
    }

#No. 5408
#File: E:\bishe\1\AbstractTransportTest.java
#Comment:
    /**
     * Test of readMetrics method, of class AbstractTransport.
     */

#Code:
    public void testReadMetrics() {
        System.out.println("readMetrics");
        String[] result = instance.readMetrics();
        assertEquals("", result[0]);
    }

#No. 5409
#File: E:\bishe\1\AbstractTransportTest.java
#Comment:
    /**
     * Test of setInterval method, of class AbstractTransport.
     */

#Code:
    public void testSetInterval() throws Exception {
        System.out.println("setInterval");
        long interval = 0L;
        instance.setInterval(interval);
    }

#No. 5410
#File: E:\bishe\1\AbstractTransportTest.java
#Comment:
    /**
     * Test of shutdownAgent method, of class AbstractTransport.
     */

#Code:
    public void testShutdownAgent() {
        System.out.println("shutdownAgent");
        instance.shutdownAgent();
    }

#No. 5411
#File: E:\bishe\1\AbstractTransportTest.java
#Comment:
    /**
     * Test of getAddressLabel method, of class AbstractTransport.
     */

#Code:
    public void testGetAddressLabel() {
        System.out.println("getAddressLabel");
        String expResult = null;
        String result = instance.getAddressLabel();
        assertEquals(expResult, result);
    }

#No. 5412
#File: E:\bishe\1\AbstractTransportTest.java
#Comment:
    /**
     * Test of setAddressLabel method, of class AbstractTransport.
     */

#Code:
    public void testSetAddressLabel() {
        System.out.println("setAddressLabel");
        String label = "";
        instance.setAddressLabel(label);
    }

#No. 5413
#File: E:\bishe\1\AbstractTree.java
#Comment:
	/**
	 * Gets the column count.
	 *
	 * @return the column count
	 * @see Tree#getColumnCount()
	 */

#Code:
	public int getColumnCount() {
		return TreeHandler.getInstance().getColumnCount(swtWidget);
	}

#No. 5414
#File: E:\bishe\1\AbstractTreeCanvas.java
#Comment:
  /**
   * Constructor used to export tree without showing it in a dockable
   */

#Code:
  public AbstractTreeCanvas(NodeTree tree) {
    super(new BorderLayout());
    this.tree = tree;
    this.controller = null;
    this.localExtentProvider = true;
    this.setBackground(Options.canv_BackgroundColor);
    this.scrollPane = null;
    this.printAttr = new HashPrintRequestAttributeSet();
    this.printAttr.add(MediaSizeName.ISO_A4);
    this.pageFormat = new PageFormat();
    this.history = new History();
    this.scale = 1;
    setScale(scale);
  }

#No. 5415
#File: E:\bishe\1\AbstractTreeCanvas.java
#Comment:
  /**
   * Gets the scrollPane for this instance.
   *
   * @return The scrollPane.
   */

#Code:
  public JScrollPane getScrollPane() {
    return this.scrollPane;
  }

#No. 5416
#File: E:\bishe\1\AbstractTreeCanvas.java
#Comment:
  /**
   * Gets the label separated into lines
   *
   * @return The array of labels with each line as a separate entry
   */

#Code:
  public abstract String getLabel(Node node);

  /**
   * Gets the label separated into lines
   *
   * @return The array of labels with each line as a separate entry
   */
  public String[] getLabelLines(Node node) {
    return getLabel(node).split("\n");
  }

#No. 5417
#File: E:\bishe\1\AbstractTreeCanvas.java
#Comment:
  /**
   * Gets the node that covers a given point.
   *
   * @param x
   *          x-coordinate of the point.
   * @param y
   *          y-coordinate of the point.
   * @return
   */

#Code:
  public Node getNode(double x, double y) {
    if (tree != null) {
      try {
        Point2D point = viewTransform.inverseTransform(new Point2D.Double(x, y), null);
        x = point.getX();
        y = point.getY();
      }
      catch (NoninvertibleTransformException e) {
        System.err.println("Cannot translate click point!!");
      }
      if (x > sizeX || y > sizeY || x < 0 || y < 0) {
        return null;
      }
      Shape shape;
      for (Node node : bufferedLayout.keySet()) {
        Rectangle2D rect = bufferedLayout.get(node);
        switch (Options.canv_ShapeDef) {
        case RECTANGLE:
          shape = rect;
          break;
        case OVAL:
          shape = new Ellipse2D.Double(rect.getX(), rect.getY(), rect.getWidth(), rect.getHeight());
          break;
        // case ROUNDRECT:
        default:
          shape = new RoundRectangle2D.Double(rect.getX(), rect.getY(), rect.getWidth(),
              rect.getHeight(), Options.canv_ArcSize, Options.canv_ArcSize);
          break;
        }
        if (shape.contains(x, y)) {
          return node;
        }
      }
    }
    return null;
  }

#No. 5418
#File: E:\bishe\1\AbstractTreeCanvas.java
#Comment:
  /**
   * Gets the scale for this instance.
   *
   * @return The scale.
   */

#Code:
  public double getScale() {
    return this.scale;
  }

#No. 5419
#File: E:\bishe\1\AbstractTreeCanvas.java
#Comment:
  /**
   * Returns label of the root node
   */

#Code:
  public String getRootLabel() {
    return tree.getRoot(true).getName();
  }

#No. 5420
#File: E:\bishe\1\AbstractTreeCanvas.java
#Comment:
  /**
   * Zoom out.
   *
   */

#Code:
  public void zoomOut() {
    Point2D.Double point = new Point2D.Double(sizeX + borderPad / 2, sizeY + borderPad / 2);
    this.viewTransform.transform(point, point);
    if (Math.max(point.getX() - moveX * getScale(), point.getY() - moveY * getScale()) > 20) {
      this.setScale(scale / Options.canv_scaleFactor);
      this.repaint();
    }
  }

#No. 5421
#File: E:\bishe\1\AbstractTreeCanvas.java
#Comment:
  /**
   * Reset zoom;
   *
   */

#Code:
  public void resetZoom() {
    setScale(1);
    this.repaint();
  }

#No. 5422
#File: E:\bishe\1\AbstractTreeCanvas.java
#Comment:
  /**
   * Sets the scale for this instance.
   *
   * @param scale
   *          The scale.
   */

#Code:
  public void setScale(double scale) {
    this.scale = scale;
    this.viewTransform = new AffineTransform();
    this.viewTransform.scale(scale, scale);
    this.viewTransform.translate(moveX, moveY);
    this.viewTransform.translate(borderPad / 2, borderPad / 2);
    this.updateSize();
  }

#No. 5423
#File: E:\bishe\1\AbstractTreeCanvas.java
#Comment:
  /**
   * Scales and centeres the tree to fit the window.
   *
   */

#Code:
  public void fitToWindow() {
    int x = viewPortSize.width;
    int y = viewPortSize.height;
    double sX = sizeX + borderPad;
    double sY = sizeY + borderPad;
    double newScale = getScale() * Math.min(x / (sX * getScale()), y / (sY * getScale()));
    setScale(newScale);
    setMoveX((x / getScale() - (sX)) / 2.0);
    setMoveY((y / getScale() - (sY)) / 2.0);
    this.updateSize();
    this.repaint();
  }

#No. 5424
#File: E:\bishe\1\AbstractTreeCanvas.java
#Comment:
  /**
   * Sets the focus for the node.
   *
   * @param focused
   *          The focused node
   */

#Code:
  public void setFocus(Node focused) {
    if (this.focused != null) {
      lastFocused = this.focused;
    }
    // TODO - ensure unique focus?
    // if (focused != null){
    // tree.defocusAll();
    // }
    this.focused = (GuiNode) focused;
    if (focused != null) {
      Rectangle2D b2 = bufferedLayout.get(focused);
      if (b2 == null) {
        this.recalculateLayout();
        b2 = bufferedLayout.get(focused);
      }
      Point2D p1 = new Point2D.Double(b2.getX() - borderPad / 2, b2.getY() - borderPad / 2);
      Point2D p2 = new Point2D.Double((b2.getWidth() + borderPad) * scale,
          (b2.getHeight() + borderPad) * scale);
      viewTransform.transform(p1, p1);
      if (p1.getX() < 0) {
        setMoveX(getMoveX() - p1.getX() / scale);
        p1.setLocation(0, p1.getY());
      }
      if (p1.getY() < 0) {
        setMoveY(getMoveY() - p1.getY() / scale);
        p1.setLocation(p1.getX(), 0);
      }
      this.updateSize();
      scrollRectToVisible(
          new Rectangle((int) p1.getX(), (int) p1.getY(), (int) p2.getX(), (int) p2.getY()));
    }
    this.repaint();
    if (controller != null && this instanceof AbstractDomainCanvas) {
      controller.getFrame().getRankingView().setFocus(this, focused, false);
    }
  }

#No. 5425
#File: E:\bishe\1\AbstractTreeCanvas.java
#Comment:
  /**
   * Show print dialog and print canvas.
   *
   * @param doPrint
   * @return true if user clicked ok, false otherwise
   *
   */

#Code:
  public boolean showPrintDialog(boolean doPrint) {
    if (tree != null) {
      try {
        PrinterJob pjob = PrinterJob.getPrinterJob();
        pjob.setPageable(this);
        printAttr.add(new PageRanges(1, getNumberOfPages()));
        if (doPrint) {
          if (pjob.printDialog(printAttr)) {
            pageFormat = pjob.getPageFormat(printAttr);
            pjob.print();
            return true;
          }
        }
        else {
          PageFormat page = pjob.pageDialog(getPageFormat(0));
          if (page != getPageFormat(0)) {
            setPageFormat(page);
            return true;
          }
        }
      }
      catch (PrinterException exc) {
        reportError(exc.getLocalizedMessage());
      }
    }
    return false;
  }

#No. 5426
#File: E:\bishe\1\AbstractTreeCanvas.java
#Comment:
  /**
   * Scrolls canvas by a given vector.
   *
   * @param xShift
   *          x-coordinate of the point.
   * @param yShift
   *          y-coordinate of the point.
   * @return returns by how much canvas was really scrolled
   */

#Code:
  public Point scrollTo(double xShift, double yShift) {
    Rectangle r = scrollPane.getViewport().getViewRect();
    Point p = r.getLocation();
    r.translate((int) -xShift, (int) -yShift);
    scrollRectToVisible(r);
    Rectangle r2 = scrollPane.getViewport().getViewRect();
    p = new Point((int) (p.getX() - r2.getX()), (int) (p.getY() - r2.getY()));
    return p;
  }

#No. 5427
#File: E:\bishe\1\AbstractTreeCanvas.java
#Comment:
  /**
   * Removes the subtree with node as root.
   *
   * @param node
   *          root of a subtree.
   */

#Code:
  public void removeTree(Node node) {
    if (!node.equals(tree.getRoot(true))) {
      this.addEditAction(new RemoveTree(node));
      if (lastFocused != null && lastFocused.equals(node)) {
        lastFocused = ((GuiNode) node).getParent(true);
      }
      if (lastFocused == null) {
        lastFocused = (GuiNode) tree.getRoot(true);
      }
      if (focused != null) {
        if (focused.equals(node)) {
          setFocus(((GuiNode) node).getParent(true));
        }
      }
      tree.removeTree(node);
      this.notifyAllTreeChanged();
      this.updateTerms();
    }
  }

#No. 5428
#File: E:\bishe\1\AbstractTreeCanvas.java
#Comment:
  /**
   * Sets the viewPortSize for this instance.
   *
   * @param viewPortSize
   *          The viewPortSize.
   */

#Code:
  public void setViewPortSize(Dimension viewPortSize) {
    this.viewPortSize = viewPortSize;
    // make up for dissapearing scrollbars
    if (this.scrollPane != null) {
      if (this.scrollPane.getHorizontalScrollBar().isVisible()) {
        this.viewPortSize.height +=
            this.scrollPane.getHorizontalScrollBar().getPreferredSize().height;
      }
      if (this.scrollPane.getVerticalScrollBar().isVisible()) {
        this.viewPortSize.width += this.scrollPane.getVerticalScrollBar().getPreferredSize().width;
      }
    }
    this.updateSize();
  }

#No. 5429
#File: E:\bishe\1\AbstractTreeCanvas.java
#Comment:
  /**
   * {@inheritDoc}
   *
   * @see Scrollable#getPreferredScrollableViewportSize()
   */

#Code:
  public Dimension getPreferredScrollableViewportSize() {
    return getPreferredSize();
  }

#No. 5430
#File: E:\bishe\1\AbstractTreeCanvas.java
#Comment:
  /**
   * Sets the moveX for this instance.
   *
   * @param moveX
   *          The moveX.
   */

#Code:
  public void setMoveX(double moveX) {
    if ((moveX) < 0) {
      moveX = 0;
    }
    this.viewTransform.translate(moveX - this.moveX, 0);
    this.moveX = moveX;
  }

#No. 5431
#File: E:\bishe\1\AbstractTreeCanvas.java
#Comment:
  /**
   * Gets the moveX for this instance.
   *
   * @return The moveX.
   */

#Code:
  public double getMoveX() {
    return this.moveX;
  }

#No. 5432
#File: E:\bishe\1\AbstractTreeCanvas.java
#Comment:
  /**
   * Sets the moveY for this instance.
   *
   * @param moveY
   *          The moveY.
   */

#Code:
  public void setMoveY(double moveY) {
    if ((moveY) < 0) {
      moveY = 0;
    }
    this.viewTransform.translate(0, moveY - this.moveY);
    this.moveY = moveY;
  }

#No. 5433
#File: E:\bishe\1\AbstractTreeCanvas.java
#Comment:
  /**
   * Gets the moveY for this instance.
   *
   * @return The moveY.
   */

#Code:
  public double getMoveY() {
    return this.moveY;
  }

#No. 5434
#File: E:\bishe\1\AbstractTreeCanvas.java
#Comment:
  /**
   * Gets the focused node for this instance.
   *
   * @return The focused node.
   */

#Code:
  public GuiNode getFocused() {
    return this.focused;
  }

#No. 5435
#File: E:\bishe\1\AbstractTreeCanvas.java
#Comment:
  /**
   * Gets the lastFocused for this instance.
   *
   * @return The lastFocused.
   */

#Code:
  public GuiNode getLastFocused() {
    return this.lastFocused;
  }

#No. 5436
#File: E:\bishe\1\AbstractTreeCanvas.java
#Comment:
  /**
   * Get the right sibling of a node.
   *
   * @param node
   * @return
   */

#Code:
  public GuiNode getRightSibling(Node node) {
    return ((GuiNode) node).getRightSibling();
  }

#No. 5437
#File: E:\bishe\1\AbstractTreeCanvas.java
#Comment:
  /**
   * Get the left sibling of a node.
   *
   * @param node
   * @return
   */

#Code:
  public GuiNode getLeftSibling(Node node) {
    return ((GuiNode) node).getLeftSibling();
  }

#No. 5438
#File: E:\bishe\1\AbstractTreeCanvas.java
#Comment:
  /**
   * Save tree as an image
   *
   * @param fileStream
   *          stream to which we write
   * @param formatName
   *          informal name of the format e. g. "jpg" or "png"
   */

#Code:
  public void createImage(FileOutputStream fileStream, String formatName) {
    Dimension dim = getPreferredSize();
    BufferedImage bufferedImage =
        new BufferedImage(dim.width, dim.height, BufferedImage.TYPE_INT_RGB);
    Graphics2D g2d = bufferedImage.createGraphics();
    g2d.setColor(Options.canv_BackgroundColor);
    Rectangle r = new Rectangle(dim);
    if (r != null) {
      g2d.fillRect(r.x, r.y, r.width, r.height);
    }
    this.paintComponent(g2d);
    g2d.dispose();
    try {
      ImageIO.write(bufferedImage, formatName, fileStream);
      fileStream.close();
    }
    catch (IOException e) {
      reportError(Options.getMsg("error.export.fail") + e);
    }
  }

#No. 5439
#File: E:\bishe\1\AbstractTreeCanvas.java
#Comment:
  /**
   * Save tree in XML format
   *
   * @param fileStream
   *          stream to which we write
   */

#Code:
  public void createXml(FileOutputStream fileStream) {
    XmlConverter converter = new XmlConverter();
    try {
      TreeLayout layout = tree.getLayout();
      if (Options.main_saveDomains) {
        Set<Integer> ids= new TreeSet<Integer>();
        for (ValuationDomain values : layout.getDomains()) {
          ids.add(values.getDomainId());
        }
        converter.exportTo(fileStream, layout, ids);
      }
      else {
        converter.exportTo(fileStream, layout, null);
      }
    }
    catch (IOException e) {
      reportError(Options.getMsg("error.xmlexport.fail") + e);
    }
  }

#No. 5440
#File: E:\bishe\1\AbstractTreeCanvas.java
#Comment:
  /**
   * Save tree in Latex format
   *
   * @param fileStream
   *          stream to which we write
   */

#Code:
  public void createLatex(FileOutputStream fileStream) {
    XmlConverter converter = new XmlConverter();
    try {
      TreeLayout layout = tree.getLayout();
      converter.exportLatex(fileStream, layout);
    }
    catch (IOException e) {
      reportError(Options.getMsg("error.latexexport.fail") + e);
    }
  }

#No. 5441
#File: E:\bishe\1\AbstractTreeCanvas.java
#Comment:
  /**
   * Get string representing term of the tree.
   */

#Code:
  public String getTermsString() {
    if (this.tree.getRoot(true) instanceof SandNode) {
      return ((SandNode) this.tree.getRoot(true)).toTerms();
    }
    else {
      return ((ADTNode) this.tree.getRoot(true)).toTerms();
    }
  }

#No. 5442
#File: E:\bishe\1\AbstractTreeCanvas.java
#Comment:
  /**
   * {@inheritDoc}
   *
   * @see Scrollable#getScrollableUnitIncrement(Rectangle,int,int)
   */

#Code:
  public int getScrollableUnitIncrement(Rectangle visibleRect, int orientation, int direction) {
    return 0;
  }

#No. 5443
#File: E:\bishe\1\AbstractTreeCanvas.java
#Comment:
  /**
   * {@inheritDoc}
   *
   * @see Scrollable#getScrollableBlockIncrement(Rectangle,int,int)
   */

#Code:
  public int getScrollableBlockIncrement(Rectangle visibleRect, int orientation, int direction) {
    int maxUnitIncrement = 1;
    if (orientation == SwingConstants.HORIZONTAL)
      return visibleRect.width - maxUnitIncrement;
    else
      return visibleRect.height - maxUnitIncrement;
  }

#No. 5444
#File: E:\bishe\1\AbstractTreeCanvas.java
#Comment:
  /**
   * {@inheritDoc}
   *
   * @see Scrollable#getScrollableTracksViewportWidth()
   */

#Code:
  public boolean getScrollableTracksViewportWidth() {
    return false;
  }

#No. 5445
#File: E:\bishe\1\AbstractTreeCanvas.java
#Comment:
  /**
   * {@inheritDoc}
   *
   * @see Scrollable#getScrollableTracksViewportHeight()
   */

#Code:
  public boolean getScrollableTracksViewportHeight() {
    return false;
  }

#No. 5446
#File: E:\bishe\1\AbstractTreeCanvas.java
#Comment:
  /**
   * {@inheritDoc}
   *
   * @see Printable#print(Graphics,PageFormat,int)
   */

#Code:
  public int print(Graphics g, PageFormat pf, int page) {
    double pW = pf.getImageableWidth();
    double pH = pf.getImageableHeight();
    Point p = getColsRows(pW, pH, getNumberOfPages());
    if (page >= (int) (p.getX() * p.getY())) {
      return NO_SUCH_PAGE;
    }
    // store focus and set it to null
    GuiNode tFocus = focused;
    focused = null;
    double printScaleX = (pW * p.getX()) / (sizeX + Options.canv_LineWidth);
    double printScaleY = (pH * p.getY()) / (sizeY + Options.canv_LineWidth);
    if (Options.print_perserveAspectRatio) {
      if (printScaleX < printScaleY) {
        printScaleY = printScaleX;
      }
      else {
        printScaleX = printScaleY;
      }
    }
    int shiftX = page % (int) p.getX();
    int shiftY = page / (int) p.getX();
    // align origin
    g.translate((int) (pf.getImageableX() - (shiftX * pW)),
        (int) (pf.getImageableY() - (shiftY * pH)));
    ((Graphics2D) g).scale(printScaleX, printScaleY);
    g.translate(Options.canv_LineWidth, Options.canv_LineWidth);
    this.paintComponent((Graphics2D) g, tree.getRoot(false));
    // restore focus
    focused = tFocus;
    return PAGE_EXISTS;
  }

#No. 5447
#File: E:\bishe\1\AbstractTreeCanvas.java
#Comment:
  /**
   * Paint the canvas starting at startNode.
   *
   * @param g2
   *          graphics context.
   * @param startNode
   *          root node from which we paint.
   */

#Code:
  public void paintComponent(final Graphics2D g2, Node startNode) {
    g2.setStroke(basicStroke);
    if (Options.canv_DoAntialiasing) {
      g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    }
    else {
      g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_OFF);
    }
    paintEdges(g2, startNode);
    // paint the boxes
    paintBox(g2, startNode);
    if (focused != null) {
      paintFocus(g2, focused);
    }
  }

#No. 5448
#File: E:\bishe\1\AbstractTreeCanvas.java
#Comment:
  /**
   * {@inheritDoc}
   *
   * @see javax.swing.JComponent#paintComponent(Graphics)
   */

#Code:
  public void paintComponent(final Graphics g) {
    super.paintComponent(g);
    final Graphics2D g2 = (Graphics2D) g;
    g2.setColor(Options.canv_BackgroundColor);
    Rectangle r = g2.getClipBounds();
    if (r != null) {
      g2.fillRect(r.x, r.y, r.width, r.height);
    }
    else {
      Debug.log("null clip bounds");
    }
    g2.transform(viewTransform);
    // g2.clearRect(-borderPad, -borderPad, (int) sizeX + borderPad, (int) sizeY
    // + borderPad);
    if (tree != null) {
      paintComponent(g2, tree.getRoot(false));
    }
  }

#No. 5449
#File: E:\bishe\1\AbstractTreeCanvas.java
#Comment:
  /**
   * {@inheritDoc}
   *
   * @see Pageable#getNumberOfPages()
   */

#Code:
  public int getNumberOfPages() {
    // return 1;
    return Options.print_noPages;
  }

#No. 5450
#File: E:\bishe\1\AbstractTreeCanvas.java
#Comment:
  /**
   * {@inheritDoc}
   *
   * @see Pageable#getPrintable(int)
   */

#Code:
  public Printable getPrintable(int pageIndex) {
    if (pageIndex >= Options.print_noPages) {
      throw new IndexOutOfBoundsException("No page with number " + pageIndex);
    }
    return this;
  }

#No. 5451
#File: E:\bishe\1\AbstractTreeCanvas.java
#Comment:
  /**
   * {@inheritDoc}
   *
   * @see Pageable#getPageFormat(int)
   */

#Code:
  public PageFormat getPageFormat(int pageIndex) {
    return pageFormat;
  }

#No. 5452
#File: E:\bishe\1\AbstractTreeCanvas.java
#Comment:
  /**
   * Sets the pageFormat for this instance.
   *
   * @param pageFormat
   *          The pageFormat.
   */

#Code:
  public void setPageFormat(PageFormat pageFormat) {
    this.pageFormat = pageFormat;
  }

#No. 5453
#File: E:\bishe\1\AbstractTreeCanvas.java
#Comment:
  /**
   * Paints the node labels.
   *
   * @param g
   * @param node
   * @param textCol
   *          color for the text.
   */

#Code:
  protected void paintLabels(final Graphics2D g, final Node node, final Color textCol) {
    final Rectangle2D.Double box = bufferedLayout.get(node);
    int x = (int) box.x;
    int y = (int) box.y;
    // draw the text on top of the box (possibly multiple lines)
    final String[] lines = this.getLabelLines(node);
    final FontMetrics m = getFontMetrics(Options.canv_Font);
    // center vertically
    y = (int) (y + box.height / 2 - (lines.length * m.getHeight()) / 2) - 1;
    // center horizontally
    x = x + (int) (box.width / 2);
    // draw strings
    y += m.getAscent() + m.getLeading() + 1;
    g.setColor(textCol);
    g.setFont(Options.canv_Font);
    for (int i = 0; i < lines.length; i++) {
      g.drawString(lines[i], x - (m.stringWidth(lines[i])) / 2, y);
      y += m.getHeight();
    }
  }

#No. 5454
#File: E:\bishe\1\AbstractTreeCanvas.java
#Comment:
  /**
   * Draws the node focus indication.
   *
   * @param g2
   * @param node
   */

#Code:
  protected void paintFocus(final Graphics2D g2, final Node node) {
    final Rectangle2D.Double box = bufferedLayout.get(node);
    if (box == null) {
      return;
    }
    int x = (int) box.x - focusPad / 2;
    int y = (int) box.y - focusPad / 2;
    g2.setColor(Color.blue);
    g2.setStroke(selectionStroke);
    // ATTACKER type
    Options.ShapeType shape = Options.canv_ShapeAtt;
    if (node instanceof ADTNode) {
      ADTNode.Role defender =
          tree.getLayout().getSwitchRole() ? ADTNode.Role.PROPONENT : ADTNode.Role.OPPONENT;
      if (((ADTNode) node).getRole() == defender) {
        shape = Options.canv_ShapeDef;
      }
    }
    switch (shape) {
    case RECTANGLE:
      g2.drawRect(x, y, (int) box.width + focusPad - 1, (int) box.height + focusPad - 1);
      break;
    case OVAL:
      g2.drawOval(x, y, (int) box.width + focusPad - 1, (int) box.height + focusPad - 1);
      break;
    // case ROUNDRECT:
    // default:
    // g2.drawRoundRect(x, y, (int) box.width + focusPad - 1, (int) box.height +
    // focusPad - 1,
    // Options.canv_ArcSize + 1, Options.canv_ArcSize + 1);
    // break;
    }
  }

#No. 5455
#File: E:\bishe\1\AbstractTreeCanvas.java
#Comment:
  /**
   * Recalculates the total size of the tree.
   *
   */

#Code:
  protected void updateSize() {
    Point2D.Double point =
        new Point2D.Double(this.sizeX + this.borderPad / 2, this.sizeY + this.borderPad / 2);
    this.viewTransform.transform(point, point);
    int x = 0;
    int y = 0;
    if (this.viewPortSize != null) {
      x = this.viewPortSize.width + x;
      y = this.viewPortSize.height + y;
    }
    Dimension dim = new Dimension(Math.max((int) point.getX(), x), Math.max((int) point.getY(), y));

    this.setPreferredSize(dim);
    this.setMinimumSize(dim);
    this.revalidate();
  }

#No. 5456
#File: E:\bishe\1\AbstractTreeCanvas.java
#Comment:
  /**
   * Calculates optimal number of rows and columns - used for printing.
   *
   * @param pageHeight
   *          height of the page.
   * @param pageWidth
   *          width of the page.
   * @param noPages
   *          maximum number of pages.
   * @return
   */

#Code:
  private Point getColsRows(double pageHeight, double pageWidth, int noPages) {
    double ratio = (pageWidth / pageHeight) / (sizeY / sizeX);
    int rows = 1;
    int cols = 1;
    while (true) {
      if (ratio * ((double) rows / cols) > 1) {
        cols++;
        if (cols * rows > noPages) {
          cols--;
          return new Point((int) cols, (int) rows);
        }
      }
      else {
        rows++;
        if (cols * rows > noPages) {
          rows--;
          return new Point((int) cols, (int) rows);
        }
      }
    }
  }

#No. 5457
#File: E:\bishe\1\AbstractTreeGenerationRule.java
#Comment:
	/**
	 * Subclasses should call super.appliesTo first, and then
	 * verify their conditions
	 * @param event
	 * @return
	 */

#Code:
	@Override
	public boolean appliesTo(Event event) {
		return event.widget instanceof Tree && event.item instanceof TreeItem;
	}

#No. 5458
#File: E:\bishe\1\AbstractTreeModel.java
#Comment:
    /**
     * @see nextapp.echo.extras.app.tree.TreeModel#addTreeModelListener(nextapp.echo.extras.app.event.TreeModelListener)
     */

#Code:
    public void addTreeModelListener(TreeModelListener l) {
        listenerList.addListener(TreeModelListener.class, l);
    }

#No. 5459
#File: E:\bishe\1\AbstractTreeModel.java
#Comment:
    /**
     * @see nextapp.echo.extras.app.tree.TreeModel#removeTreeModelListener(nextapp.echo.extras.app.event.TreeModelListener)
     */

#Code:
    public void removeTreeModelListener(TreeModelListener l) {
        listenerList.removeListener(TreeModelListener.class, l);
    }

#No. 5460
#File: E:\bishe\1\AbstractTreeModel.java
#Comment:
    /**
     * Returns column names using a "spreadsheet-style" convention, i.e., 
     * A, B, C...Y, Z, AA, AB, AC...
     * 
     * @see nextapp.echo.extras.app.tree.TreeModel#getColumnName(int)
     */

#Code:
    public String getColumnName(int column) {
        StringBuffer sb = new StringBuffer();
        int value = column;
        do {
            int digit = value % 26;
            sb.insert(0, (char) ('A' + digit));
            value = value / 26 - 1;
        } while (value >= 0);
        
        return sb.toString();
    }

#No. 5461
#File: E:\bishe\1\AbstractTreeModel.java
#Comment:
    /**
     * @see nextapp.echo.extras.app.tree.TreeModel#getColumnClass(int)
     */

#Code:
    public Class getColumnClass(int column) {
        return Object.class;
    }

#No. 5462
#File: E:\bishe\1\AbstractTreeModel.java
#Comment:
    /**
     * Notifies all listeners that have registered interest for notification on
     * this event type. The event instance is lazily created using the
     * parameters passed into the fire method.
     * 
     * @param source the node being changed
     * @param path the path to the root node
     * @param childIndices the indices of the changed elements
     * @param children the changed elements
     * @see EventListenerList
     */

#Code:
    protected void fireTreeNodesChanged(Object source, Object[] path,
            int[] childIndices, Object[] children) {
        // Guaranteed to return a non-null array
        Object[] listeners = listenerList.getListeners(TreeModelListener.class);
        TreeModelEvent e = null;
        for (int i = 0; i < listeners.length; ++i) {
            // Lazily create the event:
            if (e == null) {
                e = new TreeModelEvent(source, path, childIndices, children);
            }
            ((TreeModelListener) listeners[i]).treeNodesChanged(e);
        }
    }

#No. 5463
#File: E:\bishe\1\AbstractTreeModel.java
#Comment:
    /**
     * Notifies all listeners that have registered interest for notification on
     * this event type. The event instance is lazily created using the
     * parameters passed into the fire method.
     * 
     * @param source the node where new elements are being inserted
     * @param path the path to the root node
     * @param childIndices the indices of the new elements
     * @param children the new elements
     * @see EventListenerList
     */

#Code:
    protected void fireTreeNodesInserted(Object source, Object[] path,
            int[] childIndices, Object[] children) {
        // Guaranteed to return a non-null array
        Object[] listeners = listenerList.getListeners(TreeModelListener.class);
        TreeModelEvent e = null;
        for (int i = 0; i < listeners.length; i++) {
            // Lazily create the event:
            if (e == null) {
                e = new TreeModelEvent(source, path, childIndices, children);
            }
            ((TreeModelListener) listeners[i]).treeNodesAdded(e);
        }
    }

#No. 5464
#File: E:\bishe\1\AbstractTreeModel.java
#Comment:
    /**
     * Notifies all listeners that have registered interest for notification on
     * this event type. The event instance is lazily created using the
     * parameters passed into the fire method.
     * 
     * @param source the node where elements are being removed
     * @param path the path to the root node
     * @param childIndices the indices of the removed elements
     * @param children the removed elements
     * @see EventListenerList
     */

#Code:
    protected void fireTreeNodesRemoved(Object source, Object[] path,
            int[] childIndices, Object[] children) {
        // Guaranteed to return a non-null array
        Object[] listeners = listenerList.getListeners(TreeModelListener.class);
        TreeModelEvent e = null;
        for (int i = 0; i < listeners.length; i++) {
            // Lazily create the event:
            if (e == null) {
                e = new TreeModelEvent(source, path, childIndices, children);
            }
            ((TreeModelListener) listeners[i]).treeNodesRemoved(e);
        }
    }

#No. 5465
#File: E:\bishe\1\AbstractTreeModel.java
#Comment:
    /**
     * Notifies all listeners that have registered interest for notification on
     * this event type. The event instance is lazily created using the
     * parameters passed into the fire method.
     * 
     * @param source the node where the tree model has changed
     * @param path the path to the root node
     * @param childIndices the indices of the affected elements
     * @param children the affected elements
     * @see EventListenerList
     */

#Code:
    protected void fireTreeStructureChanged(Object source, Object[] path,
            int[] childIndices, Object[] children) {
        // Guaranteed to return a non-null array
        Object[] listeners = listenerList.getListeners(TreeModelListener.class);
        TreeModelEvent e = null;
        for (int i = 0; i < listeners.length; i++) {
            // Lazily create the event:
            if (e == null)
                e = new TreeModelEvent(source, path, childIndices, children);
            ((TreeModelListener) listeners[i]).treeStructureChanged(e);
        }
    }

#No. 5466
#File: E:\bishe\1\AbstractTreeNodeService.java
#Comment:
	/**
	 * 处理参数
	 * 
	 * @param handlers
	 *            html
	 * @param params
	 *            参数
	 */

#Code:
	protected void prepareParameters(StringBuffer handlers, Map<String, Object> params) {
		if (params == null)
			return;

		StringBuffer result = new StringBuffer();
		Iterator<String> iterKeys = params.keySet().iterator();
		int count = 0;
		while (iterKeys.hasNext()) {
			if (count > 0)
				result.append("&amp;");
			count++;

			String key = iterKeys.next();
			Object value = params.get(key);
			if (value != null) {
				if (value instanceof String) {
					result.append(key).append("=").append(value.toString());
				} else if (value instanceof String[]) {
					String[] arrs = (String[]) value;
					for (String string : arrs) {
						if (string == null) {
							result.append(key).append("=");
						} else {
							result.append(key).append("=").append(string);
						}
					}
				} else {
					throw new RuntimeException("Not support parameter: " + key + "=" + value);// TODO
				}
			} else {
				result.append(key).append("=");
			}

		}
		if (result.length() > 0) {
			this.prepareAttribute(handlers, "param", result.toString());
		}
	}

#No. 5467
#File: E:\bishe\1\AbstractTreeNodeService.java
#Comment:
	/**
	 * Prepares an attribute if the value is not null, appending it to the the
	 * given StringBuffer.
	 * 
	 * @param handlers
	 *            The StringBuffer that output will be appended to.
	 * @param name
	 *            属性名称
	 * @param value
	 *            属性值
	 */

#Code:
	protected void prepareAttribute(StringBuffer handlers, String name, Object value) {
		if (value != null) {
			handlers.append(" ");
			handlers.append(name);
			handlers.append("=\"");
			handlers.append(value);
			handlers.append("\"");
		}
	}

#No. 5468
#File: E:\bishe\1\AbstractTreeNodeService.java
#Comment:
	/**
	 * @param tree
	 *            树
	 * @param treeNode
	 *            节点
	 * @return 是否是叶子节点
	 */

#Code:
	protected boolean isLeaf(Tree tree, TreeNode treeNode) {
		return treeNode.isLeaf() || tree.isLeaf();
	}

#No. 5469
#File: E:\bishe\1\AbstractTrendsList.java
#Comment:
/**
 * Abstract model class representing a list of trends.
 *
 * @author Craig Walls
 * @author Antoine Sabot-Durand
 */

#Code:
class AbstractTrendsList {
    private final List<Trends> list;

    public AbstractTrendsList(Map<String, List<Trend>> trends, DateFormat dateFormat) {
        list = new ArrayList<Trends>(trends.size());
        for (Iterator<Entry<String, List<Trend>>> trendsIt = trends.entrySet().iterator(); trendsIt.hasNext(); ) {
            Entry<String, List<Trend>> entry = trendsIt.next();

            list.add(new Trends(toDate(entry.getKey(), dateFormat), entry.getValue()));
        }
        Collections.sort(list, new Comparator<Trends>() {
            public int compare(Trends t1, Trends t2) {
                return t1.getTime().getTime() > t2.getTime().getTime() ? -1 : 1;
            }
        });
    }

    public List<Trends> getList() {
        return list;
    }

    protected Date toDate(String dateString, DateFormat dateFormat) {
        if (dateString == null) {
            return null;
        }

        try {
            return dateFormat.parse(dateString);
        } catch (ParseException e) {
            return null;
        }
    }

}

#No. 5470
#File: E:\bishe\1\AbstractTrustedIdpOAuth2ProtocolHandler.java
#Comment:
        /**
         * Set the SubjectBean
         */

#Code:
        public void setSubjectBean(SubjectBean subjectBean) {
            this.subjectBean = subjectBean;
        }

#No. 5471
#File: E:\bishe\1\AbstractTrustedIdpOAuth2ProtocolHandler.java
#Comment:
        /**
         * Set the ConditionsBean
         */

#Code:
        public void setConditionsBean(ConditionsBean conditionsBean) {
            this.conditionsBean = conditionsBean;
        }

#No. 5472
#File: E:\bishe\1\AbstractTrustedIdpOAuth2ProtocolHandler.java
#Comment:
        /**
         * Set the issuer name
         */

#Code:
        public void setIssuer(String issuerName) {
            this.issuer = issuerName;
        }

#No. 5473
#File: E:\bishe\1\AbstractTupleTable.java
#Comment:
	/**
	 * Please override in subclass if you use the TupleTableIterator !!!!
	 * 
	 * @throws TableException
	 */

#Code:
	protected Tuple getValues(int row, List<Field> columns) throws TableException
	{
		return getRows().get(row);
	}

#No. 5474
#File: E:\bishe\1\AbstractTupleTable.java
#Comment:
	/**
	 * Checks if the column is in the current view port (the columns that the
	 * user sees in the table on the screen)
	 * 
	 * @param columnName
	 * @return
	 * @throws TableException
	 */

#Code:
	protected boolean isInViewPort(String columnName) throws TableException
	{
		for (Field field : getColumns())
		{
			if (field.getName().equals(columnName))
			{
				return true;
			}
		}

		return false;
	}

#No. 5475
#File: E:\bishe\1\AbstractTwoParamSameColTypeProjectionFunction.java
#Comment:
/**
 * Abstract implementation for projection functions with a two params and which produce the same output
 * {@link ColumnType} as the input.
 * 
 * @author Bastian Gloeckle
 */

#Code:
public abstract class AbstractTwoParamSameColTypeProjectionFunction<T>
    extends AbstractTwoParamProjectionFunction<T, T> {

  protected AbstractTwoParamSameColTypeProjectionFunction(String nameLowercase, ColumnType inputAndOutputType,
      boolean paramsAreExchangeable, BiFunction<T, T, T> fn) {
    super(nameLowercase, inputAndOutputType, inputAndOutputType, paramsAreExchangeable, fn);
  }
}

#No. 5476
#File: E:\bishe\1\AbstractTypeAccessor.java
#Comment:
  /**
   * <p>
   * Creates a new instance of type {@link AbstractTypeAccessor}.
   * </p>
   * 
   */

#Code:
  public AbstractTypeAccessor() {
    _problems = new LinkedList<DsAnnotationProblem>();
    _references = new LinkedList<Reference>();
  }

#No. 5477
#File: E:\bishe\1\AbstractTypeAccessor.java
#Comment:
  /**
   * {@inheritDoc}
   */

#Code:
  public final boolean hasProblems() {
    return !_problems.isEmpty();
  }

#No. 5478
#File: E:\bishe\1\AbstractTypeAccessor.java
#Comment:
  /**
   * {@inheritDoc}
   */

#Code:
  public final List<DsAnnotationProblem> getProblems() {
    return _problems;
  }

#No. 5479
#File: E:\bishe\1\AbstractTypeDeclarationNode.java
#Comment:
	/**
	 * {@inheritDoc}
	 */

#Code:
	@Override
	public TypeDeclaration getChildTypeAtOffset(int offs) {

		TypeDeclaration typeDec = null;

		for (int i=0; i<getChildTypeCount(); i++) {
			TypeDeclaration td = getChildType(i);
			if (td.getBodyContainsOffset(offs)) {
				typeDec = td;
				break;
			}
		}

		return typeDec;

	}

#No. 5480
#File: E:\bishe\1\AbstractTypeDeclarationNode.java
#Comment:
	/**
	 * {@inheritDoc}
	 */

#Code:
	@Override
	public Iterator<Field> getFieldIterator() {
		List<Field> fields = new ArrayList<Field>();
		for (Iterator<Member> i=getMemberIterator(); i.hasNext(); ) {
			Member member = i.next();
			if (member instanceof Field) {
				fields.add((Field)member);
			}
		}
		return fields.iterator();
	}

#No. 5481
#File: E:\bishe\1\AbstractTypeDeclarationNode.java
#Comment:
	/**
	 * {@inheritDoc}
	 */

#Code:
	@Override
	public Iterator<Member> getMemberIterator() {
		return memberList.iterator();
	}

#No. 5482
#File: E:\bishe\1\AbstractTypeDeclarationNode.java
#Comment:
	/**
	 * {@inheritDoc}
	 */

#Code:
	@Override
	public Iterator<Method> getMethodIterator() {
		List<Method> methods = new ArrayList<Method>();
		for (Iterator<Member> i=getMemberIterator(); i.hasNext(); ) {
			Member member = i.next();
			if (member instanceof Method) {
				methods.add((Method)member);
			}
		}
		return methods.iterator();
	}

#No. 5483
#File: E:\bishe\1\AbstractTypeDeclarationNode.java
#Comment:
	/**
	 * {@inheritDoc}
	 */

#Code:
	@Override
	public List<Method> getMethodsByName(String name) {
		List<Method> methods = new ArrayList<Method>();
		for (Iterator<Member> i=getMemberIterator(); i.hasNext(); ) {
			Member member = i.next();
			if (member instanceof Method && name.equals(member.getName())) {
				methods.add((Method)member);
			}
		}
		return methods;
	}

#No. 5484
#File: E:\bishe\1\AbstractTypeDeclarationNode.java
#Comment:
	/**
	 * {@inheritDoc}
	 */

#Code:
	@Override
	public String getName(boolean fullyQualified) {
		String name = getName();
		if (fullyQualified) {
			Package pkg = getPackage();
			if (pkg!=null) {
				name = pkg.getName() + "." + name;
			}
		}
		return name;
	}

#No. 5485
#File: E:\bishe\1\AbstractTypeDeclarationNode.java
#Comment:
	/**
	 * {@inheritDoc}
	 */

#Code:
	@Override
	public Package getPackage() {
		return pkg;
	}

#No. 5486
#File: E:\bishe\1\AbstractTypeDeclarationNode.java
#Comment:
	/**
	 * {@inheritDoc}
	 */

#Code:
	@Override
	public TypeDeclaration getParentType() {
		return parentType;
	}

#No. 5487
#File: E:\bishe\1\AbstractTypeDeclarationNode.java
#Comment:
	/**
	 * {@inheritDoc}
	 */

#Code:
	@Override
	public boolean isStatic() {
		return modifiers==null ? false : modifiers.isStatic();
	}

#No. 5488
#File: E:\bishe\1\AbstractTypeDeclarationNode.java
#Comment:
	/**
	 * Sets the package this type is in.
	 *
	 * @param pkg The package, or <code>null</code> if this is in the
	 *        default package.
	 * @see #getPackage()
	 */

#Code:
	public void setPackage(Package pkg) {
		this.pkg = pkg;
	}

#No. 5489
#File: E:\bishe\1\AbstractTypeDeclarationNode.java
#Comment:
	/**
	 * {@inheritDoc}
	 */

#Code:
	@Override
	public void setParentType(TypeDeclaration parentType) {
		this.parentType = parentType;
	}

#No. 5490
#File: E:\bishe\1\AbstractTypedJEvent.java
#Comment:
	/**
	 * Implementations of this class might want to add own public method with good naming (like, getUser() or getAccount())
	 *
	 * @return event object
	 */

#Code:
	@Nonnull
	protected final D getEventObject() {
		return eventObject;
	}

#No. 5491
#File: E:\bishe\1\AbstractTypedPlugin.java
#Comment:
/**
 * Abstract base class for {@link TypedPlugin}s.
 * 
 * @author Curtis Rueden
 * @param <D> Data type associated with the plugin.
 * @see Typed
 */

#Code:
public abstract class AbstractTypedPlugin<D> extends AbstractRichPlugin
	implements TypedPlugin<D>
{
	// NB: No implementation needed.
}

#No. 5492
#File: E:\bishe\1\AbstractTypedService.java
#Comment:
/**
 * Abstract base class for {@link TypedService}s.
 * 
 * @author Curtis Rueden
 * @param <DT> Base data type of the {@link TypedPlugin}s.
 * @param <PT> Plugin type of the {@link TypedPlugin}s.
 */

#Code:
public abstract class AbstractTypedService<DT, PT extends TypedPlugin<DT>>
	extends AbstractPTService<PT> implements TypedService<DT, PT>
{
	// NB: No implementation needed.
}

#No. 5493
#File: E:\bishe\1\AbstractTypeIntrospector.java
#Comment:
    /**
     * Gets the next nested property value according to the provided next token index.
     */

#Code:
    public static Object getNestedValue(Object value, int position, String[] tokens, SpacePropertyInfo[] propertyInfoCache, String originalPath) {
        if (position == tokens.length)
            throw new IllegalArgumentException("[*] can only be used on Collection properties.");

        if (value instanceof Map)
            return ((Map<?, ?>) value).get(tokens[position]);
        if (value instanceof VirtualEntry)
            return ((VirtualEntry) value).getProperty(tokens[position]);

        SpacePropertyInfo propertyInfo;
        if (propertyInfoCache != null && propertyInfoCache[position] != null)
            propertyInfo = propertyInfoCache[position];
        else {
            Class<? extends Object> type = value.getClass();
            SpaceTypeInfo typeInfo = SpaceTypeInfoRepository.getTypeInfo(type);
            propertyInfo = typeInfo.getProperty(tokens[position]);
            if (propertyInfo == null)
                throw new IllegalArgumentException("Property '" + tokens[position] + "' is not a member of " + type.getName() + " in '" + originalPath + "'");

            if (propertyInfoCache != null)
                propertyInfoCache[position] = propertyInfo;
        }

        return propertyInfo.getValue(value);
    }

#No. 5494
#File: E:\bishe\1\AbstractTypeIntrospector.java
#Comment:
    /**
     * NOTE: if you change this method, you need to make this class ISwapExternalizable
     */

#Code:
    public void writeExternal(ObjectOutput out, PlatformLogicalVersion version)
            throws IOException {
    }

#No. 5495
#File: E:\bishe\1\AbstractTypeMap.java
#Comment:
	/**
	 * 返回对应java类型的默认值
	 * 
	 * @param javaType
	 * @return
	 */

#Code:
	public Object getDefaultValue(String typeName) {
		Class javaType = types.get(typeName);
		if (javaType == null) {
			javaType = this.getJavaTypeByName(typeName);
		}

		if (PrimitiveHelper.isPrimitiveTypeOrRelative(javaType)) {
			Object value = PrimitiveHelper.getPrimitiveDefaultValue(javaType);
			return value;
		} else if (BigDecimal.class.isAssignableFrom(javaType)) {
			return BigDecimal.valueOf(0L);
		} else if (java.sql.Date.class.isAssignableFrom(javaType)) {
			return new java.sql.Date(new java.util.Date().getTime());
		} else if (java.sql.Time.class.isAssignableFrom(javaType)) {
			return new java.sql.Time(new java.util.Date().getTime());
		} else if (java.sql.Timestamp.class.isAssignableFrom(javaType)) {
			return new java.sql.Timestamp(new java.util.Date().getTime());
		} else if (javaType == byte[].class) {
			return "bytes".getBytes();
		}
		Object value = this.getDefaultValue(javaType);
		return value;
	}

#No. 5496
#File: E:\bishe\1\AbstractTypeVisitor6.java
#Comment:
    /**
     * Visits any type mirror as if by passing itself to that type
     * mirror's {@link TypeMirror#accept accept} method and passing
     * {@code null} for the additional parameter.  The invocation
     * {@code v.visit(t)} is equivalent to {@code t.accept(v, null)}.
     *
     * @param t  the type to visit
     * @return a visitor-specified result
     */

#Code:
    public final R visit(TypeMirror t) {
	return t.accept(this, null);
    }

#No. 5497
#File: E:\bishe\1\AbstractTypeVisitor6.java
#Comment:
    /**
     * {@inheritDoc}
     *
     * <p> The default implementation of this method in {@code
     * AbstractTypeVisitor6} will always throw {@code
     * UnknownTypeException}.  This behavior is not required of a
     * subclass.
     *
     * @param t  the type to visit
     * @return a visitor-specified result
     * @throws UnknownTypeException
     *	a visitor implementation may optionally throw this exception
     */

#Code:
    public R visitUnknown(TypeMirror t, P p) {
	throw new UnknownTypeException(t, p);
    }

#No. 5498
#File: E:\bishe\1\AbstractUIEvent.java
#Comment:
	/**
	 * Construct a ui event from a log.
	 */

#Code:
	public AbstractUIEvent(Trace trace, String[] args) {

		this.trace = trace;
		this.time = Long.parseLong(args[1]);
		this.ui = args[2];
		this.entity = parseEntity(args);
		this.userInitiated = false;
		
	}

#No. 5499
#File: E:\bishe\1\AbstractUIInputWidget.java
#Comment:
	/**
	 * @return the UserInterface matching the provided String
	 */

#Code:
	protected UserInterface ui(String uiName) {
		
		return uiService.getUI(uiName);
	}

#No. 5500
#File: E:\bishe\1\AbstractUIThreadManager.java
#Comment:
    /**
     * Executes a code block as a Future on an ExecutorService.
     *
     * @param callable a code block to be executed
     *
     * @return a Future that contains the result of the execution
     */

#Code:
    @Nonnull
    @Override
    public <R> Future<R> runFuture(@Nonnull Callable<R> callable) {
        requireNonNull(callable, ERROR_CALLABLE_NULL);
        return runFuture(executorService, callable);
    }

    /**
     * Executes a code block as a Future on an ExecutorService.
     *
     * @param executorService the ExecutorService to use. Will use the default ExecutorService if null.
     * @param callable        a code block to be executed
     *
     * @return a Future that contains the result of the execution
     */
    @Nonnull
    @Override
    public <R> Future<R> runFuture(@Nonnull ExecutorService executorService, @Nonnull Callable<R> callable) {
        requireNonNull(executorService, "Argument 'executorService' must not be null");
        requireNonNull(callable, ERROR_CALLABLE_NULL);
        return executorService.submit(callable);
    }

    @Override
    public void runOutsideUI(@Nonnull final Runnable runnable) {
        requireNonNull(runnable, ERROR_RUNNABLE_NULL);
        if (!isUIThread()) {
            runnable.run();
        } else {
            executorService.submit(new Runnable() {
                public void run() {
                    try {
                        runnable.run();
                    } catch (Throwable throwable) {
                        exceptionHandler.uncaughtException(Thread.currentThread(), throwable);
                    }
                }
            });
        }

#No. 5501
#File: E:\bishe\1\AbstractUnArchiver.java
#Comment:
    /**
     * @since 1.1
     */

#Code:
    public boolean isUseJvmChmod()
    {
        return useJvmChmod;
    }

#No. 5502
#File: E:\bishe\1\AbstractUnArchiver.java
#Comment:
    /**
     * <b>jvm chmod won't set group level permissions !</b>
     * @since 1.1
     */

#Code:
    public void setUseJvmChmod( final boolean useJvmChmod )
    {
        this.useJvmChmod = useJvmChmod;
    }

#No. 5503
#File: E:\bishe\1\AbstractUnArchiver.java
#Comment:
    /**
     * @since 1.1
     */

#Code:
    public boolean isIgnorePermissions()
    {
        return ignorePermissions;
    }

#No. 5504
#File: E:\bishe\1\AbstractUnArchiver.java
#Comment:
    /**
     * @since 1.1
     */

#Code:
    public void setIgnorePermissions( final boolean ignorePermissions )
    {
        this.ignorePermissions = ignorePermissions;
    }

#No. 5505
#File: E:\bishe\1\AbstractUnaryFunction.java
#Comment:
/** An abstract function requires one argument in X. 
 * @author uniker9
 *
 * @param <X> A set forms a field.
 */

#Code:
public abstract class AbstractUnaryFunction<X extends Field<X>> extends
		DifferentialFunction<X> {

	private DifferentialFunction<X> m_x;

	/** Constructs a new AbstractUnaryFunction.
	 * @param i_v the argument.
	 */
	public AbstractUnaryFunction(DifferentialFunction<X> i_v) {

		if (i_v != null) {
			m_x = i_v;
		} else {
			throw new IllegalArgumentException("Input not null variable.");
		}
	}
	
	/** Returns the argument of this function.
	 * @return the argument.
	 */
	public DifferentialFunction<X> arg() {
		return m_x;
	} 
}

#No. 5506
#File: E:\bishe\1\AbstractUnitFormat.java
#Comment:
  /**
   * Formats the specified unit.
   *
   * @param unit
   *          the unit to format.
   * @param appendable
   *          the appendable destination.
   * @return The appendable destination passed in as {@code appendable}, with formatted text appended.
   * @throws IOException
   *           if an error occurs.
   */

#Code:
  public abstract Appendable format(Unit<?> unit, Appendable appendable) throws IOException;

  /**
   * Formats an object to produce a string. This is equivalent to <blockquote> {@link #format(Unit, StringBuilder) format}<code>(unit,
   *         new StringBuilder()).toString();</code> </blockquote>
   *
   * @param obj
   *          The object to format
   * @return Formatted string.
   * @exception IllegalArgumentException
   *              if the Format cannot format the given object
   */
  public final String format(Unit<?> unit) {
    if (unit instanceof AbstractUnit) {
      return format((AbstractUnit<?>) unit, new StringBuilder()).toString();
    } else {
      try {
        return (this.format(unit, new StringBuilder())).toString();
      } catch (IOException ex) {
        throw new ParserException(ex); // Should never happen.
      }
    }
  }

#No. 5507
#File: E:\bishe\1\AbstractUnitFormat.java
#Comment:
  /**
   * Convenience method equivalent to {@link #format(AbstractUnit, Appendable)} except it does not raise an IOException.
   *
   * @param unit
   *          the unit to format.
   * @param dest
   *          the appendable destination.
   * @return the specified <code>StringBuilder</code>.
   */

#Code:
  final StringBuilder format(AbstractUnit<?> unit, StringBuilder dest) {
    try {
      return (StringBuilder) this.format(unit, (Appendable) dest);
    } catch (IOException ex) {
      throw new Error(ex); // Can never happen.
    }
  }

#No. 5508
#File: E:\bishe\1\AbstractUnitFormat.java
#Comment:
  /**
   * serialVersionUID
   */

#Code:
  // private static final long serialVersionUID = -2046025267890654321L;
}
}

#No. 5509
#File: E:\bishe\1\AbstractUnitTestsRule.java
#Comment:
    /**
     * Returns the youngest build which is usable to compare the current test result against.
     * I.e. returns the youngest build which is better than NOT_BUILD and has test results.
     * FAILURE builds are returned immediately!
     *
     * @return the previous build or null if no such build was found
     */

#Code:
    private AbstractBuild<?, ?> getPreviousBuildWithResults(AbstractBuild<?, ?> previousBuild) {
        while(previousBuild != null) {
        	if (previousBuild.getResult() != null) {
	            if (previousBuild.getResult().isBetterThan(Result.FAILURE)) {
	                @SuppressWarnings("unchecked")
	                AbstractTestResultAction action = previousBuild.getAction(AbstractTestResultAction.class);
	                if (action != null) {
	                    return previousBuild;
	                }
	                // fall through
	            } else if (previousBuild.getResult().isWorseOrEqualTo(Result.NOT_BUILT)) { 
	                // fall through
	            } else {
	                return previousBuild;
	            }
        	}
            previousBuild = previousBuild.getPreviousBuild();
        }
        
        return null;
    }

#No. 5510
#File: E:\bishe\1\AbstractUnpackMojo.java
#Comment:
/**
 * Unpacks NAR files. Unpacking happens in the local repository, and also sets flags on binaries and corrects static
 * libraries.
 */

#Code:
public abstract class AbstractUnpackMojo
    extends AbstractCompileMojo
{

    /**
     * List of classifiers which you want unpack. Example ppc-MacOSX-g++, x86-Windows-msvc, i386-Linux-g++.
     * 
     * @parameter expression=""
     */
    protected List classifiers;

    /**
     * To look up Archiver/UnArchiver implementations
     * 
     * @component role="org.codehaus.plexus.archiver.manager.ArchiverManager"
     * @required
     */
    protected ArchiverManager archiverManager;
}

#No. 5511
#File: E:\bishe\1\AbstractUpdateListener.java
#Comment:
    /**
     * Get Handler
     *
     * @return
     */

#Code:
    protected Handler getHandler() {
        return handler;
    }

#No. 5512
#File: E:\bishe\1\AbstractUpdateListener.java
#Comment:
    /**
     * Set Handler
     *
     * @param handler
     */

#Code:
    protected void setHandler(Handler handler) {
        this.handler = handler;
    }

#No. 5513
#File: E:\bishe\1\AbstractUpdateListener.java
#Comment:
    /**
     * Get the Context
     *
     * @return
     */

#Code:
    public Context getContext() {
        return context;
    }

#No. 5514
#File: E:\bishe\1\AbstractUpdateListener.java
#Comment:
    /**
     * Set the Context
     *
     * @param context
     */

#Code:
    public void setContext(Context context) {
        this.context = context;
    }

#No. 5515
#File: E:\bishe\1\AbstractUpdateListener.java
#Comment:
    /**
     * Get the update options
     *
     * @return
     */

#Code:
    public UpdateOptions getUpdateOptions() {
        return updateOptions;
    }

#No. 5516
#File: E:\bishe\1\AbstractUpdateListener.java
#Comment:
    /**
     * Set the update options
     *
     * @param updateOptions
     */

#Code:
    public void setUpdateOptions(UpdateOptions updateOptions) {
        this.updateOptions = updateOptions;
    }

#No. 5517
#File: E:\bishe\1\AbstractUpdateListener.java
#Comment:
    /**
     * show the update dialog
     *
     * @param info the info for the new app
     */

#Code:
    public abstract void onShowUpdateUI(final UpdateInfo info);

    /**
     * It's the latest app,or there is no need to update.
     */
    public abstract void onShowNoUpdateUI();

    /**
     * show the progress when downloading the new app
     */
    public abstract void onShowUpdateProgressUI(final UpdateInfo info, final DownloadTask task, final int progress);

    /**
     * user click to confirm the update
     */
    public final void informUpdate(final UpdateInfo info) {
        if (handler != null) {
            handler.obtainMessage(
                    UpdateManager.MSG_INFORM_UPDATE,
                    info).sendToTarget();
        }
    }

#No. 5518
#File: E:\bishe\1\AbstractUpdateListener.java
#Comment:
    /**
     * user click to cancel the update
     */

#Code:
    public final void informCancel(final UpdateInfo info) {
        if (handler != null) {
            handler.obtainMessage(
                    UpdateManager.MSG_INFORM_CANCEL);
        }

        if ((updateOptions != null && updateOptions.shouldForceUpdate())
                || (info != null && info.isForceUpdate())) {
            ExitApp();
        }
    }

#No. 5519
#File: E:\bishe\1\AbstractUpdateListener.java
#Comment:
    /**
     * user click to skip the update
     */

#Code:
    public final void informSkip(final UpdateInfo info) {
        if (handler != null) {
            handler.obtainMessage(
                    UpdateManager.MSG_INFORM_SKIP, info).sendToTarget();
        }

        if ((updateOptions != null && updateOptions.shouldForceUpdate())
                || (info != null && info.isForceUpdate())) {
            ExitApp();
        }
    }

#No. 5520
#File: E:\bishe\1\AbstractUpdateListener.java
#Comment:
    /**
     * Exit the app here
     */

#Code:
    public abstract void ExitApp();

    /**
     * Get the update tips for the current language
     *
     * @param info update info
     * @return
     */
    public String getUpdateTips(UpdateInfo info) {
        String tip = null;
        Context context = getContext();
        if (context == null || info == null) {
            return tip;
        }

        Locale locale = context.getResources().getConfiguration().locale;
        String language = locale.getLanguage();
        Map<String, String> tips = info.getUpdateTips();
        if (tips == null) {
            return tip;
        }

        if (language != null && tips.containsKey(language)) {
            tip = tips.get(language);
        } else {
            tip = tips.get("default");
        }

        //Android textview not supporting line break.see http://stackoverflow.com/a/12422965/821624
        return tip.replace("\\n", "\n");
    }

#No. 5521
#File: E:\bishe\1\AbstractUpdaterTask.java
#Comment:
	/**
	 * Lancement de l'ensemble des opérations applicables.
	 * 
	 * @param ops
	 *            Liste des opérations
	 */

#Code:
	protected void run(ArrayList<ContentProviderOperation> ops)
			throws RemoteException, OperationApplicationException {
		long startTime;
		Log.d(name, "applyBatch for " + ops.size() + " elements");
		startTime = System.currentTimeMillis();
		resolver.applyBatch(getAuthority(), ops);
		Log.d(name, "doneBatch in " + (System.currentTimeMillis() - startTime)
				+ "ms");
	}

#No. 5522
#File: E:\bishe\1\AbstractUpdaterTask.java
#Comment:
	/**
	 * {@inheritDoc}
	 */

#Code:
	@Override
	protected void onInterrupted(Exception e) {
		Ln.d("Interrupting background task %s", this);
	}

#No. 5523
#File: E:\bishe\1\AbstractUpnpHandler.java
#Comment:
    /**
     * Get the multicast socket object to use for sending or receiving UPnP messages.
     *
     * @return the multicast socket
     * @throws IOException upon any IO problems
     */

#Code:
    protected MulticastSocket getNewMulticastSocket() throws IOException {
        final MulticastSocket ssdpSocket = new MulticastSocket(UPNP_PORT);
        ssdpSocket.setReuseAddress(true);
        final NetworkInterface networkInterface = NetworkInterface.getByInetAddress(InetAddress.getByName(this.getSimulatorHost()));
        if (networkInterface == null) {
            throw new IOException("Could not get network interface with host name: '" + this.getSimulatorHost() + "'.");
        }
        ssdpSocket.setNetworkInterface(networkInterface);

        // Force the use of an IPv4 address.
        final Enumeration<InetAddress> inetAddresses = networkInterface.getInetAddresses();
        while (inetAddresses.hasMoreElements()) {
            final InetAddress inetAddress = inetAddresses.nextElement();
            if (inetAddress instanceof Inet4Address) {
                ssdpSocket.setInterface(inetAddress);
                break;
            }
        }

        ssdpSocket.setTimeToLive(32);
        ssdpSocket.joinGroup(this.getUPNPAddress());
        return ssdpSocket;
    }

#No. 5524
#File: E:\bishe\1\AbstractUpnpHandler.java
#Comment:
    /**
     * Send a message over a socket as a broadcast.
     *
     * @param socket the socket
     * @param message the message
     * @throws IOException upon any IO problems
     */

#Code:
    protected void sendMessage(final DatagramSocket socket, final String message) throws IOException {
        socket.send(new DatagramPacket(message.getBytes(), message.length(), this.getUPNPAddress(), UPNP_PORT));
    }

#No. 5525
#File: E:\bishe\1\AbstractUpnpHandler.java
#Comment:
    /**
     * Send a message over a socket to a specific host and port.
     *
     * @param socket the socket
     * @param message the message
     * @param host the receiving host
     * @param port the receiving port
     * @throws IOException upon any IO problems
     */

#Code:
    protected void sendMessage(final DatagramSocket socket, final String message, final InetAddress host, final int port) throws IOException {
        socket.send(new DatagramPacket(message.getBytes(), message.length(), host, port));
    }

#No. 5526
#File: E:\bishe\1\AbstractUpsertPlugin.java
#Comment:
  /**
   * 生成根据参数array判断where条件的元素
   *
   * @param introspectedTable The metadata for database table
   * @return generated where condition element
   */

#Code:
  protected XmlElement checkArrayWhere(IntrospectedTable introspectedTable) {
    XmlElement where = new XmlElement("where");

    XmlElement include = new XmlElement("include");
    include.addAttribute(new Attribute("refid", IDENTIFIERS_ARRAY_CONDITIONS));

    where.addElement(include);

    return where;
  }

#No. 5527
#File: E:\bishe\1\AbstractUpsertPlugin.java
#Comment:
  /**
   * 创建根据传入的Array数组进行判断的sql语句
   *
   * @param introspectedTable The metadata for database table
   * @return generated xml element for check input array params
   */

#Code:
  protected XmlElement buildSqlClause(IntrospectedTable introspectedTable) {

    XmlElement sql = new XmlElement("sql");
    sql.addAttribute(new Attribute("id", IDENTIFIERS_ARRAY_CONDITIONS));

    XmlElement foreach = new XmlElement("foreach");
    foreach.addAttribute(new Attribute("collection", "array"));
    foreach.addAttribute(new Attribute("item", "item"));
    foreach.addAttribute(new Attribute("index", "index"));
    foreach.addAttribute(new Attribute("separator", " and "));

    StringBuilder sb = new StringBuilder();
    for (IntrospectedColumn introspectedColumn : introspectedTable.getAllColumns()) {
      XmlElement isEqualElement = new XmlElement("if");
      sb.setLength(0);
      sb.append("item == \'");
      sb.append(introspectedColumn.getJavaProperty());
      sb.append("\'");
      isEqualElement.addAttribute(new Attribute("test", sb.toString()));
      foreach.addElement(isEqualElement);

      sb.setLength(0);
      sb.append(MyBatis3FormattingUtilities.getAliasedEscapedColumnName(introspectedColumn));
      sb.append(" = ");
      sb.append(MyBatis3FormattingUtilities.getParameterClause(introspectedColumn, PROPERTY_PREFIX));

      isEqualElement.addElement(new TextElement(sb.toString()));
    }

    sql.addElement(foreach);
    return sql;
  }

#No. 5528
#File: E:\bishe\1\AbstractUrlContentReferenceHandler.java
#Comment:
    /**
     * Gets a URL from the {@link #getRemoteBaseUrl()} and the given relative path.
     * 
     * @param remoteRelativePath
     * @return the new URL string
     */

#Code:
    protected String createNewUrl(String remoteRelativePath)
    {
        return getRemoteBaseUrl() + remoteRelativePath;
    }

#No. 5529
#File: E:\bishe\1\AbstractUrlContentReferenceHandler.java
#Comment:
    /**
     * Builds the remote path for the given remote file name. The base
     * implementation simply returns the given filename indicating
     * all files should be saved in the 'root' of the {@link #getRemoteBaseUrl()}.
     * 
     * @param remoteFilename
     * @return the remote file path
     */

#Code:
    protected String getRemotePath(String remoteFilename)
    {
        // root is fine for now
        return remoteFilename;
    }

#No. 5530
#File: E:\bishe\1\AbstractUrlContentReferenceHandler.java
#Comment:
    /**
     * Gets the relative path from the remote URL string
     * 
     * @param remoteContentUrl
     * @return the relative path
     */

#Code:
    protected String getRelativePath(String remoteContentUrl)
    {
        if (remoteContentUrl == null)
        {
            return null;
        }
        return remoteContentUrl.replaceFirst(getRemoteBaseUrl(), "");
    }

#No. 5531
#File: E:\bishe\1\AbstractUrlContentReferenceHandler.java
#Comment:
    /**
     * Gets the extension from the remote URL string
     * 
     * @param remoteContentUrl
     * @return the extension of the remote URL string
     */

#Code:
    protected String getExtension(String remoteContentUrl)
    {
        if (remoteContentUrl == null)
        {
            return null;
        }
        String[] urlComponents = remoteContentUrl.split("\\.");
        return urlComponents[urlComponents.length-1];
    }

#No. 5532
#File: E:\bishe\1\AbstractUrlContentReferenceHandler.java
#Comment:
    /**
     * Gets the remote URL string from the given content reference.  The base implementation
     * simply returns the content reference's URI.  Other implementations
     * may need to perform some mapping to another protocol and/or path.
     * 
     * @param contentReference
     * @return the remote file URL
     */

#Code:
    protected String getRemoteFileUrl(ContentReference contentReference)
    {
        if (contentReference == null)
        {
            return null;
        }
        return contentReference.getUri();
    }

#No. 5533
#File: E:\bishe\1\AbstractUserEdit.java
#Comment:
    /**
     * A handler for a click on a cancel button.
     *
     * Return to a requested response page is usually a good action. Can be overridden if needed.
     */

#Code:
    protected void onCancelButtonSubmit() {
        resolveAndSetResponsePage();
    }

#No. 5534
#File: E:\bishe\1\AbstractUsernamePasswordAuthenticationHandler.java
#Comment:
	/**
	 * Method to return the PasswordEncoder to be used to encode passwords.
	 * 
	 * @return the PasswordEncoder associated with this class.
	 */

#Code:
	protected final PasswordEncoder getPasswordEncoder() {
		return this.passwordEncoder;
	}

#No. 5535
#File: E:\bishe\1\AbstractUsernamePasswordAuthenticationHandler.java
#Comment:
	/**
	 * Method to set the class to support.
	 * 
	 * @param classToSupport
	 *            the class we want this handler to support explicitly.
	 */

#Code:
	public final void setClassToSupport(final Class<?> classToSupport) {
		this.classToSupport = classToSupport;
	}

#No. 5536
#File: E:\bishe\1\AbstractUsernamePasswordAuthenticationHandler.java
#Comment:
	/**
	 * Method to set whether this handler will support subclasses of the
	 * supported class.
	 * 
	 * @param supportSubClasses
	 *            boolean of whether to support subclasses or not.
	 */

#Code:
	public final void setSupportSubClasses(final boolean supportSubClasses) {
		this.supportSubClasses = supportSubClasses;
	}

#No. 5537
#File: E:\bishe\1\AbstractUsernamePasswordAuthenticationHandler.java
#Comment:
	/**
	 * Sets the PasswordEncoder to be used with this class.
	 * 
	 * @param passwordEncoder
	 *            the PasswordEncoder to use when encoding passwords.
	 */

#Code:
	public final void setPasswordEncoder(final PasswordEncoder passwordEncoder) {
		this.passwordEncoder = passwordEncoder;
	}

#No. 5538
#File: E:\bishe\1\AbstractUsernamePasswordAuthenticationHandler.java
#Comment:
	/**
	 * @return true if the credentials are not null and the credentials class is
	 *         equal to the class defined in classToSupport.
	 */

#Code:
	public final boolean supports(final KnightCredential credential) {
		return credential != null
				&& (this.classToSupport.equals(credential.getClass()) || (this.classToSupport
						.isAssignableFrom(credential.getClass()))
						&& this.supportSubClasses);
	}

#No. 5539
#File: E:\bishe\1\AbstractUserScript.java
#Comment:
	/**
	 * creates the context object to execute the user supplied script on the WAL event. the script has full access to this object under the 'ctx' variable and
	 * can modify everything and influence the behaviour of the indexer or even modify the data to be indexed.
	 * @param event the WAL event for which to create the context object
	 * @return the context object for the script
	 */

#Code:
	public Map<String, Object> createContextObject(WalEvent event) {
		Map<String, Object> vars = new HashMap<>();
		vars.put("id", event.getKey());
		vars.put("doc", event.getData());
		vars.put("rev", event.getRev());
		vars.put("tick", event.getTick());

		WalEventType type = event.getType();
		vars.put("opid", type.getId());
		vars.put("opname", type.name());

		if (type == WalEventType.REPLICATION_MARKER_DOCUMENT || type == WalEventType.REPLICATION_MARKER_EDGE) {
			vars.put("operation", "UPDATE");
		}
		else if (type == WalEventType.REPLICATION_MARKER_REMOVE) {
			vars.put("operation", "DELETE");
		}
		else {
			vars.put("operation", "SKIP");
		}

		return vars;
	}

#No. 5540
#File: E:\bishe\1\AbstractValidatorTest.java
#Comment:
    /**
     * Runs the validator with the specified input string and verifies that the
     * result is valid.
     *
     * @param inputValue
     *            the input value to test
     */

#Code:
    protected final void assertThatInputIsValid(final String inputValue) {
        verifyInput(inputValue, true);
    }

#No. 5541
#File: E:\bishe\1\AbstractValidatorTest.java
#Comment:
    /**
     * Runs the validator with the specified input string and verifies that the
     * result is invalid.
     *
     * @param inputValue
     *            the input value to test
     */

#Code:
    protected final void assertThatInputIsInvalid(final String inputValue) {
        verifyInput(inputValue, false);
    }

#No. 5542
#File: E:\bishe\1\AbstractValidatorTest.java
#Comment:
    /**
     * Runs the validator with the specified input string and verifies the
     * result.
     *
     * @param inputValue
     *            the input value to test
     * @param expectedIsValid
     *            the expected validation result, <code>true</code> for success
     */

#Code:
    protected void verifyInput(final String inputValue, final boolean expectedIsValid) {
        Validator validator = createValidator();
        boolean actualIsValid;
        try {
            validator.check(inputValue);
            actualIsValid = true;
        }
        catch (FormValidation exception) {
            actualIsValid = false;
        }

        Assert.assertEquals("Wrong validation of input string " + inputValue, expectedIsValid, actualIsValid);
    }

#No. 5543
#File: E:\bishe\1\AbstractValueAxis3D.java
#Comment:
    /**
     * Returns the marker with the specified key, if there is one.
     * 
     * @param key  the key ({@code null} not permitted).
     * 
     * @return The marker (possibly {@code null}). 
     * 
     * @since 1.2
     */

#Code:
    @Override
    public ValueMarker getMarker(String key) {
        return this.valueMarkers.get(key);
    }

#No. 5544
#File: E:\bishe\1\AbstractValueAxis3D.java
#Comment:
    /**
     * Sets the marker for the specified key and sends a change event to 
     * all registered listeners.  If there is an existing marker it is replaced
     * (the axis will no longer listen for change events on the previous 
     * marker).
     * 
     * @param key  the key that identifies the marker ({@code null} not 
     *         permitted).
     * @param marker  the marker ({@code null} permitted).
     * 
     * @since 1.2
     */

#Code:
    public void setMarker(String key, ValueMarker marker) {
        ValueMarker existing = this.valueMarkers.get(key);
        if (existing != null) {
            existing.removeChangeListener(this);
        }
        this.valueMarkers.put(key, marker);
        marker.addChangeListener(this);
        fireChangeEvent(false);
    } 

#No. 5545
#File: E:\bishe\1\AbstractValueAxis3D.java
#Comment:
    /**
     * Returns a new map containing the markers assigned to this axis.
     * 
     * @return A map. 
     * 
     * @since 1.2
     */

#Code:
    public Map<String, ValueMarker> getMarkers() {
        return new LinkedHashMap<String, ValueMarker>(this.valueMarkers);    
    }

#No. 5546
#File: E:\bishe\1\AbstractValueAxis3D.java
#Comment:
    /**
     * Receives a {@link ChartElementVisitor}.  This method is part of a general
     * mechanism for traversing the chart structure and performing operations
     * on each element in the chart.  You will not normally call this method
     * directly.
     * 
     * @param visitor  the visitor ({@code null} not permitted).
     * 
     * @since 1.2
     */

#Code:
    @Override
    public void receive(ChartElementVisitor visitor) {
        for (ValueMarker marker : this.valueMarkers.values()) {
            marker.receive(visitor);
        }
        visitor.visit(this);
    }

#No. 5547
#File: E:\bishe\1\AbstractValueAxis3D.java
#Comment:
    /**
     * Provides serialization support.
     *
     * @param stream  the output stream.
     *
     * @throws IOException  if there is an I/O error.
     */

#Code:
    private void writeObject(ObjectOutputStream stream) throws IOException {
        stream.defaultWriteObject();
        SerialUtils.writePaint(this.tickMarkPaint, stream);
        SerialUtils.writeStroke(this.tickMarkStroke, stream);
    }

#No. 5548
#File: E:\bishe\1\AbstractValueAxis3D.java
#Comment:
    /**
     * Provides serialization support.
     *
     * @param stream  the input stream.
     *
     * @throws IOException  if there is an I/O error.
     * @throws ClassNotFoundException  if there is a classpath problem.
     */

#Code:
    private void readObject(ObjectInputStream stream)
        throws IOException, ClassNotFoundException {
        stream.defaultReadObject();
        this.tickMarkPaint = SerialUtils.readPaint(stream);
        this.tickMarkStroke = SerialUtils.readStroke(stream);
    }

#No. 5549
#File: E:\bishe\1\AbstractValueContainer.java
#Comment:
    /**
     * Whether all the {@link Key}s in this container should be registered
     * before they can be offered/retrieved.
     *
     * @return requires key registration
     */

#Code:
    default boolean requiresKeyRegistration() {
        return false;
    }

#No. 5550
#File: E:\bishe\1\AbstractValueContainer.java
#Comment:
    /**
     * Gets the raw list with all the custom value containers,
     * this may be null if custom data isn't supported.
     *
     * @return The raw value containers
     */

#Code:
    @Nullable
    default Map<Class<?>, H> getRawAdditionalContainers() {
        return null;
    }

#No. 5551
#File: E:\bishe\1\AbstractValueContainer.java
#Comment:
    /**
     * Gets the internal map that is used to hold the value's by their key.
     *
     * @return the value by key map
     */

#Code:
    Map<Key<?>, KeyRegistration> getRawValueMap();

    @SuppressWarnings("unchecked")
    @Nullable
    default <V extends BaseValue<E>, E> KeyRegistration<V, E> getKeyRegistration(Key<? extends BaseValue<E>> key) {
        return getRawValueMap().get(key);
    }

#No. 5552
#File: E:\bishe\1\AbstractValueHolder.java
#Comment:
    /**
     * Implementation of equals that returns true only if:
     * <ul>
     * <li>other object is of the same class</li>
     * <li>values held in this and other holder are equal (via equals() method)</li>
     * </ul>
     *
     * @param obj object to compare
     * @return true if both conditions are met
     */

#Code:
    @Override
    public boolean equals(Object obj) {
        if (obj != null && obj.getClass() == this.getClass()) {

            Object v1 = getValue();
            Object v2 = ((ValueHolder) obj).getValue();

            if (v1 == null) {
                return v2 == null;
            }
            if (v2 != null) {
                return v1.equals(v2);
            }
        }
        return false;
    }

#No. 5553
#File: E:\bishe\1\AbstractValueHolder.java
#Comment:
    /**
     * Calculate hash code using formula:
     * <pre>
     * hashcode(holder) := hashcode(holder.getClass()) XOR hashcode(holder.getValue())
     * </pre>
     *
     * @return hash code
     */

#Code:
    @Override
    public int hashCode() {
        Object v = getValue();
        int vhash = v != null ? v.hashCode() : 1;
        return this.getClass().hashCode() ^ vhash;
    }

#No. 5554
#File: E:\bishe\1\AbstractValueHolder.java
#Comment:
    /**
     * Compares two holders using algorithm:
     * <ul>
     * <li>is value held comparable? (checked using {@link AbstractHolder#isComparable() } method</li>
     * <li>if not return 0 (objects are equal, cos we don't know how to compare them)</li>
     * <li>if comparable, do a null-safe comparison using {@link Comparable#compareTo(java.lang.Object)} method</li>
     * </ul>
     */

#Code:
    @Override
    @SuppressWarnings("unchecked")
    public int compareTo(ValueHolder o) {
        if (isComparable()) {
            Comparable<Object> v1 = (Comparable<Object>) this.getValue();
            Comparable<Object> v2 = (Comparable<Object>) o.getValue();

            if (v1 != null) {
                return v2 != null ? v1.compareTo(v2) : 1;
            } else {
                return v2 != null ? -1 : 0;
            }
        }

        return 0;
    }

#No. 5555
#File: E:\bishe\1\AbstractValueHolder.java
#Comment:
    /**
     * Returns String representation of held object (by using toString).
     *
     * @return toString value or null if none value held
     */

#Code:
    @Override
    public String getString() {
        Object value = getValue();
        return value != null ? value.toString() : null;
    }

#No. 5556
#File: E:\bishe\1\AbstractValueHolder.java
#Comment:
    /**
     * Returns int value if holder is capable of doing it, otherwise
     * UnsupportedOperationException is thrown.
     *
     * @return int value
     */

#Code:
    @Override
    public int intValue() {
        throw prepareUnexpectedUsageException("int");
    }

#No. 5557
#File: E:\bishe\1\AbstractValueHolder.java
#Comment:
    /**
     * Returns long value if holder is capable of doing it, otherwise
     * UnsupportedOperationException is thrown.
     *
     * @return long value
     */

#Code:
    @Override
    public long longValue() {
        throw prepareUnexpectedUsageException("long");
    }

#No. 5558
#File: E:\bishe\1\AbstractValueHolder.java
#Comment:
    /**
     * Returns double value if holder is capable of doing it, otherwise
     * UnsupportedOperationException is thrown.
     *
     * @return double value
     */

#Code:
    @Override
    public double doubleValue() {
        throw prepareUnexpectedUsageException("double");
    }

#No. 5559
#File: E:\bishe\1\AbstractValueHolder.java
#Comment:
    /**
     * Returns boolean value if holder is capable of doing it, otherwise
     * UnsupportedOperationException is thrown.
     *
     * @return boolean value
     */

#Code:
    @Override
    public boolean booleanValue() {
        throw prepareUnexpectedUsageException("boolean");
    }

#No. 5560
#File: E:\bishe\1\AbstractValueHolder.java
#Comment:
    /**
     * Returns Integer value if holder is capable of doing it, otherwise
     * UnsupportedOperationException is thrown.
     *
     * @return Integer value
     */

#Code:
    @Override
    public Integer getInteger() {
        throw prepareUnexpectedUsageException("Integer");
    }

#No. 5561
#File: E:\bishe\1\AbstractValueHolder.java
#Comment:
    /**
     * Returns Long value if holder is capable of doing it, otherwise
     * UnsupportedOperationException is thrown.
     *
     * @return Long value
     */

#Code:
    @Override
    public Long getLong() {
        throw prepareUnexpectedUsageException("Long");
    }

#No. 5562
#File: E:\bishe\1\AbstractValueHolder.java
#Comment:
    /**
     * Returns Double value if holder is capable of doing it, otherwise
     * UnsupportedOperationException is thrown.
     *
     * @return Double value
     */

#Code:
    @Override
    public Double getDouble() {
        throw prepareUnexpectedUsageException("Double");
    }

#No. 5563
#File: E:\bishe\1\AbstractValueHolder.java
#Comment:
    /**
     * Returns Boolean value if holder is capable of doing it, otherwise
     * UnsupportedOperationException is thrown.
     *
     * @return Boolean value
     */

#Code:
    @Override
    public Boolean getBoolean() {
        throw prepareUnexpectedUsageException("Boolean");
    }

#No. 5564
#File: E:\bishe\1\AbstractValueHolder.java
#Comment:
    /**
     * Returns BigDecimal value if holder is capable of doing it, otherwise
     * UnsupportedOperationException is thrown.
     *
     * @return BigDecimal value
     */

#Code:
    @Override
    public BigDecimal getBigDecimal() {
        throw prepareUnexpectedUsageException("BigDecimal");
    }

#No. 5565
#File: E:\bishe\1\AbstractValueHolder.java
#Comment:
    /**
     * Returns Date value if holder is capable of doing it, otherwise
     * UnsupportedOperationException is thrown.
     *
     * @return Date value
     */

#Code:
    @Override
    public Date getDate() {
        throw prepareUnexpectedUsageException("Date");
    }

#No. 5566
#File: E:\bishe\1\AbstractValueNamingDetected.java
#Comment:
/**
 * Feature combination
 * <ul>
 * <li>Abstract type and accessor name detection
 * <li>Generated builder naming customization
 * </ul>
 */

#Code:
@Value.Immutable(copy = true)
@Value.Style(
    visibility = ImplementationVisibility.PUBLIC,
    get = {"extract*", "collect*"},
    typeAbstract = "Abstract*",
    typeImmutable = "*",
    build = "build*",
    init = "using*",
    add = "with*Appended",
    builder = "newBuilder")
abstract class AbstractValueNamingDetected {

  abstract int extractVal();

  abstract Set<String> collectStr();

  void use() {
    ValueNamingDetected.newBuilder()
        .usingVal(1)
        .withStrAppended("Appended!")
        .buildValueNamingDetected();
  }
}
}

#No. 5567
#File: E:\bishe\1\AbstractVcsCoordinator.java
#Comment:
    /**
     * @param name The name of the vcs repository. Either svn or jetbrains.git
     * @return The first configured vcs repository with the fiven name
     * @throws IllegalArgumentException If no vcs configuration found with the given name
     */

#Code:
    protected VcsRoot getFirstVcsRoot(String name) {
        AgentRunningBuild build = runner.getBuild();
        for (VcsRootEntry entry : build.getVcsRootEntries()) {
            VcsRoot root = entry.getVcsRoot();
            if (name.equals(root.getVcsName())) {
                return root;
            }
        }
        throw new IllegalStateException("Cannot operate release management on a build with no Subversion " +
                "VCS roots.");
    }

#No. 5568
#File: E:\bishe\1\AbstractVectorGraphics.java
#Comment:
    /**
     * Creates a polyline/polygon shape from a set of points.
     * Needs a bias!
     * 
     * @param xPoints X coordinates of the polyline.
     * @param yPoints Y coordinates of the polyline.
     * @param nPoints number of points of the polyline.
     * @param close is shape closed
     */

#Code:
    protected Shape createShape(int[] xPoints, int[] yPoints, int nPoints,
            boolean close, boolean biased) {
        
        float offset = biased ? (float)bias : 0.0f;
        GeneralPath path = new GeneralPath(GeneralPath.WIND_EVEN_ODD);
        if (nPoints > 0) {
            path.moveTo(xPoints[0] + offset, yPoints[0] + offset);
            int lastX = xPoints[0];
            int lastY = yPoints[0];
            if (close && (Math.abs(xPoints[nPoints - 1] - lastX) < 1)
                    && (Math.abs(yPoints[nPoints - 1] - lastY) < 1)) {
                nPoints--;
            }
            for (int i = 1; i < nPoints; i++) {
                if ((Math.abs(xPoints[i] - lastX) > 1)
                        || (Math.abs(yPoints[i] - lastY) > 1)) {
                    path.lineTo(xPoints[i] + offset, yPoints[i] + offset);
                    lastX = xPoints[i];
                    lastY = yPoints[i];
                }
            }
            if (close)
                path.closePath();
        }
        return path;
    }

#No. 5569
#File: E:\bishe\1\AbstractVectorGraphics.java
#Comment:
    /**
     * Checks whether or not the specified <code>Shape</code> intersects
     * the specified {@link Rectangle}, which is in device
     * space.
     *
     * @param rect the area in device space to check for a hit
     * @param s the <code>Shape</code> to check for a hit
     * @param onStroke flag used to choose between testing the stroked or the filled shape.
     * @see com.google.code.appengine.awt.Graphics2D#hit(Rectangle, Shape, boolean)
     */

#Code:
    public boolean hit(Rectangle rect, Shape s, boolean onStroke) {
        if (onStroke && getStroke() != null) {
            s = getStroke().createStrokedShape(s);
        }

        if (getTransform() != null) {
            s = getTransform().createTransformedShape(s);
        }

        Area area = new Area(s);
        if (getClip() != null) {
            area.intersect(new Area(getClip()));
        }

        return area.intersects(rect);
    }

#No. 5570
#File: E:\bishe\1\AbstractVectorGraphicsIO.java
#Comment:
    /*
     * ================================================================================ |
     * 5. Drawing Methods
     * ================================================================================
     */

#Code:

    /* 5.3. Images */
    public boolean drawImage(Image image, int x, int y, ImageObserver observer) {
        int imageWidth = image.getWidth(observer);
        int imageHeight = image.getHeight(observer);
        return drawImage(image, x, y, x + imageWidth, y + imageHeight, 0, 0,
                imageWidth, imageHeight, null, observer);
    }

#No. 5571
#File: E:\bishe\1\AbstractVectorGraphicsIO.java
#Comment:
    /*
     * // first use the original orientation int clippingWidth = Math.abs(sx2 -
     * sx1); int clippingHeight = Math.abs(sy2 - sy1); int sulX = Math.min(sx1,
     * sx2); int sulY = Math.min(sy1, sy2); Image background = null; if (bgColor !=
     * null) { // Draw the image on the background color // maybe we could crop
     * it and fill the transparent pixels in one go // by means of a filter.
     * background = new BufferedImage(clippingWidth, clippingHeight,
     * BufferedImage.TYPE_INT_ARGB); Graphics bgGfx = background.getGraphics();
     * bgGfx.drawImage(image, 0, 0, clippingWidth, clippingWidth, sulX, sulY,
     * sulX+clippingWidth, sulY+clippingHeight, getPrintColor(bgColor),
     * observer); } else { // crop the source image ImageFilter crop = new
     * CropImageFilter(sulX, sulY, clippingWidth, clippingHeight); background =
     * Toolkit.getDefaultToolkit().createImage(new
     * FilteredImageSource(image.getSource(), crop)); MediaTracker mediaTracker =
     * new MediaTracker(new Panel()); mediaTracker.addImage(background, 0); try {
     * mediaTracker.waitForAll(); } catch (InterruptedException e) {
     * handleException(e); } } // now flip the image if necessary boolean
     * flipHorizontal = (dx2<dx1) ^ (sx2<sx1); // src flipped and not dest
     * flipped or vice versa boolean flipVertical = (dy2<dy1) ^ (sy2<sy1); //
     * <=> source flipped XOR dest flipped int destWidth = Math.abs(dx2-dx1);
     * int destHeight = Math.abs(dy2-dy1); try { return writeImage(background,
     * flipHorizontal ? dx2 : dx1, flipVertical ? dy2 : dy1, flipHorizontal ?
     * -destWidth : destWidth, flipVertical ? -destHeight : destHeight, (bgColor ==
     * null), observer); } catch (IOException e) { return false; } }
     */

#Code:
    /**
     * Draws a rendered image using a transform.
     *
     * @param image to be drawn
     * @param xform transform to be used on the image
     */
    public void drawRenderedImage(RenderedImage image, AffineTransform xform) {
        try {
            writeImage(image, xform, null);
        } catch (Exception e) {
            handleException(e);
        }
    }

#No. 5572
#File: E:\bishe\1\AbstractVectorGraphicsIO.java
#Comment:
    /**
     * Clears rectangle by painting it with the backgroundColor.
     *
     * @param x rectangle to be cleared.
     * @param y rectangle to be cleared.
     * @param width rectangle to be cleared.
     * @param height rectangle to be cleared.
     */

#Code:
    public void clearRect(double x, double y, double width, double height) {
        Paint temp = getPaint();
        setPaint(getBackground());
        fillRect(x, y, width, height);
        setPaint(temp);
    }

#No. 5573
#File: E:\bishe\1\AbstractVectorGraphicsIO.java
#Comment:
    /**
     * Draws the string at (x, y). If TEXT_AS_SHAPES is set
     * {@link #drawGlyphVector(com.google.code.appengine.awt.font.GlyphVector, float, float)} is used, otherwise
     * {@link #writeString(String, double, double)} for a more direct output of the string.
     *
     * @param string
     * @param x
     * @param y
     */

#Code:
    public void drawString(String string, double x, double y) {
        // something to draw?
        if (string == null || string.equals("")) {
            return;
        }

        // draw strings directly?
        if (isProperty(TEXT_AS_SHAPES)) {
        	
        	Font font = getFont();
        	
            // NOTE, see FVG-199, createGlyphVector does not seem to create the proper glyphcodes
            // for either ZapfDingbats or Symbol. We use our own encoding which seems to work...
        	String fontName = font.getName();
//        	if (fontName.equals("Symbol") || fontName.equals("ZapfDingbats")) {
//        		string = FontEncoder.getEncodedString(string, fontName);
//        		// use a standard font, not Symbol.
//        		font = new Font("Serif", font.getStyle(), font.getSize());
//        	}
        	
        	// create glyph
            GlyphVector gv = font.createGlyphVector(getFontRenderContext(), string);

            // draw it
            drawGlyphVector(gv, (float) x, (float) y);
        } else {
            // write string directly
            try {
                writeString(string, x, y);
            } catch (IOException e) {
                handleException(e);
            }
        }
    }

#No. 5574
#File: E:\bishe\1\AbstractVectorGraphicsIO.java
#Comment:
    /**
     * Use the transformation of the glyphvector and draw it
     *
     * @param g
     * @param x
     * @param y
     */

#Code:
    public void drawGlyphVector(GlyphVector g, float x, float y) {
    	Graphics2DUtil.drawGlyphVector(this, g, x, y);
    }

#No. 5575
#File: E:\bishe\1\AbstractVectorGraphicsIO.java
#Comment:
    /*
     * ================================================================================ |
     * 6. Transformations
     * ================================================================================
     */

#Code:
    /**
     * Get the current transform.
     *
     * @return current transform
     */
    public AffineTransform getTransform() {
        return new AffineTransform(currentTransform);
    }

#No. 5576
#File: E:\bishe\1\AbstractVectorGraphicsIO.java
#Comment:
    /**
     * Set the current transform. Calls writeSetTransform(Transform).
     *
     * @param transform to be set
     */

#Code:
    public void setTransform(AffineTransform transform) {
        // Fix for FREEHEP-569
    	oldTransform.setTransform(currentTransform);
        currentTransform.setTransform(transform);
        try {
            writeSetTransform(transform);
        } catch (IOException e) {
            handleException(e);
        }
    }

#No. 5577
#File: E:\bishe\1\AbstractVectorGraphicsIO.java
#Comment:
    /**
     * Transforms the current transform. Calls writeTransform(Transform)
     *
     * @param transform to be applied
     */

#Code:
    public void transform(AffineTransform transform) {
        currentTransform.concatenate(transform);
        try {
            writeTransform(transform);
        } catch (IOException e) {
            handleException(e);
        }
    }

#No. 5578
#File: E:\bishe\1\AbstractVectorGraphicsIO.java
#Comment:
    /**
     * Translates the current transform. Calls writeTransform(Transform)
     *
     * @param x amount by which to translate
     * @param y amount by which to translate
     */

#Code:
    public void translate(double x, double y) {
        currentTransform.translate(x, y);
        try {
            writeTransform(new AffineTransform(1, 0, 0, 1, x, y));
        } catch (IOException e) {
            handleException(e);
        }
    }

#No. 5579
#File: E:\bishe\1\AbstractVectorGraphicsIO.java
#Comment:
    /**
     * Rotate the current transform over the Z-axis. Calls
     * writeTransform(Transform). Rotating with a positive angle theta rotates
     * points on the positive x axis toward the positive y axis.
     *
     * @param theta radians over which to rotate
     */

#Code:
    public void rotate(double theta) {
        currentTransform.rotate(theta);
        try {
            writeTransform(new AffineTransform(Math.cos(theta),
                    Math.sin(theta), -Math.sin(theta), Math.cos(theta), 0, 0));
        } catch (IOException e) {
            handleException(e);
        }
    }

#No. 5580
#File: E:\bishe\1\AbstractVectorGraphicsIO.java
#Comment:
    /**
     * Scales the current transform. Calls writeTransform(Transform).
     *
     * @param sx amount used for scaling
     * @param sy amount used for scaling
     */

#Code:
    public void scale(double sx, double sy) {
        currentTransform.scale(sx, sy);
        try {
            writeTransform(new AffineTransform(sx, 0, 0, sy, 0, 0));
        } catch (IOException e) {
            handleException(e);
        }
    }

#No. 5581
#File: E:\bishe\1\AbstractVectorGraphicsIO.java
#Comment:
    /**
     * Shears the current transform. Calls writeTransform(Transform).
     *
     * @param shx amount for shearing
     * @param shy amount for shearing
     */

#Code:
    public void shear(double shx, double shy) {
        currentTransform.shear(shx, shy);
        try {
            writeTransform(new AffineTransform(1, shy, shx, 1, 0, 0));
        } catch (IOException e) {
            handleException(e);
        }
    }

#No. 5582
#File: E:\bishe\1\AbstractVectorGraphicsIO.java
#Comment:
    /**
     * Clears any existing transformation and sets the a new one.
     * The default implementation calls writeTransform using the
     * inverted affine transform to calculate it.
s     *
     * @param transform to be written
     */

#Code:
    protected void writeSetTransform(AffineTransform transform) throws IOException {
    	try {
	    	AffineTransform deltaTransform = new AffineTransform(transform);
	        deltaTransform.concatenate(oldTransform.createInverse());
	    	writeTransform(deltaTransform);
    	} catch (NoninvertibleTransformException e) {
    		// ignored...
    		System.err.println("Warning: (ignored) Could not invert matrix: "+oldTransform);
    	}
    }

#No. 5583
#File: E:\bishe\1\AbstractVectorGraphicsIO.java
#Comment:
    /*
     * ================================================================================ |
     * 7. Clipping
     * ================================================================================
     */

#Code:

    /**
     * Gets the current clip in form of a Shape (Rectangle).
     *
     * @return current clip
     */
    public Shape getClip() {
        return (userClip != null) ? new Area(untransformShape(userClip)) : null;
    }

#No. 5584
#File: E:\bishe\1\AbstractVectorGraphicsIO.java
#Comment:
    /**
     * Gets the current clip in form of a Rectangle.
     *
     * @return current clip
     */

#Code:
    public Rectangle getClipBounds() {
        Shape clip = getClip();
        return (clip != null) ? getClip().getBounds() : null;
    }

#No. 5585
#File: E:\bishe\1\AbstractVectorGraphicsIO.java
#Comment:
    /**
     * Gets the current clip in form of a Rectangle.
     *
     * @return current clip
     */

#Code:
    public Rectangle getClipBounds(Rectangle r) {
        Rectangle bounds = getClipBounds();
        if (bounds != null)
            r.setBounds(bounds);
        return r;
    }

#No. 5586
#File: E:\bishe\1\AbstractVectorGraphicsIO.java
#Comment:
    /**
     * Clips rectangle. Calls clip(Rectangle).
     *
     * @param x rectangle for clipping
     * @param y rectangle for clipping
     * @param width rectangle for clipping
     * @param height rectangle for clipping
     */

#Code:
    public void clipRect(int x, int y, int width, int height) {
        clip(new Rectangle(x, y, width, height));
    }

#No. 5587
#File: E:\bishe\1\AbstractVectorGraphicsIO.java
#Comment:
    /**
     * Clips rectangle. Calls clip(Rectangle2D).
     *
     * @param x rectangle for clipping
     * @param y rectangle for clipping
     * @param width rectangle for clipping
     * @param height rectangle for clipping
     */

#Code:
    public void clipRect(double x, double y, double width, double height) {
        clip(new Rectangle2D.Double(x, y, width, height));
    }

#No. 5588
#File: E:\bishe\1\AbstractVectorGraphicsIO.java
#Comment:
    /**
     * Clips rectangle. Calls clip(Rectangle).
     *
     * @param x rectangle for clipping
     * @param y rectangle for clipping
     * @param width rectangle for clipping
     * @param height rectangle for clipping
     */

#Code:
    public void setClip(int x, int y, int width, int height) {
        setClip(new Rectangle(x, y, width, height));
    }

#No. 5589
#File: E:\bishe\1\AbstractVectorGraphicsIO.java
#Comment:
    /**
     * Clips rectangle. Calls clip(Rectangle2D).
     *
     * @param x rectangle for clipping
     * @param y rectangle for clipping
     * @param width rectangle for clipping
     * @param height rectangle for clipping
     */

#Code:
    public void setClip(double x, double y, double width, double height) {
        setClip(new Rectangle2D.Double(x, y, width, height));
    }

#No. 5590
#File: E:\bishe\1\AbstractVectorGraphicsIO.java
#Comment:
    /**
     * Clips shape. Clears userClip and calls clip(Shape).
     *
     * @param s used for clipping
     */

#Code:
    public void setClip(Shape s) {

        Shape ts = transformShape(s);
        userClip = (ts != null) ? new Area(ts) : null;

        try {
            writeSetClip(s);
        } catch (IOException e) {
            handleException(e);
        }
    }

#No. 5591
#File: E:\bishe\1\AbstractVectorGraphicsIO.java
#Comment:
    /**
     * Clips using given shape. Dispatches to writeClip(Rectangle),
     * writeClip(Rectangle2D) or writeClip(Shape).
     *
     * @param s used for clipping
     */

#Code:
    public void clip(Shape s) {
        Shape ts = transformShape(s);
        if (userClip != null) {
            if (ts != null) {
                userClip.intersect(new Area(ts));
            } else {
                userClip = null;
            }
        } else {
            userClip = (ts != null) ? new Area(ts) : null;
        }

        try {
	    writeClip(s);
        } catch (IOException e) {
            handleException(e);
        }
    }

#No. 5592
#File: E:\bishe\1\AbstractVectorGraphicsIO.java
#Comment:
    /*
     * ================================================================================ |
     * 8. Graphics State
     * ================================================================================
     */

#Code:
    /* 8.1. stroke/linewidth */
    /**
     * Get the current stroke.
     *
     * @return current stroke
     */
    public Stroke getStroke() {
        return currentStroke;
    }

#No. 5593
#File: E:\bishe\1\AbstractVectorGraphicsIO.java
#Comment:
    /**
     * Sets the current stroke. Calls writeStroke if stroke is unequal to the
     * current stroke.
     *
     * @param stroke to be set
     */

#Code:
    public void setStroke(Stroke stroke) {
        if (stroke.equals(currentStroke)) {
            return;
        }
        try {
            writeStroke(stroke);
        } catch (IOException e) {
            handleException(e);
        }
        currentStroke = stroke;
    }

#No. 5594
#File: E:\bishe\1\AbstractVectorGraphicsIO.java
#Comment:
    /**
     * Writes out the width of the stroke.
     *
     * @param width of the stroke
     */

#Code:
    protected void writeWidth(float width) throws IOException {
        writeWarning(getClass() + ": writeWidth() not implemented.");
    }

#No. 5595
#File: E:\bishe\1\AbstractVectorGraphicsIO.java
#Comment:
    /**
     * Writes out the cap of the stroke.
     *
     * @param cap of the stroke
     */

#Code:
    protected void writeCap(int cap) throws IOException {
        writeWarning(getClass() + ": writeCap() not implemented.");
    }

#No. 5596
#File: E:\bishe\1\AbstractVectorGraphicsIO.java
#Comment:
    /**
     * Writes out the join of the stroke.
     *
     * @param join of the stroke
     */

#Code:
    protected void writeJoin(int join) throws IOException {
        writeWarning(getClass() + ": writeJoin() not implemented.");
    }

#No. 5597
#File: E:\bishe\1\AbstractVectorGraphicsIO.java
#Comment:
    /**
     * Writes out the miter limit of the stroke.
     *
     * @param limit miter limit of the stroke
     */

#Code:
    protected void writeMiterLimit(float limit) throws IOException {
        writeWarning(getClass() + ": writeMiterLimit() not implemented.");
    }

#No. 5598
#File: E:\bishe\1\AbstractVectorGraphicsIO.java
#Comment:
    /**
     * Writes out the dash of the stroke.
     *
     * @param dash dash pattern, empty array is solid line
     * @param phase of the dash pattern
     */

#Code:
    protected void writeDash(float[] dash, float phase) throws IOException {
        // for backward compatibility
        double[] dd = new double[dash.length];
        for (int i = 0; i < dash.length; i++) {
            dd[i] = dash[i];
        }
        writeDash(dd, (double)phase);
    }

#No. 5599
#File: E:\bishe\1\AbstractVectorGraphicsIO.java
#Comment:
    /**
     * Writes out the dash of the stroke.

     * @deprecated use writeDash(float[], float)
     * @param dash dash pattern, empty array is solid line
     * @param phase of the dash pattern
     */

#Code:
    protected void writeDash(double[] dash, double phase) throws IOException {
        writeWarning(getClass() + ": writeDash() not implemented.");
    }

#No. 5600
#File: E:\bishe\1\AbstractVectorGraphicsIO.java
#Comment:
    /**
     * Sets the current paint. Dispatches to writePaint(Color),
     * writePaint(GradientPaint), writePaint(TexturePaint paint) or
     * writePaint(Paint). In the case paint is a Color the current color is also
     * changed.
     *
     * @param paint to be set
     */

#Code:
    public void setPaint(Paint paint) {
    	if (paint == null) return;
    	
        if (paint.equals(getPaint()))
            return;

        try {
            if (paint instanceof Color) {
                setColor((Color) paint);
            } else if (paint instanceof GradientPaint) {
                super.setPaint(paint);
                writePaint((GradientPaint) paint);
            } else if (paint instanceof TexturePaint) {
                super.setPaint(paint);
                writePaint((TexturePaint) paint);
            } else {
                super.setPaint(paint);
                writePaint(paint);
            }
        } catch (IOException e) {
            handleException(e);
        }
    }

#No. 5601
#File: E:\bishe\1\AbstractVectorGraphicsIO.java
#Comment:
    /**
     * Gets the current font render context. This returns an standard
     * FontRenderContext with anti-aliasing and uses
     * fractional metrics.
     *
     * @return current font render context
     */

#Code:
    public FontRenderContext getFontRenderContext() {
        // NOTE: not sure?
        // Fixed for VG-285
        return new FontRenderContext(new AffineTransform(1, 0, 0, 1, 0, 0),
                true, true);
    }

#No. 5602
#File: E:\bishe\1\AbstractVectorGraphicsIO.java
#Comment:
    /**
     * Gets the fontmetrics.
     *
     * @deprecated
     * @param font to be used for retrieving fontmetrics
     * @return fontmetrics for given font
     */

#Code:
    public FontMetrics getFontMetrics(Font font) {
        return Toolkit.getDefaultToolkit().getFontMetrics(font);
    }

#No. 5603
#File: E:\bishe\1\AbstractVectorGraphicsIO.java
#Comment:
    /**
     * Gets a copy of the rendering hints.
     *
     * @return clone of table of rendering hints.
     */

#Code:
    public RenderingHints getRenderingHints() {
        return (RenderingHints) hints.clone();
    }

#No. 5604
#File: E:\bishe\1\AbstractVectorGraphicsIO.java
#Comment:
    /**
     * Adds to table of rendering hints.
     *
     * @param hints table to be added
     */

#Code:
    public void addRenderingHints(Map hints) {
        hints.putAll(hints);
    }

#No. 5605
#File: E:\bishe\1\AbstractVectorGraphicsIO.java
#Comment:
    /**
     * Sets table of rendering hints.
     *
     * @param hints table to be set
     */

#Code:
    public void setRenderingHints(Map hints) {
        this.hints.clear();
        if (hints instanceof RenderingHints) {
        	RenderingHints renderingHints = (RenderingHints)hints;
        	this.hints.putAll((Map)renderingHints.clone());
        } else {
        	this.hints.putAll(hints);
        }
    }

#No. 5606
#File: E:\bishe\1\AbstractVectorGraphicsIO.java
#Comment:
    /**
     * Gets a given rendering hint.
     *
     * @param key hint key
     * @return hint associated to key
     */

#Code:
    public Object getRenderingHint(RenderingHints.Key key) {
        return hints.get(key);
    }

#No. 5607
#File: E:\bishe\1\AbstractVectorGraphicsIO.java
#Comment:
    /**
     * Sets a given rendering hint.
     *
     * @param key hint key
     * @param hint to be associated with key
     */

#Code:
    public void setRenderingHint(RenderingHints.Key key, Object hint) {
        // extra protection, failed on under MacOS X 10.2.6, jdk 1.4.1_01-39/14
        if ((key == null) || (hint == null))
            return;
        hints.put(key, hint);
    }

#No. 5608
#File: E:\bishe\1\AbstractVectorGraphicsIO.java
#Comment:
    /**
     * Sets the current font.
     *
     * @param font to be set
     */

#Code:
    public void setFont(Font font) {
    	if (font == null) return;
    	
        // FIXME: maybe add delayed setting
        super.setFont(font);

        // write the font
        try {
            writeFont(font);
        } catch (IOException e) {
            handleException(e);
        }
    }

#No. 5609
#File: E:\bishe\1\AbstractVectorGraphicsIO.java
#Comment:
    /*
	 * ================================================================================ |
	 * 9. Auxiliary
	 * ================================================================================
	 */

#Code:
    /**
     * Gets current composite.
     *
     * @return current composite
     */
    public Composite getComposite() {
        return currentComposite;
    }

#No. 5610
#File: E:\bishe\1\AbstractVectorGraphicsIO.java
#Comment:
    /**
     * Sets current composite.
     *
     * @param composite to be set
     */

#Code:
    public void setComposite(Composite composite) {
        currentComposite = composite;
    }

#No. 5611
#File: E:\bishe\1\AbstractVectorGraphicsIO.java
#Comment:
    /**
     * Handles an exception which has been caught. Dispatches exception to
     * writeWarning for UnsupportedOperationExceptions and writeError for others
     *
     * @param exception to be handled
     */

#Code:
    protected void handleException(Exception exception) {
        if (exception instanceof UnsupportedOperationException) {
            writeWarning(exception);
        } else {
            writeError(exception);
        }
    }

#No. 5612
#File: E:\bishe\1\AbstractVectorGraphicsIO.java
#Comment:
    /**
     * Writes out a warning, by default to System.err.
     *
     * @param exception warning to be written
     */

#Code:
    protected void writeWarning(Exception exception) {
        writeWarning(exception.getMessage());
    }

#No. 5613
#File: E:\bishe\1\AbstractVectorGraphicsIO.java
#Comment:
    /**
     * Writes out a warning, by default to System.err.
     *
     * @param warning to be written
     */

#Code:
    protected void writeWarning(String warning) {
        if (isProperty(EMIT_WARNINGS)) {
            System.err.println(warning);
        }
    }

#No. 5614
#File: E:\bishe\1\AbstractVectorGraphicsIO.java
#Comment:
    /**
     * Writes out an error, by default the stack trace is printed.
     *
     * @param exception error to be reported
     */

#Code:
    protected void writeError(Exception exception) {
        throw new RuntimeException(exception);
        // FIXME decide what we should do
        /*
         * if (isProperty(EMIT_ERRORS)) { System.err.println(exception);
         * exception.printStackTrace(System.err); }
         */
    }

#No. 5615
#File: E:\bishe\1\AbstractVectorGraphicsIO.java
#Comment:
    /**
     * Draws an overline for the text at (x, y). The method is usesefull for
     * drivers that do not support overlines by itself.
     *
     * @param text text for width calulation
     * @param font font for width calulation
     * @param x position of text
     * @param y position of text
     */

#Code:
    protected void overLine(String text, Font font, float x, float y) {
        TextLayout layout = new TextLayout(text, font, getFontRenderContext());
        float width = Math.max(
            layout.getAdvance(),
            (float) layout.getBounds().getWidth());

        GeneralPath path = new GeneralPath();
        path.moveTo(x, y + (float) layout.getBounds().getY() - layout.getAscent());
        path.lineTo(x + width, y + (float) layout.getBounds().getY() - layout.getAscent() - layout.getAscent());
        draw(path);
    }

#No. 5616
#File: E:\bishe\1\AbstractVersioningLoggerItem.java
#Comment:
	/**
	 * This is the standard line output which may be overridden by extending classes.
	 */

#Code:
	public String formatLine() {
		StringBuilder result = new StringBuilder();
		
		/* Status information */
		if (hasStatus()) {
			result.append(getStatus().toString());
		}
		
		/* Project information */
		if (hasProject()) {
			
			if (isReference()) {
				/* If this is a reference to the examined project in another project, we first display the examined project. */
				result.append(DELIMITER);
				result.append(originalProject);
				
				appendVersionTransistion(result);
				
				result.append(DELIMITER);
				result.append("REFERENCE FROM ");
				result.append(project.id());
			}
			else {
				result.append(DELIMITER);
				result.append(project.id());
				
				appendVersionTransistion(result);
			}
		}
		
		/* Message */
		if (hasMessage()) {
			result.append(DELIMITER);
			result.append(getMessage());
		}
		
		return result.toString();
	}

#No. 5617
#File: E:\bishe\1\AbstractViewComponent.java
#Comment:
	/**
	 * {@inheritDoc}
	 * <p>
	 * If this view component has knowledge of the presenter class and view
	 * class, this implementation will try to create a new instance using the
	 * {@link Presenter#Presenter(View)} constructor or the
	 * {@link Presenter#Presenter()} constructor. In all other cases an
	 * exception will be thrown. Subclasses may override.
	 */

#Code:
	@Override
	public P createPresenter() {
		if (presenterClass == null) {
			throw new IllegalStateException(
					"No presenterClass set - override createPresenter()");
		}
		if (viewClass == null) {
			throw new IllegalStateException(
					"No viewClass set - override createPresenter()");
		}
		try {
			try {
				Constructor<P> constructor = presenterClass
						.getConstructor(viewClass);
				return constructor.newInstance(viewClass.cast(this));
			} catch (NoSuchMethodException e) {
				// Try the default constructor instead.
				Constructor<P> constructor = presenterClass.getConstructor();
				P presenter = constructor.newInstance();
				presenter.setView(viewClass.cast(this));
				return presenter;
			}
		} catch (Exception e) {
			throw new UnsupportedOperationException(
					"Cannot create a new presenter instance - override createPresenter()",
					e);
		}
	}

#No. 5618
#File: E:\bishe\1\AbstractViewComponent.java
#Comment:
	/**
	 * Sets the display name of this view and fires a
	 * {@link DisplayNameChangedViewEvent}.
	 */

#Code:
	protected void setDisplayName(String displayName) {
		viewDelegate.setDisplayName(displayName);
	}

#No. 5619
#File: E:\bishe\1\AbstractViewComponent.java
#Comment:
	/**
	 * Sets the description of this view and fires a
	 * {@link DescriptionChangedViewEvent}.
	 */

#Code:
	protected void setViewDescription(String description) {
		viewDelegate.setViewDescription(description);
	}

#No. 5620
#File: E:\bishe\1\AbstractViewComponent.java
#Comment:
	/**
	 * {@inheritDoc}
	 * <p>
	 * Please note that this method has been annotated with the
	 * {@link PostConstruct @PostConstruct} annotation. If the view is created
	 * using a container such as Spring or CDI, this method will be
	 * automatically invoked after the view has been created and all the
	 * dependencies have been injected.
	 * <p>
	 * Subclasses should preferably override {@link #initView()} or
	 * {@link #finalizeInitialization()} instead of this method.
	 */

#Code:
	@Override
	@PostConstruct
	public void init() {
		viewDelegate.init();
	}

#No. 5621
#File: E:\bishe\1\AbstractViewComponent.java
#Comment:
	/**
	 * {@inheritDoc}
	 * <p>
	 * This implementation is empty, subclasses may override.
	 */

#Code:
	@Override
	public void initView() {
	}

#No. 5622
#File: E:\bishe\1\AbstractViewComponent.java
#Comment:
	/**
	 * {@inheritDoc}
	 * <p>
	 * This implementation is empty, subclasses may override.
	 */

#Code:
	@Override
	public void finalizeInitialization() {
	}

#No. 5623
#File: E:\bishe\1\AbstractViewComponent.java
#Comment:
	/**
	 * {@inheritDoc}
	 * <p>
	 * This implementation returns the view component itself (<code>this</code>
	 * ).
	 */

#Code:
	@Override
	public ComponentContainer getViewComponent() {
		return this;
	}

#No. 5624
#File: E:\bishe\1\AbstractViewComponent.java
#Comment:
	/**
	 * Returns the presenter of this view, or <code>null</code> if none has been
	 * specified or created yet.
	 */

#Code:
	public P getPresenter() {
		return viewDelegate.getPresenter();
	}

#No. 5625
#File: E:\bishe\1\AbstractViewComponent.java
#Comment:
	/**
	 * Sets the presenter of this view. If the view is already initialized, an
	 * exception will be thrown.
	 */

#Code:
	public void setPresenter(P presenter) {
		viewDelegate.setPresenter(presenter);
	}

#No. 5626
#File: E:\bishe\1\AbstractViewComponent.java
#Comment:
	/**
	 * Returns the <code>AdaptableSupport</code> instance used by the view.
	 */

#Code:
	protected AdaptableSupport getAdaptableSupport() {
		return viewDelegate.getAdaptableSupport();
	}

#No. 5627
#File: E:\bishe\1\AbstractVMSupport.java
#Comment:
    /**
     * Launches a virtual machine asynchronously from a cached thread pool. All errors are pulled out from the
     * the {@link java.util.concurrent.Future} result.
     *
     * @param withLaunchOptions the launch options to use in launching the virtual machine
     * @return the unique ID of the launched virtual machine
     */

#Code:
    protected Future<String> launchAsync( final @Nonnull VMLaunchOptions withLaunchOptions ) {
        return launchPool.submit(new Callable<String>() {
            @Override
            public String call() throws Exception {
                return launch(withLaunchOptions).getProviderVirtualMachineId();
            }
        });

#No. 5628
#File: E:\bishe\1\AbstractVMSupport.java
#Comment:
    /**
     * <p>
     * Identifies a resource file that potentially contains VM product definitions for one or more clouds and/or
     * a default set of products. This helps this abstract base class implement some default configuration file
     * based behaviors for clouds that do not provide mechanisms for looking up VM products such as AWS or clouds
     * that don't have a concept of products like vCloud. If your cloud provides product lookups (like OpenStack),
     * then you can happily ignore this method and override {@link #listProducts(Architecture)} to do the proper
     * lookup.
     * </p>
     * <p>
     * The best way to take advantage of this feature is simply to create a resource file, place it in the application
     * CLASSPATH, and then set the {@link ProviderContext#getCustomProperties()} so it has a &quot;vmproducts&quot;
     * property that points to the resource file to use for that specific cloud connection.
     * </p>
     * <p>
     * The format of the resource file is as follows:
     * <p/>
     * </p>
     * <pre>
     * [
     *     {
     *         "provider":"default",
     *         "cloud":"default",
     *         "products":[
     *         {
     *             "architectures":["I32", "I64"],
     *             "id":"t1.micro",
     *             "name":"Micro Instance (t1.micro)",
     *             "description":"Micro Instance (t1.micro)",
     *             "cpuCount":1,
     *             "rootVolumeSizeInGb":1,
     *             "ramSizeInMb":512
     *         },
     *     }
     * ]
     * </pre>
     * <p>
     * The core element is a list of cloud/product definitions. Each cloud has a &quot;provider&quot;, &quot;cloud&quot;,
     * and &quot;products&quot; attribute. The provider is either &quot;default&quot; or a match to the value for
     * {@link ProviderContext#getProviderName()}. The cloud is similarly either &quot;default&quot; or a match to the
     * value for {@link ProviderContext#getCloudName()}. The implementation of {@link #listProducts(Architecture)}
     * in this base class will attempt to match the cloud name and provider name or look for a default.
     * </p>
     * <p>
     * Here's what happens in practice:
     * </p>
     * <p>
     * If your implementation has over-ridden {@link #listProducts(Architecture)}, then that logic prevails and
     * all of this is ignored (for that cloud implementation).
     * </p>
     * <p>
     * If your implementation is under the package something.whatever.<b>cloudname</b> (the important part is the last part
     * of the package name) and you have not specified ANY kind of properties, the default {@link #listProducts(Architecture)}
     * will look for a vmproducts.json file as the resource org.dasein.cloud.<b>cloudname</b>.vmproducts.json. If it exists,
     * it will be used.
     * </p>
     * <p>
     * If you specify a custom property with your connection called &quot;vmproducts&quot;, then the
     * default {@link #listProducts(Architecture)} method will look for a resource matching the value specified
     * in that property.
     * </p>
     * <p>
     * If no custom property is set, but there is a system property (@{@link System#getProperties()}) called
     * &quot;dasein.vmproducts.<b>cloudname</b>&quot; and look for a resource matching the value specified in that
     * property.
     * </p>
     * <p>
     * If you do absolutely nothing (or if the property file specified above doesn't actually exist),
     * Dasein Cloud will load the default vmproducts.json packages with dasein-cloud-core under
     * the resource org.dasein.cloud.std.vmproducts.json.
     * </p>
     *
     * @return a resource file location with a vmproducts JSON definition
     * @throws CloudException no context has been set for loading the products
     */

#Code:
    protected @Nonnull String getVMProductsResource() throws InternalException {
        Properties p = getContext().getCustomProperties();
        String value = null;

        if( p != null ) {
            value = p.getProperty("vmproducts");
        }

#No. 5629
#File: E:\bishe\1\AbstractVMSupport.java
#Comment:
    /**
     * Merge product iterable into the list, using providerProductId as a unique key
     * @param to
     *          the target list
     * @param from
     *          the source iterable
     */

#Code:
    private void mergeProductLists(List<VirtualMachineProduct> to, Iterable<VirtualMachineProduct> from) {
        List<VirtualMachineProduct> copy = new ArrayList<VirtualMachineProduct>(to);
        for( VirtualMachineProduct productFrom : from ) {
            boolean found = false;
            for( VirtualMachineProduct productTo : copy ) {
                if( productTo.getProviderProductId().equalsIgnoreCase(productFrom.getProviderProductId()) ) {
                    found = true;
                    break;
                }
            }
            if( !found ) {
                to.add(productFrom);
            }
        }
    }

#No. 5630
#File: E:\bishe\1\AbstractVMSupport.java
#Comment:
        /*
        Cache<Architecture> cache = Cache.getInstance(getProvider(), "architectures", Architecture.class, CacheLevel.REGION_ACCOUNT, new TimePeriod<Week>(1, TimePeriod.WEEK));
        Iterable<Architecture> architectures = cache.get(getContext());

        if( architectures == null ) {
            ArrayList<Architecture> list = new ArrayList<Architecture>();

            Collections.addAll(list, Architecture.values());
            architectures = list;
            cache.put(getContext(), architectures);
        }
        return architectures;
        */

#Code:
    }

    @Override
    public @Nonnull Iterable<ResourceStatus> listVirtualMachineStatus() throws InternalException, CloudException {
        List<ResourceStatus> status = new ArrayList<ResourceStatus>();

        for( VirtualMachine vm : listVirtualMachines() ) {
            status.add(new ResourceStatus(vm.getProviderVirtualMachineId(), vm.getCurrentState()));
        }

#No. 5631
#File: E:\bishe\1\AbstractVnfm.java
#Comment:
  /**
   * This method setups the VNFM and then subscribe it to the NFVO. We recommend to not change this
   * method or at least to override calling super()
   */

#Code:
  protected void setup() {
    loadProperties();
    vnfmManagerEndpoint = new VnfmManagerEndpoint();
    vnfmManagerEndpoint.setType(this.type);
    vnfmManagerEndpoint.setDescription(this.description);
    vnfmManagerEndpoint.setEnabled(this.enabled);
    vnfmManagerEndpoint.setActive(true);
    vnfmManagerEndpoint.setEndpoint(this.endpoint);
    log.debug("creating VnfmManagerEndpoint for vnfm endpointType: " + this.endpointType);
    vnfmManagerEndpoint.setEndpointType(EndpointType.valueOf(this.endpointType));
    register();
  }

#No. 5632
#File: E:\bishe\1\AbstractVO.java
#Comment:
    /*
     * Serialization
     */

#Code:

    private static final long serialVersionUID = -1;

    /*
     * Deleted properties
     */
    public void saveDeleteProperty(String key, Object value) {
        if (deletedProperties == null)
            deletedProperties = new MapWrap();
        deletedProperties.put(key, value);
    }

#No. 5633
#File: E:\bishe\1\AbstractVO.java
#Comment:
    /*
     * ChangeComparable
     */

#Code:

    /**
     * Get the Audit Message Key
     * @return
     */
    public abstract String getTypeKey();

    /*
     * Getters and setters
     */
    public String getXid() {
        return xid;
    }

#No. 5634
#File: E:\bishe\1\AbstractVO.java
#Comment:
    /*
     * Utility methods
     */

#Code:

    /**
     * Validates a vo
     * 
     * @param response
     */
    public void validate(ProcessResult response) {
        if (StringUtils.isBlank(xid))
            response.addContextualMessage("xid", "validate.required");
        else if (StringValidation.isLengthGreaterThan(xid, 50))
            response.addMessage("xid", new TranslatableMessage("validate.notLongerThan", 50));
        else if (!isXidUnique(xid, id))
            response.addContextualMessage("xid", "validate.xidUsed");

        if (StringUtils.isBlank(name))
            response.addContextualMessage("name", "validate.required");
        else if (StringValidation.isLengthGreaterThan(name, 255))
            response.addMessage("name", new TranslatableMessage("validate.notLongerThan", 255));
    }

#No. 5635
#File: E:\bishe\1\AbstractVO.java
#Comment:
    /**
     * Check if a vo is newly created
     * 
     * @return true if newly created, false otherwise
     */

#Code:
    public boolean isNew() {
        return (id == Common.NEW_ID);
    }

#No. 5636
#File: E:\bishe\1\AbstractVO.java
#Comment:
    /**
     * Copies a vo
     * 
     * @return Copy of this vo
     */

#Code:
    @SuppressWarnings("unchecked")
    public T copy() {
        // TODO make sure this works
        try {
            return (T) super.clone();
        }
        catch (CloneNotSupportedException e) {
            throw new ShouldNeverHappenException(e);
        }
    }

#No. 5637
#File: E:\bishe\1\AbstractVO.java
#Comment:
    /**
     * Useful For Debugging
     */

#Code:
    @Override
    public String toString() {
        return "id: " + this.id + " name: " + this.name;
    }

#No. 5638
#File: E:\bishe\1\AbstractVoModel.java
#Comment:
	/**
	 * @param data
	 */

#Code:
	public AbstractVoModel(T data) {
		super(data);
		this.messages = new ArrayList<RestValidationMessage>();

	}

#No. 5639
#File: E:\bishe\1\AbstractVoModel.java
#Comment:
	/**
	 * Helper to add Validation Message
	 * @param messageKey
	 * @param level
	 * @param property
	 */

#Code:
	public void addValidationMessage(String messageKey, RestMessageLevel level, String property){
		this.messages.add(new RestValidationMessage(new TranslatableMessage(messageKey).translate(Common.getTranslations()), level, property));
	}

#No. 5640
#File: E:\bishe\1\AbstractWalkingSelector.java
#Comment:
/**
 * ???
 *
 * @since 1.0
 */

#Code:
public abstract class AbstractWalkingSelector
    extends AbstractSelector
{
  private Walker walker;

  @Inject
  public AbstractWalkingSelector(final SelectionFactory selectionFactory, final Walker walker) {
      super(Preconditions.checkNotNull(selectionFactory));
      this.walker = Preconditions.checkNotNull(walker);
  }

  protected Walker getWalker() {
    return walker;
  }

  protected void walk(final Repository repository, final ResourceStoreRequest resourceStoreRequest,
                      final WalkerProcessor walkerProcessor)
      throws WalkerException
  {
    final DefaultWalkerContext context = new DefaultWalkerContext(repository, resourceStoreRequest);
    context.getProcessors().add(walkerProcessor);
    try {
      walker.walk(context);
    }
    catch (WalkerException e) {
      if (!(e.getWalkerContext().getStopCause() instanceof ItemNotFoundException)) {
        // everything that is not ItemNotFound should be reported,
        // otherwise just neglect it
        throw e;
      }
    }
  }
}

#No. 5641
#File: E:\bishe\1\AbstractWarningsGraphPortlet.java
#Comment:
    /**
     * Returns the trend graph for specified jobs.
     *
     * @return the trend graph
     */

#Code:
    public Graph getWarningsGraph() {
        List<ResultAction<?>> results = getActions();
        BuildResultGraph graph;
        if (results.isEmpty()) {
            graph = new NullGraph();
        }
        else {
            graph = configuration.getGraphType();
        }
        return graph.getGraph(-1, configuration, getPluginName(), results);
    }

#No. 5642
#File: E:\bishe\1\AbstractWarningsGraphPortlet.java
#Comment:
    /**
     * Checks if the results are empty.
     *
     * @return <code>true</code> if the results are empty, <code>false</code> otherwise
     */

#Code:
    public boolean isEmpty() {
        return getActions().isEmpty();
    }

#No. 5643
#File: E:\bishe\1\AbstractWarningsGraphPortlet.java
#Comment:
    /**
     * Returns the actions that should be used as base for the graph.
     *
     * @return the actions that should be used as base for the graph
     */

#Code:
    private List<ResultAction<?>> getActions() {
        List<ResultAction<?>> results = Lists.newArrayList();
        for (Job<?, ?> job : getDashboard().getJobs()) {
            AbstractProjectAction<?> action = selectAction(job);
            if (action != null && action.hasValidResults()) {
                results.add(action.getLastAction());
            }
        }
        return results;
    }

#No. 5644
#File: E:\bishe\1\AbstractWarningsGraphPortlet.java
#Comment:
    /**
     * Selects the action to show the results from. This default implementation
     * simply returns the first action that matches the given type.
     *
     * @param job
     *            the job to get the action from
     * @return the action
     */

#Code:
    protected AbstractProjectAction<?> selectAction(final Job<?, ?> job) {
        return job.getAction(getAction());
    }

#No. 5645
#File: E:\bishe\1\AbstractWarningsGraphPortlet.java
#Comment:
    /**
     * Returns the height.
     *
     * @return the height
     */

#Code:
    public int getHeight() {
        return configuration.getHeight();
    }

#No. 5646
#File: E:\bishe\1\AbstractWarningsGraphPortlet.java
#Comment:
    /**
     * Returns the width.
     *
     * @return the width
     */

#Code:
    public int getWidth() {
        return configuration.getWidth();
    }

#No. 5647
#File: E:\bishe\1\AbstractWarningsGraphPortlet.java
#Comment:
    /**
     * Returns the number of days to consider.
     *
     * @return the number of days to consider
     */

#Code:
    public String getDayCountString() {
        return configuration.getDayCount() > 0 ? Integer.toString(configuration.getDayCount()) : StringUtils.EMPTY;
    }

#No. 5648
#File: E:\bishe\1\AbstractWatchDir.java
#Comment:
    /**
     * Creates a WatchService and registers the given directory
     */

#Code:
    AbstractWatchDir(Path dir, boolean recursive) throws IOException {
        this.watcher = FileSystems.getDefault().newWatchService();
        this.keys = new HashMap<>();
        this.recursive = recursive;

        if (recursive) {
            log.debug("Scanning {} ...\n", dir);
            registerAll(dir);
            log.debug("Done.");
        } else {
            register(dir);
        }

        // enable trace after initial registration
        this.trace = true;
    }

#No. 5649
#File: E:\bishe\1\AbstractWatchDir.java
#Comment:
    /**
     * Register the given directory, and all its sub-directories, with the
     * WatchService.
     */

#Code:
    private void registerAll(final Path start) throws IOException {
        // register directory and sub-directories
        Files.walkFileTree(start, new SimpleFileVisitor<Path>() {
            @Override
            public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs)
                    throws IOException {
                register(dir);
                return FileVisitResult.CONTINUE;
            }
        });
    }

#No. 5650
#File: E:\bishe\1\AbstractWatchDir.java
#Comment:
    /**
     * Process all events for keys queued to the watcher
     */

#Code:
    void processEvents() {
        for (; ; ) {

            // wait for key to be signalled
            WatchKey key;
            try {
                key = watcher.take();
            } catch (InterruptedException x) {
                return;
            }

            Path dir = keys.get(key);
            if (dir == null) {
                log.error("WatchKey not recognized!!");
                continue;
            }
            List<WatchEvent<Path>> filteredEvents = key.pollEvents().stream()
                    .filter(watchEvent -> watchEvent.kind() != OVERFLOW)
                    .map(watchEvent -> {
                        // Context for directory entry event is the file name of entry
                        WatchEvent<Path> ev = cast(watchEvent);
                        Path name = ev.context();
                        Path child = dir.resolve(name);

                        registerDirectoryIfCreated(watchEvent, child);

                        log.debug("{}: {}\n", ev.kind().name(), child);

                        resetAndRemoveKeyIfDirNotAccessible(key);
                        return ev;
                    })
                    .collect(Collectors.toList());

            batchProcess(filteredEvents);

        }
    }

#No. 5651
#File: E:\bishe\1\AbstractWatchService.java
#Comment:
  /**
   * Checks that the watch service is open, throwing {@link ClosedWatchServiceException} if not.
   */

#Code:
  protected final void checkOpen() {
    if (!open.get()) {
      throw new ClosedWatchServiceException();
    }
  }

#No. 5652
#File: E:\bishe\1\AbstractWebDefaults.java
#Comment:
    /**
     * Append one context parameter.
     * 
     * @param builder the builder
     * @param name the name of the parameter
     * @param value the value of the parameter
     */

#Code:
    protected void appendContextParam(DOMBuilder builder, String name, Object value)
    {
        builder.begin("context-param");
        {
            builder.element("param-name", name);
            builder.element("param-value", value);
        }
        builder.end();
    }

#No. 5653
#File: E:\bishe\1\AbstractWebDefaults.java
#Comment:
    /**
     * Build the listeners.
     * 
     * @param builder the builder
     */

#Code:
    protected void buildListeners(DOMBuilder builder)
    {
        appendListeners(builder);
    }

#No. 5654
#File: E:\bishe\1\AbstractWebDefaults.java
#Comment:
    /**
     * Append one listener.
     * 
     * @param builder the builder
     * @param listenerClass the listener class
     */

#Code:
    protected void appendListener(DOMBuilder builder, String listenerClass)
    {
        builder.begin("listener");
        {
            builder.element("listener-class", listenerClass);
        }
        builder.end();
    }

#No. 5655
#File: E:\bishe\1\AbstractWebDefaults.java
#Comment:
    /**
     * Build the default servlet.
     * 
     * @param builder the builder
     */

#Code:
    private void buildDefaultServlet(DOMBuilder builder)
    {
        builder.begin("servlet");
        {
            builder.element("servlet-name", "default");
            builder.element("servlet-class", getDefaultServletClass());

            appendInitParams(builder);

            builder.element("load-on-startup", 0);
        }
        builder.end();
    }

#No. 5656
#File: E:\bishe\1\AbstractWebDefaults.java
#Comment:
    /**
     * Add init parameters for the default servlet.
     * 
     * @param builder the builder
     */

#Code:
    protected void appendInitParams(DOMBuilder builder)
    {
        appendInitParam(builder, "acceptRanges", true);
        appendInitParam(builder, "dirAllowed", true);
        appendInitParam(builder, "welcomeServlets", false);
        appendInitParam(builder, "redirectWelcome", false);
        appendInitParam(builder, "maxCacheSize", (serverCacheEnabled) ? getMaxCacheSize() : 0);
        appendInitParam(builder, "maxCachedFileSize", (serverCacheEnabled) ? getMaxCachedFileSize() : 0);
        appendInitParam(builder, "maxCachedFiles", (serverCacheEnabled) ? getMaxCachedFiles() : 0);
        appendInitParam(builder, "gzip", true);
        appendInitParam(builder, "useFileMappedBuffer", false);

        if (!clientCacheEnabled)
        {
            appendInitParam(builder, "cacheControl", "max-age=0, public");
        }
    }

#No. 5657
#File: E:\bishe\1\AbstractWebDefaults.java
#Comment:
    /**
     * Append one init parameter
     * 
     * @param builder the builder
     * @param name the name of the parameter
     * @param value the value of the parameter
     */

#Code:
    protected void appendInitParam(DOMBuilder builder, String name, Object value)
    {
        builder.begin("init-param");
        {
            builder.element("param-name", name);
            builder.element("param-value", value);
        }
        builder.end();
    }

#No. 5658
#File: E:\bishe\1\AbstractWebDefaults.java
#Comment:
    /**
     * Build the default servlet mapping.
     * 
     * @param builder the builder
     */

#Code:
    protected void buildDefaultServletMapping(DOMBuilder builder)
    {
        builder.begin("servlet-mapping");
        {
            builder.element("servlet-name", "default");
            appendURLPattern(builder, "/");
        }
        builder.end();
    }

#No. 5659
#File: E:\bishe\1\AbstractWebDefaults.java
#Comment:
    /**
     * Append the URL pattern.
     * 
     * @param builder the builder
     * @param urlPattern the pattern
     */

#Code:
    protected void appendURLPattern(DOMBuilder builder, String urlPattern)
    {
        builder.element("url-pattern", urlPattern);
    }

#No. 5660
#File: E:\bishe\1\AbstractWebDefaults.java
#Comment:
    /**
     * Build the JSP servlet section.
     * 
     * @param builder the builder
     */

#Code:
    protected void buildJSPServlet(DOMBuilder builder)
    {
        builder.begin("servlet").attribute("id", "jsp");
        {
            builder.element("servlet-name", "jsp");
            builder.element("servlet-class", "org.apache.jasper.servlet.JspServlet");

            appendInitParam(builder, "logVerbosityLevel", "DEBUG");
            appendInitParam(builder, "fork", false);
            appendInitParam(builder, "xpoweredBy", false);

            builder.element("load-on-startup", 0);
        }
        builder.end();
    }

#No. 5661
#File: E:\bishe\1\AbstractWebDefaults.java
#Comment:
    /**
     * Build the JSP servlet mapping.
     * 
     * @param builder the builder
     */

#Code:
    protected void buildJSPServletMapping(DOMBuilder builder)
    {
        builder.begin("servlet-mapping");
        {
            builder.element("servlet-name", "jsp");
            appendURLPattern(builder, "*.jsp");
            appendURLPattern(builder, "*.jspf");
            appendURLPattern(builder, "*.jspx");
            appendURLPattern(builder, "*.xsp");
            appendURLPattern(builder, "*.JSP");
            appendURLPattern(builder, "*.JSPF");
            appendURLPattern(builder, "*.JSPX");
            appendURLPattern(builder, "*.XSP");
        }
        builder.end();
    }

#No. 5662
#File: E:\bishe\1\AbstractWebDefaults.java
#Comment:
    /**
     * Build the session config section.
     * 
     * @param builder the builder
     */

#Code:
    protected void buildSessionConfig(DOMBuilder builder)
    {
        builder.begin("session-config");
        {
            builder.element("session-timeout", 30);
        }
        builder.end();
    }

#No. 5663
#File: E:\bishe\1\AbstractWebDefaults.java
#Comment:
    /**
     * Build the welcome file list.
     * 
     * @param builder the builder
     */

#Code:
    protected void buildWelcomeFileList(DOMBuilder builder)
    {
        builder.begin("welcome-file-list");
        {
            appendWelcomeFile(builder, "index.html");
            appendWelcomeFile(builder, "index.htm");
            appendWelcomeFile(builder, "index.jsp");
        }
        builder.end();
    }

#No. 5664
#File: E:\bishe\1\AbstractWebDefaults.java
#Comment:
    /**
     * Add one welcome file.
     * 
     * @param builder the builder
     * @param welcomeFile the welcome file
     */

#Code:
    protected void appendWelcomeFile(DOMBuilder builder, String welcomeFile)
    {
        builder.element("welcome-file", welcomeFile);
    }

#No. 5665
#File: E:\bishe\1\AbstractWebDefaults.java
#Comment:
    /**
     * Append one locale encoding mapping.
     * 
     * @param builder the builder
     * @param locale the locale
     * @param encoding the encoding
     */

#Code:
    protected void appendLocaleEncodingMapping(DOMBuilder builder, String locale, String encoding)
    {
        builder.begin("locale-encoding-mapping");
        {
            builder.element("locale", locale);
            builder.element("encoding", encoding);
        }
        builder.end();
    }

#No. 5666
#File: E:\bishe\1\AbstractWebDefaults.java
#Comment:
    /**
     * Build the security constraints.
     * 
     * @param builder the builder
     */

#Code:
    protected void buildSecurityConstraints(DOMBuilder builder)
    {
        builder.begin("security-constraint");
        {
            builder.begin("web-resource-collection");
            {
                builder.element("web-resource-name", "Disable TRACE");
                appendURLPattern(builder, "/");
                builder.element("http-method", "TRACE");
            }
            builder.end();

            builder.element("auth-constraint");
        }
        builder.end();
    }

#No. 5667
#File: E:\bishe\1\AbstractWebSocket.java
#Comment:
    /**
     * Constructor
     */

#Code:
    public AbstractWebSocket() {
        _buffer = new ByteArrayBuffer(BUFFER_SIZE);
    }

#No. 5668
#File: E:\bishe\1\AbstractWebSocket.java
#Comment:
    /**
     * Release resources.
     */

#Code:
    private void release() {
        _buffer.clear();
        _buffer = null;
        if (_frame.isOpen()) {
            _frame.close();
        }
        _frame = null;
    }

#No. 5669
#File: E:\bishe\1\AbstractWeightedVoteEnsembleLearner.java
#Comment:
    /** This method makes a ensemblelearners/combined prediction for all weight-based combiner classes
     * @param instanceID Data instance ID
     * @param combinedPredictionInfos Prediction info
     * @return Combined prediction
     * @throws Exception
     */

#Code:
    @Override
    protected ModelPrediction MakeInstancePrediction(String instanceID, EnsemblePredictionInfos combinedPredictionInfos) throws Exception
    {
        ArrayList<String> classes = Singletons.InstanceVault.DependentVariableOptions;

        // Initialize the class weights
        ArrayList<Double> classWeights = new ArrayList<Double>();
        for (String x : classes)
            classWeights.add(0.0);
        
        // Update the class weights based on the inner predictions
        for (EnsemblePredictionInfo info : combinedPredictionInfos.Infos)
            classWeights.set(classes.indexOf(info.OuterPrediction.Prediction), GetWeight(info));

        // Pick a winner based on the class weights
        String predictedClass = MajorityVoteEnsembleLearner.ChoosePredictedClass(instanceID, classWeights);

        // Calculate probabilities for each class
        double totalWeight = MathUtilities.Sum(classWeights);
        ArrayList<Double> classProbabilities = new ArrayList<Double>();
        for (int i=0; i<classWeights.size(); i++)
            classProbabilities.add(classWeights.get(i) / totalWeight);

        Prediction prediction = new Prediction(instanceID, Singletons.InstanceVault.GetDependentVariableValue(instanceID), predictedClass, classProbabilities);

        return new ModelPrediction(MajorityVoteEnsembleLearner.GetDescription(predictedClass, classProbabilities), prediction);
    }

#No. 5670
#File: E:\bishe\1\AbstractWheelTextAdapter.java
#Comment:
    /**
     * Configures text view. Is called for the TEXT_VIEW_ITEM_RESOURCE views.
     *
     * @param view the text view to be configured
     */

#Code:
    protected void configureTextView(TextView view) {
        if (itemResourceId == TEXT_VIEW_ITEM_RESOURCE) {
            view.setTextColor(textColor);
            view.setGravity(Gravity.CENTER);
            view.setTextSize(textSize);
            view.setLines(1);
        }
        if (textTypeface != null) {
            view.setTypeface(textTypeface);
        } else {
            view.setTypeface(Typeface.SANS_SERIF, Typeface.BOLD);
        }
    }

#No. 5671
#File: E:\bishe\1\AbstractWheelTextAdapter.java
#Comment:
    /**
     * Loads a text view from view
     *
     * @param view         the text view or layout containing it
     * @param textResource the text resource Id in layout
     * @return the loaded text view
     */

#Code:
    private TextView getTextView(View view, int textResource) {
        TextView text = null;
        try {
            if (textResource == NO_RESOURCE && view instanceof TextView) {
                text = (TextView) view;
            } else if (textResource != NO_RESOURCE) {
                text = (TextView) view.findViewById(textResource);
            }
        } catch (ClassCastException e) {
            Log.e("AbstractWheelAdapter", "You must supply a resource ID for a TextView");
            throw new IllegalStateException(
                    "AbstractWheelAdapter requires the resource ID to be a TextView", e);
        }

        return text;
    }

#No. 5672
#File: E:\bishe\1\AbstractWheelTextAdapter.java
#Comment:
    /**
     * Loads view from resources
     *
     * @param resource the resource Id
     * @return the loaded view or null if resource is not set
     */

#Code:
    private View getView(int resource, ViewGroup parent) {
        switch (resource) {
            case NO_RESOURCE:
                return null;
            case TEXT_VIEW_ITEM_RESOURCE:
                return new TextView(context);
            default:
                return inflater.inflate(resource, parent, false);
        }
    }

